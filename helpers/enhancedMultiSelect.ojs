/**
 * @fileoverview Custom UI wrapper for an HTML <select multiple> element.
 *
 * This function replaces the native multiple select with a cleaner,
 * click-toggleable button and list, implementing maximum selection limits,
 * required selection constraints, and synchronization with Observable
 * Inputs.select().
 */

/**
 * Creates a custom UI wrapper for a native HTML <select multiple> element,
 * converting it into a styled dropdown with click-to-toggle functionality.
 *
 * It hides the native select, creates a button and a dropdown list, implements
 * max/min selection constraints, and includes necessary memory cleanup for
 * Observable notebooks.
 *
 * @param {HTMLElement|HTMLFormElement} viewofSelect - The container element (or the select itself) holding the target <select multiple>.
 * @param {object} [config] - Configuration options for the toggle component.
 * @param {?number} [config.maxSelections=null] - The maximum number of items that can be selected. Null means no limit.
 * @param {boolean} [config.requireAtLeastOne=true] - If true, prevents the user from deselecting the last selected item.
 * @returns {HTMLElement} An html element, but in OJS the initial select should be returned
 *
 * @example
 * {
 *  const input = Inputs.select([1, 2, 3, 4, 5, 6], {
 *      multiple: true,
 *      label: "pretty multi-select"
 *    });
 *  enhancedMultiSelect(input, { maxSelections: 3, requireAtLeastOne: false });
 *  return input;
 * }
 */
function enhancedMultiSelect(
  viewofSelect,
  { maxSelections = Infinity, requireAtLeastOne = true } = {}
) {
  const select = viewofSelect.querySelector("select") || viewofSelect;

  if (!select || !select.multiple) {
    throw new Error("enableClickToggle: requires a multiple=true select");
  }

  // --- Styles Configuration ---
  const styles = {
    wrapper: "font-family: system-ui; max-width: 400px; position: relative;",
    btn: `
      width: 100%; min-width: 360px; padding: 10px;
      background: white; border: 2px solid #d1d5db; border-radius: 6px;
      cursor: pointer; font-size: 14px; font-weight: 500;
      text-align: left; display: flex; justify-content: space-between;
      align-items: center; transition: all 0.2s ease;
    `,
    list: `
      display: none; min-width: 360px;
      border: 1px solid #d1d5db; border-radius: 8px; background: white;
      z-index: 10; top: 100%; position: absolute;
      max-height: 240px; overflow-y: auto; margin-top: 4px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
    `,
    option: `
      padding: 8px 12px; cursor: pointer; display: flex;
      justify-content: space-between; align-items: center;
      border-bottom: 1px solid #e5e7eb; transition: background 0.1s;
    `,
    check: `
       color: rgba(0,0,0,0.8); font-weight: 400; margin-left: 12px; 
       min-width: 15px;
    `
  };

  // --- Helper Functions ---
  const applyStyle = (el, css) => (el.style.cssText = css);

  const shake = (el) => {
    const originalBg = el.style.backgroundColor;
    el.style.backgroundColor = "#ffe5e5";
    setTimeout(() => (el.style.backgroundColor = originalBg), 180);
    el.animate(
      [
        { transform: "translateX(0)" },
        { transform: "translateX(-2px)" },
        { transform: "translateX(2px)" },
        { transform: "translateX(0)" }
      ],
      { duration: 200 }
    );
  };

  const getSelectedIndices = () =>
    new Set(
      Array.from(select.options).flatMap((o, i) => (o.selected ? [i] : []))
    );

  // --- Initialization & State ---
  select.style.display = "none";

  if (
    requireAtLeastOne &&
    select.selectedIndex === -1 &&
    select.options.length > 0
  ) {
    select.options[0].selected = true;
  }

  const wrapper = document.createElement("div");
  applyStyle(wrapper, styles.wrapper);

  const btn = document.createElement("button");
  applyStyle(btn, styles.btn);

  const list = document.createElement("div");
  applyStyle(list, styles.list);

  let isCollapsed = true;

  // --- View Control ---

  const collapseList = () => {
    if (!isCollapsed) {
      isCollapsed = true;
      list.style.display = "none";
      updateUI();
    }
  };

  const expandList = () => {
    if (isCollapsed) {
      isCollapsed = false;
      list.style.display = "block";
      updateUI();
      list.scrollTop = 0;
    }
  };

  function updateUI() {
    // Update Button Text and Arrow
    const selectedOptions = Array.from(select.options).filter(
      (o) => o.selected
    );
    const text = selectedOptions.length
      ? selectedOptions.map((o) => o.textContent).join(", ")
      : "None selected";
    btn.innerHTML = `
      <span style="pointer-events:none;">${text}</span>
      <span style="opacity:0.7; pointer-events:none;">
        ${isCollapsed ? "▾" : "▴"}
      </span>
    `;

    // Update List Checkmarks and Backgrounds
    Array.from(list.children).forEach((div, i) => {
      const isSelected = select.options[i].selected;
      const check = div.querySelector("span");
      if (check) check.textContent = isSelected ? "✔" : "";
      div.style.backgroundColor = isSelected ? "#f9fafb" : "white";
    });
  }

  // --- Option Rendering ---
  Array.from(select.options).forEach((opt) => {
    const div = document.createElement("div");
    div.textContent = opt.textContent;
    applyStyle(div, styles.option);

    const check = document.createElement("span");
    applyStyle(check, styles.check);
    div.appendChild(check);

    // Hover
    div.addEventListener("mouseover", () => {
      div.style.color = "#111";  // Prevents the global button styles from breakign it
      div.style.background = opt.selected ? "#f9fafb" : "#f3f4f6";
    });

    div.addEventListener("mouseout", () => {
      div.style.color = "#111";
      div.style.background = opt.selected ? "#f9fafb" : "white";
    });

    // Click
    div.onmousedown = (e) => {
      e.preventDefault();
      const selectedCount = Array.from(select.options).filter(
        (o) => o.selected
      ).length;

      // Max limit check
      if (maxSelections && !opt.selected && selectedCount >= maxSelections) {
        shake(div);
        return;
      }

      // Min limit check
      if (requireAtLeastOne && opt.selected && selectedCount <= 1) {
        shake(div);
        return;
      }

      // Toggle & Sync
      opt.selected = !opt.selected;
      select.dispatchEvent(new Event("input", { bubbles: true }));
      updateUI();
    };

    list.appendChild(div);
  });

  // --- Event Handlers ---

  // Collapse Toggle
  btn.onclick = () => (isCollapsed ? expandList() : collapseList());

  // Button Hover
  btn.onmouseenter = () => {
    btn.style.borderColor = "#2E7636";
    btn.style.color = "#111";
  };
  btn.onmouseleave = () => (btn.style.borderColor = "#d1d5db");
  btn.onfocus = () => (btn.style.borderColor = "#2E7636");

  // External Click Handler (Closes list if click is outside the wrapper)
  const outsideClickListener = (event) => {
    if (!wrapper.contains(event.target)) {
      collapseList();
    }
  };

  // --- Assembly ---
  select.parentNode.insertBefore(wrapper, select);
  wrapper.appendChild(btn);
  wrapper.appendChild(list);
  wrapper.appendChild(select);

  document.addEventListener("click", outsideClickListener);

  updateUI();

  // --- Polling Loop & Cleanup ---
  let lastIndices = getSelectedIndices();

  const poll = setInterval(() => {
    const isAttached = document.body.contains(wrapper);
    if (!isAttached) {
      clearInterval(poll);
      // Clean up the global listener
      document.removeEventListener("click", outsideClickListener);
      return;
    }

    const currentIndices = getSelectedIndices();

    // Check for changes (efficient Set comparison)
    let changed = currentIndices.size !== lastIndices.size;
    if (!changed) {
      for (let i of currentIndices) {
        if (!lastIndices.has(i)) {
          changed = true;
          break;
        }
      }
    }

    if (changed) {
      lastIndices = currentIndices;
      updateUI();
    }
  }, 100);

  /// return wrapper;
  return viewofSelect
}
