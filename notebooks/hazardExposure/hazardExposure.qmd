---
pagetitle: "Atlas Hazard Exposure"
nb-authors:
  - Brayden Youngberg
  - Pete Stewart
  - Joseph Chemutt
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
import {
  atlasHero,
  downloadButton,
  multiLineText,
  loaderDiv,
} from "/helpers/uiComponents.ojs";
import { filterableDataTable as hz_atlasTable } from "/components/_atlasTable.ojs";

import { cleanAdminInput_SQL } from "/helpers/data.js";

import { enhancedMultiSelect } from "/helpers/enhancedMultiSelect.ojs";

import { inputTemplate } from "/helpers/std.ojs";

import { atlasTOC } from "/helpers/toc.ojs";

atlasHero(nbTitle, "../../images/default_crop.webp");
```


```{ojs}
 //| output: false
 hz_harmonizeNativeInputs = {
  const ENHANCED_FONT = 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif'
  const ARROW_SVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M6 8l4 4 4-4'/></svg>"

  const isHidden = (el) => {
    try {
      if (el.hidden) return true
      const cs = getComputedStyle(el)
      return (cs.display === "none" || cs.visibility === "hidden" || cs.opacity === "0")
    } catch { return false }
  }

  const styleSelect = (el) => {
    if (!el || el.tagName !== "SELECT") return
    if (el.multiple) return
    if (isHidden(el)) return

    el.style.fontFamily = ENHANCED_FONT
    el.style.fontSize = "14px"
    el.style.fontWeight = "500"
    el.style.width = "100%"
    el.style.minWidth = "0"
    el.style.boxSizing = "border-box"
    el.style.padding = "10px"
    el.style.paddingRight = "38px"
    el.style.backgroundColor = "white"
    el.style.color = "#111"
    el.style.border = "2px solid #d1d5db"
    el.style.borderRadius = "6px"
    el.style.cursor = "pointer"
    el.style.lineHeight = "1.2"
    el.style.transition = "all 0.2s ease"
    el.style.webkitAppearance = "none"
    el.style.mozAppearance = "none"
    el.style.appearance = "none"
    el.style.backgroundImage = 'url("' + ARROW_SVG + '")'
    el.style.backgroundRepeat = "no-repeat"
    el.style.backgroundPosition = "right 12px center"
    el.style.backgroundSize = "14px 14px"
  }

  const styleTextInput = (el) => {
    if (!el) return
    if (isHidden(el)) return
    el.style.fontFamily = ENHANCED_FONT
    el.style.fontSize = "14px"
    el.style.fontWeight = "500"
    el.style.width = "100%"
    el.style.minWidth = "0"
    el.style.boxSizing = "border-box"
    el.style.padding = "10px"
    el.style.backgroundColor = "white"
    el.style.color = "#111"
    el.style.border = "2px solid #d1d5db"
    el.style.borderRadius = "6px"
    el.style.lineHeight = "1.2"
    el.style.transition = "all 0.2s ease"
  }

  const styleInnerLabel = (label) => {
    if (!label || label.tagName !== "LABEL") return
    if (!label.querySelector("select")) return
    label.style.fontFamily = ENHANCED_FONT
    label.style.fontSize = "12px"
    label.style.fontWeight = "700"
    label.style.letterSpacing = "0.02em"
    label.style.display = "grid"
    label.style.gap = "0.35rem"
    label.style.margin = "0"
    label.style.textTransform = "uppercase"
  }

  const apply = () => {
    try {
      const roots = [
        ...document.querySelectorAll(".hz-controlsCompact"),
        ...document.querySelectorAll('[id^="observablehq-viewof-"]')
      ]
      roots.forEach(root => {
        root.querySelectorAll("label").forEach(styleInnerLabel)
        root.querySelectorAll("select").forEach(styleSelect)
        root.querySelectorAll('input[type="text"], input[type="number"], input[type="search"], textarea').forEach(styleTextInput)
      })
    } catch (e) { /* no-op */ }
  }

  apply()
  const mo = new MutationObserver(() => apply())
  mo.observe(document.body, { childList: true, subtree: true })
  invalidation.then(() => mo.disconnect())
  return null
}
```

{{< include /components/_atlasBoundaries.qmd >}}

```{ojs}
//| output: false
// Observable Plot
// Use dynamic import 
Plot = await import("https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.14/+esm")
```

```{ojs}
//| output: false
// ------------------------------------------------------------------
// Core helpers
// ------------------------------------------------------------------
hz_isHttpUrl = (x) => /^https?:\/\//i.test(String(x ?? ""))

hz_s3ToHttps = (s3) => {
  const s = String(s3 ?? "")
  const m = /^s3:\/\/([^\/]+)\/?(.*)$/.exec(s)
  if (!m) return s3
  const bucket = m[1]
  const key = (m[2] ?? "").replace(/^\/+/, "")
  if (!key) return `https://${bucket}.s3.amazonaws.com/`
  if (bucket === "digital-atlas") return `https://digital-atlas.s3.amazonaws.com/${key}`
  return `https://${bucket}.s3.amazonaws.com/${key}`
}

hz_toServedUrl = (p) => {
  const s = String(p ?? "").trim()
  if (!s) return s
  if (/^s3:\/\//i.test(s)) return hz_s3ToHttps(s)
  if (hz_isHttpUrl(s)) return s
  // Normalize Windows paths/backslashes to URL-style
  return s.replace(/\\/g, "/").replace(/^\.\//, "")
}

hz_resolvePath = (entry) => {
  if (!entry) return { ok: false, raw: null, url: null, source: "missing" }
  const local = entry.local_path ?? entry.localPath ?? null
  const s3 = entry.s3_path ?? entry.s3 ?? entry.path ?? null
  const url0 = entry.url ?? null

  if (local && String(local).trim() !== "") {
    const raw = String(local)
    return { ok: true, raw, url: hz_toServedUrl(raw), source: "local_path" }
  }
  if (s3 && String(s3).trim() !== "") {
    const raw = String(s3)
    const url = hz_isHttpUrl(raw) ? raw : hz_s3ToHttps(raw)
    return { ok: true, raw, url, source: hz_isHttpUrl(raw) ? "https" : "s3_path" }
  }
  if (url0 && String(url0).trim() !== "") {
    const raw = String(url0)
    return { ok: true, raw, url: hz_isHttpUrl(raw) ? raw : hz_toServedUrl(raw), source: "url" }
  }
  return { ok: false, raw: null, url: null, source: "missing" }
}

hz_validateParquetUrl = async (url) => {
  const u = String(url ?? "").trim()
  if (!u || !hz_isHttpUrl(u)) return { ok: true }
  try {
    const r = await fetch(u, { headers: { Range: "bytes=0-3" } })
    if (!r.ok) return { ok: false, error: `HTTP ${r.status} ${r.statusText}` }
    const buf = new Uint8Array(await r.arrayBuffer())
    const magic = String.fromCharCode(...buf)
    if (magic !== "PAR1") return { ok: false, error: `Not a Parquet file (magic=${magic})` }
    return { ok: true }
  } catch (e) {
    // If the check fails due to CORS/network quirks, don't block — DuckDB will still try.
    return { ok: true, warn: String(e) }
  }
}

hz_formatNumber = (v, { digits = 0, compact = true } = {}) => {
  const x = Number(v)
  if (!Number.isFinite(x)) return "—"
  const opts = compact
    ? { notation: "compact", compactDisplay: "short", maximumFractionDigits: digits, minimumFractionDigits: 0 }
    : { maximumFractionDigits: digits, minimumFractionDigits: 0 }
  return new Intl.NumberFormat(undefined, opts).format(x)
}

// Shared display formatters (used in Chart/Table/Map)
fmtAbs = (v) => hz_formatNumber(v, { digits: 2, compact: true })
fmtAbs0 = (v) => hz_formatNumber(v, { digits: 0, compact: true })
fmtPct = (v) => {
  const x = Number(v)
  if (!Number.isFinite(x)) return "—"
  return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
}
fmtSigned = (v) => {
  const x = Number(v)
  if (!Number.isFinite(x)) return "—"
  const s = x > 0 ? "+" : ""
  return s + hz_formatNumber(x, { digits: 2, compact: true })
}

hz_titleCase = (s) =>

  String(s ?? "")
    .replace(/[-_]+/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase())
```

```{ojs}
//| output: false
// hazardExposure_{varShort}_{period}_{model}_{severity}[_{suffix}]
hz_parseKeyParts = (key) => {
  const s = String(key ?? "").trim()
  const out = { raw: s, ok: false, varShort: null, period: null, model: null, severity: null, suffix: null, scenario: null, timeframe: null }
  if (!s) return out
  const parts = s.split("_")
  if (parts.length < 5 || parts[0] !== "hazardExposure") return out

  out.varShort = parts[1]
  out.period = parts[2]
  out.severity = parts[parts.length - 1]

  // model may include underscores (e.g., ssp585_2041-2060)
  const mid = parts.slice(3, parts.length - 1)
  out.model = mid.join("_") || null

  const knownSuffixes = new Set(["generic", "crop-specific", "crop_specific", "auto", "best"])
  if (out.model) {
    const mparts = out.model.split("_")
    const last = mparts[mparts.length - 1]
    if (knownSuffixes.has(last)) {
      out.suffix = last
      out.model = mparts.slice(0, -1).join("_") || null
    }
  }

  // derive scenario/timeframe from model
  if (out.model) {
    const mod = out.model
    if (mod === "historic" || mod === "Historical") {
      out.scenario = "historic"
      out.timeframe = "historic"
    } else {
      const mm = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(mod)
      if (mm) {
        out.scenario = mm[1]
        out.timeframe = mm[2]
      } else {
        out.scenario = mod
        out.timeframe = null
      }
    }
  }

  out.ok = true
  return out
}
```

```{ojs}
//| output: false
// Responsive width sensor for Plot
viewof hz_plotWidth = {
  const el = html`<div class="hz-width-sensor"></div>`
  el.value = 900
  const ro = new ResizeObserver(() => {
    const w = Math.floor(el.getBoundingClientRect().width || 900)
    if (w && w !== el.value) {
      el.value = w
      el.dispatchEvent(new Event("input", {bubbles:true}))
    }
  })
  ro.observe(el)
  return el
}
```

```{ojs}
//| output: false
// Create a DuckDB client
hz_db = DuckDBClient.of()
```

```{ojs}
//| output: false
hz_rows = {
  function rows(res) {
    if (!res) return []
    if (typeof res.toArray === "function") return rows(res.toArray())
    if (Array.isArray(res)) return res
    if (res.data && Array.isArray(res.data)) return res.data
    // Last resort: try iterable
    try { return Array.from(res) } catch (e) { return res }
  }
  return rows
}

// Convenience wrapper
hz_query = async (sql) => {
  try {
    return hz_rows(await hz_db.query(sql))
  } catch (e) {
    try { hz_addError("hz_query", e, { sql }) } catch (e2) {}
    if (typeof console !== "undefined") console.error("hz_query failed", e, sql)
    return []
  }
}
```

```{=html}
<style>
  .atlasFigCaption {
    position: relative;
    z-index: -1;
  }

  .hz-card,
  .hz-question,
  .hz-controlsPanel,
  .hz-qToolbar {
    background: transparent;
    border: 0;
    box-shadow: none;
    border-radius: 0;
    padding: 0;
    margin: 0 0 1.25rem 0;
  }

  .hz-card__title {
    font-weight: 600;
    font-size: 1.1rem;
    line-height: 1.3;
    margin: 0.25rem 0;
  }

  .hz-card__sub,
  .hz-muted,
  .hz-loading {
    color: var(--bs-secondary-color, #6c757d);
    font-size: 0.95rem;
  }

  .hz-chip {
    display: inline-block;
    padding: 0.1rem 0.5rem;
    margin: 0.125rem 0.25rem 0.125rem 0;
    border: 1px solid rgba(0, 0, 0, 0.15);
    border-radius: 999px;
    font-size: 0.9rem;
  }

  .hz-chartWrap,
  .hz-grid,
  .hz-mount {
    width: 100%;
  }

  .hz-grid {
    overflow-x: auto;
  }


.hz-grid2{
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
  align-items: start;
}
@media (max-width: 992px){
  .hz-grid2{ grid-template-columns: 1fr; }
}

  .hz-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    align-items: center;
  }


  .hz-controlsCompact .hz-controlsRows{
    display:flex;
    flex-direction:column;
    gap:0.75rem;
  }
  .hz-controlsCompact .hz-row{
    display:grid;
    gap:0.75rem;
    align-items:end;
  }
  .hz-controlsCompact .hz-row--2{
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  .hz-controlsCompact .hz-row--3{
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
  
  .hz-controlsCompact .hz-row--3.hz-row--grow{
    grid-template-columns: minmax(190px, 1fr) minmax(280px, 2fr) minmax(190px, 1fr);
  }
  .hz-controlsCompact .hz-field{ min-width:0; }

  @media (max-width: 992px){
    .hz-controlsCompact .hz-row--3{
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
    .hz-controlsCompact .hz-row--3.hz-row--grow{
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
  @media (max-width: 576px){
    .hz-controlsCompact .hz-row--2,
    .hz-controlsCompact .hz-row--3{
      grid-template-columns: 1fr;
    }
  }

  /* Q1 toolbar (Chart/Table + toggles) */
  .hz-qToolbar{
    display:flex;
    flex-wrap:wrap;
    gap:0.75rem;
    align-items:flex-end;
    justify-content:space-between;
    margin-bottom:0.75rem;
  }
  .hz-viewToggle{
    display:flex;
    gap:0.75rem;
    align-items:center;
    flex-wrap:wrap;
  }
  .hz-inlineToggles{
    display:flex;
    gap:0.75rem;
    align-items:flex-end;
    flex-wrap:wrap;
  }
  .hz-miniSetting{
    display:flex;
    gap:0.4rem;
    align-items:center;
  }
  .hz-miniSetting > span{
    color: var(--bs-secondary-color, #6c757d);
    font-size: 0.9rem;
    white-space:nowrap;
  }
  .hz-miniSetting--range input[type="range"]{
    min-width: 180px;
  }
  @media (max-width: 576px){
    .hz-miniSetting{
      width:100%;
      justify-content:space-between;
    }
  }

.hidden { display: none !important; }


.hz-controlsCompact{
  font-family: var(--bs-body-font-family, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif);
  font-size: 14px;
}
.hz-controlsCompact .form-select,
.hz-controlsCompact .form-control,
.hz-controlsCompact .form-range,
.hz-controlsCompact .form-check-input,
.hz-controlsCompact select,
.hz-controlsCompact input,
.hz-controlsCompact textarea,
.hz-controlsCompact button{
  font-family: inherit !important;
  font-size: inherit !important;
}

.hz-controlsCompact .choices,
.hz-controlsCompact .choices *{
  font-family: inherit !important;
  font-size: inherit !important;
}


.hz-chartWrap { position: relative; min-height: 340px; }
.hz-chartWrap--busy::before {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.62);
  backdrop-filter: blur(2px);
  border-radius: 14px;
  z-index: 10;
}
.hz-chartWrap--busy::after {
  content: "Updating chart…";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  padding: 10px 14px;
  border-radius: 999px;
  border: 1px solid rgba(0, 0, 0, 0.12);
  background: rgba(255, 255, 255, 0.9);
  box-shadow: 0 10px 26px rgba(0, 0, 0, 0.10);
  font-weight: 900;
  font-size: 0.9rem;
  z-index: 11;
  white-space: nowrap;
}

.hz-tableWrap { position: relative; min-height: 560px; padding: 6px; font-size: 12px; }
.hz-tableWrap--busy::before {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.62);
  backdrop-filter: blur(2px);
  border-radius: 14px;
  z-index: 10;
}
.hz-tableWrap--busy::after {
  content: "Updating table…";
  position: absolute;
  top: 14px;
  right: 14px;
  background: rgba(15, 23, 42, 0.85);
  color: #fff;
  font-size: 12px;
  font-weight: 800;
  padding: 6px 10px;
  border-radius: 999px;
  z-index: 11;
  white-space: nowrap;
}

@media (prefers-color-scheme: dark) {
  .hz-chartWrap--busy::before,
  .hz-tableWrap--busy::before {
    background: rgba(0, 0, 0, 0.35);
  }
  .hz-chartWrap--busy::after {
    background: rgba(17, 24, 39, 0.9);
    color: #fff;
    border: 1px solid rgba(255, 255, 255, 0.18);
    box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35);
  }
  .hz-tableWrap--busy::after {
    background: rgba(17, 24, 39, 0.9);
  }
}


.hz-qHeading{
  margin: 0 0 .5rem 0;
}
</style>
```

# `{ojs} heading1` {#overview}

```{ojs}
md`${_lang(nbText.sections.intro.text)}`;
```

# `{ojs} q1Title` {#q1}

```{ojs}
md`${_lang(nbText.sections.q1.introText)}`;
```

```{=html}
<div id="hz-dashboard"></div>
```

```{ojs}
//| output: false

// Runtime diagnostics (browser)

hz_diagInit = {
  try {
    if (typeof window === "undefined") return null
    if (window.__hzDiag) return window.__hzDiag

    const state = { errors: [], seen: new Set() }

    const addError = (context, err, details=null) => {
      try {
        const msg = String(err?.message ?? err)
        const stack = err?.stack ? String(err.stack) : ""
        const id = `${context}::${msg}`

        if (!state.seen.has(id)) {
          state.seen.add(id)
          state.errors.push({
            time: new Date().toISOString(),
            context,
            message: msg,
            stack,
            details
          })

          window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
        }
      } catch (e) {
        state.errors.push({
          time: new Date().toISOString(),
          context: "hz:addError",
          message: String(e?.message ?? e),
          stack: e?.stack ? String(e.stack) : "",
          details: null
        })
        window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
      }
    }

    window.__hzDiag = { state, addError }

    // Hook global errors once
    if (!window.__hzRuntimeHooked) {
      window.__hzRuntimeHooked = true
      window.addEventListener("error", (ev) => {
        addError("window.error", ev?.error ?? ev?.message ?? ev, {
          filename: ev?.filename, lineno: ev?.lineno, colno: ev?.colno
        })
      })
      window.addEventListener("unhandledrejection", (ev) => {
        addError("window.unhandledrejection", ev?.reason ?? ev)
      })
    }

    // Initial broadcast
    window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
    return window.__hzDiag
  } catch (e) {
    if (typeof console !== "undefined") console.error("hz_diagInit failed", e)
    return null
  }
}

hz_addError = (context, err, details=null) => {
  try {
    if (typeof window !== "undefined" && window.__hzDiag?.addError) {
      window.__hzDiag.addError(context, err, details)
    } else if (typeof console !== "undefined") {
      console.error(`[${context}]`, err, details ?? "")
    }
  } catch (e) {
    if (typeof console !== "undefined") console.error("hz_addError failed", e)
  }
}

// Reactive stream of errors for display
hz_errors = Generators.observe((notify) => {
  // ensure diagnostics are initialized
  hz_diagInit
  if (typeof window === "undefined") {
    notify([])
    return () => {}
  }

  const handler = (ev) => notify(ev?.detail ?? [])
  window.addEventListener("hz:diag", handler)

  // seed with current state (if any)
  const existing = window.__hzDiag?.state?.errors ?? []
  notify(existing.slice())

  return () => window.removeEventListener("hz:diag", handler)
})

hz_renderErrors = (errors) => {
  const esc = (s) => String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")

  if (!errors || errors.length === 0) {
    return html`<div class="callout callout-note"><strong>No runtime errors captured.</strong></div>`
  }

  return html`<div class="callout callout-warning">
    <strong>Runtime diagnostics (${errors.length})</strong>
    <ol style="margin-top:0.5rem;">
      ${errors.map(e => html`<li style="margin-bottom:0.75rem;">
        <div><strong>${esc(e.context)}</strong> <span style="opacity:.75;">${esc(e.time)}</span></div>
        <div style="white-space:pre-wrap;">${esc(e.message)}</div>

        ${e.details ? html`<details style="margin-top:0.25rem;">
          <summary>details</summary>
          <pre style="white-space:pre-wrap; margin:0.5rem 0 0 0;">${esc(JSON.stringify(e.details, null, 2))}</pre>
        </details>` : null}

        ${e.stack ? html`<details style="margin-top:0.25rem;">
          <summary>stack</summary>
          <pre style="white-space:pre-wrap; margin:0.5rem 0 0 0;">${esc(e.stack)}</pre>
        </details>` : null}
      </li>`)}
    </ol>
  </div>`
}

// nbData.json loader + normalizer

hz_loadJson = async (path) => {
  try {
    const res = await fetch(path)
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`)
    return await res.json()
  } catch (e) {
    hz_addError(`loadJson(${path})`, e)
    throw e
  }
}

// Make nbData tolerant to different JSON shapes
// Expected final: Array of dataset objects [{key, local_path|s3_path, sql, ...}, ...]
hz_normalizeNbData = (raw) => {
  if (Array.isArray(raw)) return { ok:true, data: raw, note: "root is array" }

  if (raw && typeof raw === "object") {
    // Common wrapper fields
    const candidates = ["data", "datasets", "items", "resources", "catalog", "tables"]
    for (const k of candidates) {
      const v = raw[k]
      if (Array.isArray(v)) return { ok:true, data: v, note: `using raw.${k}` }
      if (v && typeof v === "object" && Array.isArray(v.data)) {
        return { ok:true, data: v.data, note: `using raw.${k}.data` }
      }
    }

    // Object-of-objects → values()
    const vals = Object.values(raw)
    if (vals.length && vals.every(v => v && typeof v === "object")) {
      const looksLike = vals.some(v =>
        ("key" in v) || ("sql" in v) || ("local_path" in v) || ("s3_path" in v)
      )
      if (looksLike) return { ok:true, data: vals, note: "using Object.values(raw)" }
    }

    return {
      ok: false,
      data: null,
      note: "root object not recognized",
      rawKeys: Object.keys(raw).slice(0, 50)
    }
  }

  return { ok:false, data:null, note: `unsupported JSON type: ${typeof raw}` }
}

// Load dataset index
hz_nbMeta = {
  try {
    const raw = await hz_loadJson("/data/hazardExposure/nbData.json")
    const norm = hz_normalizeNbData(raw)

    if (!norm.ok || !Array.isArray(norm.data)) {
      const err = new Error(`nbData.json did not parse to an array. ${norm.note || ""}`)
      hz_addError("nbData.json shape", err, { norm, rawType: typeof raw })
      return {
        ok: false,
        reason: err.message,
        data: [],
        rawType: typeof raw,
        rawKeys: norm.rawKeys ?? (raw && typeof raw === "object" ? Object.keys(raw).slice(0, 50) : [])
      }
    }

    return {
      ok: true,
      reason: norm.note,
      data: norm.data,
      rawType: typeof raw,
      rawKeys: raw && typeof raw === "object" ? Object.keys(raw).slice(0, 50) : []
    }
  } catch (e) {
    hz_addError("Load nbData.json", e)
    return {
      ok: false,
      reason: "Failed to load nbData.json: " + String(e?.message ?? e),
      data: [],
      rawType: null,
      rawKeys: []
    }
  }
}
```

```{ojs}
//| output: false
hz_nbMeta.ok
  ? html`<div class="callout callout-note">
      <strong>nbData.json:</strong> Loaded ${hz_nbMeta.data.length} entries <span style="opacity:.75;">(${hz_nbMeta.reason})</span>
    </div>`
  : html`<div class="callout callout-important">
      <strong>nbData.json:</strong> ${hz_nbMeta.reason}
      <div style="margin-top:.25rem; white-space:pre-wrap; opacity:.85;">
        Raw keys: ${JSON.stringify(hz_nbMeta.rawKeys)}
      </div>
    </div>`
```

```{ojs}
//| output: false
// Build a lookup map for fast key -> entry access
hz_nbIndex = {
  const m = new Map()
  for (const d of hz_nbMeta.data ?? []) m.set(d.key, d)
  return m
}
```

```{ojs}
//| output: false
// Parse available hazard exposure datasets from keys like: hazardExposure_usd15_annual_historic_moderate
hz_hazEntries = {
  const out = []
  const methodSuffixes = new Set(["generic", "crop_specific"])
  for (const d of hz_nbMeta.data ?? []) {
    if (!d.key?.startsWith("hazardExposure_")) continue
    const parts = d.key.split("_").filter(Boolean)
    if (parts.length < 5) continue

    const maybeMethod = parts[parts.length - 1]
    const hasMethod = methodSuffixes.has(maybeMethod)

    const severity = hasMethod ? parts[parts.length - 2] : parts[parts.length - 1]
    const method = hasMethod ? maybeMethod : null
    const modelParts = parts.slice(3, hasMethod ? (parts.length - 2) : (parts.length - 1))
    const model = modelParts.join("_")

    if (!model || !severity) continue

    out.push({
      key: d.key,
      varShort: parts[1],     // usd15 / intld15 etc.
      period: parts[2],       // annual / jagermeyr etc.
      model,                 // historical / ensemble / ssp245_2041-2060 etc.
      severity,              // moderate / severe / extreme etc.
      method,                // generic / crop_specific (optional)
      entry: d
    })
  }
  return out
}
```

```{ojs}
//| output: false
// Options derived from nbData.json (hazard exposure datasets)

hz_parseHazKey = (key) => {
  try {
    const s = String(key ?? "")
    if (!s.startsWith("hazardExposure_")) return null

    const parts = s.split("_")
    if (parts.length < 5) return null

    const varShort = parts[1]
    const period = parts[2]

    const knownMethods = new Set(["generic","crop_specific"])
    let method = null
    let severity = null
    let model = null

    if (knownMethods.has(parts[parts.length - 1])) {
      method = parts[parts.length - 1]
      severity = parts[parts.length - 2]
      model = parts.slice(3, parts.length - 2).join("_")
    } else {
      severity = parts[parts.length - 1]
      model = parts.slice(3, parts.length - 1).join("_")
    }

    return { key: s, varShort, period, model, severity, method }
  } catch (e) {
    hz_addError("hz_parseHazKey", e, { key })
    return null
  }
}

hz_parsed = {
  const parsed = hz_hazEntries
    .map(d => hz_parseHazKey(d.key))
    .filter(Boolean)

  if (hz_nbMeta.ok && hz_hazEntries.length > 0 && parsed.length === 0) {
    hz_addError(
      "Key parsing",
      new Error("No keys matched expected pattern hazardExposure_{varShort}_{period}_{model}_{severity}"),
      { exampleKeys: hz_hazEntries.slice(0, 10).map(d => d.key) }
    )
  }

  return parsed
}

hz_varShorts = Array.from(new Set(hz_parsed.map(d => d.varShort))).sort()
hz_periods   = Array.from(new Set(hz_parsed.map(d => d.period))).sort()
hz_models    = Array.from(new Set(hz_parsed.map(d => d.model))).sort()
hz_severities= Array.from(new Set(hz_parsed.map(d => d.severity))).sort()

hz_formatVarShort = (v) => {
  const s = String(v ?? "")
  if (s === "vop") return "Value of production (vop)"
  if (s === "prod") return "Production (prod)"
  if (s === "area") return "Area (area)"
  return s
}

// Friendly label for the selected exposure value
hz_varLabel = (() => {
  const s = String(hz_varShort ?? "")
  if (s === "intld15") return "International Dollars (2015)"
  if (s === "usd15") return "USD (2015)"
  if (s === "people") return "People"
  return hz_formatVarShort(s)
})()

// Absolute axis label used by charts (when not in Relative % mode)
hz_varLabelAbs = (() => {
  const base = String(hz_varLabel ?? '').trim()
  if (!base) return 'Exposure'
  // If hz_varLabel already reads like a full label, keep it.
  if (/exposure/i.test(base)) return base
  return `Exposure (${base})`
})()

hz_formatPeriod = (p) => {
  const s = String(p ?? "")
  if (s === "annual") return "Annual"
  if (s.toLowerCase().includes("jaeger") || s.toLowerCase().includes("jager")) return "Jägermeyr"
  return s
}

hz_formatSeverity = (sev) => {
  const s = String(sev ?? "")
  if (s === "all") return "All"
  return s.toUpperCase()
}

hz_formatModel = (m) => {
  const s = String(m ?? "")
  if (/hist|historic/i.test(s)) return "Historical"
  // ssp245_2050 -> SSP245 (2050)
  const mm = /^ssp(\d{3})_(\d{4})$/.exec(s)
  if (mm) return `SSP${mm[1]} (${mm[2]})`
  return s
}

hz_varShortOptions  = hz_varShorts.map(v => ({ label: hz_formatVarShort(v), value: v }))
hz_periodOptions    = hz_periods.map(p => ({ label: hz_formatPeriod(p), value: p }))
hz_severityOptions  = hz_severities.map(s => ({ label: hz_formatSeverity(s), value: s }))
hz_scenOptions      = hz_models.map(m => ({ label: hz_formatModel(m), value: m }))

hz_defaultVarShort = hz_varShorts.find(v => /usd15/i.test(String(v))) ?? hz_varShorts.find(v => /intld15/i.test(String(v))) ?? hz_varShorts[0] ?? null
hz_defaultPeriod    = hz_periods.includes("annual") ? "annual" : (hz_periods[0] ?? null)
hz_defaultSeverity = hz_severities.find(s => String(s).toLowerCase() === "severe") ?? hz_severities.find(s => String(s).toLowerCase() === "extreme") ?? hz_severities[0] ?? null

hz_defaultModel1 = hz_models.find(m => /historic/i.test(String(m))) ?? hz_models[0] ?? null
hz_defaultModel2 = hz_models.find(m => /ensemble/i.test(String(m))) ?? hz_models.find(m => String(m) !== String(hz_defaultModel1)) ?? hz_defaultModel1
hz_defaultScen1 = (hz_scenXTime ?? []).includes("historic") ? "historic" : ((hz_scenXTime ?? [])[0] ?? null)
hz_defaultScen2 = {
  const xs = hz_scenXTime ?? []
  const left = hz_defaultScen1
  return xs.find(d => String(d) !== String(left)) ?? left ?? null
}

({
  varShorts: hz_varShorts,
  periods: hz_periods,
  models: hz_models,
  severities: hz_severities
})
```

```{ojs}
//| output: false
// Label used in compact summaries / headers
hz_periodLabel = (typeof hz_formatPeriod === 'function') ? hz_formatPeriod(hz_period) : String(hz_period ?? '')
```

```{ojs}
//| output: false
// View controls
viewof hz_varShort = Inputs.select(hz_varShorts, {
  label: "Exposure value:",
  format: hz_formatVarShort,
  value: hz_defaultVarShort
})
```

```{ojs}
//| output: false
viewof hz_period = Inputs.select(hz_periods, {
  label: "Period:",
  format: hz_formatPeriod,
  value: hz_defaultPeriod
})
```

```{ojs}
//| output: false
viewof hz_severity = Inputs.select(hz_severities, {
  label: "Severity:",
  format: hz_formatSeverity,
  value: hz_defaultSeverity
})
```

```{ojs}
//| output: false
hz_severityLabel = (typeof hz_formatSeverity === "function")
  ? hz_formatSeverity(hz_severity)
  : String(hz_severity ?? "")
```

```{ojs}
//| output: false
// Scenario/timeframe label formatter + parser 
hz_formatScenXTime = (scenTime) => {
  const s = String(scenTime ?? "").trim()
  if (!s) return ""
  if (s === "historic" || s === "Historical") return "Historical"
  const m = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(s)
  if (m) return `${m[1].toUpperCase()} ${m[2]}`
  return s
}

hz_parseScenXTime = (scenTime) => {
  const s = String(scenTime ?? "").trim()
  if (!s || s === "historic" || s === "Historical") {
    return { scenTime: "historic", scenario: "historic", timeframe: "historic", model: "historic" }
  }
  const m = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(s)
  if (m) return { scenTime: s, scenario: m[1], timeframe: m[2], model: "ENSEMBLE" }
  return { scenTime: s, scenario: s, timeframe: null, model: s }
}
```

```{ojs}
//| output: false
viewof hz_scen1 = Inputs.select(hz_scenXTime, {
  label: "Scenario A:",
  format: hz_formatScenXTime,
  value: "historic"
})
```

```{ojs}
//| output: false
viewof hz_scen2 = Inputs.select(hz_scenXTime, {
  label: "Scenario B:",
  format: hz_formatScenXTime,
  value: "ssp585_2041-2060"
})

hz_scenXTime = [
  "historic",
  "ssp126_2021-2040","ssp126_2041-2060","ssp126_2061-2080",
  "ssp245_2021-2040","ssp245_2041-2060","ssp245_2061-2080",
  "ssp370_2021-2040","ssp370_2041-2060","ssp370_2061-2080",
  "ssp585_2021-2040","ssp585_2041-2060","ssp585_2061-2080"
]
// Default  values:
// scenario1 = historic; scenario2 = ssp585_2041-2060
```

```{ojs}
//| output: false
// Chart toggles
viewof hz_relative = Inputs.toggle({ label: "", value: false })
```

```{ojs}
//| output: false
viewof hz_difference = Inputs.toggle({ label: "", value: false })
```

```{ojs}
//| output: false
// Hazard dataset method (suffix) selector
hz_methodOptions = ["auto", "generic", "crop_specific"]
hz_methodLabel = (v) => ({
  auto: "Auto (best available)",
  generic: "Generic (all commodities aggregated)",
  crop_specific: "Crop-specific (SPAM crops + GLW livestock)"
}[v] ?? v)

viewof hz_method = Inputs.select(hz_methodOptions, {
  label: "Hazard method:",
  value: "generic",
  format: hz_methodLabel
})
```

```{ojs}
 //| output: false

 hz_spamCropsMapUrl = "/data/shared/MapSpamCrops.json"
 hz_spamCropsMap = await (await fetch(hz_spamCropsMapUrl)).json()

 
 hz_spamCodes = {
   const j = hz_spamCropsMap ?? {}

   const collectIds = (key) => (j?.[key]?.items ?? [])
     .map(d => String(d?.id ?? "").trim())
     .filter(Boolean)

   // "crops" = all non-livestock categories in this JSON
   const cropCats = ["cereals", "legumes", "rootsTuber", "fruitVeg", "nonEdible"]
   const crops = cropCats.flatMap(collectIds)

   // Groups used by the UI ("roots_tubers" naming kept for compatibility)
   const groups = {
     cereals: collectIds("cereals"),
     legumes: collectIds("legumes"),
     roots_tubers: collectIds("rootsTuber")
   }

   // Labels lookup: id -> localized label (falls back to en / fr / id)
   const labels = {}
   for (const v of Object.values(j)) {
     for (const it of (v?.items ?? [])) {
       const id = String(it?.id ?? "").trim()
       if (!id) continue
       const lab = it?.label ?? {}
       const label = (typeof _lang === "function")
         ? _lang(lab)
         : (lab?.en ?? lab?.fr ?? id)
       labels[id] = label
     }
   }

   return {
     crops: [...new Set(crops)],
     groups,
     labels
   }
 }

 // Livestock list (from same JSON)
 hz_livestock = (hz_spamCropsMap?.livestock?.items ?? [])
   .map(d => String(d?.id ?? "").trim())
   .filter(Boolean)
```

```{ojs}
//| output: false
// Union of crops + livestock
hz_allCommodities = {
  const crops = hz_spamCodes?.crops ?? []
  const livestock = hz_livestock ?? []
  const set = new Set([...crops, ...livestock].filter(Boolean))
  return Array.from(set).sort((a,b) => String(a).localeCompare(String(b)))
}
```

```{ojs}
//| output: false
// Commodity selectors
hz_commodityGroupOptions = ["all", "crops", "livestock", "cereals", "legumes", "roots_tubers", "custom"]
hz_commodityGroupLabel = (v) => ({
  all: "All (crops + livestock)",
  crops: "Crops (SPAM2020)",
  livestock: "Livestock (GLW4)",
  cereals: "Cereals",
  legumes: "Legumes",
  roots_tubers: "Roots & tubers",
  custom: "Custom (pick manually)"
}[v] ?? v)

viewof hz_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], {
  label: "Group",
  value: "crops",
  format: hz_commodityGroupLabel
})
```

```{ojs}
//| output: false
hz_selectedCommodGroup = hz_commodityGroup
```

```{ojs}
//| output: false
hz_commodityOptions = {
  const g = hz_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  // default list for "all" and "custom"
  return [...(hz_spamCodes?.crops ?? []), ...(hz_livestock ?? [])].filter(Boolean).sort()
}

hz_commodityLabelOf = (v) => {
  const id = String(v ?? "").trim()
  const label = hz_spamCodes?.labels?.[id]
  return label ?? hz_titleCase(id.replaceAll("-", " "))
}

// multi-select (enhanced): filter + chips + checklist (shared component)
viewof hz_commodities = {
  const disabled = (hz_commodityGroup === "all")

  // Normalize option values to strings to avoid showing [object Object]
  const norm = (v) => {
    if (v == null) return null
    if (typeof v === "string" || typeof v === "number") return String(v)
    if (typeof v === "object") {
      return String(v.code ?? v.value ?? v.id ?? v.name ?? v.label ?? v.crop ?? v.commodity ?? "")
    }
    return null
  }

  const options = (hz_commodityOptions ?? [])
    .map(norm)
    .map(s => String(s ?? "").trim())
    .filter(Boolean)

  const label = (typeof _lang === "function")
    ? _lang({ en: "Commodities", fr: "Produits" })
    : "Commodities"

  // Avoid self-reference (circular definition) by not reading hz_commodities here.
  const initial = disabled ? [] : []

  const viewofSelect = Inputs.select(options, {
    label,
    multiple: true,
    value: initial,
    disabled,
    format: hz_commodityLabelOf
  })

  // enhancedMultiSelect expects the *view element* as the first argument.
  const enhanced = enhancedMultiSelect(viewofSelect, {
placeholder: "Search commodities…",
    requireAtLeastOne: false,
    maxHeight: 200,
    width: "100%"
  })

  // Ensure truly empty-by-default (no implicit first selection)
  try {
    const sel = enhanced.querySelector("select") || enhanced
    Array.from(sel.options).forEach((o) => (o.selected = false))
    sel.selectedIndex = -1
    sel.dispatchEvent(new Event("input", { bubbles: true }))
  } catch (_) {}

  return enhanced
}
```

```{ojs}
//| output: false
// Final set of commodities used in SQL filter (array of crop strings)
hz_selectedCommodities = {
  // If user picks nothing, we still apply the selected Group as the default
  // (e.g., Group = cereals => all cereals). This keeps the UI empty-by-default,
  // but makes the query semantics match the group selection.
  const g = hz_commodityGroup

  const opts = (hz_commodityOptions ?? [])
    .map((v) => String(v).trim())
    .filter(Boolean)
  const optSet = new Set(opts)

  const pickedRaw = (hz_commodities ?? [])
    .filter(Boolean)
    .map((v) => String(v).trim())
    .filter(Boolean)

  // Prevent stale picks when changing groups (only keep picks in current options)
  const picked = pickedRaw.filter((v) => optSet.has(v))

  // User override
  if (picked.length) return picked

  // Group defaults
  if (g === "livestock") return (hz_livestock ?? []).slice()
  if (g === "crops") return (hz_spamCodes?.crops ?? []).slice()
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? []).slice()
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? []).slice()
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? []).slice()

  // "all" with no picks => include everything
  if (g === "all") return hz_allCommodities ?? []

  // "custom" with no picks => no filter (empty selection)
  if (g === "custom") return []

  // fallback
  return hz_allCommodities ?? []
}
```

```{ojs}
//| output: false
hz_selectedCommoditiesForReq = {
  const g = hz_commodityGroup
  const picked = (hz_selectedCommodities ?? []).filter(Boolean)
  if (g === "custom" && picked.length === 0) return ["all"]
  return picked
}
```

```{ojs}
//| output: false
hz_commoditiesUI = viewof hz_commodities
```

```{ojs}
//| output: false
hz_previewList = (arr, max = 4) => {
  const xs = Array.isArray(arr) ? arr.filter(Boolean) : []
  if (xs.length <= max) return xs.join(", ")
  return xs.slice(0, max).join(", ") + ` +${xs.length - max}`
}
```

```{ojs}
//| output: false
// Display controls
// Compare mode affects Q2/Q4 when comparing Left vs Right.
viewof hz_compareMode = {
  const options = [
    { value: 'side', label: 'Side-by-side' },
    { value: 'diff', label: 'Δ Right − Left' }
  ]
  const root = document.createElement('div')
  root.className = 'hz-tabs hz-tabs--small'
  const buttons = new Map()

  const set = (v) => {
    root.value = v
    for (const [val, btn] of buttons.entries()) btn.classList.toggle('is-active', val === v)
    root.dispatchEvent(new Event('input', { bubbles: true }))
  }

  for (const opt of options) {
    const b = document.createElement('button')
    b.type = 'button'
    b.className = 'hz-tab'
    b.textContent = opt.label
    b.onclick = () => set(opt.value)
    root.appendChild(b)
    buttons.set(opt.value, b)
  }

  set('side')
  return root
}

viewof hz_topN = Inputs.range([5, 50], { label: "Top items (Top N):", step: 1, value: 25 })
viewof hz_groupOther = Inputs.toggle({ label: 'Group remaining hazards into "Other" (Q1)', value: false })
viewof hz_rel = Inputs.toggle({ label: "Relative (%)", value: false })
hz_isRelative = !!hz_rel
viewof hz_q1ChartHeight = Inputs.range([360, 900], { label: "", step: 10, value: 520 })
hz_chartHeight = hz_q1ChartHeight
```

```{ojs}
//| output: false
hz_stripIso = (v) => String(v ?? "").replace(/\s*\([A-Z]{2,3}\)\s*$/, "")

// Cleaned geo filter for API payloads and UI labels
hz_geoFilterApi = {
  const g = hz_geoFilter ?? {}
  return {
    ...g,
    admin0: (g.admin0 ?? []).map(hz_stripIso),
    admin1: (g.admin1 ?? []).map(hz_stripIso),
    admin2: (g.admin2 ?? []).map(hz_stripIso),
    admin0_name: (g.admin0_name ?? []).map(hz_stripIso),
    admin1_name: (g.admin1_name ?? []).map(hz_stripIso),
    admin2_name: (g.admin2_name ?? []).map(hz_stripIso)
  }
}

// Friendly labels for the UI
hz_geoLabel = {
  const gf = hz_geoFilterApi ?? {}
  const a0 = Array.isArray(gf.admin0) ? gf.admin0.filter(Boolean) : []
  const a1 = Array.isArray(gf.admin1) ? gf.admin1.filter(Boolean) : []
  const a2 = Array.isArray(gf.admin2) ? gf.admin2.filter(Boolean) : []

  const hasAll = a0.length === 0 || a0.includes("all")
  const fmt = (arr, max = 2) => {
    const xs = arr.slice(0, max)
    const more = arr.length > max ? ` +${arr.length - max}` : ""
    return xs.join(", ") + more
  }

  if (hasAll) return "admin0: all"
  if (a2.length) return `admin2: ${fmt(a2)} (${a2.length})`
  if (a1.length) return `admin1: ${fmt(a1)} (${a1.length})`
  return `admin0: ${fmt(a0)} (${a0.length})`
}

hz_commodityLabel = {
  const g = hz_commodityGroup
  const pickedUI = (hz_commodities ?? []).filter(Boolean)
  const n = (hz_selectedCommodities ?? []).length

  // Custom + empty => no commodity filter
  if (g === "custom" && pickedUI.length === 0) return "Commodities: custom (no filter)"

  if (g === "all") return `Commodities: all (${n})`
  if (g === "crops") return `Commodities: crops (${n})`
  if (g === "livestock") return `Commodities: livestock (${n})`
  if (g === "custom") return `Commodities: custom (${n})`

  const label = hz_commodityGroupOptions?.[g] ?? String(g)
  return `Commodities: ${label} (${n})`
}
```

```{ojs}
//| output: false
hz_parseScenario = (s) => {
  const raw = String(s ?? "")
  if (!raw) return { raw: "", model: "", scenario: null, timeframe: null, label: "" }

  const parts = raw.split("_").filter(Boolean)
  const scenario = parts[0] ?? null
  const timeframe = parts.length > 1 ? parts.slice(1).join("_") : null

  // In this notebook, the dataset key uses the FULL model token as stored in nbData keys
  // (e.g., historical, ensemble, ssp245_2041-2060). We keep that as `model`.
  return { raw, model: raw, scenario, timeframe, label: hz_formatModel(raw) }
}
hz_parseScenarioPick = (x) => {
  const p = hz_parseScenXTime(x)
  const isHist = (p?.scenTime === "historic") || (p?.scenario === "historic")
  const model = isHist ? "historic" : "ENSEMBLE"
  const label = isHist ? "historic" : `${String(p.scenario ?? "").toUpperCase()} ${p.timeframe ?? ""}`.trim()
  return { ...p, model, label }
}
hz_s1 = (() => hz_parseScenarioPick(hz_scen1))()
hz_s2 = (() => hz_parseScenarioPick(hz_scen2))()

```

```{ojs}
//| output: false
// Resolve a dataset key from selected controls (note: model determined by scenario pick)
hz_keyBaseFor = ({ varShort, period, model, severity }) => {
  // Base key: hazardExposure_{varShort}_{period}_{model}_{severity}
  return `hazardExposure_${varShort}_${period}_${model}_${severity}`
}

hz_keyCandidatesFor = ({ varShort, period, model, severity, method }) => {
  const base = hz_keyBaseFor({ varShort, period, model, severity })

  // Method is modeled as an optional suffix on the key:
  // ..._{severity}_{generic|crop_specific}
  if (!method || method === "auto") {
    // Try base first, then known method suffixes
    return [base, `${base}_generic`, `${base}_crop_specific`]
  }

  return [`${base}_${method}`, base]
}

hz_computeShinyInteractionUrl = ({ varShort, period, model, severity } = {}) => {
  const u = String(varShort ?? "")
  const variable = (/usd15|intld15/i.test(u)) ? `vop_${u}` : u
  const per = String(period ?? "annual")
  const mod =
    /hist/i.test(String(model ?? "")) ? "historic" :
    /ens/i.test(String(model ?? "")) ? "ENSEMBLE" :
    String(model ?? "")
  const sev = String(severity ?? "severe").toLowerCase()
  if (!variable || !per || !mod || !sev) return null
  return `https://digital-atlas.s3.amazonaws.com/hazard_exposure/v0.4.2/exported_data/${variable}/${per}/model=${mod}/severity=${sev}/interaction.parquet`
}

hz_resolveFromCandidates = (candidates) => {
  const cands = Array.isArray(candidates) ? candidates : [String(candidates ?? "")]
  for (const k of cands) {
    if (hz_nbIndex?.has(k)) {
      const entry = hz_nbIndex.get(k)
      const r = hz_resolvePath(entry)
      return { ...r, resolvedKey: k, candidates: cands }
    }
  }

  const first = cands[0]
  const parts = hz_parseKeyParts(first)
  const computedUrl = hz_computeShinyInteractionUrl(parts)

  const entry = hz_nbIndex?.get(first) ?? null
  const r = hz_resolvePath(entry)

  const out = { ...r }
  if (!out.url && computedUrl) out.url = computedUrl
  if (!out.path && computedUrl) out.path = computedUrl
  if (computedUrl && (!out.pathSource || out.pathSource === "none")) out.pathSource = "computed"

  return { ...out, resolvedKey: first, candidates: cands }
}

 // Base keys (no suffix)
hz_key1 = hz_keyBaseFor({ varShort: hz_varShort, period: hz_period, model: hz_s1.model, severity: hz_severity })
hz_key2 = hz_keyBaseFor({ varShort: hz_varShort, period: hz_period, model: hz_s2.model, severity: hz_severity })

// Candidates that incorporate the selected method preference
hz_keyCandidates1 = hz_keyCandidatesFor({ varShort: hz_varShort, period: hz_period, model: hz_s1.model, severity: hz_severity, method: hz_method })
hz_keyCandidates2 = hz_keyCandidatesFor({ varShort: hz_varShort, period: hz_period, model: hz_s2.model, severity: hz_severity, method: hz_method })

// Resolve path/url using nbData.json
hz_src1 = hz_resolveFromCandidates(hz_keyCandidates1)
hz_src2 = hz_resolveFromCandidates(hz_keyCandidates2)

// Handy aliases for display
hz_key1Resolved = hz_src1.resolvedKey
hz_key2Resolved = hz_src2.resolvedKey
```

```{ojs}
//| output: false
// (debug) suppressed
null
```

```{ojs}
//| output: false
// Controls panel (collapsible) — summary reflects current selections.
hz_controlsPanelSummary = {
  const parts = []
  if (hz_varShort) parts.push(`Hazard: ${hz_varShort}`)
  if (hz_period) parts.push(`Period: ${hz_period}`)
  if (hz_severity) parts.push(`Severity: ${hz_severity}`)
  if (hz_method) parts.push(`Method: ${hz_method}`)
  if (hz_commodityLabel) parts.push(hz_commodityLabel)
  if (hz_geoLabel) parts.push(hz_geoLabel)
  return parts.filter(Boolean).join(" · ")
}

hz_controlsPanelReal = html`
  <div class="hz-controlsCompact hz-controlsPanel">
    <div class="hz-controlsRows">
      <div class="hz-row hz-row--3">
        <div class="hz-field">${viewof hz_varShort}</div>
        <div class="hz-field">${viewof hz_period}</div>
        <div class="hz-field">${viewof hz_severity}</div>
      </div>

      <div class="hz-row hz-row--3 hz-row--grow">
        <div class="hz-field hz-field--sm">${viewof hz_commodityGroup}</div>
        <div class="hz-field hz-field--grow">${hz_commoditiesUI}</div>
        <div class="hz-field hz-field--sm">${viewof hz_method}</div>
      </div>

      <div class="hz-row hz-row--3">
        <div class="hz-field">${viewof hz_admin0}</div>
        <div class="hz-field">${viewof hz_admin1}</div>
        <div class="hz-field">${viewof hz_admin2}</div>
      </div>

      <div class="hz-row hz-row--2">
        <div class="hz-field">${viewof hz_scen1}</div>
        <div class="hz-field">${viewof hz_scen2}</div>
      </div>
    </div>
  </div>
`;
```

```{ojs}
//| output: false
// Admin name tuples (admin0/admin1/admin2) for cascading selectors.
// Uses the shared local component: components/_atlasBoundaries.ojs
// (No remote parquet needed.)
hz_adminNames = {
  try {
    const { admin2 } = await getAdminBoundaries([2])
    const feats = admin2?.features ?? []

    const pick = (p, keys) => {
      for (const k of keys) {
        const v = p?.[k]
        if (v != null && String(v).trim() !== "") return v
      }
      return null
    }

    const rows = feats.map((f) => {
      const p = f?.properties ?? {}
      
      const admin0_name = pick(p, ["admin0_name","ADM0_NAME","NAME_0","adm0_name","country","COUNTRY","admin0","name0"])
      const admin1_name = pick(p, ["admin1_name","ADM1_NAME","NAME_1","adm1_name","admin1","name1"])
      const admin2_name = pick(p, ["admin2_name","ADM2_NAME","NAME_2","adm2_name","admin2","name2"])
      return { admin0_name, admin1_name, admin2_name }
    }).filter((d) => d.admin0_name != null)

    
    const seen = new Set()
    const out = []
    for (const d of rows) {
      const k = `${d.admin0_name ?? ""}||${d.admin1_name ?? ""}||${d.admin2_name ?? ""}`
      if (!seen.has(k)) { seen.add(k); out.push(d) }
    }

    return out
  } catch (e) {
    return [{ error: `Failed to load admin names from components/_atlasBoundaries.ojs: ${e}` }]
  }
}

```

```{ojs}
//| output: false
// Build choice lists
hz_admin0Choices = {
  const isErr = hz_adminNames?.[0]?.error
  if (isErr) return ["all"]
  const vals = Array.from(new Set(hz_adminNames.map(d => d.admin0_name).filter(Boolean))).sort()
  return vals.includes("all") ? vals : ["all", ...vals]
}
```

```{ojs}
//| output: false
// multi-select (chips + search + checklist).
hz_makeMultiSelect = ({
  label = "Select",
  options = [],
  value = [],
  placeholder = "Search…",
  disabled = false,
  actions = [{ id: "none", label: "Clear" }],
  exclusive = null,         // e.g., "all" (cannot coexist with others)
  maxHeight = 240,
  maxRender = 600
} = {}) => {
  const form = html`<form class="hz-ms" style="opacity:${disabled ? 0.65 : 1}; pointer-events:${disabled ? "none" : "auto"}">
    <label class="hz-ms__label">${label}</label>
    <div class="hz-ms__top">
      <input class="hz-ms__search" type="search" placeholder="${placeholder}" />
      <div class="hz-ms__btns"></div>
    </div>
    <div class="hz-ms__chips" aria-label="Selected"></div>
    <div class="hz-ms__list" style="max-height:${maxHeight}px;"></div>
    <div class="hz-ms__meta"></div>
  </form>`

  const search = form.querySelector(".hz-ms__search")
  const chips = form.querySelector(".hz-ms__chips")
  const list  = form.querySelector(".hz-ms__list")
  const btns  = form.querySelector(".hz-ms__btns")
  const meta  = form.querySelector(".hz-ms__meta")

  const norm = (arr) => Array.from(new Set((arr ?? []).filter((d) => d != null && String(d).trim() !== "")))

  const setExclusiveRules = (selSet) => {
    if (!exclusive) return selSet
    if (selSet.size === 0) { selSet.add(exclusive); return selSet }
    if (selSet.has(exclusive) && selSet.size > 1) selSet.delete(exclusive)
    return selSet
  }

  const selected = new Set(norm(value))
  setExclusiveRules(selected)

  form.value = Array.from(selected)

  const emit = () => {
    // Apply exclusive rules + keep stable order based on options list
    setExclusiveRules(selected)
    const optIndex = new Map(options.map((d, i) => [String(d), i]))
    const ordered = Array.from(selected).sort((a, b) => (optIndex.get(String(a)) ?? 1e9) - (optIndex.get(String(b)) ?? 1e9))
    form.value = ordered
    form.dispatchEvent(new Event("input", { bubbles: true }))
    renderChips()
    renderList()
  }

  const renderChips = () => {
    chips.replaceChildren()
    const vals = Array.from(selected)
    if (!vals.length) return
    for (const v of vals) {
      const chip = html`<span class="hz-chip" title="${v}">
        <span>${v}</span>
        <button type="button" aria-label="Remove">×</button>
      </span>`
      chip.querySelector("button").onclick = () => { selected.delete(v); emit() }
      chips.appendChild(chip)
    }
  }

  const filteredOptions = () => {
    const q = (search.value ?? "").trim().toLowerCase()
    if (!q) return options
    return options.filter((d) => String(d).toLowerCase().includes(q))
  }

  const renderList = () => {
    list.replaceChildren()
    const filt = filteredOptions()
    const shown = filt.slice(0, maxRender)

    meta.replaceChildren(
      html`<span class="hz-ms__metaText">
        ${filt.length.toLocaleString()} match(es) · showing ${shown.length.toLocaleString()}
        ${filt.length > maxRender ? html` <span class="hz-ms__metaWarn">(refine search to see more)</span>` : ""}
      </span>`
    )

    for (const v of shown) {
      const row = html`<label class="hz-ms__item">
        <input type="checkbox" />
        <span class="hz-ms__itemText">${v}</span>
      </label>`
      const cb = row.querySelector("input")
      cb.checked = selected.has(v)
      cb.onchange = () => {
        if (cb.checked) {
          if (exclusive && v === exclusive) {
            selected.clear()
            selected.add(exclusive)
          } else {
            selected.add(v)
            if (exclusive) selected.delete(exclusive)
          }
        } else {
          selected.delete(v)
          setExclusiveRules(selected)
        }
        emit()
      }
      list.appendChild(row)
    }

    if (!shown.length) {
      list.appendChild(html`<div class="hz-ms__empty">No matches.</div>`)
    }
  }

  // Build action buttons
  btns.replaceChildren()
  for (const a of (actions ?? [])) {
    const b = html`<button type="button" class="hz-ms__btn">${a.label}</button>`
    b.onclick = () => {
      if (a.id === "none") {
        selected.clear()
        if (exclusive) selected.add(exclusive)
        emit()
      } else if (a.id === "all") {
        if (exclusive) {
          selected.clear()
          selected.add(exclusive)
        } else {
          selected.clear()
          for (const v of options) selected.add(v)
        }
        emit()
      }
    }
    btns.appendChild(b)
  }

  search.oninput = () => renderList()

  // initial paint
  renderChips()
  renderList()

  return form
}
```

```{ojs}
//| output: false
// Geography selectors (standard Atlas boundary UI)
viewof hz_admin0 = renderA0Multi({ key: "q1", maxSelections: 8, requireAtLeastOne: true })
viewof hz_admin1 = renderA1Multi({ key: "q1", a0: viewof hz_admin0, maxSelections: 12 })
viewof hz_admin2 = renderA2Multi({ key: "q1", a0: viewof hz_admin0, a1: viewof hz_admin1, maxSelections: 20 })

// Render the 3 selectors with the shared input template
hz_geoUI = html`<div class="hz-geoRow">${inputTemplate({ gap: "10px" })([viewof hz_admin0, viewof hz_admin1, viewof hz_admin2])}</div>`
```

```{ojs}
//| output: false
hz_normSel = (xs) => {
  const arr = Array.isArray(xs) ? xs : []
  return arr
    .map((d) => {
      if (d == null) return ""
      if (typeof d === "string" || typeof d === "number") return String(d)

      // Admin selector objects from /components/_adminSelectorsMulti.qmd:
      // - admin0 objects have admin0_name (and iso3c)
      // - admin1 objects have admin1_name (and admin0_name, iso3)
      // - admin2 objects have admin2_name (and admin1_name, admin0_name, iso3)
      // We must send clean names to the API (no “(ISO)” label strings) and
      // treat “Full Country” rows (admin1_name/admin2_name == null) as “no filter”.
      if (typeof d === "object") {
        if ("admin2_name" in d) return d.admin2_name == null ? "" : String(d.admin2_name)
        if ("admin1_name" in d) return d.admin1_name == null ? "" : String(d.admin1_name)
        if ("admin0_name" in d) return d.admin0_name == null ? "" : String(d.admin0_name)
        return String(d.value ?? d.name ?? d.label ?? d.id ?? "")
      }

      return String(d)
    })
    .map((s) => String(s).trim())
    .filter((s) => s.length > 0)
}

hz_geoFilter = ({
  admin0: hz_normSel(hz_admin0),
  admin1: hz_normSel(hz_admin1),
  admin2: hz_normSel(hz_admin2)
})

hz_geoResolvedLevel = {
  const a0 = hz_geoFilter.admin0 ?? []
  const hasAll = a0.length === 0 || a0.includes("all")
  if (hasAll) return "admin0"
  if ((hz_geoFilter.admin2 ?? []).length) return "admin2"
  if ((hz_geoFilter.admin1 ?? []).length) return "admin1"
  return "admin0"
}

hz_geoSelectionCount = {
  const lvl = hz_geoResolvedLevel
  const a0 = (hz_geoFilter.admin0 ?? []).filter((d) => d != null && String(d).trim() !== "" && d !== "all")
  if (lvl === "admin2") return (hz_geoFilter.admin2 ?? []).length
  if (lvl === "admin1") return (hz_geoFilter.admin1 ?? []).length
  return (hz_geoFilter.admin0 ?? []).includes("all") || (hz_geoFilter.admin0 ?? []).length === 0 ? 1 : a0.length
}

```

```{ojs}
//| output: false
// Geo filter preview
hz_geoTable = {
  const gf = hz_geoFilter ?? {admin0: [], admin1: [], admin2: []}
  const a0raw = Array.isArray(gf.admin0) ? gf.admin0.filter(Boolean) : []
  const hasAll = a0raw.length === 0 || a0raw.includes("all")
  const a0 = hasAll ? ["all"] : a0raw.filter((d) => d !== "all")
  const a1 = hasAll ? [] : (Array.isArray(gf.admin1) ? gf.admin1.filter(Boolean) : [])
  const a2 = hasAll ? [] : (Array.isArray(gf.admin2) ? gf.admin2.filter(Boolean) : [])

  const chipRow = (arr, max = 10) => {
    const shown = arr.slice(0, max)
    const more = arr.length > max ? arr.length - max : 0
    return html`<div style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;">
      ${shown.map((d) => html`<span class="hz-chip"><span>${d}</span></span>`)}
      ${more ? html`<span class="hz-chip"><span>+${more} more</span></span>` : ""}
    </div>`
  }

  return html`<div class="hz-card" style="margin-top:10px;">
    <div class="hz-card__head">
      <div>
        <div class="hz-card__title">Geography summary</div>
        <div class="hz-card__sub">Resolved level: <b>${hz_geoResolvedLevel}</b> · selections: <b>${hz_geoSelectionCount}</b></div>
      </div>
    </div>
    <div class="hz-muted" style="margin-top:4px;">Admin0</div>
    ${chipRow(a0)}
    <div class="hz-muted" style="margin-top:10px;">Admin1</div>
    ${a1.length ? chipRow(a1) : html`<div class="hz-muted">—</div>`}
    <div class="hz-muted" style="margin-top:10px;">Admin2</div>
    ${a2.length ? chipRow(a2) : html`<div class="hz-muted">—</div>`}
  </div>`
}

hz_geoPanelReal = html`
  <div>
    <div class="hz-card">
      <div class="hz-card__head">
        <div>
          <div class="hz-card__title">Geography</div>
          <div class="hz-card__sub">Geography selection is in <a href="#q1">Q1 Controls</a>. This section shows a summary.</div>
        </div>
        <a class="hz-pill" href="#q1" style="text-decoration:none">Change selection</a>
      </div>
      <div class="hz-muted">Tip: If you need to confirm what’s being queried, use the chips below (resolved level + selected admin names).</div>
    </div>

    <div style="height:12px"></div>
    ${hz_geoTable}

    ${
      hz_adminNames?.[0]?.error
        ? html`<div class="warn" style="margin-top:10px"><b>Admin names load failed:</b><br>${hz_adminNames[0].error}</div>`
        : ""
    }
  </div>
`
```

```{ojs}
//| output: false
// WHERE clause builder for the hazard exposure parquet schema
hz_q = (s) => "'" + String(s).replaceAll("'", "''") + "'"

// Crop WHERE helper (safe SQL quoting; supports UI sentinel "all")
hz_cropWhere = (commodities) => {
  const list = Array.isArray(commodities) ? commodities.filter((d) => d != null && String(d).trim() !== "") : []
  const hasAll = list.length === 0 || list.includes("all")
  if (hasAll) return "TRUE"
  const vals = list.filter((d) => d !== "all")
  if (!vals.length) return "TRUE"
  return `crop IN (${vals.map(hz_q).join(", ")})`
}

// hazard_vars lists
// - generic: NDWS (drought) + NTx35 / THI-max (heat) + NDWL0 (flood)
// - crop_specific: PTOT-L (drought) + NTxS / THI-max (heat) + PTOT-G (flood)
hz_interactions = ({
  generic: [
    "NDWS+NTx35+NDWL0",
    "NDWS+THI-max+NDWL0"
  ],
  crop_specific: [
    "PTOT-L+NTxS+PTOT-G",
    "PTOT-L+THI-max+PTOT-G"
  ]
})

// hazard_vars WHERE helper
hz_hazardVarsWhere = (method, commodGroup) => {
  const m = String(method ?? "").toLowerCase()
  const cg = String(commodGroup ?? "").toLowerCase()

  const vars =
    (m === "generic") ? hz_interactions.generic :
    (m === "crop-specific" || m === "crop_specific") ? hz_interactions.crop_specific :
    // auto (best available): default to crop_specific unless we're aggregating "all"
    ((cg === "all" || cg === "" || cg === "total") ? hz_interactions.generic : hz_interactions.crop_specific)

  return `hazard_vars IN (${vars.map(hz_q).join(", ")})`
}

// Exposure value/unit WHERE helper
hz_unitWhere = (varShort) => {
  return "TRUE"
}

// Severity WHERE helper
hz_sevWhere = (severity) => {
  return "TRUE"
}

hz_geoWhere = (geoFilter) => {
  const gf = geoFilter ?? {}
  const admin0 = Array.isArray(gf.admin0) ? gf.admin0.filter((d) => d != null && String(d).trim() !== "") : []
  const admin1 = Array.isArray(gf.admin1) ? gf.admin1.filter((d) => d != null && String(d).trim() !== "") : []
  const admin2 = Array.isArray(gf.admin2) ? gf.admin2.filter((d) => d != null && String(d).trim() !== "") : []

  
  const hasAll = admin0.length === 0 || admin0.includes("all")
  const a0 = hasAll ? [] : admin0.filter((d) => d !== "all")
  const a1 = hasAll ? [] : admin1
  const a2 = hasAll ? [] : admin2

  const q = (s) => `'${String(s).replaceAll("'", "''")}'`
  const inList = (vals) => vals.map(q).join(", ")

  const wh = []

  // Only constrain admin0 when user chose specific countries
  if (a0.length > 0) {
    wh.push(`admin0_name IN (${inList(a0)})`)
  }

  if (a2.length > 0) {
    // Admin2 totals: admin0 + (optional admin1) + admin2
    if (a1.length > 0) wh.push(`admin1_name IN (${inList(a1)})`)
    wh.push(`admin2_name IN (${inList(a2)})`)
  } else if (a1.length > 0) {
    // Admin1 totals: admin0 + admin1, and admin2 NULL
    wh.push(`admin1_name IN (${inList(a1)})`)
    wh.push(`admin2_name IS NULL`)
  } else {
    // Admin0 totals: admin1/admin2 NULL
    wh.push(`admin1_name IS NULL`)
    wh.push(`admin2_name IS NULL`)
  }

  return wh.join("\n      AND ")
}

hz_scenWhere = (sc) => {
  const p = (typeof sc === "string") ? hz_parseScenXTime(sc) : (sc ?? {})
  const scenario = p.scenario
  const timeframe = p.timeframe ?? (scenario === "historic" ? "historic" : null)
  if (!scenario || !timeframe) return "FALSE"
  return `scenario = ${hz_q(scenario)} AND timeframe = ${hz_q(timeframe)}`
}
```

```{ojs}
//| output: false
viewof hz_loadSchema = Inputs.toggle(false, { label: "Load schema tables (debug, slower)" })
```

```{ojs}
//| output: false
// -----------------------------
// FAST API PATH (v3): call the FastAPI + Redis service for all heavy queries.

// API base URL
hz_apiBaseUrl = (() => {
  try {
    const u = new URL(window.location.href)
    const p = u.searchParams.get('api')
    if (p) return p.replace(/\/+$/, '')
  } catch (_) {}
  return (globalThis.__ATLAS_HZ_API_BASE__ ??= 'https://atlasapi.jcdevops.com')
})()

// Tiny client cache + debounce state (persists across reactive runs)
hz_apiState = globalThis.__ATLAS_HZ_API_STATE__ ??= {
  cache: new Map(),       // key -> { t:number, v:any }
  order: [],              // insertion order for LRU
  inflight: new Map(),    // key -> Promise
  timers: new Map(),      // group -> timeout id
  aborts: new Map(),      // group -> AbortController
  tokens: new Map(),      // group -> number
  maxEntries: 40
}

hz_stableStringify = (v) => {
  const seen = new WeakSet()
  const norm = (x) => {
    if (x === null || x === undefined) return x
    if (typeof x !== 'object') return x
    if (seen.has(x)) return null
    seen.add(x)
    if (Array.isArray(x)) return x.map(norm)
    const out = {}
    for (const k of Object.keys(x).sort()) out[k] = norm(x[k])
    return out
  }
  return JSON.stringify(norm(v))
}

hz_lruGet = (key, ttlMs) => {
  const hit = hz_apiState.cache.get(key)
  if (!hit) return null
  if (ttlMs > 0 && (Date.now() - hit.t) > ttlMs) {
    hz_apiState.cache.delete(key)
    return null
  }
  // refresh LRU position
  const i = hz_apiState.order.indexOf(key)
  if (i >= 0) hz_apiState.order.splice(i, 1)
  hz_apiState.order.push(key)
  return hit.v
}

hz_lruSet = (key, val) => {
  if (hz_apiState.cache.has(key)) {
    hz_apiState.cache.delete(key)
    const i = hz_apiState.order.indexOf(key)
    if (i >= 0) hz_apiState.order.splice(i, 1)
  }
  hz_apiState.cache.set(key, { t: Date.now(), v: val })
  hz_apiState.order.push(key)
  while (hz_apiState.order.length > hz_apiState.maxEntries) {
    const oldest = hz_apiState.order.shift()
    if (oldest) hz_apiState.cache.delete(oldest)
  }
  return val
}

hz_apiPostJson = async (path, body, { signal } = {}) => {
  const url = hz_apiBaseUrl + path
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body ?? {}),
    signal
  })
  const isJson = (res.headers.get('content-type') || '').includes('application/json')
  const payload = isJson ? await res.json() : { ok: false, detail: await res.text() }
  if (!res.ok) {
    const msg = payload?.detail || payload?.error || payload?.message || ('' + res.status)
    throw new Error(msg)
  }
  return payload
}

// Debounced + cached API call.
//| output: false
// ============================================================
// Map view (choropleth) — reuses getAdminBoundaries + by-admin API
// ============================================================

viewof hz_mapMetric = {
  const labels = {
    right: "Right",
    left:  "Left",
    delta: "Δ (Right − Left)"
  }
  const values = ["right", "left", "delta"]
  const root = Inputs.radio(values, {
    label: "Color by",
    value: (hz_compareMode === "diff") ? "delta" : "right",
    format: (v) => labels[v] || String(v)
  })
  root.classList.add("hz-mapMetric")
  return root
}

hz_mapMetricEff = hz_mapMetric || ((hz_compareMode === "diff") ? "delta" : "right")

hz_mapReqExtra = ({ group_child: true })

hz_mapRespL = {
  if (hz_viewMode !== "map") return null
  const out = await hz_apiDebouncedCached("mapL", "/api/v1/hz/by-admin", hz_sideReq(hz_src1, hz_s1, hz_mapReqExtra), { debounceMs: 120 })
  return (out && typeof out === "object" && ("ok" in out)) ? out : null
}

hz_mapRespR = {
  if (hz_viewMode !== "map") return null
  const out = await hz_apiDebouncedCached("mapR", "/api/v1/hz/by-admin", hz_sideReq(hz_src2, hz_s2, hz_mapReqExtra), { debounceMs: 120 })
  return (out && typeof out === "object" && ("ok" in out)) ? out : null
}

hz_mapMeta = {
  if (hz_viewMode !== "map") return { ok: false, loading: false, error: "hidden" }
  if (!hz_mapRespL || !hz_mapRespR) return { ok: false, loading: true, error: null }
  const ok = Boolean(hz_mapRespL?.ok && hz_mapRespR?.ok)
  const err = (!ok) ? String(hz_mapRespL?.error || hz_mapRespR?.error || "Map query failed") : null
  return { ok, loading: false, error: err }
}

hz_mapRowsL = (hz_mapRespL?.data ?? [])
hz_mapRowsR = (hz_mapRespR?.data ?? [])

hz_mapLevel = {
  const a2 = (hz_geoFilter?.admin2 ?? []).filter(Boolean)
  const a1 = (hz_geoFilter?.admin1 ?? []).filter(Boolean)
  const a0 = (hz_geoFilter?.admin0 ?? []).filter(Boolean).filter(x => String(x).toLowerCase() !== "all")
  if (a2.length) return 2
  if (a1.length) return 2
  if (a0.length) return 1
  return 0
}

hz_mapLevelLabel = (hz_mapLevel === 2) ? "Admin2" : (hz_mapLevel === 1) ? "Admin1" : "Admin0"

hz_mapSub = {
  const a2 = (hz_geoFilter?.admin2 ?? []).filter(Boolean)
  const a1 = (hz_geoFilter?.admin1 ?? []).filter(Boolean)
  const a0 = (hz_geoFilter?.admin0 ?? []).filter(Boolean).filter(x => String(x).toLowerCase() !== "all")
  if (hz_mapLevel === 2 && a1.length && !a2.length) return `Showing Admin2 (children of selected Admin1).`
  if (hz_mapLevel === 2 && a2.length) return `Showing selected Admin2 areas.`
  if (hz_mapLevel === 1 && a0.length) return `Showing Admin1 (children of selected Admin0).`
  return `Showing Admin0 across current selection.`
}

hz_guessNameKey = (feature, level) => {
  const props = feature?.properties ?? {}
  const keys = Object.keys(props)
  const prefer = (level === 0)
    ? ["admin0_name", "ADM0_NAME", "NAME_0", "name", "NAME", "country", "COUNTRY"]
    : (level === 1)
      ? ["admin1_name", "ADM1_NAME", "NAME_1", "name", "NAME"]
      : ["admin2_name", "ADM2_NAME", "NAME_2", "name", "NAME"]

  for (const k of prefer) if (k in props) return k
  const re = (level === 0) ? /(adm0|admin0|name_0|country)/i : (level === 1) ? /(adm1|admin1|name_1)/i : /(adm2|admin2|name_2)/i
  return keys.find(k => re.test(k)) || keys.find(k => /name/i.test(k)) || null
}

hz_mapPlot = {
  if (hz_viewMode !== "map") return html``
  if (hz_mapMeta.loading) return html`<div class="hz-loading">Loading map…</div>`
  if (!hz_mapMeta.ok) return html`<div class="warn"><b>Map query failed:</b><br>${hz_mapMeta.error}</div>`

  // Value lookups
  const mapL = new Map((hz_mapRowsL ?? []).map(d => [String(d.admin ?? ""), +d.total]))
  const mapR = new Map((hz_mapRowsR ?? []).map(d => [String(d.admin ?? ""), +d.total]))
  const names = new Set([...mapL.keys(), ...mapR.keys()].filter(Boolean))

  const metric = hz_mapMetricEff || "right"
  const lookup = (name) => {
    const vL = mapL.get(name)
    const vR = mapR.get(name)
    if (metric === "left") return vL
    if (metric === "right") return vR
    return (Number(vR ?? 0) - Number(vL ?? 0))
  }

  const boundsObj = await getAdminBoundaries([hz_mapLevel])
  const fc = boundsObj?.[`admin${hz_mapLevel}`]
  const feats = Array.isArray(fc?.features) ? fc.features : []
  if (!feats.length) return html`<div class="warn"><b>No boundary features found</b> for ${hz_mapLevelLabel}.</div>`

  const nameKey = hz_guessNameKey(feats[0], hz_mapLevel)
  const getName = (f) => {
    const p = f?.properties ?? {}
    return (nameKey && p[nameKey] != null) ? String(p[nameKey]) : ""
  }

// Scope features to the user's geographic selection (more intuitive than filtering by join results)
const a0 = (hz_geoFilter?.admin0 ?? []).filter(Boolean).filter(x => String(x).toLowerCase() !== "all")
const a1 = (hz_geoFilter?.admin1 ?? []).filter(Boolean)
const a2 = (hz_geoFilter?.admin2 ?? []).filter(Boolean)

const guessKey = (levelWanted) => {
  const props0 = feats?.[0]?.properties ?? {}
  const keys = Object.keys(props0)
  const prefer = (levelWanted === 0)
    ? ["admin0_name", "ADM0_NAME", "NAME_0", "country", "COUNTRY", "name", "NAME"]
    : (levelWanted === 1)
      ? ["admin1_name", "ADM1_NAME", "NAME_1", "name", "NAME"]
      : ["admin2_name", "ADM2_NAME", "NAME_2", "name", "NAME"]
  for (const k of prefer) if (k in props0) return k
  const re = (levelWanted === 0) ? /(adm0|admin0|name_0|country)/i
    : (levelWanted === 1) ? /(adm1|admin1|name_1)/i
    : /(adm2|admin2|name_2)/i
  return keys.find(k => re.test(k)) || keys.find(k => /name/i.test(k)) || null
}

const admin0Key = guessKey(0)
const admin1Key = guessKey(1)
const getAdmin0 = (f) => {
  const p = f?.properties ?? {}
  return (admin0Key && p[admin0Key] != null) ? String(p[admin0Key]) : ""
}
const getAdmin1 = (f) => {
  const p = f?.properties ?? {}
  return (admin1Key && p[admin1Key] != null) ? String(p[admin1Key]) : ""
}

let featsUse = feats

// If a country is selected, show only its children at admin1
if (hz_mapLevel === 1 && a0.length) {
  featsUse = featsUse.filter(f => a0.includes(getAdmin0(f)))
}

// If an admin1 is selected, show only its children at admin2
if (hz_mapLevel === 2) {
  if (a1.length) featsUse = featsUse.filter(f => a1.includes(getAdmin1(f)))
  else if (a2.length) featsUse = featsUse.filter(f => a2.includes(getName(f)))
}

// Keep only valid geometries
featsUse = featsUse.filter(f => f?.geometry && f.geometry.coordinates && f.geometry.coordinates.length)

if (!featsUse.length) {
  return html`<div class="warn"><b>No boundary features found for the current selection.</b><br>
    Try clearing the most specific boundary filter (Admin2 → Admin1 → Admin0).</div>`
}

const fcUse = { type: "FeatureCollection", features: featsUse }

// If the join doesn't match, we still render boundaries; data-less areas appear empty
const joinHits = featsUse.some(f => names.has(getName(f)))
const joinNote = (!joinHits)
  ? html`<div class="hz-muted hz-note">Note: could not match by-admin names to boundary properties; showing boundaries without fill.</div>`
  : null

const isDelta = (metric === "delta")
  const label = isDelta ? "Δ exposure (Right − Left)" : (metric === "left" ? "Exposure (Left)" : "Exposure (Right)")

  const plot = Plot.plot({
    projection: { type: "mercator", domain: fcUse, inset: 10 },
    height: 440,
    color: isDelta
      ? { type: "diverging", legend: true, label, pivot: 0 }
      : { legend: true, label },
    marks: [
      Plot.geo(fcUse, {
        fill: f => {
          const n = getName(f)
          const v = lookup(n)
          return (v == null) ? NaN : v
        },
        stroke: "white",
        strokeWidth: 0.4,
        title: f => {
          const n = getName(f)
          const v = lookup(n)
          const vv = (v == null) ? "n/a" : fmtAbs(v)
          return `${n}\n${label}: ${vv}`
        }
      })
    ]
  })

  const box = html`<div class="hz-mapPlot"></div>`
  if (joinNote) box.appendChild(joinNote)
  box.appendChild(plot)
  return box
}

hz_apiDebouncedCached = async (groupKey, path, body, { ttlMs = 60000, debounceMs = 250 } = {}) => {
  const key = `${path}|${hz_stableStringify(body)}`

  // local cache hit
  const cached = hz_lruGet(key, ttlMs)
  if (cached != null) return cached

  // share inflight identical requests
  if (hz_apiState.inflight.has(key)) return await hz_apiState.inflight.get(key)

  // cancel previous in this group
  try { clearTimeout(hz_apiState.timers.get(groupKey)) } catch (_) {}
  try { hz_apiState.aborts.get(groupKey)?.abort() } catch (_) {}

  const token = (hz_apiState.tokens.get(groupKey) || 0) + 1
  hz_apiState.tokens.set(groupKey, token)

  const ac = new AbortController()
  hz_apiState.aborts.set(groupKey, ac)

  const p = new Promise((resolve) => {
    const t = setTimeout(async () => {
      let busyOn = false
      try {
        // If a newer request has superseded this one before it even starts, skip.
        if (hz_apiState.tokens.get(groupKey) !== token) return resolve([])

        // UI: show an 'Updating…' overlay ONLY when the network call actually starts.
        try { const __ui = globalThis.__ATLAS_HZ_UI__
    if (__ui?.setBusyFor) {
      __ui.setBusyFor(groupKey, true)
    } else if (String(groupKey || "").startsWith("q1")) {
      __ui?.setBusy?.(true)
    }
    busyOn = true } catch (_) { busyOn = false }

        const out = await hz_apiPostJson(path, body, { signal: ac.signal })
        // Only accept latest
        if (hz_apiState.tokens.get(groupKey) !== token) return resolve([])
        resolve(hz_lruSet(key, out))
      } catch (e) {
        if (String(e).includes('AbortError')) return resolve([])
        resolve({ ok: false, error: String(e) })
      } finally {
        // Always clear the busy overlay if we turned it on.
        try { if (busyOn) {
      const __ui = globalThis.__ATLAS_HZ_UI__
      if (__ui?.setBusyFor) {
        __ui.setBusyFor(groupKey, false)
      } else if (String(groupKey || "").startsWith("q1")) {
        __ui?.setBusy?.(false)
      }
    } } catch (_) {}
        hz_apiState.inflight.delete(key)
      }
    }, debounceMs)
    hz_apiState.timers.set(groupKey, t)
  })

  hz_apiState.inflight.set(key, p)
  return await p
}

```

```{ojs}
//| output: false
// Build a single "Q1" request that returns everything needed for the main chart.
hz_isBroadGeo = (geo) => {
  const a0 = Array.isArray(geo?.admin0) ? geo.admin0.filter((d) => d && d !== "all") : []
  // If no specific admin0 selected, it's broad.
  if (a0.length === 0) return true
  // If the UI includes "all" explicitly, treat as broad.
  if (Array.isArray(geo?.admin0) && geo.admin0.includes("all")) return true
  return false
}

hz_q1Req = (() => {
  if (hz_isBroadGeo?.(hz_geoFilter)) {
    return { ok: false, error: 'Select at least an Admin0 (or Admin1/Admin2). Broad selection is intentionally blocked for speed.' }
  }

  if (!(hz_src1?.ok && hz_src2?.ok)) {
    return { ok: false, error: 'Dataset URLs not resolved yet.' }
  }

  const left = {
    dataset_url: hz_src1.url,
    scen: { scenario: hz_s1?.scenario, timeframe: hz_s1?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
  }

  const right = {
    dataset_url: hz_src2.url,
    scen: { scenario: hz_s2?.scenario, timeframe: hz_s2?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
  }

  const denom = null
return { ok: true, body: { left, right, denom } }
})()

```

```{ojs}
//| output: false
// Question routing (stacked Q1–Q4). For incremental dev, Q1 is the only wired question for now.
hz_activeQuestion = "q1"

hz_dashTitle = ({
  q1: "Total exposure by hazard",
  q2: "Total exposure by crop",
  q3: "Hazard composition by crop",
  q4: "Exposure by administrative area"
})[hz_activeQuestion] || "Dashboard"

hz_dashSub = ({
  q1: "Compare Left vs Right (side-by-side or Δ). Filters: scenarios, geography, commodities.",
  q2: "Compare Left vs Right. Filters: scenarios, geography, commodities.",
  q3: "Compare Left vs Right. Filters: scenarios, geography, commodities.",
  q4: "Compare Left vs Right. Filters: scenarios, geography, commodities."
})[hz_activeQuestion] || ""

// Common request payload for single-side endpoints (used by map + other side queries)
hz_sideReq = (src, scen, extra = {}) => ({
  dataset_url: src?.url,
  scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
  geo: hz_geoFilterApi,
  commodities: hz_selectedCommoditiesForReq ?? [],
  hazard_vars: null,
  hazards: null,
  method: hz_method,
  commodity_group: hz_selectedCommodGroup,
  ...extra
})
```

```{ojs}
//| output: false
// Call the API (debounced + cached)

hz_q1Resp = (hz_q1Req?.ok)
  ? await hz_apiDebouncedCached("q1", "/api/v1/hz/q1", hz_q1Req.body, { ttlMs: 60000, debounceMs: 250 })
  : { ok: false, error: hz_q1Req?.error || "Invalid request", left: [], right: [], merged: [], denom: { ok: false, denom: null }, relative_label: "% of hazard sum" }

// Expose the same variables the rest of the notebook already expects
hz_tot1 = hz_q1Resp?.left ?? []
hz_tot2 = hz_q1Resp?.right ?? []
hz_merged = hz_q1Resp?.merged ?? []
hz_denom = hz_q1Resp?.denom ?? { ok: false, denom: null, error: "No denom" }
hz_relativeLabel = hz_q1Resp?.relative_label ?? "% of hazard sum"

// Meta object expected by hz_updateChart
hz_q1Meta = ({
  ok: !!(hz_q1Resp?.ok),
  cached: !!(hz_q1Resp?.cached),
  t_ms: Number(hz_q1Resp?.t_ms || 0),
  error: hz_q1Resp?.error || null
})

// Normalize + rank rows for chart/table (Q1)
hz_chartRows = {
  const src = Array.isArray(hz_merged) ? hz_merged : []

  const rows = src.map((r) => {
    const hazard = r.hazard ?? r.Hazard ?? r.name ?? r.key ?? "Unknown"
    const total1 = Number(r.total1 ?? r.left ?? r.value1 ?? r.total_left ?? 0)
    const total2 = Number(r.total2 ?? r.right ?? r.value2 ?? r.total_right ?? 0)
    const total_diff = Number(r.total_diff ?? (total2 - total1))
    return { ...r, hazard, total1, total2, total_diff }
  })

  const sumAll1 = rows.reduce((a, r) => a + Number(r.total1 ?? 0), 0)
  const sumAll2 = rows.reduce((a, r) => a + Number(r.total2 ?? 0), 0)
  const pct = (v, denom) => (denom ? (100 * Number(v ?? 0)) / denom : 0)

  for (const r of rows) {
    r.perc1 = Number(r.perc1 ?? pct(r.total1, sumAll1))
    r.perc2 = Number(r.perc2 ?? pct(r.total2, sumAll2))
    r.pct_diff = Number(r.pct_diff ?? (r.perc2 - r.perc1))
  }

  if (hz_compareMode === "diff") {
    const metric = hz_relative ? "pct_diff" : "total_diff"
    rows.sort((a, b) =>
      Math.abs(Number(b[metric] ?? 0)) - Math.abs(Number(a[metric] ?? 0))
    )
  } else {
    const m2 = hz_relative ? "perc2" : "total2"
    const m1 = hz_relative ? "perc1" : "total1"
    rows.sort((a, b) =>
      (Number(b[m2] ?? 0) - Number(a[m2] ?? 0)) ||
      (Number(b[m1] ?? 0) - Number(a[m1] ?? 0))
    )
  }

  const topN = Math.max(1, Number(hz_topN ?? 15) || 15)
  let head = rows.slice(0, topN)

  if (hz_groupOther && rows.length > topN) {
    const rest = rows.slice(topN)
    const sum = (k) => rest.reduce((a, r) => a + Number(r[k] ?? 0), 0)

    const otherTotal1 = sum("total1")
    const otherTotal2 = sum("total2")
    const otherDiff = otherTotal2 - otherTotal1

    head = head.concat([{
      hazard: "Other",
      total1: otherTotal1,
      total2: otherTotal2,
      total_diff: otherDiff,
      perc1: pct(otherTotal1, sumAll1),
      perc2: pct(otherTotal2, sumAll2),
      pct_diff: pct(otherTotal2, sumAll2) - pct(otherTotal1, sumAll1)
    }])
  }

  return head.map((r) => {
    const total1 = Number(r.total1 ?? 0)
    const total2 = Number(r.total2 ?? 0)
    const total_diff = Number(r.total_diff ?? (total2 - total1))
    const perc1 = pct(total1, sumAll1)
    const perc2 = pct(total2, sumAll2)
    const pct_diff = perc2 - perc1
    return { ...r, hazard: r.hazard ?? "Unknown", total1, total2, total_diff, perc1, perc2, pct_diff }
  })
}
```

```{ojs}
//| output: false
// Build Plot chart
hz_q1Chart = {
  const data = Array.isArray(hz_chartRows) ? hz_chartRows : []
  if (!data.length) return html`<div class="hz-empty">No data for the current filters.</div>`

  const absLabel = hz_varLabel || "Value"
  const pctLabel = hz_relativeLabel || "%"
  const xLabel = hz_relative ? pctLabel : absLabel

  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })
  const fmtPct = (x) => `${hz_formatNumber(x, { digits: 2 })}%`

  const subtitle = `${hz_q3_geoLabel} • ${hz_q3_commodityLabel} • Left: ${hz_q3_s1.label} • Right: ${hz_q3_s2.label}`

  if (!hz_difference) {
    const side = data.flatMap(d => ([
      { hazard: d.hazard, scenario: hz_s1.label, value: hz_relative ? d.perc1 : d.total1, raw: d.total1, pct: d.perc1 },
      { hazard: d.hazard, scenario: hz_s2.label, value: hz_relative ? d.perc2 : d.total2, raw: d.total2, pct: d.perc2 }
    ]))

    return Plot.plot({
      width: Math.max(520, (hz_plotWidth ?? 900) - 24),
      height: hz_chartHeight,
      marginLeft: 210,
      marginRight: 24,
      marginTop: 36,
      marginBottom: 40,
      x: {
        label: xLabel,
        grid: true,
        tickFormat: hz_relative ? fmtPct : fmtAbs
      },
      y: { label: null },
      color: { legend: true },
      caption: subtitle,
      marks: [
        Plot.ruleX([0]),
        Plot.barX(side, {
          x: "value",
          y: "hazard",
          fill: "scenario",
          inset: 0.5,
          tip: {
            format: {
              hazard: true,
              scenario: true,
              value: hz_relative ? fmtPct : fmtAbs,
              raw: hz_relative ? fmtAbs : null,
              pct: hz_relative ? null : fmtPct
            }
          }
        })
      ]
    })
  }

  // Difference mode
  return Plot.plot({
    height: hz_chartHeight,
    marginLeft: 210,
    marginRight: 24,
    marginTop: 36,
    marginBottom: 40,
    x: {
      label: xLabel,
      grid: true,
      tickFormat: hz_relative ? fmtPct : fmtAbs
    },
    y: { label: null },
    color: { legend: true },
    caption: subtitle,
    marks: [
      Plot.ruleX([0]),
      Plot.barX(data, {
        x: hz_relative ? "pct_diff" : "total_diff",
        y: "hazard",
        fill: (d) => (Number(d.total_diff ?? 0) >= 0 ? "Increase" : "Decrease"),
        inset: 0.5,
        tip: {
          format: {
            hazard: true,
            value: hz_relative ? fmtPct : fmtAbs
          }
        }
      })
    ]
  })
}
```

```{ojs}
//| output: false
// ----------------------------
// Q2 — totals by crop (independent inputs)
// ----------------------------

// Parse scenarios (Q2-specific)
hz_q2_s1 = (() => hz_parseScenarioPick(hz_q2_scen1))()
hz_q2_s2 = (() => hz_parseScenarioPick(hz_q2_scen2))()

// Resolve dataset URLs (Q2-specific)
hz_q2_keyCandidates1 = hz_keyCandidatesFor({
  varShort: hz_q2_varShort,
  period: hz_q2_period,
  model: hz_q2_s1?.model,
  severity: hz_q2_severity,
  method: hz_q2_method
})
hz_q2_keyCandidates2 = hz_keyCandidatesFor({
  varShort: hz_q2_varShort,
  period: hz_q2_period,
  model: hz_q2_s2?.model,
  severity: hz_q2_severity,
  method: hz_q2_method
})

hz_q2_src1 = hz_resolveFromCandidates(hz_q2_keyCandidates1)
hz_q2_src2 = hz_resolveFromCandidates(hz_q2_keyCandidates2)

// Commodities payload (Q2-specific)
hz_q2_selectedCommoditiesForReq = {
  const picked = (hz_q2_commodities ?? []).filter(Boolean)
  return picked.length ? picked : ["all"]
}

// Geo payload (Q2-specific)
hz_q2_geoFilterApi = {
  const g = hz_q2_geoFilter ?? {}
  return {
    ...g,
    admin0: (g.admin0 ?? []).map(hz_stripIso),
    admin1: (g.admin1 ?? []).map(hz_stripIso),
    admin2: (g.admin2 ?? []).map(hz_stripIso)
  }
}
// ----------------------------
// Q3 — hazard-by-crop (independent inputs)
// ----------------------------

// Parse scenarios (Q3-specific)
hz_q3_s1 = (() => hz_parseScenarioPick(hz_q3_scen1))()
hz_q3_s2 = (() => hz_parseScenarioPick(hz_q3_scen2))()

// Resolve dataset URLs (Q3-specific)
hz_q3_keyCandidates1 = hz_keyCandidatesFor({
  varShort: hz_q3_varShort,
  period: hz_q3_period,
  model: hz_q3_s1?.model,
  severity: hz_q3_severity,
  method: hz_q3_method
})
hz_q3_keyCandidates2 = hz_keyCandidatesFor({
  varShort: hz_q3_varShort,
  period: hz_q3_period,
  model: hz_q3_s2?.model,
  severity: hz_q3_severity,
  method: hz_q3_method
})

hz_q3_src1 = hz_resolveFromCandidates(hz_q3_keyCandidates1)
hz_q3_src2 = hz_resolveFromCandidates(hz_q3_keyCandidates2)

// Commodities payload (Q3-specific)
hz_q3_selectedCommoditiesForReq = {
  const picked = (hz_q3_commodities ?? []).filter(Boolean)
  return picked.length ? picked : ["all"]
}

// Geo payload (Q3-specific)
hz_q3_geoFilterApi = {
  const g = hz_q3_geoFilter ?? {}
  return {
    ...g,
    admin0: (g.admin0 ?? []).map(hz_stripIso),
    admin1: (g.admin1 ?? []).map(hz_stripIso),
    admin2: (g.admin2 ?? []).map(hz_stripIso)
  }
}

// Guard: require Admin0 and resolved datasets (Q3)
hz_q3ReqOk = (() => {
  if (hz_isBroadGeo?.(hz_q3_geoFilter)) {
    return { ok: false, error: "Select at least an Admin0 for Q3 (broad selection blocked for speed)." }
  }
  if (!(hz_q3_src1?.ok && hz_q3_src2?.ok)) {
    return { ok: false, error: "Q3 dataset URLs not resolved yet." }
  }
  return { ok: true, error: null }
})()

hz_q3_sideReq = (src, scen, extra) => ({
  dataset_url: src?.url,
  // API schema expects these nested keys (same style as Q2)
  scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
  geo: hz_q3_geoFilterApi,
  commodities: hz_q3_selectedCommoditiesForReq ?? [],
  hazard_vars: null,
  hazards: null,
  method: hz_q3_method,
  commodity_group: hz_q3_commodityGroup,
  ...(extra ?? {})
})

// Guard: require Admin0 and resolved datasets
hz_q2ReqOk = (() => {
  if (hz_isBroadGeo?.(hz_q2_geoFilter)) {
    return { ok: false, error: "Select at least an Admin0 for Q2 (broad selection blocked for speed)." }
  }
  if (!(hz_q2_src1?.ok && hz_q2_src2?.ok)) {
    return { ok: false, error: "Q2 dataset URLs not resolved yet." }
  }
  return { ok: true, error: null }
})()

hz_q2_sideReq = (src, scen) => ({
  dataset_url: src?.url,
  scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
  geo: hz_q2_geoFilterApi,
  commodities: hz_q2_selectedCommoditiesForReq ?? [],
  hazard_vars: null,
  hazards: null,
  method: hz_q2_method,
  commodity_group: hz_q2_commodityGroup
})

// API calls (no hz_activeQuestion gate)
hz_q2RespL = hz_q2ReqOk.ok
  ? await hz_apiDebouncedCached("q2L", "/api/v1/hz/totals-by-crop", hz_q2_sideReq(hz_q2_src1, hz_q2_s1), { ttlMs: 300000, debounceMs: 250 })
  : { ok: false, error: hz_q2ReqOk.error, data: [] }

hz_q2RespR = hz_q2ReqOk.ok
  ? await hz_apiDebouncedCached("q2R", "/api/v1/hz/totals-by-crop", hz_q2_sideReq(hz_q2_src2, hz_q2_s2), { ttlMs: 300000, debounceMs: 250 })
  : { ok: false, error: hz_q2ReqOk.error, data: [] }

hz_q2DataL = hz_q2RespL?.data ?? []
hz_q2DataR = hz_q2RespR?.data ?? []

hz_q2Meta = ({
  ok: !!(hz_q2RespL?.ok && hz_q2RespR?.ok),
  cached: !!(hz_q2RespL?.cached && hz_q2RespR?.cached),
  t_ms: Math.max(Number(hz_q2RespL?.t_ms || 0), Number(hz_q2RespR?.t_ms || 0)),
  error: hz_q2RespL?.error || hz_q2RespR?.error || null
})

// Merge + rank (Top N from Q2 slider)
hz_q2Rows = {
  const mapL = new Map(hz_q2DataL.map(d => [d.crop, Number(d.total)]))
  const mapR = new Map(hz_q2DataR.map(d => [d.crop, Number(d.total)]))
  const crops = Array.from(new Set([...mapL.keys(), ...mapR.keys()]))

  const rows = crops.map(crop => ({
    crop,
    total1: mapL.get(crop) || 0,
    total2: mapR.get(crop) || 0
  }))

  rows.sort((a,b) => (b.total2 - a.total2) || (b.total1 - a.total1))
  return rows.slice(0, Number(hz_q2_topN || 25))
}

// Labels (Q2-specific)
hz_q2_geoLabel = hz_makeGeoLabel(hz_q2_geoFilter)
hz_q2_commodityLabel = hz_makeComLabel(hz_q2_selectedCommoditiesForReq ?? [])

// Labels (Q3-specific)
hz_q3_geoLabel = hz_makeGeoLabel(hz_q3_geoFilter)
hz_q3_commodityLabel = hz_makeComLabel(hz_q3_selectedCommoditiesForReq ?? [])

// Q3 absolute axis label
hz_q3_varLabelAbs = (() => {
  const s = String(hz_q3_varShort ?? "")
  const varLabel =
    (s === "intld15") ? "International Dollars (2015)" :
    (s === "usd15") ? "USD (2015)" :
    (s === "people") ? "People" :
    hz_formatVarShort(s)
  const base = String(varLabel ?? '').trim()
  if (!base) return 'Exposure'
  if (/exposure/i.test(base)) return base
  return `Exposure (${base})`
})()

// Chart (Q2-specific)
hz_q2Chart = {
  const rows = hz_q2Rows ?? []
  const labelAbs = hz_varLabelAbs
  const xLabel = hz_q2_relative ? "Percent of side total (%)" : labelAbs

  const subtitle = `${hz_q2_geoLabel} • ${hz_q2_commodityLabel} • Left: ${hz_q2_s1.label} • Right: ${hz_q2_s2.label}`

  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const sum1 = rows.reduce((s,r) => s + (r.total1 || 0), 0)
  const sum2 = rows.reduce((s,r) => s + (r.total2 || 0), 0)

  const v1 = (d) => hz_q2_relative ? (sum1 ? (100 * d.total1 / sum1) : 0) : d.total1
  const v2 = (d) => hz_q2_relative ? (sum2 ? (100 * d.total2 / sum2) : 0) : d.total2

  if (hz_q2_difference) {
    const diff = rows.map(d => ({ crop: d.crop, delta: v2(d) - v1(d) }))
    return Plot.plot({
      height: Math.max(280, diff.length * 22, Number(hz_q2_chartHeight ?? 520)),
      marginLeft: 160,
      x: { grid: true, label: hz_q2_relative ? "Δ percentage points (Right − Left)" : "Δ exposure (Right − Left)" },
      y: { domain: diff.map(d => d.crop) },
      caption: subtitle,
      marks: [Plot.ruleX([0]), Plot.barX(diff, { x: "delta", y: "crop", tip: true })]
    })
  }

  const crops = rows.map(d => d.crop)
  const left = rows.map(d => ({ crop: d.crop, value: v1(d) }))
  const right = rows.map(d => ({ crop: d.crop, value: v2(d) }))

  const plotSide = (data, title) => html`
    <div class="hz-mini">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(280, crops.length * 22, Number(hz_q2_chartHeight ?? 520)),
        marginLeft: 160,
        x: { grid: true, label: xLabel },
        y: { domain: crops },
        caption: subtitle,
        marks: [Plot.barX(data, { x: "value", y: "crop", tip: true }), Plot.ruleX([0])]
      })}
    </div>
  `

  return html`<div class="hz-grid2">${plotSide(left, "Left")}${plotSide(right, "Right")}</div>`
}
```

```{ojs}
//| output: false
// ----------------------------
// Q2 — summary table (AtlasTable, same style as Q1)
// ----------------------------
hz_q2TableView = {
  const rows = Array.isArray(hz_q2Rows) ? hz_q2Rows : []
  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const sum1 = rows.reduce((s,r) => s + (r.total1 || 0), 0)
  const sum2 = rows.reduce((s,r) => s + (r.total2 || 0), 0)

  const showPct = !!hz_q2_relative

  const fmtAbsFull = (v) => hz_formatNumber(v, { digits: 2, compact: false })
  const fmtPct = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
  }

  const fmtPP = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    const sign = x > 0 ? "+" : ""
    return `${sign}${hz_formatNumber(x, { digits: 2, compact: false })} pp`
  }

  const tableData = rows.map((r) => {
    const p1 = sum1 ? (100 * r.total1 / sum1) : 0
    const p2 = sum2 ? (100 * r.total2 / sum2) : 0
    return ({
      "Crop": r.crop,
      "Left (abs)": r.total1,
      "Right (abs)": r.total2,
      "Δ (abs)": (r.total2 - r.total1),
      "Left (%)": p1,
      "Right (%)": p2,
      "Δ (pp)": (p2 - p1)
    })
  })

  return hz_atlasTable(tableData, {
    columns: showPct
      ? ["Crop", "Left (%)", "Right (%)", "Δ (pp)"]
      : ["Crop", "Left (abs)", "Right (abs)", "Δ (abs)"],
    format: {
      "Left (abs)": fmtAbsFull,
      "Right (abs)": fmtAbsFull,
      "Δ (abs)": fmtAbsFull,
      "Left (%)": fmtPct,
      "Right (%)": fmtPct,
      "Δ (pp)": fmtPP
    },
    rows: 12,
    height: "540px",
    width: {
      "Crop": 240,
      "Left (abs)": 140,
      "Right (abs)": 140,
      "Δ (abs)": 140,
      "Left (%)": 120,
      "Right (%)": 120,
      "Δ (pp)": 120
    }
  })
}
```

```{ojs}
//| output: false
// ----------------------------
// Q3 — summary table (AtlasTable, hazards ranked)
// ----------------------------
hz_q3Rows = {
  const L = Array.isArray(hz_q3DataL) ? hz_q3DataL : []
  const R = Array.isArray(hz_q3DataR) ? hz_q3DataR : []

  const haz = new Set([...L.map(d => d.hazard), ...R.map(d => d.hazard)])
  const mapL = new Map()
  const mapR = new Map()
  const topCropR = new Map() // hazard -> { crop, v }

  for (const d of L) {
    const h = d.hazard
    mapL.set(h, (mapL.get(h) || 0) + Number(d.total || 0))
  }
  for (const d of R) {
    const h = d.hazard
    const v = Number(d.total || 0)
    mapR.set(h, (mapR.get(h) || 0) + v)
    const prev = topCropR.get(h)
    if (!prev || v > prev.v) topCropR.set(h, { crop: d.crop, v })
  }

  const rows = Array.from(haz).map(h => {
    const total1 = mapL.get(h) || 0
    const total2 = mapR.get(h) || 0
    const tc = topCropR.get(h)
    const topCrop = tc?.crop ?? "—"
    const topShare = total2 ? (100 * (tc?.v || 0) / total2) : 0
    return ({ hazard: h, total1, total2, delta: (total2 - total1), topCrop, topShare })
  })

  rows.sort((a,b) => (b.total2 - a.total2) || (b.total1 - a.total1))

  // Keep the same magnitude as the API selection (top_hazards)
  const k = Math.max(5, Number(hz_q3ReqExtra?.top_hazards || 10))
  return rows.slice(0, k)
}

hz_q3TableView = {
  const rows = Array.isArray(hz_q3Rows) ? hz_q3Rows : []
  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const fmtAbsFull = (v) => hz_formatNumber(v, { digits: 2, compact: false })
  const fmtPct = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
  }

  const tableData = rows.map((r) => ({
    "Hazard": r.hazard,
    "Left (abs)": r.total1,
    "Right (abs)": r.total2,
    "Δ (abs)": r.delta,
    "Top crop (Right)": r.topCrop,
    "Top crop share (Right %)": r.topShare
  }))

  return hz_atlasTable(tableData, {
    columns: ["Hazard", "Left (abs)", "Right (abs)", "Δ (abs)", "Top crop (Right)", "Top crop share (Right %)"],
    format: {
      "Left (abs)": fmtAbsFull,
      "Right (abs)": fmtAbsFull,
      "Δ (abs)": fmtAbsFull,
      "Top crop share (Right %)": fmtPct
    },
    rows: 12,
    height: "540px",
    width: {
      "Hazard": 200,
      "Left (abs)": 140,
      "Right (abs)": 140,
      "Δ (abs)": 140,
      "Top crop (Right)": 240,
      "Top crop share (Right %)": 170
    }
  })
}
```

```{ojs}
//| output: false
// ----------------------------
// Q3 — hazard by crop
// ----------------------------
hz_q3ReqExtra = ({ top_hazards: Number(hz_q3_topHazards || 10), top_crops: Number(hz_q3_topCrops || 12) })

hz_q3RespL = hz_q3ReqOk.ok
  ? await hz_apiDebouncedCached("q3L", "/api/v1/hz/hazard-by-crop", hz_q3_sideReq(hz_q3_src1, hz_q3_s1, hz_q3ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : { ok: false, error: hz_q3ReqOk.error, data: [] }

hz_q3RespR = hz_q3ReqOk.ok
  ? await hz_apiDebouncedCached("q3R", "/api/v1/hz/hazard-by-crop", hz_q3_sideReq(hz_q3_src2, hz_q3_s2, hz_q3ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : { ok: false, error: hz_q3ReqOk.error, data: [] }

hz_q3DataL = hz_q3RespL?.data ?? []
hz_q3DataR = hz_q3RespR?.data ?? []

hz_q3Meta = ({
  ok: !!(hz_q3RespL?.ok && hz_q3RespR?.ok),
  cached: !!(hz_q3RespL?.cached && hz_q3RespR?.cached),
  t_ms: Math.max(Number(hz_q3RespL?.t_ms || 0), Number(hz_q3RespR?.t_ms || 0)),
  error: hz_q3RespL?.error || hz_q3RespR?.error || null
})

hz_q3Chart = {
  const L = hz_q3DataL ?? []
  const R = hz_q3DataR ?? []
  if (!L.length && !R.length) return html`<div class="hz-muted">No data.</div>`

  const subtitle = `${hz_q3_geoLabel} • ${hz_q3_commodityLabel} • Left: ${hz_q3_s1.label} • Right: ${hz_q3_s2.label}`
  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })

  // ----------------------------
  // Δ mode (hazard-ranked)
  // ----------------------------
  if ((hz_q3_compareMode || "side") === "diff") {
    const rows = Array.isArray(hz_q3Rows) ? hz_q3Rows : []
    if (!rows.length) return html`<div class="hz-muted">No data.</div>`

    const hazards = rows.map(r => r.hazard)
    const height = Math.max(280, hazards.length * 26, Number(hz_q3_chartHeight ?? 520))

    return Plot.plot({
      height,
      marginLeft: 200,
      marginRight: 18,
      marginTop: 10,
      marginBottom: 28,
      x: { grid: true, label: "Δ exposure (Right − Left)" },
      y: { domain: hazards, label: null },
      caption: subtitle,
      marks: [
        Plot.barX(rows, {
          x: "delta",
          y: "hazard",
          tip: {
            format: {
              hazard: true,
              delta: fmtAbs,
              total1: fmtAbs,
              total2: fmtAbs,
              topCrop: true,
              topShare: (v) => `${hz_formatNumber(v, { digits: 2, compact: false })}%`
            }
          }
        }),
        Plot.ruleX([0])
      ]
    })
  }

  // ----------------------------
  // Side-by-side mode (crop-ranked, hazard-stacked)
  // ----------------------------

  // Top crops by combined exposure (Left + Right)
  const cropTotals = new Map()
  const bump = (crop, v) => cropTotals.set(crop, (cropTotals.get(crop) || 0) + Number(v || 0))
  for (const d of R) bump(d.crop, d.total)
  for (const d of L) bump(d.crop, d.total)

  const maxCrops = Math.min(25, Number(hz_q3ReqExtra?.top_crops || 12))
  const crops = Array.from(cropTotals.entries())
    .sort((a,b) => b[1] - a[1])
    .slice(0, maxCrops)
    .map(([c]) => c)

  const hazards = Array.from(new Set([...L.map(d => d.hazard), ...R.map(d => d.hazard)])).sort()

  const filter = (data) =>
    data
      .filter(d => crops.includes(d.crop) && hazards.includes(d.hazard))
      .map(d => ({ crop: d.crop, hazard: d.hazard, total: Number(d.total || 0) }))

  // Shared categorical color scale (keeps left/right colors aligned)
  const color = { type: "categorical", domain: hazards, scheme: "tableau10", legend: false }
  const legend = Plot.legend({ color: { domain: hazards, scheme: "tableau10" }, columns: 3 })

  const plotStack = (data, title) => html`
    <div class="hz-mini hz-mini--stack">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(320, crops.length * 26, Number(hz_q3_chartHeight ?? 520)),
        marginLeft: 160,
        marginRight: 18,
        marginTop: 10,
        marginBottom: 28,
        x: { label: (hz_q3_varLabelAbs ?? "Exposure"), grid: true },
        y: { domain: crops, label: null },
        color,
        caption: subtitle,
        marks: [
          Plot.barX(filter(data), {
            ...Plot.stackX({ x: "total", y: "crop", fill: "hazard" }),
            tip: {
              format: {
                crop: true,
                hazard: true,
                total: fmtAbs
              }
            }
          }),
          Plot.ruleX([0])
        ]
      })}
    </div>
  `

  return html`
    <div class="hz-legendRow">${legend}</div>
    <div class="hz-grid2 hz-grid2--equal">
      ${plotStack(L, "Left")}
      ${plotStack(R, "Right")}
    </div>
  `
}

```

```{ojs}
//| output: false
// ----------------------------
// Q4 — totals by admin area
// ----------------------------
hz_q4ReqExtra = ({ group_child: false })

hz_q4RespL = await hz_apiDebouncedCached("q4L", "/api/v1/hz/by-admin", hz_sideReq(hz_src1, hz_s1, hz_q4ReqExtra), { ttlMs: 300000, debounceMs: 250 })

hz_q4RespR = await hz_apiDebouncedCached("q4R", "/api/v1/hz/by-admin", hz_sideReq(hz_src2, hz_s2, hz_q4ReqExtra), { ttlMs: 300000, debounceMs: 250 })

hz_q4DataL = hz_q4RespL?.data ?? []
hz_q4DataR = hz_q4RespR?.data ?? []

hz_q4Meta = ({
  ok: !!(hz_q4RespL?.ok && hz_q4RespR?.ok),
  cached: !!(hz_q4RespL?.cached && hz_q4RespR?.cached),
  t_ms: Math.max(Number(hz_q4RespL?.t_ms || 0), Number(hz_q4RespR?.t_ms || 0)),
  error: hz_q4RespL?.error || hz_q4RespR?.error || null
})

hz_q4Rows = {
  const mapL = new Map(hz_q4DataL.map(d => [(d.admin_name ?? d.admin), Number(d.total)]))
  const mapR = new Map(hz_q4DataR.map(d => [(d.admin_name ?? d.admin), Number(d.total)]))
  const names = Array.from(new Set([...mapL.keys(), ...mapR.keys()]))
  const rows = names.map(name => ({ name, total1: mapL.get(name) || 0, total2: mapR.get(name) || 0 }))
  rows.sort((a,b) => (b.total2 - a.total2) || (b.total1 - a.total1))
  return rows.slice(0, hz_topN)
}

hz_q4Chart = {
  const rows = hz_q4Rows ?? []
  const xLabel = hz_rel ? "Percent of side total (%)" : hz_varLabelAbs

  const subtitle = `${hz_q3_geoLabel} • ${hz_q3_commodityLabel} • Left: ${hz_q3_s1.label} • Right: ${hz_q3_s2.label}`

  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const sum1 = rows.reduce((s,r) => s + (r.total1 || 0), 0)
  const sum2 = rows.reduce((s,r) => s + (r.total2 || 0), 0)

  const v1 = (d) => hz_rel ? (sum1 ? (100 * d.total1 / sum1) : 0) : d.total1
  const v2 = (d) => hz_rel ? (sum2 ? (100 * d.total2 / sum2) : 0) : d.total2

  if (hz_compareMode === "diff") {
    const diff = rows.map(d => ({ name: d.name, delta: v2(d) - v1(d) }))
    return Plot.plot({
      height: Math.max(280, diff.length * 22, Number(hz_q3_chartHeight ?? 520)),
      marginLeft: 180,
      x: { grid: true, label: hz_rel ? "Δ percentage points (Right − Left)" : "Δ exposure (Right − Left)" },
      y: { domain: diff.map(d => d.name) },
      caption: subtitle,
      marks: [
        Plot.ruleX([0]),
        Plot.barX(diff, { x: "delta", y: "name", tip: true })
      ]
    })
  }

  const names = rows.map(d => d.name)
  const left = rows.map(d => ({ name: d.name, value: v1(d) }))
  const right = rows.map(d => ({ name: d.name, value: v2(d) }))

  const plotSide = (data, title) => html`
    <div class="hz-mini">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(280, names.length * 22, Number(hz_q3_chartHeight ?? 520)),
        marginLeft: 180,
        x: { grid: true, label: xLabel },
        y: { domain: names },
        caption: subtitle,
        marks: [
          Plot.barX(data, { x: "value", y: "name", tip: true }),
          Plot.ruleX([0])
        ]
      })}
    </div>
  `
  return html`<div class="hz-grid2">${plotSide(left, "Left")}${plotSide(right, "Right")}</div>`
}
```

```{ojs}
//| output: false

// ------------------------------------------------------------
// View mode toggle (Chart / Dashboard / Summary / Map / Raw records)
// (Copied from original hazardExposure.qmd to restore missing cell)
// ------------------------------------------------------------
viewof hz_viewMode = {
  // Q1 only: Chart + Summary table
  const form = Inputs.radio(
    ["chart", "table"],
    {
      label: "",
      value: "chart",
      format: (v) => ({ chart: "Chart", table: "Summary table" }[v] ?? v),
    }
  )

  form.classList.add("hz-viewToggle")

  const getScroller = () =>
    document.scrollingElement ||
    document.querySelector("#quarto-content") ||
    document.documentElement ||
    document.body

  const preserveAnchor = () => {
    const sc = getScroller()
    const y0 = sc.scrollTop
    const anchor = document.getElementById("q1")
    const a0 = anchor ? anchor.getBoundingClientRect().top : 0

    const restore = () => {
      const sc2 = getScroller()
      const anchor2 = document.getElementById("q1")
      const a1 = anchor2 ? anchor2.getBoundingClientRect().top : 0
      sc2.scrollTop = y0 + (a1 - a0)
    }

    // Restore after reactive reflow
    setTimeout(() => {
      restore()
      requestAnimationFrame(restore)
      requestAnimationFrame(restore)
    }, 0)
  }

  form.addEventListener(
    "change",
    () => {
      try {
        document.activeElement?.blur?.()
      } catch (_) {}
      preserveAnchor()
    },
    true
  )

  return form
}
// ------------------------------------------------------------
// Records-view controls (pager + sort). (Copied from the stable v3 notebook.)
// ------------------------------------------------------------
viewof hz_recordsSide = {
  const options = [
    { value: "left",  label: "Left" },
    { value: "right", label: "Right" }
  ];

  const root = document.createElement("div");
  root.className = "hz-tabs hz-tabs--small";

  const buttons = new Map();
  const paint = (v) => {
    for (const [val, btn] of buttons.entries()) btn.classList.toggle("is-active", val === v);
  };

  const set = (v, { silent = false } = {}) => {
    if (root.value === v) return;
    root.value = v;
    paint(v);
    if (!silent) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  for (const op of options) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "hz-tab";
    btn.textContent = op.label;
    btn.onclick = () => set(op.value);
    buttons.set(op.value, btn);
    root.appendChild(btn);
  }

  set("left", { silent: true });
  return root;
}

viewof hz_recordsSort = {
  const options = ["value_desc", "value_asc"]
  const labelMap = { value_desc: "Value ↓", value_asc: "Value ↑" }
  const sel = Inputs.select(options, {
    value: "value_desc",
    label: null,
    format: (d) => labelMap[d] ?? String(d)
  });
  sel.classList.add("hz-select");
  return sel;
}

viewof hz_recordsPageSize = {
  const options = [50, 100, 200, 500]
  const sel = Inputs.select(options, {
    value: 100,
    label: null,
    format: (d) => `${d} rows`
  });
  sel.classList.add("hz-select");
  return sel;
}

viewof hz_recordsPage = {
  const root = document.createElement("div");
  root.className = "hz-pager";
  root.value = 1;

  const prev = document.createElement("button");
  prev.type = "button";
  prev.className = "hz-btn hz-btn--sm";
  prev.textContent = "Prev";

  const label = document.createElement("div");
  label.className = "hz-pager__label";

  const next = document.createElement("button");
  next.type = "button";
  next.className = "hz-btn hz-btn--sm";
  next.textContent = "Next";

  const paint = () => { label.textContent = `Page ${root.value}`; };

  const set = (v, { silent = false } = {}) => {
    const n = Math.max(1, Number(v || 1));
    if (root.value === n) return;
    root.value = n;
    paint();
    if (!silent) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  prev.onclick = () => set(root.value - 1);
  next.onclick = () => set(root.value + 1);

  root.appendChild(prev);
  root.appendChild(label);
  root.appendChild(next);

  paint();
  return root;
}
```

```{ojs}
//| output: false
// Render main shell
hz_controlsMount = html`<div class="hz-mount"><div class="hz-loading">Loading controls…</div></div>`
hz_dashMount = html`<div class="hz-mount"><div class="hz-loading">Loading dashboard…</div></div>`

hz_chartHost  = html`<div class="hz-chartWrap"><div class="hz-loading">Loading chart…</div></div>`
hz_q2_chartHost  = html`<div class="hz-chartWrap"><div class="hz-loading">Loading chart…</div></div>`
hz_q2_tableHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading table…</div></div>`
hz_tableActionsHost = html`<div class="hz-actions"></div>`
hz_q3_chartHost  = html`<div class="hz-chartWrap"><div class="hz-loading">Loading chart…</div></div>`
hz_q3_tableHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading table…</div></div>`
hz_q3_tableActionsHost = html`<div class="hz-actions"></div>`

hz_q1_downloadMount = {
  try {
    const rows = Array.isArray(hz_chartRows) ? hz_chartRows : []
    const data = rows.map((r) => ({
      "Hazard": r?.hazard ?? "",
      "Historic (Total)": r?.total1 ?? null,
      "Scenario (Total)": r?.total2 ?? null,
      "Difference (Total)": r?.total_diff ?? null,
      "Historic (%)": r?.perc1 ?? null,
      "Scenario (%)": r?.perc2 ?? null,
      "Difference (%)": r?.pct_diff ?? null
    }))
    hz_tableActionsHost.replaceChildren(downloadButton(data, "hazardExposure_q1_summary"))
  } catch (_) {}
  return null
}

hz_q3_downloadMount = {
  try {
    const rows = Array.isArray(hz_q3Rows) ? hz_q3Rows : []
    const data = rows.map((r) => ({
      "Hazard": r?.hazard ?? "",
      "Left (abs)": r?.total1 ?? null,
      "Right (abs)": r?.total2 ?? null,
      "Δ (abs)": r?.delta ?? null,
      "Top crop (Right)": r?.topCrop ?? "",
      "Top crop share (Right %)": r?.topShare ?? null
    }))
    hz_q3_tableActionsHost.replaceChildren(downloadButton(data, "hazardExposure_q3_summary"))
  } catch (_) {}
  return null
}

hz_tableHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading table…</div></div>`
hz_mapHost  = html`<div class="hz-mapWrap"><div class="hz-loading">Loading map…</div></div>`
hz_recordsActionsHost = html`<div class="hz-actions"></div>`
hz_recordsHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading records…</div></div>`
hz_debugHost  = html``
hz_pathHost   = html``
hz_schemaHost = html``

// Register UI elements for cross-cell updates
hz_registerUi = {
  const ui = (globalThis.__ATLAS_HZ_UI__ ??= {})
  // Q1 mounts
  ui.chartWrap = hz_chartHost
  ui.tableWrap = hz_tableHost
  ui.mapWrap = hz_mapHost
  ui.recordsWrap = hz_recordsHost

  // Q2 mounts
  ui.q2_chartWrap = hz_q2_chartHost
  ui.q2_tableWrap = hz_q2_tableHost

  // Q3 mounts (chart + table hosts exist; table wiring comes in later patches)
  ui.q3_chartWrap = hz_q3_chartHost
  ui.q3_tableWrap = hz_q3_tableHost

  ui._busyCounts = ui._busyCounts ?? {}

  ui.setBusyFor = (groupKey, on) => {
    const g = String(groupKey || "")
    const target =
      g.startsWith("q2") ? "q2" :
      g.startsWith("q3") ? "q3" :
      g.startsWith("q4") ? "q4" :
      "q1"

    ui._busyCounts[target] = Math.max(0, (ui._busyCounts[target] || 0) + (on ? 1 : -1))
    const busy = ui._busyCounts[target] > 0

    const pick = (k) => ({
      q1: { chart: ui.chartWrap, table: ui.tableWrap },
      q2: { chart: ui.q2_chartWrap, table: ui.q2_tableWrap },
      q3: { chart: ui.q3_chartWrap, table: ui.q3_tableWrap },
      q4: { chart: ui.q4_chartWrap, table: ui.q4_tableWrap }
    }[k] ?? { chart: ui.chartWrap, table: ui.tableWrap })

    const { chart: chartWrap, table: tableWrap } = pick(target)

    try { chartWrap?.classList.toggle("hz-chartWrap--busy", busy) } catch (_) {}
    try { tableWrap?.classList.toggle("hz-tableWrap--busy", busy) } catch (_) {}

    // Only Q1 has map/records mounts today
    if (target === "q1") {
      try { ui.mapWrap?.classList.toggle("hz-mapWrap--busy", busy) } catch (_) {}
      try { ui.recordsWrap?.classList.toggle("hz-tableWrap--busy", busy) } catch (_) {}
    }
  }

  // Backwards-compatible: default busy targets Q1
  ui.setBusy = (on) => ui.setBusyFor("q1", on)

  return null
}
// Dashboard UI (static shell) — avoid re-rendering the whole card on view toggle.
hz_q1_settingsWrap = {
  const el = html`
  <div class="hz-qToolbar__right">
    <div class="hz-inlineToggles">
      <div class="hz-miniSetting"><span>Show %</span>${viewof hz_relative}</div>
      <div class="hz-miniSetting"><span>Difference</span>${viewof hz_difference}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Height</span>${viewof hz_q1ChartHeight}</div>
    </div>
  </div>
`;
  try { el.style.visibility = "visible" } catch (_) {}
  return el
}

hz_q1_chartCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header">
    <div class="hz-sideCard__title">Chart</div>
  </div>
  <div class="hz-sideCard__body">${hz_chartHost}</div>
</div>`

hz_q1_tableCard = {
  const el = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header">
    <div class="hz-sideCard__title">Summary table</div>
    <div class="hz-sideCard__right">${hz_tableActionsHost}</div>
  </div>
  <div class="hz-sideCard__body">${hz_tableHost}</div>
</div>`;
  try { el.style.display = "none" } catch (_) {}
  return el
}

// Wrap both result cards; we toggle visibility (display) instead of swapping nodes.
hz_q1_resultsWrap = {
  const wrap = html`<div class="hz-qResults"></div>`
  wrap.append(hz_q1_chartCard, hz_q1_tableCard)
  return wrap
}

// Apply current view mode without rebuilding the whole Q1 card.
hz_q1_applyView = {
  const mode = (hz_viewMode || "chart")
  try { hz_q1_chartCard.style.display = (mode === "chart") ? "" : "none" } catch (_) {}
  try { hz_q1_tableCard.style.display = (mode === "table") ? "" : "none" } catch (_) {}
  try { hz_q1_settingsWrap.style.visibility = (mode === "chart") ? "visible" : "hidden" } catch (_) {}
  return null
}

// Dashboard shell renders once; inner parts update via hz_q1_applyView + mount cells.
hz_dashboardShell = html`
  <div class="hz-card">
    <div class="hz-card__body">
      <div class="hz-qOverview">${q1DetailText}</div>

      ${hz_controlsPanelReal}

      <div class="hz-qToolbar">
        <div class="hz-qToolbar__left">${viewof hz_viewMode}</div>
        ${hz_q1_settingsWrap}
      </div>

      <div class="hz-vizWrap">
        ${hz_q1_resultsWrap}
      </div>
    </div>
  </div>
`;

// --------------------------
// Q2–Q4: independent controls
// --------------------------
// (These are not yet connected to queries/outputs; they exist now so each question has its own state.)

viewof hz_q2_viewMode = Inputs.radio(["chart", "table"], {
  label: "",
  value: "chart",
  format: (v) => ({ chart: "Chart", table: "Summary table" }[v] ?? v)
})
hz_q2_viewMode.classList?.add?.("hz-viewToggle")

viewof hz_q2_relative = Inputs.toggle({ label: "", value: false })
viewof hz_q2_difference = Inputs.toggle({ label: "", value: false })
viewof hz_q2_topN = Inputs.range([5, 50], { label: "", step: 1, value: 25 })

viewof hz_q2_chartHeight = Inputs.range([360, 900], { label: "", step: 10, value: 520 })

viewof hz_q3_chartHeight = Inputs.range([360, 900], { label: "", step: 10, value: 520 })
viewof hz_q3_topHazards = Inputs.range([5, 30], { label: "", step: 1, value: 10 })
viewof hz_q3_topCrops = Inputs.range([5, 30], { label: "", step: 1, value: 12 })

viewof hz_q4_viewMode = Inputs.radio(["chart", "both", "table", "map"], {
  label: "",
  value: "both",
  format: (v) => ({ chart: "Chart", both: "Dashboard", table: "Summary", map: "Map" }[v] ?? v)
})
viewof hz_q4_chartHeight = Inputs.range([360, 900], { label: "Chart height:", step: 10, value: 520 })

// Dataset / scenarios (independent per question; use same primitive option lists as Q1)
viewof hz_q2_varShort = Inputs.select(hz_varShorts ?? [], {
  label: "Exposure value:",
  format: hz_formatVarShort,
  value: hz_defaultVarShort ?? (hz_varShorts ?? [])[0] ?? null
})

viewof hz_q2_period = Inputs.select(hz_periods ?? [], {
  label: "Period:",
  format: hz_formatPeriod,
  value: hz_defaultPeriod ?? (hz_periods ?? [])[0] ?? null
})

viewof hz_q2_severity = Inputs.select(hz_severities ?? [], {
  label: "Severity:",
  format: hz_formatSeverity,
  value: hz_defaultSeverity ?? (hz_severities ?? [])[0] ?? null
})

viewof hz_q2_method = Inputs.select(hz_methodOptions ?? ["generic","auto"], {
  label: "Hazard method:",
  value: "generic",
  format: hz_methodLabel
})

viewof hz_q2_scen1 = Inputs.select(hz_scenXTime ?? [], {
  label: "Scenario A:",
  format: hz_formatScenXTime,
  value: "historic"
})

viewof hz_q2_scen2 = Inputs.select(hz_scenXTime ?? [], {
  label: "Scenario B:",
  format: hz_formatScenXTime,
  value: (hz_scenXTime ?? []).find(d => d !== "historic") ?? "historic"
})

// Commodities (enhanced multiselect, climateRationale-style)
viewof hz_q2_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], { label: "Group", value: "crops", format: hz_commodityGroupLabel })
hz_q2_commodityOptions = {
  const g = hz_q2_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  return [...(hz_spamCodes?.crops ?? []), ...(hz_livestock ?? [])].filter(Boolean).sort()
}

hz_safeEnhancedMultiSelect = (options, cfg = {}) => {
  const label = cfg.label ?? "Select"
  const placeholder = cfg.placeholder ?? "Search…"
  const disabled = !!cfg.disabled

  // Normalize selected values to plain strings
  const value = (Array.isArray(cfg.value) ? cfg.value : [])
    .map(v => (v && typeof v === "object") ? (v.value ?? v.name ?? v.label ?? v.id ?? v) : v)
    .map(v => String(v ?? "").trim())
    .filter(Boolean)

  // Normalize options into {value,label} with *string* values.
  const rows = (options ?? [])
    .map((o) => {
      if (o == null) return null
      if (typeof o === "string" || typeof o === "number") {
        const v = String(o).trim()
        if (!v) return null
        const lbl = (typeof cfg.format === "function") ? String(cfg.format(v)) : v
        return { value: v, label: lbl }
      }
      if (typeof o === "object") {
        const v = String(o.value ?? o.id ?? o.key ?? o.name ?? "").trim()
        if (!v) return null
        const lbl = String(o.label ?? o.name ?? o.value ?? v)
        return { value: v, label: lbl }
      }
      return null
    })
    .filter(Boolean)

  const map = new Map(rows.map(r => [r.value, r.label]))
  const values = Array.from(new Set(rows.map(r => r.value)))

  const format = (v) => map.get(String(v)) ?? String(v)

  const viewofSelect = Inputs.select(values, {
    label,
    multiple: true,
    value,
    disabled,
    format
  })

  return enhancedMultiSelect(viewofSelect, {
    placeholder,
    requireAtLeastOne: false,
    maxHeight: cfg.maxHeight ?? 200,
    width: cfg.width ?? "100%"
  })
}

viewof hz_q2_commodities = hz_safeEnhancedMultiSelect(
  (hz_q2_commodityOptions ?? []).map(v => ({ value: v, label: hz_commodityLabelOf(v) })),
  { label: "Commodities", value: [] , placeholder: "Search commodities…" }
)

// Geography UI (exact Atlas boundary UI)
viewof hz_q2_admin0 = renderA0Multi({ key: "q2", maxSelections: 8, requireAtLeastOne: true })
viewof hz_q2_admin1 = renderA1Multi({ key: "q2", a0: viewof hz_q2_admin0, maxSelections: 12 })
viewof hz_q2_admin2 = renderA2Multi({ key: "q2", a0: viewof hz_q2_admin0, a1: viewof hz_q2_admin1, maxSelections: 20 })
hz_q2_geoUI = inputTemplate()([viewof hz_q2_admin0, viewof hz_q2_admin1, viewof hz_q2_admin2])

hz_normSel2 = (x) => {
  const arr = x == null ? [] : (Array.isArray(x) ? x : [x])
  const toStr = (d) => {
    if (d == null) return ""
    if (typeof d === "string" || typeof d === "number") return String(d)
    if (typeof d === "object") {
      if ("admin2_name" in d) return d.admin2_name == null ? "" : String(d.admin2_name)
      if ("admin1_name" in d) return d.admin1_name == null ? "" : String(d.admin1_name)
      if ("admin0_name" in d) return d.admin0_name == null ? "" : String(d.admin0_name)
      return String(d.value ?? d.name ?? d.label ?? d.id ?? "")
    }
    return String(d)
  }
  return arr.map(toStr).map((s) => String(s).trim()).filter((s) => s.length > 0)
}
hz_q2_geoFilter = ({ admin0: hz_normSel2(hz_q2_admin0), admin1: hz_normSel2(hz_q2_admin1), admin2: hz_normSel2(hz_q2_admin2) })

hz_makeGeoLabel = (gf) => {
  const a0 = Array.isArray(gf?.admin0) ? gf.admin0.filter(Boolean) : []
  const a1 = Array.isArray(gf?.admin1) ? gf.admin1.filter(Boolean) : []
  const a2 = Array.isArray(gf?.admin2) ? gf.admin2.filter(Boolean) : []
  const hasAll = a0.length === 0 || a0.includes("all")
  const fmt = (arr, max = 2) => {
    const xs = arr.slice(0, max)
    const more = arr.length > max ? ` +${arr.length - max}` : ""
    return xs.join(", ") + more
  }
  if (hasAll) return "All"
  if (a2.length) return `ADM2: ${fmt(a2)}`
  if (a1.length) return `ADM1: ${fmt(a1)}`
  return `ADM0: ${fmt(a0)}`
}

hz_makeComLabel = (arr) => {
  const xs = (arr ?? []).map(v => (v?.value ?? v)).filter(Boolean)
  if (!xs.length) return "All"
  const head = xs.slice(0, 2).map(hz_commodityLabelOf).join(", ")
  const more = xs.length > 2 ? ` +${xs.length - 2}` : ""
  return head + more
}

// ------------------------------------------------------------
// Q3/Q4 dataset + commodities + geography (independent controls)
// ------------------------------------------------------------
viewof hz_q3_varShort = Inputs.select(hz_varShorts ?? [], {
  label: "Exposure value:",
  format: hz_formatVarShort,
  value: hz_defaultVarShort ?? (hz_varShorts ?? [])[0] ?? null
})
viewof hz_q3_period = Inputs.select(hz_periods ?? [], {
  label: "Period:",
  format: hz_formatPeriod,
  value: (hz_periods ?? [])[0] ?? null
})
viewof hz_q3_severity = Inputs.select(hz_severities ?? [], {
  label: "Severity:",
  format: hz_formatSeverity,
  value: hz_defaultSeverity ?? (hz_severities ?? [])[0] ?? null
})
viewof hz_q3_scen1 = Inputs.select(hz_scenXTime ?? [], {
  label: "Left:",
  format: hz_formatScenXTime,
  value: hz_defaultScen1 ?? (hz_scenXTime ?? [])[0] ?? null
})
viewof hz_q3_scen2 = Inputs.select(hz_scenXTime ?? [], {
  label: "Right:",
  format: hz_formatScenXTime,
  value: hz_defaultScen2 ?? (hz_scenXTime ?? [])[1] ?? (hz_scenXTime ?? [])[0] ?? null
})
viewof hz_q3_compareMode = Inputs.radio(["side", "diff"], {
  label: "Compare:",
  value: "side",
  format: (v) => ({ side: "Side-by-side", diff: "Δ (Right − Left)" }[v] ?? v)
})
viewof hz_q3_method = Inputs.select(hz_methodOptions ?? [], {
  label: "Method:",
  value: "generic"
})

viewof hz_q3_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], {
  label: "Group:",
  value: "crops",
  format: hz_commodityGroupLabel
})

hz_q3_commodityOptions = {
  const g = hz_q3_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  if (g === "all") return (hz_spamCodes?.all ?? hz_spamCodes?.crops ?? [])
  return (hz_spamCodes?.crops ?? [])
}

viewof hz_q3_commodities = hz_safeEnhancedMultiSelect(
  (hz_q3_commodityOptions ?? []).map(v => ({ value: v, label: hz_commodityLabelOf(v) })),
  { label: "Commodities", value: [], placeholder: "Search commodities…" }
)

viewof hz_q3_admin0 = renderA0Multi({ key: "q3", maxSelections: 10, requireAtLeastOne: true })
viewof hz_q3_admin1 = renderA1Multi({ key: "q3", a0: viewof hz_q3_admin0, maxSelections: 20 })
viewof hz_q3_admin2 = renderA2Multi({ key: "q3", a0: viewof hz_q3_admin0, a1: viewof hz_q3_admin1, maxSelections: 50 })

hz_q3_geoUI = inputTemplate()([viewof hz_q3_admin0, viewof hz_q3_admin1, viewof hz_q3_admin2])
hz_q3_geoFilter = ({ admin0: hz_normSel2(hz_q3_admin0), admin1: hz_normSel2(hz_q3_admin1), admin2: hz_normSel2(hz_q3_admin2) })

viewof hz_q4_varShort = Inputs.select(hz_varShortOptions ?? [], { label: "Hazard variable", value: (hz_varShortOptions ?? [])[0], format: hz_formatVarShort })
viewof hz_q4_period = Inputs.select(hz_periodOptions ?? [], { label: "Period", value: (hz_periodOptions ?? [])[0], format: hz_formatPeriod })
viewof hz_q4_severity = Inputs.select(hz_severityOptions ?? [], { label: "Severity", value: (hz_severityOptions ?? [])[0], format: hz_formatSeverity })
viewof hz_q4_scen1 = Inputs.select(hz_scenOptions ?? [], { label: "Left", value: (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q4_scen2 = Inputs.select(hz_scenOptions ?? [], { label: "Right", value: (hz_scenOptions ?? [])[1] ?? (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q4_compareMode = Inputs.radio(["side", "diff"], { label: "Compare", value: "side", format: (v) => ({ side: "Side-by-side", diff: "Δ (Right − Left)" }[v] ?? v) })
viewof hz_q4_method = Inputs.select(hz_methodOptions ?? [], { label: "Method", value: (hz_methodOptions ?? [])[0] ?? "auto" })

viewof hz_q4_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], { label: "Group", value: "crops", format: hz_commodityGroupLabel })
hz_q4_commodityOptions = {
  const g = hz_q4_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  return [...(hz_spamCodes?.crops ?? []), ...(hz_livestock ?? [])].filter(Boolean).sort()
}
viewof hz_q4_commodities = hz_safeEnhancedMultiSelect(
  (hz_q4_commodityOptions ?? []).map(v => ({ value: v, label: hz_commodityLabelOf(v) })),
  { label: "Commodities", value: [], placeholder: "Search commodities…" }
)

viewof hz_q4_admin0 = renderA0Multi({ key: "q4", maxSelections: 8 })
viewof hz_q4_admin1 = renderA1Multi({ key: "q4", a0: viewof hz_q4_admin0, maxSelections: 12 })
viewof hz_q4_admin2 = renderA2Multi({ key: "q4", a0: viewof hz_q4_admin0, a1: viewof hz_q4_admin1, maxSelections: 20 })
hz_q4_geoUI = inputTemplate()([viewof hz_q4_admin0, viewof hz_q4_admin1, viewof hz_q4_admin2])
hz_q4_geoFilter = ({ admin0: hz_normSel2(hz_q4_admin0), admin1: hz_normSel2(hz_q4_admin1), admin2: hz_normSel2(hz_q4_admin2) })

hz_q2_controlsSummary = {
  const left = hz_parseScenarioPick(hz_q2_scen1)?.label ?? String(hz_q2_scen1 ?? "")
  const right = hz_parseScenarioPick(hz_q2_scen2)?.label ?? String(hz_q2_scen2 ?? "")
  const geo = hz_makeGeoLabel(hz_q2_geoFilter)
  const com = hz_makeComLabel(hz_q2_commodities ?? [])
  return `${hz_formatVarShort(hz_q2_varShort)} · ${hz_formatPeriod(hz_q2_period)} · ${hz_formatSeverity(hz_q2_severity)} · ${left} vs ${right} · Geo: ${geo} · Com: ${com}`
}

hz_q2_controlsPanel = html`
  <div class="hz-controlsCompact hz-controlsPanel">
    <div class="hz-controlsRows">
      <div class="hz-row hz-row--3">
        <div class="hz-field">${viewof hz_q2_varShort}</div>
        <div class="hz-field">${viewof hz_q2_period}</div>
        <div class="hz-field">${viewof hz_q2_severity}</div>
      </div>

      <div class="hz-row hz-row--3 hz-row--grow">
        <div class="hz-field hz-field--sm">${viewof hz_q2_commodityGroup}</div>
        <div class="hz-field hz-field--grow">${viewof hz_q2_commodities}</div>
        <div class="hz-field hz-field--sm">${viewof hz_q2_method}</div>
      </div>

      <div class="hz-row hz-row--3">
        <div class="hz-field">${viewof hz_q2_admin0}</div>
        <div class="hz-field">${viewof hz_q2_admin1}</div>
        <div class="hz-field">${viewof hz_q2_admin2}</div>
      </div>

      <div class="hz-row hz-row--2">
        <div class="hz-field">${viewof hz_q2_scen1}</div>
        <div class="hz-field">${viewof hz_q2_scen2}</div>
      </div>
    </div>
  </div>
`;

hz_q2_settingsWrap = html`
  <div class="hz-qToolbar__right">
    <div class="hz-inlineToggles">
      <div class="hz-miniSetting"><span>Show %</span>${viewof hz_q2_relative}</div>
      <div class="hz-miniSetting"><span>Difference</span>${viewof hz_q2_difference}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Number of commodities</span>${viewof hz_q2_topN}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Height</span>${viewof hz_q2_chartHeight}</div>
    </div>
  </div>
`;

hz_q2_chartCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header"><div class="hz-sideCard__title">Chart</div></div>
  <div class="hz-sideCard__body">${hz_q2_chartHost}</div>
</div>`;

hz_q2_tableCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header"><div class="hz-sideCard__title">Summary table</div></div>
  <div class="hz-sideCard__body">${hz_q2_tableHost}</div>
</div>`;

hz_q2_render = {
  // Chart content
  try { hz_q2_chartHost.replaceChildren(hz_q2Chart) } catch (e) {
    try { hz_q2_chartHost.replaceChildren(html`<div class="warn"><b>Plot error</b><br/><div class="hz-muted">${String(e)}</div></div>`) } catch (_) {}
  }
  // Table content
  try { hz_q2_tableHost.replaceChildren(hz_q2TableView) } catch (e) {
    try { hz_q2_tableHost.replaceChildren(html`<div class="warn"><b>Table error</b><br/><div class="hz-muted">${String(e)}</div></div>`) } catch (_) {}
  }
  return null
};

hz_q2_applyView = {
  const mode = (hz_q2_viewMode || "chart");
  try { hz_q2_chartCard.style.display = (mode === "chart") ? "" : "none"; } catch (_) {}
  try { hz_q2_tableCard.style.display = (mode === "table") ? "" : "none"; } catch (_) {}
  try { hz_q2_settingsWrap.style.visibility = (mode === "chart") ? "visible" : "hidden"; } catch (_) {}
  return null;
};

hz_q2_dashboardCard = html`
<div class="hz-card">
  <div class="hz-card__body">
    <h1 class="anchored hz-qHeading">${q2Title}</h1>
    <div class="hz-qOverview">${q2DetailText}</div>

    ${hz_q2_controlsPanel}

    <div class="hz-qToolbar">
      <div class="hz-qToolbar__left">${viewof hz_q2_viewMode}</div>
      ${hz_q2_settingsWrap}
    </div>

    <div class="hz-vizWrap">
      <div class="hz-qResults">
        ${hz_q2_chartCard}
        ${hz_q2_tableCard}
      </div>
    </div>
  </div>
</div>
`;

// ------------------------------------------------------------
// Q3/Q4 Controls (incremental dev placeholders)
// ------------------------------------------------------------
hz_q3_controlsPanel = html`
  <div class="hz-controlsCompact hz-controlsPanel">
    <div class="hz-controlsRows">
      <div class="hz-row hz-row--3">
        <div class="hz-field">${viewof hz_q3_varShort}</div>
        <div class="hz-field">${viewof hz_q3_period}</div>
        <div class="hz-field">${viewof hz_q3_severity}</div>
      </div>

      <div class="hz-row hz-row--3 hz-row--grow">
        <div class="hz-field hz-field--sm">${viewof hz_q3_commodityGroup}</div>
        <div class="hz-field hz-field--grow">${viewof hz_q3_commodities}</div>
        <div class="hz-field hz-field--sm">${viewof hz_q3_method}</div>
      </div>

      <div class="hz-row hz-row--3">
        <div class="hz-field">${viewof hz_q3_admin0}</div>
        <div class="hz-field">${viewof hz_q3_admin1}</div>
        <div class="hz-field">${viewof hz_q3_admin2}</div>
      </div>

      <div class="hz-row hz-row--3">
        <div class="hz-field">${viewof hz_q3_scen1}</div>
        <div class="hz-field">${viewof hz_q3_scen2}</div>
        <div class="hz-field">${viewof hz_q3_compareMode}</div>
      </div>
    </div>
  </div>
`;

hz_q4_controlsPanel = html`
  <div class="hz-controlsCompact hz-controlsPanel">
    <div class="hz-controlsGrid2">
      <div class="hz-field">${viewof hz_q4_varShort}</div>
      <div class="hz-field">${viewof hz_q4_period}</div>

      <div class="hz-field">${viewof hz_q4_severity}</div>
      <div class="hz-field">${viewof hz_q4_method}</div>

      <div class="hz-field">${viewof hz_q4_scen1}</div>
      <div class="hz-field">${viewof hz_q4_scen2}</div>

      <div class="hz-field">${viewof hz_q4_compareMode}</div>
      <div class="hz-field"></div>

      <div class="hz-field hz-field--full">
        <div class="hz-inlineRow hz-inlineRow--commodities">
          <div class="hz-inlineRow__small">${viewof hz_q4_commodityGroup}</div>
          <div class="hz-inlineRow__grow">${viewof hz_q4_commodities}</div>
        </div>
      </div>
      <div class="hz-field hz-field--full">${hz_q4_geoUI}</div>
    </div>
  </div>
`;

hz_q3_settingsWrap = html`
  <div class="hz-qToolbar__right">
    <div class="hz-inlineToggles">
      <div class="hz-miniSetting hz-miniSetting--range"><span>Number of hazards</span>${viewof hz_q3_topHazards}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Number of crops</span>${viewof hz_q3_topCrops}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Height</span>${viewof hz_q3_chartHeight}</div>
    </div>
  </div>
`;
hz_q3_chartCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header"><div class="hz-sideCard__title">Chart</div></div>
  <div class="hz-sideCard__body">${hz_q3_chartHost}</div>
</div>`;

hz_q3_tableCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header">
    <div class="hz-sideCard__title">Summary table</div>
    <div class="hz-sideCard__right">${hz_q3_tableActionsHost}</div>
  </div>
  <div class="hz-sideCard__body">${hz_q3_tableHost}</div>
</div>`;

hz_q3_render = {

  if (hz_q3ReqOk && !hz_q3ReqOk.ok) {
    const msg = hz_q3ReqOk.error || "Please adjust your Q3 selections."
    try {
      hz_q3_chartHost.replaceChildren(html`<div class="warn"><b>Selection required</b><br/><div class="hz-muted">${msg}</div></div>`)
    } catch (_) {}
    try {
      hz_q3_tableHost.replaceChildren(html`<div class="warn"><b>Selection required</b><br/><div class="hz-muted">${msg}</div></div>`)
    } catch (_) {}
    return null
  }

  // Chart content
  try { hz_q3_chartHost.replaceChildren(hz_q3Chart) } catch (e) {
    try { hz_q3_chartHost.replaceChildren(html`<div class="warn"><b>Plot error</b><br/><div class="hz-muted">${String(e)}</div></div>`) } catch (_) {}
  }

  // Table content (AtlasTable)
  try { hz_q3_tableHost.replaceChildren(hz_q3TableView) } catch (e) {
    try { hz_q3_tableHost.replaceChildren(html`<div class="warn"><b>Table error</b><br/><div class="hz-muted">${String(e)}</div></div>`) } catch (_) {}
  }

  return null
};

viewof hz_q3_viewMode = Inputs.radio(["chart", "table"], {
  label: "",
  value: "chart",
  format: (v) => ({ chart: "Chart", table: "Summary" }[v] ?? v)
})

hz_q3_applyView = {
  const mode = (hz_q3_viewMode || "chart");
  try { hz_q3_chartCard.style.display = (mode === "chart") ? "" : "none"; } catch (_) {}
  try { hz_q3_tableCard.style.display = (mode === "table") ? "" : "none"; } catch (_) {}
  try { hz_q3_settingsWrap.style.visibility = (mode === "chart") ? "visible" : "hidden"; } catch (_) {}
  return null;
};

hz_q3_dashboardCard = html`
<div class="hz-card">
  <div class="hz-card__body">
    <h1 class="anchored hz-qHeading">${q3Title}</h1>
    <div class="hz-qOverview">
      <div>${q3DetailText}</div>
      <div class="hz-muted" style="margin-top:.5rem">
        This view is useful when:
        <ul style="margin:.35rem 0 0 1.2rem">
          <li>You want to prioritize hazard-specific actions (e.g. drought resilience).</li>
          <li>You’re interested in which crops dominate exposure to dry, heat, or compound hazards.</li>
        </ul>
      </div>
    </div>

    ${hz_q3_controlsPanel}

    <div class="hz-qToolbar">
      <div class="hz-qToolbar__left">${viewof hz_q3_viewMode}</div>
      ${hz_q3_settingsWrap}
    </div>

    <div class="hz-vizWrap">
      <div class="hz-qResults">
        ${hz_q3_chartCard}
        ${hz_q3_tableCard}
      </div>
    </div>
  </div>
</div>
`;

hz_q4_dashboardCard = html`
<div class="hz-card">
  <div class="hz-card__head">
    <div>
      <div class="hz-card__title">Q4 — Scenario comparison</div>
    </div>
  </div>

  <div class="hz-card__body">
    <div class="hz-qOverview">
      Side-by-side scenario differences for the selected dataset and commodities. (Outputs will be wired after Q1 layout and controls are final.)
    </div>

    ${hz_q4_controlsPanel}

    <div class="hz-qToolbar">
      <div class="hz-qToolbar__left">
        ${viewof hz_q4_viewMode}
      </div>
      ${
        (hz_q4_viewMode === "chart" || hz_q4_viewMode === "both")
          ? html`<div class="hz-qToolbar__right"><div class="hz-inlineRange">${viewof hz_q4_chartHeight}</div></div>`
          : ""
      }
    </div>

    <div class="hz-sideCard">
      <div class="hz-sideCard__header"><div class="hz-sideCard__title">Placeholder</div></div>
      <div class="hz-sideCard__body"><div class="hz-muted">Q4 chart/table/map will render here.</div></div>
    </div>
  </div>
</div>
`;

// Q1 wrapper: controls live in the Q1 section (not in a global Controls panel)
hz_q1_block = html`<section id="q1" class="hz-question">${hz_dashboardShell}</section>`
hz_questionsStack = html`
  <div class="hz-stack hz-stack--questions">
    ${hz_q1_block}
    <section id="q2" class="hz-question">${hz_q2_dashboardCard}</section>
    <section id="q3" class="hz-question">${hz_q3_dashboardCard}</section>
    <section id="q4" class="hz-question">$</section>
  </div>
`

hz_mountDash = {
  try {
    // Preserve scroll position even if Quarto makes a wrapper scroll container.
    const scroller =
      document.scrollingElement ||
      document.querySelector("#quarto-content") ||
      document.querySelector(".page-columns") ||
      document.documentElement ||
      document.body

    const y = scroller?.scrollTop ?? window.scrollY
    const x = scroller?.scrollLeft ?? window.scrollX

    // Avoid focus-driven jump when the radio/checkbox inputs are recreated.
    try { document.activeElement?.blur?.() } catch (e) {}

    hz_dashMount.replaceChildren(hz_questionsStack)

    const restore = () => {
      if (scroller) {
        scroller.scrollTop = y
        scroller.scrollLeft = x
      } else {
        window.scrollTo(x, y)
      }
    }

    requestAnimationFrame(() => {
      restore()
      requestAnimationFrame(restore)
    })
  } catch (e) {
    hz_dashMount.replaceChildren(html`<div class="warn"><b>Dashboard failed to render:</b><br>${String(e)}</div>`)
  }
  return html``
}

// ------------------------------------------------------------
// Table rendering (Grid.js) + CSV export
// ------------------------------------------------------------
hz_loadCssOnce = (id, href) => {
  if (document.getElementById(id)) return Promise.resolve(true)
  return new Promise((resolve, reject) => {
    const el = document.createElement("link")
    el.id = id
    el.rel = "stylesheet"
    el.href = href
    el.onload = () => resolve(true)
    el.onerror = (e) => reject(e)
    document.head.appendChild(el)
  })
}

hz_loadScriptOnce = (id, src) => {
  if (document.getElementById(id)) return Promise.resolve(true)
  return new Promise((resolve, reject) => {
    const el = document.createElement("script")
    el.id = id
    el.src = src
    el.async = true
    el.onload = () => resolve(true)
    el.onerror = (e) => reject(e)
    document.head.appendChild(el)
  })
}

hz_loadGridjs = async () => {
  await hz_loadCssOnce("hz-gridjs-theme", "https://unpkg.com/gridjs/dist/theme/mermaid.min.css")
  await hz_loadScriptOnce("hz-gridjs-lib", "https://cdnjs.cloudflare.com/ajax/libs/gridjs/6.2.0/gridjs.production.min.js")
  return window.gridjs
}

hz_csvEscape = (v) => {
  const s = String(v ?? "")
  if (/[",\n]/.test(s)) return `"${s.replaceAll('"', '""')}"`
  return s
}

hz_downloadCsv = (filename, rows) => {
  const lines = rows.map(r => r.map(hz_csvEscape).join(",")).join("\n")
  const blob = new Blob([lines], { type: "text/csv;charset=utf-8" })
  const a = document.createElement("a")
  a.href = URL.createObjectURL(blob)
  a.download = filename || "table.csv"
  document.body.appendChild(a)
  a.click()
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove() }, 250)
}

hz_mountGrid = (host, key, cfg) => {
  const g = window.gridjs
  if (!g?.Grid) throw new Error("Grid.js not loaded")
  const store = (globalThis.__ATLAS_HZ_GRIDS__ ??= {})
  try { store[key]?.destroy?.() } catch (_) {}
  host.replaceChildren()
  const grid = new g.Grid(cfg)
  store[key] = grid
  grid.render(host)
  return grid
}


hz_updateChart = {
  const q = (hz_activeQuestion || "q1")
  const view = (hz_viewMode || "both")
  const wantsChart = (view === "chart" || view === "both")
  const wantsTable = (view === "table" || view === "both")
  const wantsRecords = (view === "records")
  const errors = []

  // Records-only view: status pill reflects /records endpoint; rendering handled by hz_updateRecords.
  if (wantsRecords) {
    const r = hz_recordsResp
    if (!r) {
      return html``
    }
    if (!r.ok) {
      return html``
    }
    return html``
  }

  // Map view: choropleth by admin (uses by-admin endpoint + getAdminBoundaries)
  if (hz_viewMode === "map") {
    const meta = hz_mapMeta || { loading: true, ok: false }

    // Loading
    if (meta.loading) {
      hz_mapHost.replaceChildren(html`<div class="hz-loading">Loading map…</div>`)
      return html``
    }

    // Error
    if (!meta.ok) {
      const err = html`<div class="warn"><b>Map error:</b><br>${String(meta.error || "Map query failed")}</div>`
      hz_mapHost.replaceChildren(err)
      return html``
    }

    // Ready
    hz_mapHost.replaceChildren(hz_mapPlot)
    return html``
  }

  const pick = () => {
    if (q === "q1") return { meta: hz_q1Meta, chart: hz_q1Chart }
    if (q === "q2") return { meta: hz_q2Meta, chart: hz_q2Chart }
    if (q === "q3") return { meta: hz_q3Meta, chart: hz_q3Chart }
    if (q === "q4") return { meta: hz_q4Meta, chart: hz_q4Chart }
    return { meta: hz_q1Meta, chart: hz_q1Chart }
  }

  const { meta, chart } = pick()

  if (!meta?.ok) {
    errors.push({ side: "api", error: meta?.error || "API call failed" })
  }

  // Status pill
  if (errors.length) {
  } else {
    const tag = meta?.cached ? "Cached" : "Ready"
    const ms = Number.isFinite(meta?.t_ms) ? ` (${meta.t_ms} ms)` : ""
  }

  // Chart area
  if (wantsChart) {
    if (errors.length) {
      hz_chartHost.replaceChildren(
        html`<div class="warn"><b>Chart failed</b><br/><div class="hz-muted">${errors[0].error}</div></div>`
      )
    } else {
      try {
        hz_chartHost.replaceChildren(chart)
      } catch (e) {
        hz_chartHost.replaceChildren(
          html`<div class="warn"><b>Plot error</b><br/><div class="hz-muted">${String(e)}</div></div>`
        )
      }
    }
  } else {
    hz_chartHost.replaceChildren(html`<div class="hz-muted">Chart hidden.</div>`)
  }

  // Table area
  const clearTable = (msg) => {
    try { hz_tableActionsHost.replaceChildren() } catch (_) {}
    hz_tableHost.replaceChildren(html`<div class="hz-muted">${msg}</div>`)
  }

  if (!wantsTable) {
    clearTable("Table hidden.")
    return html``
  }

  if (errors.length) {
    clearTable("Table unavailable because the API request failed.")
    return html``
  }

  // Load Grid.js (once)
  let gridOk = true
  try { await hz_loadGridjs() } catch (e) { gridOk = false }
  if (!gridOk) {
    clearTable("Table library failed to load (Grid.js). Check network/CSP and reload.")
    return html``
  }

  const showPct = !!(hz_relative || hz_rel)
  const fmtAbs = (v) => hz_formatNumber(v, { digits: 2, compact: true })
  const fmtAbsFull = (v) => hz_formatNumber(v, { digits: 2, compact: false })
  const fmtPct = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
  }

  const payload = (() => {
    if (q === "q1") {
      const rows = Array.isArray(hz_chartRows) ? hz_chartRows : []
      const headers = ["Hazard","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => [
        r.hazard,
        Number(r.total1 ?? 0),
        Number(r.total2 ?? 0),
        Number(r.total_diff ?? (Number(r.total2 ?? 0) - Number(r.total1 ?? 0))),
        Number(r.perc1 ?? 0),
        Number(r.perc2 ?? 0),
        Number(r.pct_diff ?? (Number(r.perc2 ?? 0) - Number(r.perc1 ?? 0)))
      ])

      const columns = [
        { name: "Hazard" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q1_by_hazard.csv", headers, data, columns }
    }

    if (q === "q2") {
      const rows = Array.isArray(hz_q2Rows) ? hz_q2Rows : []
      const sum1 = rows.reduce((a,r) => a + Number(r.total1 ?? 0), 0)
      const sum2 = rows.reduce((a,r) => a + Number(r.total2 ?? 0), 0)
      const headers = ["Crop","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => {
        const t1 = Number(r.total1 ?? 0), t2 = Number(r.total2 ?? 0)
        const p1 = sum1 ? (t1/sum1*100) : 0
        const p2 = sum2 ? (t2/sum2*100) : 0
        return [r.crop, t1, t2, (t2 - t1), p1, p2, (p2 - p1)]
      })
      const columns = [
        { name: "Crop" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q2_by_crop.csv", headers, data, columns }
    }

    if (q === "q3") {
      // Match chart selection: top crops by (Left+Right)
      const L = Array.isArray(hz_q3DataL) ? hz_q3DataL : []
      const R = Array.isArray(hz_q3DataR) ? hz_q3DataR : []
      const cropTotals = new Map()
      const bump = (crop, v) => cropTotals.set(crop, (cropTotals.get(crop) || 0) + Number(v || 0))
      for (const d of R) bump(d.crop, d.total)
      for (const d of L) bump(d.crop, d.total)

      const maxCrops = Math.min(25, Number(hz_q3ReqExtra?.top_crops || 12))
      const crops = Array.from(cropTotals.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, maxCrops)
        .map(([c]) => c)

     
      const hazTotals = new Map()
      const bumpH = (haz, v) => hazTotals.set(haz, (hazTotals.get(haz) || 0) + Number(v || 0))
      for (const d of R) bumpH(d.hazard, d.total)
      for (const d of L) bumpH(d.hazard, d.total)

      const maxHaz = Math.min(12, Array.from(hazTotals.keys()).length)
      const hazards = Array.from(hazTotals.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, maxHaz)
        .map(([h]) => h)

      const key = (crop, hazard) => `${crop}|||${hazard}`
      const mapL = new Map(L.filter(d => crops.includes(d.crop) && hazards.includes(d.hazard)).map(d => [key(d.crop, d.hazard), Number(d.total || 0)]))
      const mapR = new Map(R.filter(d => crops.includes(d.crop) && hazards.includes(d.hazard)).map(d => [key(d.crop, d.hazard), Number(d.total || 0)]))

      const pairs = []
      for (const c of crops) for (const h of hazards) pairs.push([c,h])

      const headers = ["Crop","Hazard","Left total","Right total","Δ (abs)"]
      const data = pairs.map(([crop, hazard]) => {
        const t1 = mapL.get(key(crop,hazard)) || 0
        const t2 = mapR.get(key(crop,hazard)) || 0
        return [crop, hazard, t1, t2, (t2 - t1)]
      }).sort((a,b) => (b[3] - a[3]) || (b[2] - a[2]))

      const columns = [
        { name: "Crop" },
        { name: "Hazard" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) }
      ]
      return { filename: "q3_hazard_x_crop.csv", headers, data, columns }
    }

    if (q === "q4") {
      const rows = Array.isArray(hz_q4Rows) ? hz_q4Rows : []
      const sum1 = rows.reduce((a,r) => a + Number(r.total1 ?? 0), 0)
      const sum2 = rows.reduce((a,r) => a + Number(r.total2 ?? 0), 0)

      const headers = ["Admin","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => {
        const t1 = Number(r.total1 ?? 0), t2 = Number(r.total2 ?? 0)
        const p1 = sum1 ? (t1/sum1*100) : 0
        const p2 = sum2 ? (t2/sum2*100) : 0
        return [r.admin_name, t1, t2, (t2 - t1), p1, p2, (p2 - p1)]
      })

      const columns = [
        { name: "Admin" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q4_by_admin.csv", headers, data, columns }
    }

    return null
  })()

  if (!payload) {
    clearTable("No table available for this view yet.")
    return html``
  }

  // Actions: download CSV
  const dl = document.createElement("button")
  dl.className = "hz-btn"
  dl.textContent = "Download CSV"
  dl.onclick = () => hz_downloadCsv(payload.filename, [payload.headers, ...payload.data])

  const rowsMeta = document.createElement("div")
  rowsMeta.className = "hz-muted"
  rowsMeta.style.marginRight = "10px"
  rowsMeta.textContent = `${payload.data.length.toLocaleString()} rows`

  const actionsWrap = document.createElement("div")
  actionsWrap.style.display = "flex"
  actionsWrap.style.alignItems = "center"
  actionsWrap.style.gap = "10px"
  actionsWrap.appendChild(rowsMeta)
  actionsWrap.appendChild(dl)

  hz_tableActionsHost.replaceChildren(actionsWrap)

  if (q === "q1") {
    const rows = Array.isArray(hz_chartRows) ? hz_chartRows : []

    const fmtPP = (v) => {
      const x = Number(v)
      if (!Number.isFinite(x)) return "—"
      const sign = x > 0 ? "+" : ""
      return `${sign}${hz_formatNumber(x, { digits: 2, compact: false })} pp`
    }

    const tableData = rows.map((r) => ({
      "Hazard": r.hazard,
      "Left (abs)": r.total1,
      "Right (abs)": r.total2,
      "Δ (abs)": r.total_diff,
      "Left (%)": r.perc1,
      "Right (%)": r.perc2,
      "Δ (pp)": r.pct_diff
    }))

    const view = hz_atlasTable(tableData, {
      columns: showPct
        ? ["Hazard", "Left (%)", "Right (%)", "Δ (pp)"]
        : ["Hazard", "Left (abs)", "Right (abs)", "Δ (abs)"],
      format: {
        "Left (abs)": fmtAbsFull,
        "Right (abs)": fmtAbsFull,
        "Δ (abs)": fmtAbsFull,
        "Left (%)": fmtPct,
        "Right (%)": fmtPct,
        "Δ (pp)": fmtPP
      },
      rows: 12,
      height: "540px",
      width: {
        "Hazard": 240,
        "Left (abs)": 140,
        "Right (abs)": 140,
        "Δ (abs)": 140,
        "Left (%)": 120,
        "Right (%)": 120,
        "Δ (pp)": 120
      }
    })

    hz_tableHost.replaceChildren(view)
    return html``
  }

  const tableDiv = document.createElement("div")
  hz_tableHost.replaceChildren(tableDiv)
  hz_mountGrid(tableDiv, "hz_table", {
    columns: payload.columns,
    data: payload.data,
    search: true,
    sort: true,
    pagination: { enabled: true, limit: 12 },
    fixedHeader: true,
    height: "540px"
  })

  return html``
}

// ------------------------------------------------------------
// Raw records (paged) — server-backed
// ------------------------------------------------------------

hz_recordsReq = {
  if (hz_viewMode !== "records") return null

  const side = (hz_recordsSide || "left")
  const src = (side === "right") ? hz_src2 : hz_src1
  const scen = (side === "right") ? hz_s2 : hz_s1

  const req = {
    dataset_url: src?.url,
    scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
    page: Number(hz_recordsPage || 1)
  }

  const ps = Number(hz_recordsPageSize)
  if (Number.isFinite(ps) && ps > 0) req.page_size = ps

  const s = hz_recordsSort
  if (typeof s === "string" && s) req.sort = s

  return req
}

hz_recordsResp = (hz_recordsReq)
  ? await hz_apiDebouncedCached("records", "/api/v1/hz/records", hz_recordsReq, { ttlMs: 30000, debounceMs: 150 })
  : null

hz_recordsRows = hz_recordsResp?.rows ?? []
hz_recordsHasMore = !!hz_recordsResp?.has_more

hz_recordsPagerSync = {
  const pager = globalThis.__ATLAS_HZ_REC_PAGER__
  if (pager) {
    pager.prev.disabled = Number(hz_recordsPage || 1) <= 1
    pager.next.disabled = !hz_recordsHasMore
    pager.label.textContent = `Page ${Number(hz_recordsPage || 1)}`
  }
  return html``
}

hz_recordsResetPage = {
  if (hz_viewMode !== "records") return html``

  // When these change, jump back to page 1
  hz_recordsSide
  hz_recordsSort
  hz_recordsPageSize

  const pager = globalThis.__ATLAS_HZ_REC_PAGER__
  if (pager?.set) pager.set(1, { silent: false })
  return html``
}

hz_exportRecordsCsv = async ({ scope = "all" } = {}) => {
  const req = hz_recordsReq
  if (!req) return

  // "all" means: let the server export up to its EXPORT_MAX_ROWS guardrail (default 200k).
  const body = (scope === "all")
    ? { ...req, page: 1, page_size: 200000 }
    : req

  const url = hz_apiBaseUrl + "/api/v1/hz/records_csv"
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  })

  if (!res.ok) {
    const txt = await res.text()
    throw new Error(txt || ("HTTP " + res.status))
  }

  const blob = await res.blob()
  const stamp = new Date().toISOString().slice(0,19).replaceAll(":","").replace("T","_")
  const name = `records_export_${stamp}.csv`

  const a = document.createElement("a")
  a.href = URL.createObjectURL(blob)
  a.download = name
  document.body.appendChild(a)
  a.click()
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove() }, 300)
}

hz_updateRecords = {
  if (hz_viewMode !== "records") return html``

  // Ensure Grid.js is available
  try { await hz_loadGridjs() } catch (e) {
    hz_recordsActionsHost.replaceChildren()
    hz_recordsHost.replaceChildren(
      html`<div class="warn"><b>Records table failed</b><br/><div class="hz-muted">Could not load Grid.js. ${String(e)}</div></div>`
    )
    return html``
  }

  const resp = hz_recordsResp
  if (!resp?.rows || !resp?.ok) {
    hz_recordsActionsHost.replaceChildren()
    const msg = resp?.error || "No data"
    hz_recordsHost.replaceChildren(
      html`<div class="warn"><b>Could not load records</b><br/><div class="hz-muted">${String(msg)}</div></div>`
    )
    return html``
  }

  // Actions
  const actions = document.createElement("div")
  actions.style.display = "flex"
  actions.style.gap = "8px"
  actions.style.flexWrap = "wrap"
  actions.style.justifyContent = "flex-end"
  actions.style.alignItems = "center"

  const badge = document.createElement("div")
  badge.className = "hz-muted"
  badge.style.fontWeight = "900"
  badge.style.fontSize = "12px"
  badge.textContent = `Rows: ${hz_recordsRows.length}${hz_recordsHasMore ? "+" : ""}`

  const btnAll = document.createElement("button")
  btnAll.className = "hz-btn hz-btn--sm"
  btnAll.textContent = "Export (server, max 200k)"
  btnAll.onclick = async () => {
    try {
      btnAll.disabled = true
      btnAll.textContent = "Exporting…"
      await hz_exportRecordsCsv({ scope: "all" })
    } catch (e) {
      alert(`Export failed: ${String(e?.message || e)}`)
    } finally {
      btnAll.disabled = false
      btnAll.textContent = "Export (server, max 200k)"
    }
  }

  actions.appendChild(badge)
  actions.appendChild(btnAll)
  hz_recordsActionsHost.replaceChildren(actions)

  const columns = [
    { name: "admin0" },
    { name: "admin1" },
    { name: "admin2" },
    { name: "scenario" },
    { name: "timeframe" },
    { name: "hazard" },
    { name: "hazard_vars" },
    { name: "crop" },
    { name: "value", sort: true, formatter: (c) => hz_formatNumber(c, { digits: 2, compact: true }) }
  ]

  const data = hz_recordsRows.map(r => [
    r.admin0_name ?? null,
    r.admin1_name ?? null,
    r.admin2_name ?? null,
    r.scenario ?? null,
    r.timeframe ?? null,
    r.hazard ?? null,
    r.hazard_vars ?? null,
    r.crop ?? null,
    (r.value === null || r.value === undefined) ? null : Number(r.value)
  ])

  const host = document.createElement("div")
  hz_recordsHost.replaceChildren(host)

  hz_mountGrid(host, "records", {
    columns,
    data,
    search: true,
    sort: true,
    fixedHeader: true,
    height: "560px"
  })

  return html``
}
hz_bootstrap = {
  hz_mountDash
  hz_registerUi
  hz_recordsPagerSync
  hz_recordsResetPage
  await hz_updateChart
  await hz_updateRecords
  return html``
}

hz_main = html`
  <div class="hz-stack hz-stack--page">
    ${hz_dashMount}
  </div>
`;
hz_renderApp = {
  const host = document.getElementById("hz-dashboard")
  if (!host) return null
  const ui = (globalThis.__ATLAS_HZ_UI__ ??= {})
  if (ui.__appMounted) return null

  host.replaceChildren(hz_main)
  ui.__appMounted = true
  return null
}

hz_run = {
  hz_renderApp
  await hz_bootstrap
  return null
}

hz_run
```



<!-- Add .hidden back in to hide -->


::: {.hidden}
{{< include /components/_lang.qmd >}}
:::



```{ojs}
function NavbarLangSelector(language_obj, masterLanguage) {
  const existing = document.getElementById("nav-lang-selector");
  if (existing) return;

  const lang_sel = Inputs.bind(
    Inputs.radio(language_obj, {
      label: "",
      format: (d) => d.label
    }),
    viewof masterLanguage
  );
  lang_sel.id = "nav-lang-selector";

  lang_sel.style.display = "flex";
  lang_sel.style.alignItems = "center";
  lang_sel.style.marginLeft = "10px";
  const lang_div = lang_sel.querySelector("div");
  if (lang_div) {
    lang_div.style.display = "flex";
    lang_div.style.flexDirection = "column";
  }

  const navList = document.querySelector(".navbar-nav.ms-auto");
  if (navList) {
    navList.appendChild(lang_sel);
    return;
  }

  const navEnd = document.querySelector(".navbar-nav.ms-auto .nav-item.compact");
  if (navEnd && navEnd.parentNode) {
    navEnd.parentNode.appendChild(lang_sel);
    return;
  }

  let mount = document.getElementById("atlas-lang-float");
  if (!mount) {
    mount = document.createElement("div");
    mount.id = "atlas-lang-float";
    mount.style.position = "fixed";
    mount.style.top = "12px";
    mount.style.right = "12px";
    mount.style.zIndex = "1030";
    mount.style.padding = "6px 10px";
    mount.style.borderRadius = "999px";
    mount.style.border = "1px solid rgba(0,0,0,.12)";
    mount.style.background = "rgba(255,255,255,.92)";
    mount.style.boxShadow = "0 10px 26px rgba(0,0,0,.10)";
    document.body.appendChild(mount);
  }
  mount.appendChild(lang_sel);
}

NavbarLangSelector(languages, masterLanguage)
```

```{ojs}
nbTitle = _lang({
  en: "Atlas Hazard Exposure Explorer",
  fr: "Explorateur d’exposition aux aléas de l’Atlas",
});

nbText = await FileAttachment("/data/hazardExposure/nbText.json").json();

heading1 = _lang({ en: "Overview", fr: "Aperçu" });
q1Title = _lang(nbText.sections?.q1?.title);
q1DetailText = _lang(nbText.sections?.q1?.detailText);

heading2 = q1Title;
q2Title = _lang(nbText.sections?.q2?.title);

q2DetailText = _lang(nbText.sections?.q2?.detailText);

q3Title = _lang(nbText.sections?.q3?.title);
q3DetailText = _lang(nbText.sections?.q3?.detailText);

heading3 = q2Title;

```

{{< include /components/_adminSelectorsMulti.qmd >}}
