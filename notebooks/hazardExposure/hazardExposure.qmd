---
pagetitle: "Atlas Hazard Exposure"
nb-authors:
  - Brayden Youngberg
  - Pete Stewart
  - Joseph Chemutt
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
import {
  atlasHero,
  downloadButton,
  multiLineText,
  loaderDiv,
} from "/helpers/uiComponents.ojs";

import { filterableDataTable as hz_atlasTable } from "/components/_atlasTable.ojs";

import { cleanAdminInput_SQL } from "/helpers/data.js";

import { enhancedMultiSelect } from "/helpers/enhancedMultiSelect.ojs";

import { inputTemplate } from "/helpers/std.ojs";

import { atlasTOC } from "/helpers/toc.ojs";

atlasHero(nbTitle, "../../images/default_crop.webp");
```

```{ojs}
 //| output: false
 hz_harmonizeNativeInputs = {
  const ENHANCED_FONT = 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif'
  const ARROW_SVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M6 8l4 4 4-4'/></svg>"

  const isHidden = (el) => {
    try {
      if (el.hidden) return true
      const cs = getComputedStyle(el)
      return (cs.display === "none" || cs.visibility === "hidden" || cs.opacity === "0")
    } catch { return false }
  }

  const styleSelect = (el) => {
    if (!el || el.tagName !== "SELECT") return
    if (el.multiple) return
    if (isHidden(el)) return

    el.style.fontFamily = ENHANCED_FONT
    el.style.fontSize = "14px"
    el.style.fontWeight = "500"
    el.style.width = "100%"
    el.style.minWidth = "0"
    el.style.boxSizing = "border-box"
    el.style.padding = "10px"
    el.style.paddingRight = "38px"
    el.style.backgroundColor = "white"
    el.style.color = "#111"
    el.style.border = "2px solid #d1d5db"
    el.style.borderRadius = "6px"
    el.style.cursor = "pointer"
    el.style.lineHeight = "1.2"
    el.style.transition = "all 0.2s ease"

    // Make the dropdown chevron closer to enhancedMultiSelect
    el.style.webkitAppearance = "none"
    el.style.mozAppearance = "none"
    el.style.appearance = "none"
    el.style.backgroundImage = 'url("' + ARROW_SVG + '")'
    el.style.backgroundRepeat = "no-repeat"
    el.style.backgroundPosition = "right 12px center"
    el.style.backgroundSize = "14px 14px"
  }

  const styleTextInput = (el) => {
    if (!el) return
    if (isHidden(el)) return
    el.style.fontFamily = ENHANCED_FONT
    el.style.fontSize = "14px"
    el.style.fontWeight = "500"
    el.style.width = "100%"
    el.style.minWidth = "0"
    el.style.boxSizing = "border-box"
    el.style.padding = "10px"
    el.style.backgroundColor = "white"
    el.style.color = "#111"
    el.style.border = "2px solid #d1d5db"
    el.style.borderRadius = "6px"
    el.style.lineHeight = "1.2"
    el.style.transition = "all 0.2s ease"
  }

  const styleInnerLabel = (label) => {
    if (!label || label.tagName !== "LABEL") return
    if (!label.querySelector("select")) return
    label.style.fontFamily = ENHANCED_FONT
    label.style.fontSize = "12px"
    label.style.fontWeight = "700"
    label.style.letterSpacing = "0.02em"
    label.style.display = "grid"
    label.style.gap = "0.35rem"
    label.style.margin = "0"
    label.style.textTransform = "uppercase"
  }

  const apply = () => {
    try {
      const roots = [
        ...document.querySelectorAll(".hz-controlsCompact"),
        ...document.querySelectorAll('[id^="observablehq-viewof-"]')
      ]
      roots.forEach(root => {
        root.querySelectorAll("label").forEach(styleInnerLabel)
        root.querySelectorAll("select").forEach(styleSelect)
        root.querySelectorAll('input[type="text"], input[type="number"], input[type="search"], textarea').forEach(styleTextInput)
      })
    } catch (e) { /* no-op */ }
  }

  apply()
  const mo = new MutationObserver(() => apply())
  mo.observe(document.body, { childList: true, subtree: true })
  invalidation.then(() => mo.disconnect())
  return null
}
```

{{< include /components/_atlasBoundaries.qmd >}}

```{ojs}
//| output: false
// ------------------------------------------------------------------
// Core helpers
// ------------------------------------------------------------------
hz_isHttpUrl = (x) => /^https?:\/\//i.test(String(x ?? ""))

hz_s3ToHttps = (s3) => {
  const s = String(s3 ?? "")
  const m = /^s3:\/\/([^\/]+)\/?(.*)$/.exec(s)
  if (!m) return s3
  const bucket = m[1]
  const key = (m[2] ?? "").replace(/^\/+/, "")
  if (!key) return `https://${bucket}.s3.amazonaws.com/`
  if (bucket === "digital-atlas") return `https://digital-atlas.s3.amazonaws.com/${key}`
  return `https://${bucket}.s3.amazonaws.com/${key}`
}

hz_toServedUrl = (p) => {
  const s = String(p ?? "").trim()
  if (!s) return s
  if (/^s3:\/\//i.test(s)) return hz_s3ToHttps(s)
  if (hz_isHttpUrl(s)) return s
  // Normalize Windows paths/backslashes to URL-style
  return s.replace(/\\/g, "/").replace(/^\.\//, "")
}

hz_resolvePath = (entry) => {
  if (!entry) return { ok: false, raw: null, url: null, source: "missing" }
  const local = entry.local_path ?? entry.localPath ?? null
  const s3 = entry.s3_path ?? entry.s3 ?? entry.path ?? null
  const url0 = entry.url ?? null

  if (local && String(local).trim() !== "") {
    const raw = String(local)
    return { ok: true, raw, url: hz_toServedUrl(raw), source: "local_path" }
  }
  if (s3 && String(s3).trim() !== "") {
    const raw = String(s3)
    const url = hz_isHttpUrl(raw) ? raw : hz_s3ToHttps(raw)
    return { ok: true, raw, url, source: hz_isHttpUrl(raw) ? "https" : "s3_path" }
  }
  if (url0 && String(url0).trim() !== "") {
    const raw = String(url0)
    return { ok: true, raw, url: hz_isHttpUrl(raw) ? raw : hz_toServedUrl(raw), source: "url" }
  }
  return { ok: false, raw: null, url: null, source: "missing" }
}

hz_validateParquetUrl = async (url) => {
  const u = String(url ?? "").trim()
  if (!u || !hz_isHttpUrl(u)) return { ok: true }
  try {
    const r = await fetch(u, { headers: { Range: "bytes=0-3" } })
    if (!r.ok) return { ok: false, error: `HTTP ${r.status} ${r.statusText}` }
    const buf = new Uint8Array(await r.arrayBuffer())
    const magic = String.fromCharCode(...buf)
    if (magic !== "PAR1") return { ok: false, error: `Not a Parquet file (magic=${magic})` }
    return { ok: true }
  } catch (e) {
    return { ok: true, warn: String(e) }
  }
}

hz_formatNumber = (v, { digits = 0, compact = true } = {}) => {
  const x = Number(v)
  if (!Number.isFinite(x)) return "—"
  const opts = compact
    ? { notation: "compact", compactDisplay: "short", maximumFractionDigits: digits, minimumFractionDigits: 0 }
    : { maximumFractionDigits: digits, minimumFractionDigits: 0 }
  return new Intl.NumberFormat(undefined, opts).format(x)
}

// Shared display formatters (used in Chart/Table/Map)
fmtAbs = (v) => hz_formatNumber(v, { digits: 2, compact: true })
fmtAbs0 = (v) => hz_formatNumber(v, { digits: 0, compact: true })
fmtPct = (v) => {
  const x = Number(v)
  if (!Number.isFinite(x)) return "—"
  return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
}
fmtSigned = (v) => {
  const x = Number(v)
  if (!Number.isFinite(x)) return "—"
  const s = x > 0 ? "+" : ""
  return s + hz_formatNumber(x, { digits: 2, compact: true })
}

hz_titleCase = (s) =>

  String(s ?? "")
    .replace(/[-_]+/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase())



hz_restoreScroll = (y) => {
  try {
    const restore = () => window.scrollTo({ top: y, left: 0, behavior: "auto" })
    requestAnimationFrame(() => requestAnimationFrame(restore))
    setTimeout(restore, 0)
    setTimeout(restore, 140)
  } catch (e) {}
}

hz_noJumpRoot = (node) => {
  const root = node
  const key = "__hz_nojump_installed"
  if (root && !root[key]) {
    root[key] = true
    let lastY = null
    const snap = () => { lastY = window.scrollY }
    const restore = () => { if (lastY != null) hz_restoreScroll(lastY) }
    root.addEventListener("pointerdown", snap, true)
    root.addEventListener("mousedown", snap, true)
    root.addEventListener("touchstart", snap, true)
    root.addEventListener("click", restore, true)
    root.addEventListener("input", restore, true)
    root.addEventListener("change", restore, true)
  }
  return root
}

hz_noJumpInput = (node) => {
  const el = node
  const key = "__hz_nojump_input"
  if (el && !el[key]) {
    el[key] = true
    let lastY = null
    const snap = () => { lastY = window.scrollY }
    const restore = () => { if (lastY != null) hz_restoreScroll(lastY) }
    el.addEventListener("pointerdown", snap, true)
    el.addEventListener("mousedown", snap, true)
    el.addEventListener("touchstart", snap, true)
    el.addEventListener("click", restore, true)
    el.addEventListener("input", restore, true)
    el.addEventListener("change", restore, true)
  }
  return el
}

hz_keepScroll = async (promise) => {
  const y = window.scrollY
  const res = await promise
  hz_restoreScroll(y)
  return res
}

```

```{ojs}
//| output: false
// hazardExposure_{varShort}_{period}_{model}_{severity}[_{suffix}]
hz_parseKeyParts = (key) => {
  const s = String(key ?? "").trim()
  const out = { raw: s, ok: false, varShort: null, period: null, model: null, severity: null, suffix: null, scenario: null, timeframe: null }
  if (!s) return out
  const parts = s.split("_")
  if (parts.length < 5 || parts[0] !== "hazardExposure") return out

  out.varShort = parts[1]
  out.period = parts[2]
  out.severity = parts[parts.length - 1]

  // model may include underscores (e.g., ssp585_2041-2060)
  const mid = parts.slice(3, parts.length - 1)
  out.model = mid.join("_") || null

  const knownSuffixes = new Set(["generic", "crop-specific", "crop_specific", "auto", "best"])
  if (out.model) {
    const mparts = out.model.split("_")
    const last = mparts[mparts.length - 1]
    if (knownSuffixes.has(last)) {
      out.suffix = last
      out.model = mparts.slice(0, -1).join("_") || null
    }
  }

  // derive scenario/timeframe from model
  if (out.model) {
    const mod = out.model
    if (mod === "historic" || mod === "Historical") {
      out.scenario = "historic"
      out.timeframe = "historic"
    } else {
      const mm = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(mod)
      if (mm) {
        out.scenario = mm[1]
        out.timeframe = mm[2]
      } else {
        out.scenario = mod
        out.timeframe = null
      }
    }
  }

  out.ok = true
  return out
}
```

```{ojs}
//| output: false
// Responsive width sensor for Plot
viewof hz_plotWidth = {
  const el = html`<div class="hz-width-sensor"></div>`
  el.value = 900
  const ro = new ResizeObserver(() => {
    const w = Math.floor(el.getBoundingClientRect().width || 900)
    if (w && w !== el.value) {
      el.value = w
      el.dispatchEvent(new Event("input", {bubbles:true}))
    }
  })
  ro.observe(el)
  return el
}
```

```{ojs}
//| output: false
// Create a DuckDB client
hz_db = DuckDBClient.of()
```

```{ojs}
//| output: false
hz_rows = {
  function rows(res) {
    if (!res) return []
    if (typeof res.toArray === "function") return rows(res.toArray())
    if (Array.isArray(res)) return res
    if (res.data && Array.isArray(res.data)) return res.data
    // Last resort: try iterable
    try { return Array.from(res) } catch (e) { return res }
  }
  return rows
}

// Convenience wrapper
hz_query = async (sql) => {
  try {
    return hz_rows(await hz_db.query(sql))
  } catch (e) {
    try { hz_addError("hz_query", e, { sql }) } catch (e2) {}
    if (typeof console !== "undefined") console.error("hz_query failed", e, sql)
    return []
  }
}
```

```{=html}
<style>
html, body { overflow-anchor: none; }
  .atlasFigCaption {
    position: relative;
    z-index: -1;
  }
  .hz-card,
  .hz-question,
  .hz-controlsPanel,
  .hz-qToolbar {
    background: transparent;
    border: 0;
    box-shadow: none;
    border-radius: 0;
    padding: 0;
    margin: 0 0 1.25rem 0;
  }

  .hz-card__title {
    font-weight: 600;
    font-size: 1.1rem;
    line-height: 1.3;
    margin: 0.25rem 0;
  }

  .hz-card__sub,
  .hz-muted,
  .hz-loading {
    color: var(--bs-secondary-color, #6c757d);
    font-size: 0.95rem;
  }

  .hz-chip {
    display: inline-block;
    padding: 0.1rem 0.5rem;
    margin: 0.125rem 0.25rem 0.125rem 0;
    border: 1px solid rgba(0, 0, 0, 0.15);
    border-radius: 999px;
    font-size: 0.9rem;
  }

  .hz-chartWrap,
  .hz-grid,
  .hz-mount {
    width: 100%;
  }

  .hz-grid {
    overflow-x: auto;
  }

  .hz-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    align-items: center;
  }

  /* Controls layout: responsive 2–3 columns to reduce scrolling */
  .hz-controlsCompact .hz-controlsRows{
    display:flex;
    flex-direction:column;
    gap:0.75rem;
  }
  .hz-controlsCompact .hz-row{
    display:grid;
    gap:0.75rem;
    align-items:end;
  }
  .hz-controlsCompact .hz-row--2{
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  .hz-controlsCompact .hz-row--3{
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
  /* Special row where the middle “Commodities” UI should be wider */
  .hz-controlsCompact .hz-row--3.hz-row--grow{
    grid-template-columns: minmax(190px, 1fr) minmax(280px, 2fr) minmax(190px, 1fr);
  }
  .hz-controlsCompact .hz-field{ min-width:0; }

  /* Special row where the right “Commodities” UI should be wider (2-col variant) */
  .hz-controlsCompact .hz-row--2.hz-row--grow{
    grid-template-columns: minmax(190px, 1fr) minmax(280px, 2fr);
  }


  details.hz-furl{
    border: 1px solid rgba(0,0,0,0.12);
    border-radius: 14px;
    padding: 0.35rem 0.75rem;
    margin: 0.75rem 0 1rem 0;
  }
  details.hz-furl > summary{
    cursor: pointer;
    display: flex;
    gap: 0.6rem;
    align-items: baseline;
    justify-content: space-between;
    font-weight: 700;
    list-style: none;
  }
  details.hz-furl > summary::-webkit-details-marker{
    display:none;
  }
  details.hz-furl > summary::before{
    content: "▸";
    font-size: 1.05rem;
    line-height: 1;
    margin-right: 0.25rem;
    flex: 0 0 auto;
    transform: translateY(1px);
  }
  details.hz-furl[open] > summary::before{
    content: "▾";
  }
    .hz-furl__hint{
    color: var(--bs-secondary-color, #6c757d);
    font-weight: 400;
    font-size: 0.92rem;
    text-align: right;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  details.hz-furl[open]{
    padding-bottom: 0.75rem;
  }
  .hz-furl__body{
    margin-top: 0.75rem;
  }

  @media (max-width: 992px){
    .hz-controlsCompact .hz-row--3{
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
    .hz-controlsCompact .hz-row--3.hz-row--grow{
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
  @media (max-width: 576px){
    .hz-controlsCompact .hz-row--2,
    .hz-controlsCompact .hz-row--3{
      grid-template-columns: 1fr;
    }
  }

  /* Q1 toolbar (Chart/Table + toggles) */
  .hz-qToolbar{
    display:flex;
    flex-wrap:wrap;
    gap:0.75rem;
    align-items:flex-end;
    justify-content:space-between;
    margin-bottom:0.75rem;
  }
  .hz-viewToggle{
    display:flex;
    gap:0.75rem;
    align-items:center;
    flex-wrap:wrap;
  }
  .hz-inlineToggles{
    display:flex;
    gap:0.75rem;
    align-items:flex-end;
    flex-wrap:wrap;
  }
  .hz-miniSetting{
    display:flex;
    gap:0.4rem;
    align-items:center;
  }
  .hz-miniSetting > span{
    color: var(--bs-secondary-color, #6c757d);
    font-size: 0.9rem;
    white-space:nowrap;
  }
  .hz-miniSetting--range input[type="range"]{
    min-width: 180px;
  }
  @media (max-width: 576px){
    .hz-miniSetting{
      width:100%;
      justify-content:space-between;
    }
  }


  /* Q1 Dynamic Insight */
  .hz-qInsight{
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(248, 250, 252, 0.7);
    border-radius: 14px;
    padding: 0.75rem 1rem;
    margin-bottom: 0.75rem;
  }
  .hz-qInsight .hz-loading{
    font-size: 0.95rem;
  }
  .hz-insightSubhead{
    font-weight: 650;
    margin: 0.25rem 0 0.35rem;
  }




.hidden { display: none !important; }

.hz-controlsCompact{
  font-family: var(--bs-body-font-family, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif);
  font-size: 14px;
}
.hz-controlsCompact .form-select,
.hz-controlsCompact .form-control,
.hz-controlsCompact .form-range,
.hz-controlsCompact .form-check-input,
.hz-controlsCompact select,
.hz-controlsCompact input,
.hz-controlsCompact textarea,
.hz-controlsCompact button{
  font-family: inherit !important;
  font-size: inherit !important;
}
/* Choices.js (enhancedMultiSelect) */
.hz-controlsCompact .choices,
.hz-controlsCompact .choices *{
  font-family: inherit !important;
  font-size: inherit !important;
}


.hz-chartWrap { position: relative; min-height: 340px; }
.hz-chartWrap--busy::before {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.62);
  backdrop-filter: blur(2px);
  border-radius: 14px;
  z-index: 10;
}
.hz-chartWrap--busy::after {
  content: "Updating chart…";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  padding: 10px 14px;
  border-radius: 999px;
  border: 1px solid rgba(0, 0, 0, 0.12);
  background: rgba(255, 255, 255, 0.9);
  box-shadow: 0 10px 26px rgba(0, 0, 0, 0.10);
  font-weight: 900;
  font-size: 0.9rem;
  z-index: 11;
  white-space: nowrap;
}

.hz-tableWrap { position: relative; min-height: 560px; padding: 6px; font-size: 12px; }
.hz-tableWrap--busy::before {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.62);
  backdrop-filter: blur(2px);
  border-radius: 14px;
  z-index: 10;
}
.hz-tableWrap--busy::after {
  content: "Updating table…";
  position: absolute;
  top: 14px;
  right: 14px;
  background: rgba(15, 23, 42, 0.85);
  color: #fff;
  font-size: 12px;
  font-weight: 800;
  padding: 6px 10px;
  border-radius: 999px;
  z-index: 11;
  white-space: nowrap;
}

@media (prefers-color-scheme: dark) {
  .hz-chartWrap--busy::before,
  .hz-tableWrap--busy::before {
    background: rgba(0, 0, 0, 0.35);
  }
  .hz-chartWrap--busy::after {
    background: rgba(17, 24, 39, 0.9);
    color: #fff;
    border: 1px solid rgba(255, 255, 255, 0.18);
    box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35);
  }
  .hz-tableWrap--busy::after {
    background: rgba(17, 24, 39, 0.9);
  }
}


  .hz-grid2{display:grid;gap:16px}
  .hz-grid2--equal{grid-template-columns:1fr}
  @media (min-width: 980px){ .hz-grid2--equal{grid-template-columns:1fr 1fr} }
  .hz-mini{min-width:0}
  .hz-mini figure{margin:0}

  /* Q1 UpSet layout (two plots side-by-side, like the Shiny prototype) */
  .hz-upsetGrid{display:grid;gap:18px;align-items:start;grid-template-columns:1fr}
  @media (min-width: 980px){ .hz-upsetGrid{grid-template-columns:1fr 1fr} }
  .hz-upsetGrid--single{grid-template-columns:1fr !important}
  .hz-upsetCol{min-width:0}
  .hz-upsetTitle{text-align:center;font-weight:600;font-size:0.9rem;margin:0 0 6px 0;opacity:0.95}
  .hz-upsetStack{display:flex;flex-direction:column;gap:0}
  .hz-upsetStack figure{margin:0}



  .hz-sectionIntro{margin:0 0 12px 0}
  .hz-sectionIntro p{margin:0}
</style>
```


# `{ojs} heading1` {#overview}

```{ojs}
md`${_lang(nbText.sections.intro.text)}`;
```

```{=html}
<div id="hz-advanced-controls"></div>
```

```{ojs}
//| output: false
{
  const mount = document.getElementById("hz-advanced-controls");
  if (mount) {
    mount.replaceChildren();
    mount.append(hz_globalAdvancedControlsPanel);
  }
  null
}
```

# `{ojs} q1Title` {#q1}

```{ojs}
md`${_lang(nbText.sections.q1.introText)}\n\n${_lang(nbText.sections.q1.detailText)}`;
```


```{=html}
<div id="hz-dashboard"></div>
```

```{ojs}
//| output: false

// Runtime diagnostics (browser)

hz_diagInit = {
  try {
    if (typeof window === "undefined") return null
    if (window.__hzDiag) return window.__hzDiag

    const state = { errors: [], seen: new Set() }

    const addError = (context, err, details=null) => {
      try {
        const msg = String(err?.message ?? err)
        const stack = err?.stack ? String(err.stack) : ""
        const id = `${context}::${msg}`

        if (!state.seen.has(id)) {
          state.seen.add(id)
          state.errors.push({
            time: new Date().toISOString(),
            context,
            message: msg,
            stack,
            details
          })

          window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
        }
      } catch (e) {
        state.errors.push({
          time: new Date().toISOString(),
          context: "hz:addError",
          message: String(e?.message ?? e),
          stack: e?.stack ? String(e.stack) : "",
          details: null
        })
        window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
      }
    }

    window.__hzDiag = { state, addError }

    // Hook global errors once
    if (!window.__hzRuntimeHooked) {
      window.__hzRuntimeHooked = true
      window.addEventListener("error", (ev) => {
        addError("window.error", ev?.error ?? ev?.message ?? ev, {
          filename: ev?.filename, lineno: ev?.lineno, colno: ev?.colno
        })
      })
      window.addEventListener("unhandledrejection", (ev) => {
        addError("window.unhandledrejection", ev?.reason ?? ev)
      })
    }

    // Initial broadcast
    window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
    return window.__hzDiag
  } catch (e) {
    if (typeof console !== "undefined") console.error("hz_diagInit failed", e)
    return null
  }
}

hz_addError = (context, err, details=null) => {
  try {
    if (typeof window !== "undefined" && window.__hzDiag?.addError) {
      window.__hzDiag.addError(context, err, details)
    } else if (typeof console !== "undefined") {
      console.error(`[${context}]`, err, details ?? "")
    }
  } catch (e) {
    if (typeof console !== "undefined") console.error("hz_addError failed", e)
  }
}

// Reactive stream of errors for display
hz_errors = Generators.observe((notify) => {
  // ensure diagnostics are initialized
  hz_diagInit
  if (typeof window === "undefined") {
    notify([])
    return () => {}
  }

  const handler = (ev) => notify(ev?.detail ?? [])
  window.addEventListener("hz:diag", handler)

  // seed with current state (if any)
  const existing = window.__hzDiag?.state?.errors ?? []
  notify(existing.slice())

  return () => window.removeEventListener("hz:diag", handler)
})

hz_renderErrors = (errors) => {
  const esc = (s) => String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")

  if (!errors || errors.length === 0) {
    return html`<div class="callout callout-note"><strong>No runtime errors captured.</strong></div>`
  }

  return html`<div class="callout callout-warning">
    <strong>Runtime diagnostics (${errors.length})</strong>
    <ol style="margin-top:0.5rem;">
      ${errors.map(e => html`<li style="margin-bottom:0.75rem;">
        <div><strong>${esc(e.context)}</strong> <span style="opacity:.75;">${esc(e.time)}</span></div>
        <div style="white-space:pre-wrap;">${esc(e.message)}</div>

        ${e.details ? html`<details style="margin-top:0.25rem;">
          <summary>details</summary>
          <pre style="white-space:pre-wrap; margin:0.5rem 0 0 0;">${esc(JSON.stringify(e.details, null, 2))}</pre>
        </details>` : null}

        ${e.stack ? html`<details style="margin-top:0.25rem;">
          <summary>stack</summary>
          <pre style="white-space:pre-wrap; margin:0.5rem 0 0 0;">${esc(e.stack)}</pre>
        </details>` : null}
      </li>`)}
    </ol>
  </div>`
}

// nbData.json loader + normalizer

hz_loadJson = async (path) => {
  try {
    const res = await fetch(path)
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`)
    return await res.json()
  } catch (e) {
    hz_addError(`loadJson(${path})`, e)
    throw e
  }
}

// Make nbData tolerant to different JSON shapes
// Expected final: Array of dataset objects [{key, local_path|s3_path, sql, ...}, ...]
hz_normalizeNbData = (raw) => {
  if (Array.isArray(raw)) return { ok:true, data: raw, note: "root is array" }

  if (raw && typeof raw === "object") {
    // Common wrapper fields
    const candidates = ["data", "datasets", "items", "resources", "catalog", "tables"]
    for (const k of candidates) {
      const v = raw[k]
      if (Array.isArray(v)) return { ok:true, data: v, note: `using raw.${k}` }
      if (v && typeof v === "object" && Array.isArray(v.data)) {
        return { ok:true, data: v.data, note: `using raw.${k}.data` }
      }
    }

    // Object-of-objects → values()
    const vals = Object.values(raw)
    if (vals.length && vals.every(v => v && typeof v === "object")) {
      const looksLike = vals.some(v =>
        ("key" in v) || ("sql" in v) || ("local_path" in v) || ("s3_path" in v)
      )
      if (looksLike) return { ok:true, data: vals, note: "using Object.values(raw)" }
    }

    return {
      ok: false,
      data: null,
      note: "root object not recognized",
      rawKeys: Object.keys(raw).slice(0, 50)
    }
  }

  return { ok:false, data:null, note: `unsupported JSON type: ${typeof raw}` }
}

// Load dataset index
hz_nbMeta = {
  try {
    const raw = await hz_loadJson("/data/hazardExposure/nbData.json")
    const norm = hz_normalizeNbData(raw)

    if (!norm.ok || !Array.isArray(norm.data)) {
      const err = new Error(`nbData.json did not parse to an array. ${norm.note || ""}`)
      hz_addError("nbData.json shape", err, { norm, rawType: typeof raw })
      return {
        ok: false,
        reason: err.message,
        data: [],
        rawType: typeof raw,
        rawKeys: norm.rawKeys ?? (raw && typeof raw === "object" ? Object.keys(raw).slice(0, 50) : [])
      }
    }

    return {
      ok: true,
      reason: norm.note,
      data: norm.data,
      rawType: typeof raw,
      rawKeys: raw && typeof raw === "object" ? Object.keys(raw).slice(0, 50) : []
    }
  } catch (e) {
    hz_addError("Load nbData.json", e)
    return {
      ok: false,
      reason: "Failed to load nbData.json: " + String(e?.message ?? e),
      data: [],
      rawType: null,
      rawKeys: []
    }
  }
}
```

```{ojs}
//| output: false
hz_nbMeta.ok
  ? html`<div class="callout callout-note">
      <strong>nbData.json:</strong> Loaded ${hz_nbMeta.data.length} entries <span style="opacity:.75;">(${hz_nbMeta.reason})</span>
    </div>`
  : html`<div class="callout callout-important">
      <strong>nbData.json:</strong> ${hz_nbMeta.reason}
      <div style="margin-top:.25rem; white-space:pre-wrap; opacity:.85;">
        Raw keys: ${JSON.stringify(hz_nbMeta.rawKeys)}
      </div>
    </div>`
```

```{ojs}
//| output: false
// Build a lookup map for fast key -> entry access
hz_nbIndex = {
  const m = new Map()
  for (const d of hz_nbMeta.data ?? []) m.set(d.key, d)
  return m
}
```

```{ojs}
//| output: false
// Parse available hazard exposure datasets from keys like: hazardExposure_usd15_annual_historic_moderate
hz_hazEntries = {
  const out = []
  const methodSuffixes = new Set(["generic", "crop_specific"])
  for (const d of hz_nbMeta.data ?? []) {
    if (!d.key?.startsWith("hazardExposure_")) continue
    const parts = d.key.split("_").filter(Boolean)
    if (parts.length < 5) continue

    const maybeMethod = parts[parts.length - 1]
    const hasMethod = methodSuffixes.has(maybeMethod)

    const severity = hasMethod ? parts[parts.length - 2] : parts[parts.length - 1]
    const method = hasMethod ? maybeMethod : null
    const modelParts = parts.slice(3, hasMethod ? (parts.length - 2) : (parts.length - 1))
    const model = modelParts.join("_")

    if (!model || !severity) continue

    out.push({
      key: d.key,
      varShort: parts[1],     // usd15 / intld15 etc.
      period: parts[2],       // annual / jagermeyr etc.
      model,                 // historical / ensemble / ssp245_2041-2060 etc.
      severity,              // moderate / severe / extreme etc.
      method,                // generic / crop_specific (optional)
      entry: d
    })
  }
  return out
}
```

```{ojs}
//| output: false
// Options derived from nbData.json (hazard exposure datasets)

hz_parseHazKey = (key) => {
  try {
    const s = String(key ?? "")
    if (!s.startsWith("hazardExposure_")) return null

    const parts = s.split("_")
    if (parts.length < 5) return null

    const varShort = parts[1]
    const period = parts[2]

    const knownMethods = new Set(["generic","crop_specific"])
    let method = null
    let severity = null
    let model = null

    if (knownMethods.has(parts[parts.length - 1])) {
      method = parts[parts.length - 1]
      severity = parts[parts.length - 2]
      model = parts.slice(3, parts.length - 2).join("_")
    } else {
      severity = parts[parts.length - 1]
      model = parts.slice(3, parts.length - 1).join("_")
    }

    return { key: s, varShort, period, model, severity, method }
  } catch (e) {
    hz_addError("hz_parseHazKey", e, { key })
    return null
  }
}

hz_parsed = {
  const parsed = hz_hazEntries
    .map(d => hz_parseHazKey(d.key))
    .filter(Boolean)

  if (hz_nbMeta.ok && hz_hazEntries.length > 0 && parsed.length === 0) {
    hz_addError(
      "Key parsing",
      new Error("No keys matched expected pattern hazardExposure_{varShort}_{period}_{model}_{severity}"),
      { exampleKeys: hz_hazEntries.slice(0, 10).map(d => d.key) }
    )
  }

  return parsed
}

hz_varShorts = Array.from(new Set(hz_parsed.map(d => d.varShort))).sort()
hz_periods   = Array.from(new Set(hz_parsed.map(d => d.period))).sort()
hz_models    = Array.from(new Set(hz_parsed.map(d => d.model))).sort()
hz_severities= Array.from(new Set(hz_parsed.map(d => d.severity))).sort()

hz_formatVarShort = (v) => {
  const s = String(v ?? "")
  if (s === "vop") return "Value of production (vop)"
  if (s === "prod") return "Production (prod)"
  if (s === "area") return "Area (area)"
  return s
}

hz_varLabel = (() => {
  const s = String(hz_varShort ?? "")
  if (s === "intld15") return "International Dollars (2015)"
  if (s === "usd15") return "USD (2015)"
  if (s === "people") return "People"
  return hz_formatVarShort(s)
})()

// Absolute axis label used by charts (when not in Relative % mode)
hz_varLabelAbs = (() => {
  const base = String(hz_varLabel ?? '').trim()
  if (!base) return 'Exposure'
  // If hz_varLabel already reads like a full label, keep it.
  if (/exposure/i.test(base)) return base
  return `Exposure (${base})`
})()

hz_formatPeriod = (p) => {
  const s = String(p ?? "")
  if (s === "annual") return "Annual"
  if (s.toLowerCase().includes("jaeger") || s.toLowerCase().includes("jager")) return "Jägermeyr"
  return s
}

hz_formatSeverity = (sev) => {
  const s = String(sev ?? "")
  if (s === "all") return "All"
  return s.toUpperCase()
}

hz_formatModel = (m) => {
  const s = String(m ?? "")
  if (/hist|historic/i.test(s)) return "Historical"
  // ssp245_2050 -> SSP245 (2050)
  const mm = /^ssp(\d{3})_(\d{4})$/.exec(s)
  if (mm) return `SSP${mm[1]} (${mm[2]})`
  return s
}

hz_varShortOptions  = hz_varShorts.map(v => ({ label: hz_formatVarShort(v), value: v }))
hz_periodOptions    = hz_periods.map(p => ({ label: hz_formatPeriod(p), value: p }))
hz_severityOptions  = hz_severities.map(s => ({ label: hz_formatSeverity(s), value: s }))
hz_scenOptions      = hz_models.map(m => ({ label: hz_formatModel(m), value: m }))

hz_defaultVarShort = hz_varShorts.find(v => /usd15/i.test(String(v))) ?? hz_varShorts.find(v => /intld15/i.test(String(v))) ?? hz_varShorts[0] ?? null
hz_defaultPeriod    = hz_periods.includes("annual") ? "annual" : (hz_periods[0] ?? null)
hz_defaultSeverity = hz_severities.find(s => String(s).toLowerCase() === "severe") ?? hz_severities.find(s => String(s).toLowerCase() === "extreme") ?? hz_severities[0] ?? null

hz_defaultModel1 = hz_models.find(m => /historic/i.test(String(m))) ?? hz_models[0] ?? null
hz_defaultModel2 = hz_models.find(m => /ensemble/i.test(String(m))) ?? hz_models.find(m => String(m) !== String(hz_defaultModel1)) ?? hz_defaultModel1

({
  varShorts: hz_varShorts,
  periods: hz_periods,
  models: hz_models,
  severities: hz_severities
})
```

```{ojs}
//| output: false
// Label used in compact summaries / headers
hz_periodLabel = (typeof hz_formatPeriod === 'function') ? hz_formatPeriod(hz_period) : String(hz_period ?? '')
```

```{ojs}
//| output: false
// View controls
viewof hz_varShort = Inputs.select(hz_varShorts, {
  label: "Exposure value:",
  format: hz_formatVarShort,
  value: hz_defaultVarShort
})
```

```{ojs}
//| output: false
hz_denomSpec = (() => {
  const v = String(hz_varShort ?? "").trim()
  if (!v) return { exposure: null, unit: null }

  // Core trio used in current UI
  if (v === "prod") return { exposure: "prod", unit: "t" }
  if (v === "area") return { exposure: "harv-area", unit: "ha" }
  if (v === "vop")  return { exposure: "vop", unit: "intld15" } // Shiny uses intld15 by default

  
  if (v === "intld15") return { exposure: "vop", unit: "intld15" }
  if (v === "usd15" || v === "usd") return { exposure: "vop", unit: "usd" }
  if (v === "people") return { exposure: "number", unit: "number" }

  // Fallback: treat v as exposure code
  return { exposure: v, unit: null }
})()
```


```{ojs}
//| output: false
viewof hz_period = Inputs.select(hz_periods, {
  label: "Period:",
  format: hz_formatPeriod,
  value: hz_defaultPeriod
})
```

```{ojs}
//| output: false
viewof hz_severity = Inputs.select(hz_severities, {
  label: "Severity:",
  format: hz_formatSeverity,
  value: hz_defaultSeverity
})
```

```{ojs}
//| output: false
hz_severityLabel = (typeof hz_formatSeverity === "function")
  ? hz_formatSeverity(hz_severity)
  : String(hz_severity ?? "")
```

```{ojs}
//| output: false
// Scenario/timeframe label formatter + parser 
hz_formatScenXTime = (scenTime) => {
  const s = String(scenTime ?? "").trim()
  if (!s) return ""
  if (s === "historic" || s === "Historical") return "Historical"
  const m = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(s)
  if (m) return `${m[1].toUpperCase()} ${m[2]}`
  return s
}

hz_parseScenXTime = (scenTime) => {
  const s = String(scenTime ?? "").trim()
  if (!s || s === "historic" || s === "Historical") {
    return { scenTime: "historic", scenario: "historic", timeframe: "historic", model: "historic" }
  }
  const m = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(s)
  if (m) return { scenTime: s, scenario: m[1], timeframe: m[2], model: "ENSEMBLE" }
  return { scenTime: s, scenario: s, timeframe: null, model: s }
}
```

```{ojs}
//| output: false
viewof hz_scen1 = Inputs.select(hz_scenXTime, {
  label: "Scenario A:",
  format: hz_formatScenXTime,
  value: "historic"
})
```

```{ojs}
//| output: false
viewof hz_scen2 = Inputs.select(hz_scenXTime, {
  label: "Scenario B:",
  format: hz_formatScenXTime,
  value: "ssp585_2041-2060"
})

hz_scenXTime = [
  "historic",
  "ssp126_2021-2040","ssp126_2041-2060","ssp126_2061-2080",
  "ssp245_2021-2040","ssp245_2041-2060","ssp245_2061-2080",
  "ssp370_2021-2040","ssp370_2041-2060","ssp370_2061-2080",
  "ssp585_2021-2040","ssp585_2041-2060","ssp585_2061-2080"
]
// Default  values:
// scenario1 = historic; scenario2 = ssp585_2041-2060
```

```{ojs}
//| output: false
// Chart toggles
viewof hz_relative = Inputs.toggle({ label: "", value: false })
```

```{ojs}
//| output: false
viewof hz_difference = Inputs.toggle({ label: "", value: false })
```

```{ojs}
//| output: false
// Hazard dataset method (suffix) selector
hz_methodOptions = ["auto", "generic", "crop_specific"]
hz_methodLabel = (v) => ({
  auto: "Auto (best available)",
  generic: "Generic (all commodities aggregated)",
  crop_specific: "Crop-specific (SPAM crops + GLW livestock)"
}[v] ?? v)

viewof hz_method = Inputs.select(hz_methodOptions, {
  label: "Hazard method:",
  value: "generic",
  format: hz_methodLabel
})
```

```{ojs}
 //| output: false
 hz_spamCropsMapUrl = "/data/shared/MapSpamCrops.json"
 hz_spamCropsMap = await (await fetch(hz_spamCropsMapUrl)).json()


 hz_spamCodes = {
   const j = hz_spamCropsMap ?? {}

   const collectIds = (key) => (j?.[key]?.items ?? [])
     .map(d => String(d?.id ?? "").trim())
     .filter(Boolean)

   // "crops" = all non-livestock categories in this JSON
   const cropCats = ["cereals", "legumes", "rootsTuber", "fruitVeg", "nonEdible"]
   const crops = cropCats.flatMap(collectIds)

   // Groups used by the UI ("roots_tubers" naming kept for compatibility)
   const groups = {
     cereals: collectIds("cereals"),
     legumes: collectIds("legumes"),
     roots_tubers: collectIds("rootsTuber")
   }

   // Labels lookup: id -> localized label (falls back to en / fr / id)
   const labels = {}
   for (const v of Object.values(j)) {
     for (const it of (v?.items ?? [])) {
       const id = String(it?.id ?? "").trim()
       if (!id) continue
       const lab = it?.label ?? {}
       const label = (typeof _lang === "function")
         ? _lang(lab)
         : (lab?.en ?? lab?.fr ?? id)
       labels[id] = label
     }
   }

   return {
     crops: [...new Set(crops)],
     groups,
     labels
   }
 }

 // Livestock list (from same JSON)
 hz_livestock = (hz_spamCropsMap?.livestock?.items ?? [])
   .map(d => String(d?.id ?? "").trim())
   .filter(Boolean)
```

```{ojs}
//| output: false
// Union of crops + livestock
hz_allCommodities = {
  const crops = hz_spamCodes?.crops ?? []
  const livestock = hz_livestock ?? []
  const set = new Set([...crops, ...livestock].filter(Boolean))
  return Array.from(set).sort((a,b) => String(a).localeCompare(String(b)))
}
```

```{ojs}
//| output: false
// Commodity selectors
hz_commodityGroupOptions = ["all", "crops", "livestock", "cereals", "legumes", "roots_tubers", "custom"]
hz_commodityGroupLabel = (v) => ({
  all: "All (crops + livestock)",
  crops: "Crops (SPAM2020)",
  livestock: "Livestock (GLW4)",
  cereals: "Cereals",
  legumes: "Legumes",
  roots_tubers: "Roots & tubers",
  custom: "Custom (pick manually)"
}[v] ?? v)

viewof hz_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], {
  label: "Group",
  value: "crops",
  format: hz_commodityGroupLabel
})
```

```{ojs}
//| output: false
hz_selectedCommodGroup = hz_commodityGroup
```

```{ojs}
//| output: false
hz_commodityOptions = {
  const g = hz_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  // default list for "all" and "custom"
  return [...(hz_spamCodes?.crops ?? []), ...(hz_livestock ?? [])].filter(Boolean).sort()
}

hz_commodityLabelOf = (v) => {
  const id = String(v ?? "").trim()
  const label = hz_spamCodes?.labels?.[id]
  return label ?? hz_titleCase(id.replaceAll("-", " "))
}

// multi-select (enhanced): filter + chips + checklist (shared component)
viewof hz_commodities = {
  const disabled = (hz_commodityGroup === "all")

  // Normalize option values to strings to avoid showing [object Object]
  const norm = (v) => {
    if (v == null) return null
    if (typeof v === "string" || typeof v === "number") return String(v)
    if (typeof v === "object") {
      return String(v.code ?? v.value ?? v.id ?? v.name ?? v.label ?? v.crop ?? v.commodity ?? "")
    }
    return null
  }

  const options = (hz_commodityOptions ?? [])
    .map(norm)
    .map(s => String(s ?? "").trim())
    .filter(Boolean)

  const label = (typeof _lang === "function")
    ? _lang({ en: "Commodities", fr: "Produits" })
    : "Commodities"

 
  const initial = disabled ? [] : []

  const viewofSelect = Inputs.select(options, {
    label,
    multiple: true,
    value: initial,
    disabled,
    format: hz_commodityLabelOf
  })

  // enhancedMultiSelect expects the *view element* as the first argument.
  const enhanced = enhancedMultiSelect(viewofSelect, {
placeholder: "Search commodities…",
    requireAtLeastOne: false,
    maxHeight: 200,
    width: "100%"
  })

  // Ensure truly empty-by-default (no implicit first selection)
  try {
    const sel = enhanced.querySelector("select") || enhanced
    Array.from(sel.options).forEach((o) => (o.selected = false))
    sel.selectedIndex = -1
    sel.dispatchEvent(new Event("input", { bubbles: true }))
  } catch (_) {}

  return enhanced
}
```

```{ojs}
//| output: false
// Final set of commodities used in SQL filter (array of crop strings)
hz_selectedCommodities = {
  const g = hz_commodityGroup

  const opts = (hz_commodityOptions ?? [])
    .map((v) => String(v).trim())
    .filter(Boolean)
  const optSet = new Set(opts)

  const pickedRaw = (hz_commodities ?? [])
    .filter(Boolean)
    .map((v) => String(v).trim())
    .filter(Boolean)

  // Prevent stale picks when changing groups (only keep picks in current options)
  const picked = pickedRaw.filter((v) => optSet.has(v))

  // User override
  if (picked.length) return picked

  // Group defaults
  if (g === "livestock") return (hz_livestock ?? []).slice()
  if (g === "crops") return (hz_spamCodes?.crops ?? []).slice()
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? []).slice()
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? []).slice()
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? []).slice()

  // "all" with no picks => include everything
  if (g === "all") return hz_allCommodities ?? []

  // "custom" with no picks => no filter (empty selection)
  if (g === "custom") return []

  // fallback
  return hz_allCommodities ?? []
}
```

```{ojs}
//| output: false
// Commodities value sent to the API.
// For custom + empty, interpret as "no commodity filter".
// We encode that as ["all"] to match the backend's "no filter" semantics.
hz_selectedCommoditiesForReq = {
  const g = hz_commodityGroup
  const picked = (hz_selectedCommodities ?? []).filter(Boolean)
  if (g === "custom" && picked.length === 0) return ["all"]
  return picked
}
```

```{ojs}
//| output: false
hz_commoditiesUI = viewof hz_commodities
```

```{ojs}
//| output: false
// Compact preview for long lists (used in controls summaries)
hz_previewList = (arr, max = 4) => {
  const xs = Array.isArray(arr) ? arr.filter(Boolean) : []
  if (xs.length <= max) return xs.join(", ")
  return xs.slice(0, max).join(", ") + ` +${xs.length - max}`
}
```

```{ojs}
//| output: false
// Display controls
// Compare mode affects Q2/Q4 when comparing Left vs Right.
viewof hz_compareMode = {
  const options = [
    { value: 'side', label: 'Side-by-side' },
    { value: 'diff', label: 'Δ Right − Left' }
  ]
  const root = document.createElement('div')
  root.className = 'hz-tabs hz-tabs--small'
  const buttons = new Map()

  const set = (v) => {
    root.value = v
    for (const [val, btn] of buttons.entries()) btn.classList.toggle('is-active', val === v)
    root.dispatchEvent(new Event('input', { bubbles: true }))
  }

  for (const opt of options) {
    const b = document.createElement('button')
    b.type = 'button'
    b.className = 'hz-tab'
    b.textContent = opt.label
    b.onclick = () => set(opt.value)
    root.appendChild(b)
    buttons.set(opt.value, b)
  }

  set('side')
  return root
}

viewof hz_topN = Inputs.range([5, 50], { label: "Top items (Top N):", step: 1, value: 25 })
viewof hz_groupOther = Inputs.toggle({ label: 'Group remaining hazards into "Other" (Q1)', value: false })
viewof hz_rel = Inputs.toggle({ label: "Relative (%)", value: false })
hz_isRelative = !!hz_rel
viewof hz_q1ChartHeight = Inputs.range([360, 900], { label: "", step: 10, value: 520 })
hz_chartHeight = hz_q1ChartHeight
```

```{ojs}
//| output: false
// Strip ISO suffixes like "Cabinda (AGO)" -> "Cabinda"
hz_stripIso = (v) => String(v ?? "").replace(/\s*\([A-Z]{2,3}\)\s*$/, "")

// Cleaned geo filter for API payloads and UI labels
hz_geoFilterApi = {
  const g = hz_geoFilter ?? {}
  return {
    ...g,
    admin0: (g.admin0 ?? []).map(hz_stripIso),
    admin1: (g.admin1 ?? []).map(hz_stripIso),
    admin2: (g.admin2 ?? []).map(hz_stripIso),
    admin0_name: (g.admin0_name ?? []).map(hz_stripIso),
    admin1_name: (g.admin1_name ?? []).map(hz_stripIso),
    admin2_name: (g.admin2_name ?? []).map(hz_stripIso)
  }
}

// Friendly labels for the UI
hz_geoLabel = {
  const gf = hz_geoFilterApi ?? {}
  const a0 = Array.isArray(gf.admin0) ? gf.admin0.filter(Boolean) : []
  const a1 = Array.isArray(gf.admin1) ? gf.admin1.filter(Boolean) : []
  const a2 = Array.isArray(gf.admin2) ? gf.admin2.filter(Boolean) : []

  const hasAll = a0.length === 0 || a0.includes("all")
  const fmt = (arr, max = 2) => {
    const xs = arr.slice(0, max)
    const more = arr.length > max ? ` +${arr.length - max}` : ""
    return xs.join(", ") + more
  }

  if (hasAll) return "admin0: all"
  if (a2.length) return `admin2: ${fmt(a2)} (${a2.length})`
  if (a1.length) return `admin1: ${fmt(a1)} (${a1.length})`
  return `admin0: ${fmt(a0)} (${a0.length})`
}

hz_commodityLabel = {
  const g = hz_commodityGroup
  const pickedUI = (hz_commodities ?? []).filter(Boolean)
  const n = (hz_selectedCommodities ?? []).length

  // Custom + empty => no commodity filter
  if (g === "custom" && pickedUI.length === 0) return "Commodities: custom (no filter)"

  if (g === "all") return `Commodities: all (${n})`
  if (g === "crops") return `Commodities: crops (${n})`
  if (g === "livestock") return `Commodities: livestock (${n})`
  if (g === "custom") return `Commodities: custom (${n})`

  const label = hz_commodityGroupOptions?.[g] ?? String(g)
  return `Commodities: ${label} (${n})`
}
```

```{ojs}
//| output: false
hz_parseScenario = (s) => {
  const raw = String(s ?? "")
  if (!raw) return { raw: "", model: "", scenario: null, timeframe: null, label: "" }

  const parts = raw.split("_").filter(Boolean)
  const scenario = parts[0] ?? null
  const timeframe = parts.length > 1 ? parts.slice(1).join("_") : null

  // In this notebook, the dataset key uses the FULL model token as stored in nbData keys
  // (e.g., historical, ensemble, ssp245_2041-2060). We keep that as `model`.
  return { raw, model: raw, scenario, timeframe, label: hz_formatModel(raw) }
}
hz_parseScenarioPick = (x) => {
  const p = hz_parseScenXTime(x)
  const isHist = (p?.scenTime === "historic") || (p?.scenario === "historic")
  const model = isHist ? "historic" : "ENSEMBLE"
  const label = isHist ? "historic" : `${String(p.scenario ?? "").toUpperCase()} ${p.timeframe ?? ""}`.trim()
  return { ...p, model, label }
}
hz_s1 = (() => hz_parseScenarioPick(hz_scen1))()
hz_s2 = (() => hz_parseScenarioPick(hz_scen2))()

```

```{ojs}
//| output: false
// Resolve a dataset key from selected controls (note: model determined by scenario pick)
hz_keyBaseFor = ({ varShort, period, model, severity }) => {
  // Base key: hazardExposure_{varShort}_{period}_{model}_{severity}
  return `hazardExposure_${varShort}_${period}_${model}_${severity}`
}

hz_keyCandidatesFor = ({ varShort, period, model, severity, method }) => {
  const base = hz_keyBaseFor({ varShort, period, model, severity })

  // Method is modeled as an optional suffix on the key:
  // ..._{severity}_{generic|crop_specific}
  if (!method || method === "auto") {
    // Try base first, then known method suffixes
    return [base, `${base}_generic`, `${base}_crop_specific`]
  }

  return [`${base}_${method}`, base]
}

hz_computeShinyInteractionUrl = ({ varShort, period, model, severity } = {}) => {
  const u = String(varShort ?? "")
  const variable = (/usd15|intld15/i.test(u)) ? `vop_${u}` : u
  const per = String(period ?? "annual")
  const mod =
    /hist/i.test(String(model ?? "")) ? "historic" :
    /ens/i.test(String(model ?? "")) ? "ENSEMBLE" :
    String(model ?? "")
  const sev = String(severity ?? "severe").toLowerCase()
  if (!variable || !per || !mod || !sev) return null
  return `https://digital-atlas.s3.amazonaws.com/hazard_exposure/v0.4.2/exported_data/${variable}/${per}/model=${mod}/severity=${sev}/interaction.parquet`
}

hz_resolveFromCandidates = (candidates) => {
  const cands = Array.isArray(candidates) ? candidates : [String(candidates ?? "")]
  for (const k of cands) {
    if (hz_nbIndex?.has(k)) {
      const entry = hz_nbIndex.get(k)
      const r = hz_resolvePath(entry)
      return { ...r, resolvedKey: k, candidates: cands }
    }
  }

  const first = cands[0]
  const parts = hz_parseKeyParts(first)
  const computedUrl = hz_computeShinyInteractionUrl(parts)

  const entry = hz_nbIndex?.get(first) ?? null
  const r = hz_resolvePath(entry)

  const out = { ...r }
  if (!out.url && computedUrl) out.url = computedUrl
  if (!out.path && computedUrl) out.path = computedUrl
  if (computedUrl && (!out.pathSource || out.pathSource === "none")) out.pathSource = "computed"

  return { ...out, resolvedKey: first, candidates: cands }
}

 // Base keys (no suffix)
hz_key1 = hz_keyBaseFor({ varShort: hz_varShort, period: hz_period, model: hz_s1.model, severity: hz_severity })
hz_key2 = hz_keyBaseFor({ varShort: hz_varShort, period: hz_period, model: hz_s2.model, severity: hz_severity })

// Candidates that incorporate the selected method preference
hz_keyCandidates1 = hz_keyCandidatesFor({ varShort: hz_varShort, period: hz_period, model: hz_s1.model, severity: hz_severity, method: hz_method })
hz_keyCandidates2 = hz_keyCandidatesFor({ varShort: hz_varShort, period: hz_period, model: hz_s2.model, severity: hz_severity, method: hz_method })

// Resolve path/url using nbData.json
hz_src1 = hz_resolveFromCandidates(hz_keyCandidates1)
hz_src2 = hz_resolveFromCandidates(hz_keyCandidates2)

// Handy aliases for display
hz_key1Resolved = hz_src1.resolvedKey
hz_key2Resolved = hz_src2.resolvedKey

// Total exposure denominator parquet (used for Relative % and 'no hazard' derivations)
hz_denomUrl = "https://digital-atlas.s3.amazonaws.com/domain=exposure/type=combined/source=glw4-2020_spam2020AA/region=ssa/processing=atlas-harmonized/variable=crop-livestock_all.parquet"
```

```{ojs}
//| output: false
// (debug) suppressed
null
```

```{ojs}
//| output: false
// ------------------------------------------------------------
// Global advanced controls (shared by all questions)
// - Furled (collapsed by default)
// ------------------------------------------------------------
hz_advancedSummary = {
  const v = hz_formatVarShort(hz_varShort)
  const p = hz_formatPeriod(hz_period)
  const s = hz_formatSeverity(hz_severity)
  const m = hz_methodLabel?.(hz_method) ?? String(hz_method ?? "")
  return `${v} · ${p} · ${s} · ${m}`
}

hz_globalAdvancedControlsPanel = html`
  <details class="hz-furl hz-furl--advanced">
    <summary>
      <span>Advanced filters</span>
      <span class="hz-furl__hint">${hz_sharedControlsSummary} · ${hz_advancedSummary}</span>
    </summary>
    <div class="hz-furl__body">
      <div class="hz-controlsCompact hz-controlsPanel">
        <div class="hz-controlsRows">
          <!-- Question filters (shared) -->
          <div class="hz-row hz-row--2 hz-row--grow">
            <div class="hz-field">${viewof hz_commodityGroup}</div>
            <div class="hz-field">${hz_commoditiesUI}</div>
          </div>
          <div class="hz-row hz-row--3">
            <div class="hz-field">${viewof hz_admin0}</div>
            <div class="hz-field">${viewof hz_admin1}</div>
            <div class="hz-field">${viewof hz_admin2}</div>
          </div>
          <div class="hz-row hz-row--2">
            <div class="hz-field">${viewof hz_scen1}</div>
            <div class="hz-field">${viewof hz_scen2}</div>
          </div>

          <hr style="margin: 0.85rem 0; opacity: .2;" />

          <!-- Dataset controls -->
          <div class="hz-row hz-row--2">
            <div class="hz-field">${viewof hz_varShort}</div>
            <div class="hz-field">${viewof hz_period}</div>
          </div>
          <div class="hz-row hz-row--2">
            <div class="hz-field">${viewof hz_severity}</div>
            <div class="hz-field">${viewof hz_method}</div>
          </div>
        </div>
      </div>
    </div>
  </details>
`


// ------------------------------------------------------------
// Shared question controls (sync across questions)
// - Group, Commodities, Geo, Scenario A/B
// - Furled (collapsed by default)
// ------------------------------------------------------------
hz_sharedControlsSummary = {
  const left = hz_parseScenarioPick(hz_scen1)?.label ?? String(hz_scen1 ?? "")
  const right = hz_parseScenarioPick(hz_scen2)?.label ?? String(hz_scen2 ?? "")
  const geo = hz_geoLabel ?? ""
  const com = hz_commodityLabel ?? ""
  return `${left} vs ${right} · ${geo} · ${com}`
}

hz_q1_filtersPanel = html`
  <details class="hz-furl hz-furl--filters">
    <summary>
      <span>Filters</span>
      <span class="hz-furl__hint">${hz_sharedControlsSummary}</span>
    </summary>
    <div class="hz-furl__body">
      <div class="hz-controlsCompact hz-controlsPanel">
        <div class="hz-controlsRows">
          <div class="hz-row hz-row--2 hz-row--grow">
            <div class="hz-field">${viewof hz_commodityGroup}</div>
            <div class="hz-field">${hz_commoditiesUI}</div>
          </div>
          <div class="hz-row hz-row--3">
            <div class="hz-field">${viewof hz_admin0}</div>
            <div class="hz-field">${viewof hz_admin1}</div>
            <div class="hz-field">${viewof hz_admin2}</div>
          </div>
          <div class="hz-row hz-row--2">
            <div class="hz-field">${viewof hz_scen1}</div>
            <div class="hz-field">${viewof hz_scen2}</div>
          </div>
        </div>
      </div>
    </div>
  </details>
`

// Helper panel for other questions until their filter UI is duplicated.
// Keeps filters shared by linking back to Q1.
hz_sharedFiltersLinkPanel = (targetId = "q1") => {
  const btn = html`<button type="button" class="hz-btn hz-btn--sm">Open filters</button>`
  btn.onclick = () => {
    try {
      const details = document.querySelector(`#${targetId}-filters details.hz-furl--filters`)
        || document.querySelector(`#${targetId} details.hz-furl--filters`)
      if (details) details.open = true
      const anchor = document.getElementById(`${targetId}-filters`) || details || document.getElementById(targetId)
      anchor?.scrollIntoView?.({ behavior: "smooth", block: "start" })
    } catch (_) {}
  }

  return html`
    <details class="hz-furl hz-furl--filters">
      <summary>
        <span>Filters</span>
        <span class="hz-furl__hint">${hz_sharedControlsSummary}</span>
      </summary>
      <div class="hz-furl__body">
        <div class="hz-muted">These filters are shared across questions.</div>
        <div style="margin-top:0.5rem">${btn}</div>
      </div>
    </details>
  `
}
```

```{ojs}
//| output: false
// Admin name tuples (admin0/admin1/admin2) for cascading selectors.
// Uses the shared local component: components/_atlasBoundaries.ojs
// (No remote parquet needed.)
hz_adminNames = {
  try {
    const { admin2 } = await getAdminBoundaries([2])
    const feats = admin2?.features ?? []

    const pick = (p, keys) => {
      for (const k of keys) {
        const v = p?.[k]
        if (v != null && String(v).trim() !== "") return v
      }
      return null
    }

    const rows = feats.map((f) => {
      const p = f?.properties ?? {}
      
      const admin0_name = pick(p, ["admin0_name","ADM0_NAME","NAME_0","adm0_name","country","COUNTRY","admin0","name0"])
      const admin1_name = pick(p, ["admin1_name","ADM1_NAME","NAME_1","adm1_name","admin1","name1"])
      const admin2_name = pick(p, ["admin2_name","ADM2_NAME","NAME_2","adm2_name","admin2","name2"])
      return { admin0_name, admin1_name, admin2_name }
    }).filter((d) => d.admin0_name != null)

    
    const seen = new Set()
    const out = []
    for (const d of rows) {
      const k = `${d.admin0_name ?? ""}||${d.admin1_name ?? ""}||${d.admin2_name ?? ""}`
      if (!seen.has(k)) { seen.add(k); out.push(d) }
    }

    return out
  } catch (e) {
    return [{ error: `Failed to load admin names from components/_atlasBoundaries.ojs: ${e}` }]
  }
}

```

```{ojs}
//| output: false
// Build choice lists
hz_admin0Choices = {
  const isErr = hz_adminNames?.[0]?.error
  if (isErr) return ["all"]
  const vals = Array.from(new Set(hz_adminNames.map(d => d.admin0_name).filter(Boolean))).sort()
  return vals.includes("all") ? vals : ["all", ...vals]
}
```

```{ojs}
//| output: false
// multi-select (chips + search + checklist).
hz_makeMultiSelect = ({
  label = "Select",
  options = [],
  value = [],
  placeholder = "Search…",
  disabled = false,
  actions = [{ id: "none", label: "Clear" }],
  exclusive = null,         // e.g., "all" (cannot coexist with others)
  maxHeight = 240,
  maxRender = 600
} = {}) => {
  const form = html`<form class="hz-ms" style="opacity:${disabled ? 0.65 : 1}; pointer-events:${disabled ? "none" : "auto"}">
    <label class="hz-ms__label">${label}</label>
    <div class="hz-ms__top">
      <input class="hz-ms__search" type="search" placeholder="${placeholder}" />
      <div class="hz-ms__btns"></div>
    </div>
    <div class="hz-ms__chips" aria-label="Selected"></div>
    <div class="hz-ms__list" style="max-height:${maxHeight}px;"></div>
    <div class="hz-ms__meta"></div>
  </form>`

  const search = form.querySelector(".hz-ms__search")
  const chips = form.querySelector(".hz-ms__chips")
  const list  = form.querySelector(".hz-ms__list")
  const btns  = form.querySelector(".hz-ms__btns")
  const meta  = form.querySelector(".hz-ms__meta")

  const norm = (arr) => Array.from(new Set((arr ?? []).filter((d) => d != null && String(d).trim() !== "")))

  const setExclusiveRules = (selSet) => {
    if (!exclusive) return selSet
    if (selSet.size === 0) { selSet.add(exclusive); return selSet }
    if (selSet.has(exclusive) && selSet.size > 1) selSet.delete(exclusive)
    return selSet
  }

  const selected = new Set(norm(value))
  setExclusiveRules(selected)

  form.value = Array.from(selected)

  const emit = () => {
    // Apply exclusive rules + keep stable order based on options list
    setExclusiveRules(selected)
    const optIndex = new Map(options.map((d, i) => [String(d), i]))
    const ordered = Array.from(selected).sort((a, b) => (optIndex.get(String(a)) ?? 1e9) - (optIndex.get(String(b)) ?? 1e9))
    form.value = ordered
    form.dispatchEvent(new Event("input", { bubbles: true }))
    renderChips()
    renderList()
  }

  const renderChips = () => {
    chips.replaceChildren()
    const vals = Array.from(selected)
    if (!vals.length) return
    for (const v of vals) {
      const chip = html`<span class="hz-chip" title="${v}">
        <span>${v}</span>
        <button type="button" aria-label="Remove">×</button>
      </span>`
      chip.querySelector("button").onclick = () => { selected.delete(v); emit() }
      chips.appendChild(chip)
    }
  }

  const filteredOptions = () => {
    const q = (search.value ?? "").trim().toLowerCase()
    if (!q) return options
    return options.filter((d) => String(d).toLowerCase().includes(q))
  }

  const renderList = () => {
    list.replaceChildren()
    const filt = filteredOptions()
    const shown = filt.slice(0, maxRender)

    meta.replaceChildren(
      html`<span class="hz-ms__metaText">
        ${filt.length.toLocaleString()} match(es) · showing ${shown.length.toLocaleString()}
        ${filt.length > maxRender ? html` <span class="hz-ms__metaWarn">(refine search to see more)</span>` : ""}
      </span>`
    )

    for (const v of shown) {
      const row = html`<label class="hz-ms__item">
        <input type="checkbox" />
        <span class="hz-ms__itemText">${v}</span>
      </label>`
      const cb = row.querySelector("input")
      cb.checked = selected.has(v)
      cb.onchange = () => {
        if (cb.checked) {
          if (exclusive && v === exclusive) {
            selected.clear()
            selected.add(exclusive)
          } else {
            selected.add(v)
            if (exclusive) selected.delete(exclusive)
          }
        } else {
          selected.delete(v)
          setExclusiveRules(selected)
        }
        emit()
      }
      list.appendChild(row)
    }

    if (!shown.length) {
      list.appendChild(html`<div class="hz-ms__empty">No matches.</div>`)
    }
  }

  // Build action buttons
  btns.replaceChildren()
  for (const a of (actions ?? [])) {
    const b = html`<button type="button" class="hz-ms__btn">${a.label}</button>`
    b.onclick = () => {
      if (a.id === "none") {
        selected.clear()
        if (exclusive) selected.add(exclusive)
        emit()
      } else if (a.id === "all") {
        if (exclusive) {
          selected.clear()
          selected.add(exclusive)
        } else {
          selected.clear()
          for (const v of options) selected.add(v)
        }
        emit()
      }
    }
    btns.appendChild(b)
  }

  search.oninput = () => renderList()

  // initial paint
  renderChips()
  renderList()

  return form
}
```

```{ojs}
//| output: false
// Geography selectors (standard Atlas boundary UI)
viewof hz_admin0 = renderA0Multi({ key: "shared", maxSelections: 8 })
viewof hz_admin1 = renderA1Multi({ key: "shared", a0: viewof hz_admin0, maxSelections: 12 })
viewof hz_admin2 = renderA2Multi({ key: "shared", a0: viewof hz_admin0, a1: viewof hz_admin1, maxSelections: 20 })

// Render the 3 selectors with the shared input template
hz_geoUI = html`<div class="hz-geoRow">${inputTemplate({ gap: "10px" })([viewof hz_admin0, viewof hz_admin1, viewof hz_admin2])}</div>`
```

```{ojs}
//| output: false
hz_normSel = (xs) => {
  const arr = Array.isArray(xs) ? xs : []
  return arr
    .map((d) => {
      if (d == null) return ""
      if (typeof d === "string" || typeof d === "number") return String(d)

      // Admin selector objects from /components/_adminSelectorsMulti.qmd:
      // - admin0 objects have admin0_name (and iso3c)
      // - admin1 objects have admin1_name (and admin0_name, iso3)
      // - admin2 objects have admin2_name (and admin1_name, admin0_name, iso3)
      // We must send clean names to the API (no “(ISO)” label strings) and
      // treat “Full Country” rows (admin1_name/admin2_name == null) as “no filter”.
      if (typeof d === "object") {
        if ("admin2_name" in d) return d.admin2_name == null ? "" : String(d.admin2_name)
        if ("admin1_name" in d) return d.admin1_name == null ? "" : String(d.admin1_name)
        if ("admin0_name" in d) return d.admin0_name == null ? "" : String(d.admin0_name)
        return String(d.value ?? d.name ?? d.label ?? d.id ?? "")
      }

      return String(d)
    })
    .map((s) => String(s).trim())
    .filter((s) => s.length > 0)
}

hz_geoFilter = ({
  admin0: hz_normSel(hz_admin0),
  admin1: hz_normSel(hz_admin1),
  admin2: hz_normSel(hz_admin2)
})

hz_geoResolvedLevel = {
  const a0 = hz_geoFilter.admin0 ?? []
  const hasAll = a0.length === 0 || a0.includes("all")
  if (hasAll) return "admin0"
  if ((hz_geoFilter.admin2 ?? []).length) return "admin2"
  if ((hz_geoFilter.admin1 ?? []).length) return "admin1"
  return "admin0"
}

hz_geoSelectionCount = {
  const lvl = hz_geoResolvedLevel
  const a0 = (hz_geoFilter.admin0 ?? []).filter((d) => d != null && String(d).trim() !== "" && d !== "all")
  if (lvl === "admin2") return (hz_geoFilter.admin2 ?? []).length
  if (lvl === "admin1") return (hz_geoFilter.admin1 ?? []).length
  return (hz_geoFilter.admin0 ?? []).includes("all") || (hz_geoFilter.admin0 ?? []).length === 0 ? 1 : a0.length
}

```

```{ojs}
//| output: false
// Geo filter preview
hz_geoTable = {
  const gf = hz_geoFilter ?? {admin0: [], admin1: [], admin2: []}
  const a0raw = Array.isArray(gf.admin0) ? gf.admin0.filter(Boolean) : []
  const hasAll = a0raw.length === 0 || a0raw.includes("all")
  const a0 = hasAll ? ["all"] : a0raw.filter((d) => d !== "all")
  const a1 = hasAll ? [] : (Array.isArray(gf.admin1) ? gf.admin1.filter(Boolean) : [])
  const a2 = hasAll ? [] : (Array.isArray(gf.admin2) ? gf.admin2.filter(Boolean) : [])

  const chipRow = (arr, max = 10) => {
    const shown = arr.slice(0, max)
    const more = arr.length > max ? arr.length - max : 0
    return html`<div style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;">
      ${shown.map((d) => html`<span class="hz-chip"><span>${d}</span></span>`)}
      ${more ? html`<span class="hz-chip"><span>+${more} more</span></span>` : ""}
    </div>`
  }

  return html`<div class="hz-card" style="margin-top:10px;">
    <div class="hz-card__head">
      <div>
        <div class="hz-card__title">Geography summary</div>
        <div class="hz-card__sub">Resolved level: <b>${hz_geoResolvedLevel}</b> · selections: <b>${hz_geoSelectionCount}</b></div>
      </div>
    </div>
    <div class="hz-muted" style="margin-top:4px;">Admin0</div>
    ${chipRow(a0)}
    <div class="hz-muted" style="margin-top:10px;">Admin1</div>
    ${a1.length ? chipRow(a1) : html`<div class="hz-muted">—</div>`}
    <div class="hz-muted" style="margin-top:10px;">Admin2</div>
    ${a2.length ? chipRow(a2) : html`<div class="hz-muted">—</div>`}
  </div>`
}

hz_geoPanelReal = html`
  <div>
    <div class="hz-card">
      <div class="hz-card__head">
        <div>
          <div class="hz-card__title">Geography</div>
          <div class="hz-card__sub">Geography selection is in <a href="#q1">Q1 Controls</a>. This section shows a summary.</div>
        </div>
        <a class="hz-pill" href="#q1" style="text-decoration:none">Change selection</a>
      </div>
      <div class="hz-muted">Tip: If you need to confirm what’s being queried, use the chips below (resolved level + selected admin names).</div>
    </div>

    <div style="height:12px"></div>
    ${hz_geoTable}

    ${
      hz_adminNames?.[0]?.error
        ? html`<div class="warn" style="margin-top:10px"><b>Admin names load failed:</b><br>${hz_adminNames[0].error}</div>`
        : ""
    }
  </div>
`
```

```{ojs}
//| output: false
// WHERE clause builder for the hazard exposure parquet schema
hz_q = (s) => "'" + String(s).replaceAll("'", "''") + "'"

// Crop WHERE helper (safe SQL quoting; supports UI sentinel "all")
hz_cropWhere = (commodities) => {
  const list = Array.isArray(commodities) ? commodities.filter((d) => d != null && String(d).trim() !== "") : []
  const hasAll = list.length === 0 || list.includes("all")
  if (hasAll) return "TRUE"
  const vals = list.filter((d) => d !== "all")
  if (!vals.length) return "TRUE"
  return `crop IN (${vals.map(hz_q).join(", ")})`
}

// hazard_vars lists
// - generic: NDWS (drought) + NTx35 / THI-max (heat) + NDWL0 (flood)
// - crop_specific: PTOT-L (drought) + NTxS / THI-max (heat) + PTOT-G (flood)
hz_interactions = ({
  generic: [
    "NDWS+NTx35+NDWL0",
    "NDWS+THI-max+NDWL0"
  ],
  crop_specific: [
    "PTOT-L+NTxS+PTOT-G",
    "PTOT-L+THI-max+PTOT-G"
  ]
})

// hazard_vars WHERE helper
hz_hazardVarsWhere = (method, commodGroup) => {
  const m = String(method ?? "").toLowerCase()
  const cg = String(commodGroup ?? "").toLowerCase()

  const vars =
    (m === "generic") ? hz_interactions.generic :
    (m === "crop-specific" || m === "crop_specific") ? hz_interactions.crop_specific :
    // auto (best available): default to crop_specific unless we're aggregating "all"
    ((cg === "all" || cg === "" || cg === "total") ? hz_interactions.generic : hz_interactions.crop_specific)

  return `hazard_vars IN (${vars.map(hz_q).join(", ")})`
}

// Exposure value/unit WHERE helper
hz_unitWhere = (varShort) => {
  return "TRUE"
}

// Severity WHERE helper
hz_sevWhere = (severity) => {
  return "TRUE"
}

hz_geoWhere = (geoFilter) => {
  const gf = geoFilter ?? {}
  const admin0 = Array.isArray(gf.admin0) ? gf.admin0.filter((d) => d != null && String(d).trim() !== "") : []
  const admin1 = Array.isArray(gf.admin1) ? gf.admin1.filter((d) => d != null && String(d).trim() !== "") : []
  const admin2 = Array.isArray(gf.admin2) ? gf.admin2.filter((d) => d != null && String(d).trim() !== "") : []

  
  const hasAll = admin0.length === 0 || admin0.includes("all")
  const a0 = hasAll ? [] : admin0.filter((d) => d !== "all")
  const a1 = hasAll ? [] : admin1
  const a2 = hasAll ? [] : admin2

  const q = (s) => `'${String(s).replaceAll("'", "''")}'`
  const inList = (vals) => vals.map(q).join(", ")

  const wh = []

  // Only constrain admin0 when user chose specific countries
  if (a0.length > 0) {
    wh.push(`admin0_name IN (${inList(a0)})`)
  }

  if (a2.length > 0) {
    // Admin2 totals: admin0 + (optional admin1) + admin2
    if (a1.length > 0) wh.push(`admin1_name IN (${inList(a1)})`)
    wh.push(`admin2_name IN (${inList(a2)})`)
  } else if (a1.length > 0) {
    // Admin1 totals: admin0 + admin1, and admin2 NULL
    wh.push(`admin1_name IN (${inList(a1)})`)
    wh.push(`admin2_name IS NULL`)
  } else {
    // Admin0 totals: admin1/admin2 NULL
    wh.push(`admin1_name IS NULL`)
    wh.push(`admin2_name IS NULL`)
  }

  return wh.join("\n      AND ")
}

hz_scenWhere = (sc) => {
  const p = (typeof sc === "string") ? hz_parseScenXTime(sc) : (sc ?? {})
  const scenario = p.scenario
  const timeframe = p.timeframe ?? (scenario === "historic" ? "historic" : null)
  if (!scenario || !timeframe) return "FALSE"
  return `scenario = ${hz_q(scenario)} AND timeframe = ${hz_q(timeframe)}`
}
```

```{ojs}
//| output: false
viewof hz_loadSchema = Inputs.toggle(false, { label: "Load schema tables (debug, slower)" })
```

```{ojs}
//| output: false
// -----------------------------
// FAST API PATH (v3): call the FastAPI + Redis service for all heavy queries.

// API base URL
hz_apiBaseUrl = (() => {
  try {
    const u = new URL(window.location.href)
    const p = u.searchParams.get('api')
    if (p) return p.replace(/\/+$/, '')
  } catch (_) {}
  return (globalThis.__ATLAS_HZ_API_BASE__ ??= 'https://atlasapi.jcdevops.com')
})()

// Tiny client cache + debounce state (persists across reactive runs)
hz_apiState = globalThis.__ATLAS_HZ_API_STATE__ ??= {
  cache: new Map(),       // key -> { t:number, v:any }
  order: [],              // insertion order for LRU
  inflight: new Map(),    // key -> Promise
  timers: new Map(),      // group -> timeout id
  aborts: new Map(),      // group -> AbortController
  tokens: new Map(),      // group -> number
  maxEntries: 40
}

hz_stableStringify = (v) => {
  const seen = new WeakSet()
  const norm = (x) => {
    if (x === null || x === undefined) return x
    if (typeof x !== 'object') return x
    if (seen.has(x)) return null
    seen.add(x)
    if (Array.isArray(x)) return x.map(norm)
    const out = {}
    for (const k of Object.keys(x).sort()) out[k] = norm(x[k])
    return out
  }
  return JSON.stringify(norm(v))
}

hz_lruGet = (key, ttlMs) => {
  const hit = hz_apiState.cache.get(key)
  if (!hit) return null
  if (ttlMs > 0 && (Date.now() - hit.t) > ttlMs) {
    hz_apiState.cache.delete(key)
    return null
  }
  // refresh LRU position
  const i = hz_apiState.order.indexOf(key)
  if (i >= 0) hz_apiState.order.splice(i, 1)
  hz_apiState.order.push(key)
  return hit.v
}

hz_lruSet = (key, val) => {
  if (hz_apiState.cache.has(key)) {
    hz_apiState.cache.delete(key)
    const i = hz_apiState.order.indexOf(key)
    if (i >= 0) hz_apiState.order.splice(i, 1)
  }
  hz_apiState.cache.set(key, { t: Date.now(), v: val })
  hz_apiState.order.push(key)
  while (hz_apiState.order.length > hz_apiState.maxEntries) {
    const oldest = hz_apiState.order.shift()
    if (oldest) hz_apiState.cache.delete(oldest)
  }
  return val
}

hz_apiPostJson = async (path, body, { signal } = {}) => {
  const url = hz_apiBaseUrl + path
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body ?? {}),
    signal
  })
  const isJson = (res.headers.get('content-type') || '').includes('application/json')
  const payload = isJson ? await res.json() : { ok: false, detail: await res.text() }
  if (!res.ok) {
    const msg = payload?.detail || payload?.error || payload?.message || ('' + res.status)
    throw new Error(msg)
  }
  return payload
}

// Debounced + cached API call.
//| output: false
// ============================================================
// Map view (choropleth) — reuses getAdminBoundaries + by-admin API
// ============================================================

viewof hz_mapMetric = {
  const labels = {
    right: "Right",
    left:  "Left",
    delta: "Δ (Right − Left)"
  }
  const values = ["right", "left", "delta"]
  const root = Inputs.radio(values, {
    label: "Color by",
    value: (hz_compareMode === "diff") ? "delta" : "right",
    format: (v) => labels[v] || String(v)
  })
  root.classList.add("hz-mapMetric")
  return root
}

hz_mapMetricEff = hz_mapMetric || ((hz_compareMode === "diff") ? "delta" : "right")

hz_mapReqExtra = ({ group_child: true })

hz_mapRespL = {
  if (hz_viewMode !== "map") return null
  const out = await hz_apiDebouncedCached("mapL", "/api/v1/hz/by-admin", hz_sideReq(hz_src1, hz_s1, hz_mapReqExtra), { debounceMs: 120 })
  return (out && typeof out === "object" && ("ok" in out)) ? out : null
}

hz_mapRespR = {
  if (hz_viewMode !== "map") return null
  const out = await hz_apiDebouncedCached("mapR", "/api/v1/hz/by-admin", hz_sideReq(hz_src2, hz_s2, hz_mapReqExtra), { debounceMs: 120 })
  return (out && typeof out === "object" && ("ok" in out)) ? out : null
}

hz_mapMeta = {
  if (hz_viewMode !== "map") return { ok: false, loading: false, error: "hidden" }
  if (!hz_mapRespL || !hz_mapRespR) return { ok: false, loading: true, error: null }
  const ok = Boolean(hz_mapRespL?.ok && hz_mapRespR?.ok)
  const err = (!ok) ? String(hz_mapRespL?.error || hz_mapRespR?.error || "Map query failed") : null
  return { ok, loading: false, error: err }
}

hz_mapRowsL = (hz_mapRespL?.data ?? [])
hz_mapRowsR = (hz_mapRespR?.data ?? [])

hz_mapLevel = {
  const a2 = (hz_geoFilter?.admin2 ?? []).filter(Boolean)
  const a1 = (hz_geoFilter?.admin1 ?? []).filter(Boolean)
  const a0 = (hz_geoFilter?.admin0 ?? []).filter(Boolean).filter(x => String(x).toLowerCase() !== "all")
  if (a2.length) return 2
  if (a1.length) return 2
  if (a0.length) return 1
  return 0
}

hz_mapLevelLabel = (hz_mapLevel === 2) ? "Admin2" : (hz_mapLevel === 1) ? "Admin1" : "Admin0"

hz_mapSub = {
  const a2 = (hz_geoFilter?.admin2 ?? []).filter(Boolean)
  const a1 = (hz_geoFilter?.admin1 ?? []).filter(Boolean)
  const a0 = (hz_geoFilter?.admin0 ?? []).filter(Boolean).filter(x => String(x).toLowerCase() !== "all")
  if (hz_mapLevel === 2 && a1.length && !a2.length) return `Showing Admin2 (children of selected Admin1).`
  if (hz_mapLevel === 2 && a2.length) return `Showing selected Admin2 areas.`
  if (hz_mapLevel === 1 && a0.length) return `Showing Admin1 (children of selected Admin0).`
  return `Showing Admin0 across current selection.`
}

hz_guessNameKey = (feature, level) => {
  const props = feature?.properties ?? {}
  const keys = Object.keys(props)
  const prefer = (level === 0)
    ? ["admin0_name", "ADM0_NAME", "NAME_0", "name", "NAME", "country", "COUNTRY"]
    : (level === 1)
      ? ["admin1_name", "ADM1_NAME", "NAME_1", "name", "NAME"]
      : ["admin2_name", "ADM2_NAME", "NAME_2", "name", "NAME"]

  for (const k of prefer) if (k in props) return k
  const re = (level === 0) ? /(adm0|admin0|name_0|country)/i : (level === 1) ? /(adm1|admin1|name_1)/i : /(adm2|admin2|name_2)/i
  return keys.find(k => re.test(k)) || keys.find(k => /name/i.test(k)) || null
}

hz_mapPlot = {
  if (hz_viewMode !== "map") return html``
  if (hz_mapMeta.loading) return html`<div class="hz-loading">Loading map…</div>`
  if (!hz_mapMeta.ok) return html`<div class="warn"><b>Map query failed:</b><br>${hz_mapMeta.error}</div>`

  // Value lookups
  const mapL = new Map((hz_mapRowsL ?? []).map(d => [String(d.admin ?? ""), +d.total]))
  const mapR = new Map((hz_mapRowsR ?? []).map(d => [String(d.admin ?? ""), +d.total]))
  const names = new Set([...mapL.keys(), ...mapR.keys()].filter(Boolean))

  const metric = hz_mapMetricEff || "right"
  const lookup = (name) => {
    const vL = mapL.get(name)
    const vR = mapR.get(name)
    if (metric === "left") return vL
    if (metric === "right") return vR
    return (Number(vR ?? 0) - Number(vL ?? 0))
  }

  const boundsObj = await getAdminBoundaries([hz_mapLevel])
  const fc = boundsObj?.[`admin${hz_mapLevel}`]
  const feats = Array.isArray(fc?.features) ? fc.features : []
  if (!feats.length) return html`<div class="warn"><b>No boundary features found</b> for ${hz_mapLevelLabel}.</div>`

  const nameKey = hz_guessNameKey(feats[0], hz_mapLevel)
  const getName = (f) => {
    const p = f?.properties ?? {}
    return (nameKey && p[nameKey] != null) ? String(p[nameKey]) : ""
  }

// Scope features to the user's geographic selection (more intuitive than filtering by join results)
const a0 = (hz_geoFilter?.admin0 ?? []).filter(Boolean).filter(x => String(x).toLowerCase() !== "all")
const a1 = (hz_geoFilter?.admin1 ?? []).filter(Boolean)
const a2 = (hz_geoFilter?.admin2 ?? []).filter(Boolean)

const guessKey = (levelWanted) => {
  const props0 = feats?.[0]?.properties ?? {}
  const keys = Object.keys(props0)
  const prefer = (levelWanted === 0)
    ? ["admin0_name", "ADM0_NAME", "NAME_0", "country", "COUNTRY", "name", "NAME"]
    : (levelWanted === 1)
      ? ["admin1_name", "ADM1_NAME", "NAME_1", "name", "NAME"]
      : ["admin2_name", "ADM2_NAME", "NAME_2", "name", "NAME"]
  for (const k of prefer) if (k in props0) return k
  const re = (levelWanted === 0) ? /(adm0|admin0|name_0|country)/i
    : (levelWanted === 1) ? /(adm1|admin1|name_1)/i
    : /(adm2|admin2|name_2)/i
  return keys.find(k => re.test(k)) || keys.find(k => /name/i.test(k)) || null
}

const admin0Key = guessKey(0)
const admin1Key = guessKey(1)
const getAdmin0 = (f) => {
  const p = f?.properties ?? {}
  return (admin0Key && p[admin0Key] != null) ? String(p[admin0Key]) : ""
}
const getAdmin1 = (f) => {
  const p = f?.properties ?? {}
  return (admin1Key && p[admin1Key] != null) ? String(p[admin1Key]) : ""
}

let featsUse = feats

// If a country is selected, show only its children at admin1
if (hz_mapLevel === 1 && a0.length) {
  featsUse = featsUse.filter(f => a0.includes(getAdmin0(f)))
}

// If an admin1 is selected, show only its children at admin2
if (hz_mapLevel === 2) {
  if (a1.length) featsUse = featsUse.filter(f => a1.includes(getAdmin1(f)))
  else if (a2.length) featsUse = featsUse.filter(f => a2.includes(getName(f)))
}

// Keep only valid geometries
featsUse = featsUse.filter(f => f?.geometry && f.geometry.coordinates && f.geometry.coordinates.length)

if (!featsUse.length) {
  return html`<div class="warn"><b>No boundary features found for the current selection.</b><br>
    Try clearing the most specific boundary filter (Admin2 → Admin1 → Admin0).</div>`
}

const fcUse = { type: "FeatureCollection", features: featsUse }

// If the join doesn't match, we still render boundaries; data-less areas appear empty
const joinHits = featsUse.some(f => names.has(getName(f)))
const joinNote = (!joinHits)
  ? html`<div class="hz-muted hz-note">Note: could not match by-admin names to boundary properties; showing boundaries without fill.</div>`
  : null

const isDelta = (metric === "delta")
  const label = isDelta ? "Δ exposure (Right − Left)" : (metric === "left" ? "Exposure (Left)" : "Exposure (Right)")

  const plot = Plot.plot({
    projection: { type: "mercator", domain: fcUse, inset: 10 },
    height: 440,
    color: isDelta
      ? { type: "diverging", legend: true, label, pivot: 0 }
      : { legend: true, label },
    marks: [
      Plot.geo(fcUse, {
        fill: f => {
          const n = getName(f)
          const v = lookup(n)
          return (v == null) ? NaN : v
        },
        stroke: "white",
        strokeWidth: 0.4,
        title: f => {
          const n = getName(f)
          const v = lookup(n)
          const vv = (v == null) ? "n/a" : fmtAbs(v)
          return `${n}\n${label}: ${vv}`
        }
      })
    ]
  })

  const box = html`<div class="hz-mapPlot"></div>`
  if (joinNote) box.appendChild(joinNote)
  box.appendChild(plot)
  return box
}

hz_apiDebouncedCached = async (groupKey, path, body, { ttlMs = 60000, debounceMs = 250 } = {}) => {
  const key = `${path}|${hz_stableStringify(body)}`

  // local cache hit
  const cached = hz_lruGet(key, ttlMs)
  if (cached != null) return cached

  // share inflight identical requests
  if (hz_apiState.inflight.has(key)) {
    const p = hz_apiState.inflight.get(key)
    let busyQ1 = false, busyQ2 = false, busyQ3 = false
    const shouldBusyQ1 = (groupKey !== "q2" && groupKey !== "q3" && groupKey !== "q4")
    try { if (shouldBusyQ1) { globalThis.__ATLAS_HZ_UI__?.setBusy?.(true); busyQ1 = true } } catch (_) {}
    if (groupKey === "q2") { try { globalThis.__ATLAS_HZ_UI_Q2__?.setBusy?.(true); busyQ2 = true } catch (_) {} }
    if (groupKey === "q3") { try { globalThis.__ATLAS_HZ_UI_Q3__?.setBusy?.(true); busyQ3 = true } catch (_) {} }
    try { return await p }
    finally {
      if (busyQ1) { try { globalThis.__ATLAS_HZ_UI__?.setBusy?.(false) } catch (_) {} }
      if (busyQ2) { try { globalThis.__ATLAS_HZ_UI_Q2__?.setBusy?.(false) } catch (_) {} }
      if (busyQ3) { try { globalThis.__ATLAS_HZ_UI_Q3__?.setBusy?.(false) } catch (_) {} }
    }
  }
  // cancel previous in this group
  try { clearTimeout(hz_apiState.timers.get(groupKey)) } catch (_) {}
  try { hz_apiState.aborts.get(groupKey)?.abort() } catch (_) {}

  const token = (hz_apiState.tokens.get(groupKey) || 0) + 1
  hz_apiState.tokens.set(groupKey, token)

  const ac = new AbortController()
  hz_apiState.aborts.set(groupKey, ac)

  const p = new Promise((resolve) => {
    const t = setTimeout(async () => {
      let busyQ1 = false, busyQ2 = false, busyQ3 = false
      try {
        // If a newer request has superseded this one before it even starts, skip.
        if (hz_apiState.tokens.get(groupKey) !== token) return resolve([])

        // UI: show an 'Updating…' overlay ONLY when the network call actually starts.
        const shouldBusyQ1 = (groupKey !== "q2" && groupKey !== "q3" && groupKey !== "q4")
        try { if (shouldBusyQ1) { globalThis.__ATLAS_HZ_UI__?.setBusy?.(true); busyQ1 = true } } catch (_) { busyQ1 = false }
        if (groupKey === "q2") { try { globalThis.__ATLAS_HZ_UI_Q2__?.setBusy?.(true); busyQ2 = true } catch (_) { busyQ2 = false } }
        if (groupKey === "q3") { try { globalThis.__ATLAS_HZ_UI_Q3__?.setBusy?.(true); busyQ3 = true } catch (_) { busyQ3 = false } }

        const out = await hz_apiPostJson(path, body, { signal: ac.signal })
        // Only accept latest
        if (hz_apiState.tokens.get(groupKey) !== token) return resolve([])
        resolve(hz_lruSet(key, out))
      } catch (e) {
        if (String(e).includes('AbortError')) return resolve([])
        resolve({ ok: false, error: String(e) })
      } finally {        // Always clear the busy overlay if we turned it on.
        try { if (busyQ1) globalThis.__ATLAS_HZ_UI__?.setBusy?.(false) } catch (_) {}
        if (groupKey === "q2") { try { if (busyQ2) globalThis.__ATLAS_HZ_UI_Q2__?.setBusy?.(false) } catch (_) {} }
        if (groupKey === "q3") { try { if (busyQ3) globalThis.__ATLAS_HZ_UI_Q3__?.setBusy?.(false) } catch (_) {} }

        hz_apiState.inflight.delete(key)
      }
    }, debounceMs)
    hz_apiState.timers.set(groupKey, t)
  })

  hz_apiState.inflight.set(key, p)
  return await p
}

```

```{ojs}
//| output: false
// Build a single "Q1" request that returns everything needed for the main chart.
hz_isBroadGeo = (geo) => {
  const a0 = Array.isArray(geo?.admin0) ? geo.admin0.filter((d) => d && d !== "all") : []
  // If no specific admin0 selected, it's broad.
  if (a0.length === 0) return true
  // If the UI includes "all" explicitly, treat as broad.
  if (Array.isArray(geo?.admin0) && geo.admin0.includes("all")) return true
  return false
}

hz_q1Req = (() => {
  if (hz_isBroadGeo?.(hz_geoFilter)) {
    return { ok: false, error: 'Select at least an Admin0 (or Admin1/Admin2). Broad selection is intentionally blocked for speed.' }
  }

  if (!(hz_src1?.ok && hz_src2?.ok)) {
    return { ok: false, error: 'Dataset URLs not resolved yet.' }
  }

  const left = {
    dataset_url: hz_src1.url,
    scen: { scenario: hz_s1?.scenario, timeframe: hz_s1?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
  }

  const right = {
    dataset_url: hz_src2.url,
    scen: { scenario: hz_s2?.scenario, timeframe: hz_s2?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
  }

  const denom = {
    denom_url: hz_denomUrl,
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    exposure: hz_denomSpec?.exposure ?? null,
    unit: hz_denomSpec?.unit ?? null,
    // keep legacy key for backwards compatibility on the API side
    exposure_unit: hz_denomSpec?.unit ?? hz_varShort
  }
return { ok: true, body: { left, right, denom } }
})()

```

```{ojs}
//| output: false
// Question routing (stacked Q1–Q4). For incremental dev, Q1 is the only wired question for now.
hz_activeQuestion = "q1"

hz_dashTitle = ({
  q1: "Total exposure by hazard",
  q2: "Total exposure by crop",
  q3: "Hazard composition by crop",
  q4: "Exposure by administrative area"
})[hz_activeQuestion] || "Dashboard"

hz_dashSub = ({
  q1: "Compare Left vs Right (side-by-side or Δ). Filters: scenarios, geography, commodities.",
  q2: "Compare Left vs Right. Filters: scenarios, geography, commodities.",
  q3: "Compare Left vs Right. Filters: scenarios, geography, commodities.",
  q4: "Compare Left vs Right. Filters: scenarios, geography, commodities."
})[hz_activeQuestion] || ""

// Common request payload for single-side endpoints (used by map + other side queries)
hz_sideReq = (src, scen, extra = {}) => ({
  dataset_url: src?.url,
  scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
  geo: hz_geoFilterApi,
  commodities: hz_selectedCommoditiesForReq ?? [],
  hazard_vars: null,
  hazards: null,
  method: hz_method,
  commodity_group: hz_selectedCommodGroup,
  ...extra
})
```

```{ojs}
//| output: false
// Call the API (debounced + cached)

hz_q1Resp = (hz_q1Req?.ok)
  ? await hz_keepScroll(hz_apiDebouncedCached("q1", "/api/v1/hz/q1", hz_q1Req.body, { ttlMs: 60000, debounceMs: 250 }))
  : { ok: false, error: hz_q1Req?.error || "Inactive", left: [], right: [], merged: [], denom: { ok: false, denom: null }, relative_label: "% of hazard sum" }

// Expose the same variables the rest of the notebook already expects
hz_tot1 = hz_q1Resp?.left ?? []
hz_tot2 = hz_q1Resp?.right ?? []
hz_merged = hz_q1Resp?.merged ?? []
hz_denom = hz_q1Resp?.denom ?? { ok: false, denom: null, error: "No denom" }
hz_relativeLabel = hz_q1Resp?.relative_label ?? "% of hazard sum"

// Meta object expected by hz_updateChart
hz_q1Meta = ({
  ok: !!(hz_q1Resp?.ok),
  cached: !!(hz_q1Resp?.cached),
  t_ms: Number(hz_q1Resp?.t_ms || 0),
  error: hz_q1Resp?.error || null
})

// Normalize + rank rows for chart/table (Q1)
hz_chartRows = {
  const src = Array.isArray(hz_merged) ? hz_merged : []

  const rows = src.map((r) => {
    const hazard = r.hazard ?? r.Hazard ?? r.name ?? r.key ?? "Unknown"
    const total1 = Number(r.total1 ?? r.left ?? r.value1 ?? r.total_left ?? 0)
    const total2 = Number(r.total2 ?? r.right ?? r.value2 ?? r.total_right ?? 0)
    const total_diff = Number(r.total_diff ?? (total2 - total1))
    return { ...r, hazard, total1, total2, total_diff }
  })

  const sumAll1 = rows.reduce((a, r) => a + Number(r.total1 ?? 0), 0)
  const sumAll2 = rows.reduce((a, r) => a + Number(r.total2 ?? 0), 0)
  const pct = (v, denom) => (denom ? (100 * Number(v ?? 0)) / denom : 0)

  for (const r of rows) {
    r.perc1 = Number(r.perc1 ?? pct(r.total1, sumAll1))
    r.perc2 = Number(r.perc2 ?? pct(r.total2, sumAll2))
    r.pct_diff = Number(r.pct_diff ?? (r.perc2 - r.perc1))
  }

  if (hz_compareMode === "diff") {
    const metric = hz_relative ? "pct_diff" : "total_diff"
    rows.sort((a, b) =>
      Math.abs(Number(b[metric] ?? 0)) - Math.abs(Number(a[metric] ?? 0))
    )
  } else {
    const m2 = hz_relative ? "perc2" : "total2"
    const m1 = hz_relative ? "perc1" : "total1"
    rows.sort((a, b) =>
      (Number(b[m2] ?? 0) - Number(a[m2] ?? 0)) ||
      (Number(b[m1] ?? 0) - Number(a[m1] ?? 0))
    )
  }

  const topN = Math.max(1, Number(hz_topN ?? 15) || 15)
  let head = rows.slice(0, topN)

  if (hz_groupOther && rows.length > topN) {
    const rest = rows.slice(topN)
    const sum = (k) => rest.reduce((a, r) => a + Number(r[k] ?? 0), 0)

    const otherTotal1 = sum("total1")
    const otherTotal2 = sum("total2")
    const otherDiff = otherTotal2 - otherTotal1

    head = head.concat([{
      hazard: "Other",
      total1: otherTotal1,
      total2: otherTotal2,
      total_diff: otherDiff,
      perc1: pct(otherTotal1, sumAll1),
      perc2: pct(otherTotal2, sumAll2),
      pct_diff: pct(otherTotal2, sumAll2) - pct(otherTotal1, sumAll1)
    }])
  }

  return head.map((r) => {
    const total1 = Number(r.total1 ?? 0)
    const total2 = Number(r.total2 ?? 0)
    const total_diff = Number(r.total_diff ?? (total2 - total1))
    const perc1 = pct(total1, sumAll1)
    const perc2 = pct(total2, sumAll2)
    const pct_diff = perc2 - perc1
    return { ...r, hazard: r.hazard ?? "Unknown", total1, total2, total_diff, perc1, perc2, pct_diff }
  })
}
```

```{ojs}
//| output: false
// Build Q1 UpSet chart (Shiny/prototype parity)
hz_q1Chart = {
  // numeric guard (prevents NaN propagating into Plot scales)
  const num = (x) => {
    const v = Number(x)
    return Number.isFinite(v) ? v : 0
  }

  // Use the full merged result (not the ranked/sliced chartRows), so all intersections stay accurate.
  const src = Array.isArray(hz_merged) ? hz_merged : []
  const raw = src.map((r) => {
    const hazard = r.hazard ?? r.Hazard ?? r.name ?? r.key ?? "Unknown"
    const total1 = num(r.total1 ?? r.left ?? r.value1 ?? r.total_left ?? 0)
    const total2 = num(r.total2 ?? r.right ?? r.value2 ?? r.total_right ?? 0)
    const total_diff = num(r.total_diff ?? (total2 - total1))
    const perc1 = num(r.perc1 ?? 0)
    const perc2 = num(r.perc2 ?? 0)
    const pct_diff = num(r.pct_diff ?? (perc2 - perc1))
    return { hazard, total1, total2, total_diff, perc1, perc2, pct_diff }
  })
  if (!raw.length) return html`<div class="hz-empty">No data for the current filters.</div>`

  const absLabel = hz_varLabel || "Value"
  const pctLabel = hz_relativeLabel || "%"
  const yLabel = hz_relative ? pctLabel : absLabel

  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })
  const fmtPct = (x) => `${hz_formatNumber(x, { digits: 2 })}%`
  const fmtY = hz_relative ? fmtPct : fmtAbs

  // Keep only intersection-style hazard classes (drop helpers)
  const isIntersection = (h) => {
    const h0 = String(h ?? "")
    if (!h0) return false
    if (h0 === "any" || h0 === "no hazard") return false
    if (h0 === "Other") return false
    return true
  }

  const baseOrder = ["dry", "heat", "wet"]

  const getParts = (h) =>
    String(h ?? "")
      .split("+")
      .map((s) => s.trim())
      .filter(Boolean)

  const baseSets = (() => {
    const s = new Set()
    for (const r of raw) {
      if (!isIntersection(r.hazard)) continue
      for (const p of getParts(r.hazard)) s.add(p)
    }
    const arr = [...s]
    const rest = arr.filter((d) => !baseOrder.includes(d)).sort()
    return baseOrder.filter((d) => arr.includes(d)).concat(rest)
  })()

  // Generate a complete set of combinations when manageable (<=4 sets).
  // This matches Shiny's behavior of keeping "missing" intersections as 0.
  const combos = (() => {
    if (baseSets.length >= 2 && baseSets.length <= 4) {
      const arr = baseSets
      const out = []
      const n = arr.length
      for (let mask = 1; mask < (1 << n); mask++) {
        const parts = []
        for (let i = 0; i < n; i++) if (mask & (1 << i)) parts.push(arr[i])
        out.push(parts.join("+"))
      }

      // Prefer classic dry/heat/wet ordering when available
      const prefer = ["dry", "heat", "wet", "dry+heat", "dry+wet", "heat+wet", "dry+heat+wet"]
      const preferSet = new Set(prefer)
      const ordered = prefer.filter((c) => out.includes(c)).concat(out.filter((c) => !preferSet.has(c)))

      return ordered
    }

    // Fallback: whatever hazards exist (already ranked upstream)
    return raw.filter((r) => isIntersection(r.hazard)).map((r) => String(r.hazard))
  })()

  const byHaz = new Map(raw.map((r) => [String(r.hazard), r]))

  const rows = combos.map((haz) => {
    const r = byHaz.get(haz) || {}
    const total1 = num(r.total1 ?? 0)
    const total2 = num(r.total2 ?? 0)
    const total_diff = num(r.total_diff ?? (total2 - total1))
    const perc1 = num(r.perc1 ?? 0)
    const perc2 = num(r.perc2 ?? 0)
    const pct_diff = num(r.pct_diff ?? (perc2 - perc1))
    return { hazard: haz, total1, total2, total_diff, perc1, perc2, pct_diff }
  })

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`

  const totalWidth = (() => {
    const w0 = Number(hz_plotWidth) || 900
    return Math.max(720, w0 - 24)
  })()
  const gap = 18
  const colWidth = (() => {
    const w = hz_difference ? totalWidth : Math.floor((totalWidth - gap) / 2)
    return Number.isFinite(w) && w > 0 ? w : 720
  })()

  const barH = Math.max(260, (Number(hz_chartHeight) || 520) - 140)
  const matH = 110

  const buildMatrixData = (domain) => {
    const all = []
    const presentPts = []
    for (const haz of domain) {
      const parts = new Set(getParts(haz))
      for (const s of baseSets) {
        const present = parts.has(s)
        all.push({ hazard: haz, set: s, present })
        if (present) presentPts.push({ hazard: haz, set: s })
      }
    }
    return { all, presentPts }
  }

  const buildUpSet = ({ label, valueKey, isDiff = false }) => {
    const domain = combos
    const data = rows.map((r) => ({ hazard: r.hazard, value: num(r[valueKey] ?? 0) }))
    const { all, presentPts } = buildMatrixData(domain)

    const maxAbs = Math.max(0, ...data.map((d) => Math.abs(num(d.value ?? 0))))
    const yNice = hz_relative ? [0, 100] : [0, maxAbs * 1.08]
    const yDiff = hz_relative ? [-Math.min(100, maxAbs * 1.08), Math.min(100, maxAbs * 1.08)] : [-maxAbs * 1.08, maxAbs * 1.08]

    const barPlot = Plot.plot({
      width: colWidth,
      height: barH,
      marginLeft: 60,
      marginRight: 14,
      marginTop: 18,
      marginBottom: 0,
      x: { domain, tickFormat: () => "", label: null },
      y: {
        label: yLabel,
        grid: true,
        domain: isDiff ? yDiff : yNice,
        tickFormat: fmtY
      },
      marks: [
        Plot.ruleY([0]),
        Plot.barY(data, { x: "hazard", y: "value" }),
        Plot.text(data, {
          x: "hazard",
          y: "value",
          text: (d) => fmtY(d.value),
          dy: (d) => (Number(d.value ?? 0) >= 0 ? -6 : 12),
          fontSize: 10
        })
      ]
    })

    const matrixPlot = Plot.plot({
      width: colWidth,
      height: matH,
      marginLeft: 60,
      marginRight: 14,
      marginTop: 0,
      marginBottom: 22,
      x: { domain, tickFormat: () => "", label: null },
      y: { domain: baseSets, label: null },
      marks: [
        Plot.line(presentPts, { x: "hazard", y: "set", z: "hazard" }),
        Plot.dot(all, {
          x: "hazard",
          y: "set",
          r: 3,
          fill: (d) => (d.present ? "#111827" : "#d1d5db")
        })
      ]
    })

    return html`<div class="hz-upsetCol">
      <div class="hz-upsetTitle">${label}</div>
      <div class="hz-upsetStack">${barPlot}${matrixPlot}</div>
    </div>`
  }

  if (!hz_difference) {
    return html`<div class="hz-upsetGrid">
      ${buildUpSet({ label: hz_s1.label, valueKey: (hz_relative ? "perc1" : "total1") })}
      ${buildUpSet({ label: hz_s2.label, valueKey: (hz_relative ? "perc2" : "total2") })}
    </div>
    <div class="hz-upsetCaption">${subtitle}</div>`
  }

  return html`<div class="hz-upsetGrid hz-upsetGrid--single">
    ${buildUpSet({ label: "Difference (Right − Left)", valueKey: (hz_relative ? "pct_diff" : "total_diff"), isDiff: true })}
  </div>
  <div class="hz-upsetCaption">${subtitle}</div>`
}
```


```{ojs}
//| output: false
// ----------------------------
// Q2 — totals by crop (uses shared global Advanced filters)
// ----------------------------
// Reuse global scenario parsing + dataset resolution used by Q1
hz_q2_s1 = hz_s1
hz_q2_s2 = hz_s2

hz_q2_keyCandidates1 = hz_keyCandidates1
hz_q2_keyCandidates2 = hz_keyCandidates2

hz_q2_src1 = hz_src1
hz_q2_src2 = hz_src2

// Reuse shared commodities + geo payload used by Q1
hz_q2_selectedCommoditiesForReq = hz_selectedCommoditiesForReq
hz_q2_geoFilterApi = hz_geoFilterApi

// Guard: require Admin0 and resolved datasets (shared)
hz_q2ReqOk = (() => {
  if (hz_isBroadGeo?.(hz_geoFilter)) {
    return { ok: false, error: "Select at least an Admin0 (broad selection blocked for speed)." }
  }
  if (!(hz_src1?.ok && hz_src2?.ok)) {
    return { ok: false, error: "Dataset URLs not resolved yet." }
  }
  return { ok: true, error: null }
})()

hz_q2_sideReq = (src, scen) => ({
  dataset_url: src?.url,
  scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
  geo: hz_geoFilterApi,
  commodities: hz_selectedCommoditiesForReq ?? [],
  hazard_vars: null,
  hazards: null,
  method: hz_method,
  commodity_group: hz_selectedCommodGroup
})

// API calls (no hz_activeQuestion gate)
// API call (Q2) — Shiny-aligned data feed
// We use the dedicated /api/v1/hz/q2 endpoint so we can:
// - pull hazard×crop rows for both scenarios
// - pull denom totals per crop (for "no hazard" + true % of total exposure)
//
// Note: this patch focuses on DATA ONLY (no chart changes yet).
hz_q2ReqBody = (() => {
  if (!hz_q2ReqOk.ok) return { ok: false, error: hz_q2ReqOk.error, body: null }

  const left = {
    dataset_url: hz_src1?.url,
    scen: { scenario: hz_s1?.scenario, timeframe: hz_s1?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
    top_crops: Number(hz_q2_topN || 25),
    bucket_other: false
  }

  const right = {
    dataset_url: hz_src2?.url,
    scen: { scenario: hz_s2?.scenario, timeframe: hz_s2?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
    top_crops: Number(hz_q2_topN || 25),
    bucket_other: false
  }

  const denom = {
    denom_url: hz_denomUrl,
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    exposure: hz_denomSpec?.exposure ?? null,
    unit: hz_denomSpec?.unit ?? null,
    exposure_unit: hz_denomSpec?.unit ?? hz_varShort
  }

  return { ok: true, error: null, body: { left, right, denom } }
})()

hz_q2Resp = hz_q2ReqBody.ok
  ? await hz_keepScroll(hz_apiDebouncedCached("q2", "/api/v1/hz/q2", hz_q2ReqBody.body, { ttlMs: 300000, debounceMs: 250 }))
  : { ok: false, error: hz_q2ReqBody.error, left: [], right: [], denom_by_crop: null, denom: null, cached: false, t_ms: 0 }

// Back-compat shims so existing Q2 chart/table continues to render while we incrementally migrate.
hz_q2RespL = ({
  ok: !!hz_q2Resp?.ok,
  cached: !!hz_q2Resp?.cached,
  t_ms: Number(hz_q2Resp?.t_ms || 0),
  error: hz_q2Resp?.error || null,
  data: hz_q2Resp?.left ?? []
})
hz_q2RespR = ({
  ok: !!hz_q2Resp?.ok,
  cached: !!hz_q2Resp?.cached,
  t_ms: Number(hz_q2Resp?.t_ms || 0),
  error: hz_q2Resp?.error || null,
  data: hz_q2Resp?.right ?? []
})

hz_q2DataL = hz_q2RespL?.data ?? []
hz_q2DataR = hz_q2RespR?.data ?? []
hz_q2DenomByCrop = hz_q2Resp?.denom_by_crop ?? []

hz_q2Meta = ({
  ok: !!(hz_q2RespL?.ok && hz_q2RespR?.ok),
  cached: !!(hz_q2RespL?.cached && hz_q2RespR?.cached),
  t_ms: Number(hz_q2Resp?.t_ms || 0),
  error: hz_q2RespL?.error || hz_q2RespR?.error || null
})

// ---- Shiny-style derived tables (DATA ONLY) ----

// denom map: crop -> total exposure
hz_q2DenomMap = {
  const m = new Map()
  for (const d of (hz_q2DenomByCrop ?? [])) {
    const crop = d?.crop
    if (!crop) continue
    const v = Number(d?.value_tot ?? d?.total ?? d?.value ?? 0)
    m.set(crop, (Number.isFinite(v) ? v : 0))
  }
  return m
}

// helper: crop -> total for a hazard label
hz_q2HazMap = (rows, hazLabel) => {
  const m = new Map()
  for (const r of (rows ?? [])) {
    if (String(r?.hazard ?? "") !== String(hazLabel)) continue
    const crop = r?.crop
    if (!crop) continue
    const v = Number(r?.total ?? 0)
    m.set(crop, (Number.isFinite(v) ? v : 0))
  }
  return m
}

// Add "no hazard" per crop for each scenario: total exposure - any hazard exposure
hz_q2RowsL_withNoHazard = {
  const base = (hz_q2DataL ?? []).slice()
  const anyMap = hz_q2HazMap(base, "any")
  const denom = hz_q2DenomMap
  const crops = new Set([...Array.from(denom.keys()), ...base.map(d => d?.crop).filter(Boolean)])

  for (const crop of crops) {
    const tot = Number(denom.get(crop) || 0)
    const any = Number(anyMap.get(crop) || 0)
    const nh = Math.max(0, tot - any)
    base.push({ hazard: "no hazard", crop, total: nh })
  }
  return base
}

hz_q2RowsR_withNoHazard = {
  const base = (hz_q2DataR ?? []).slice()
  const anyMap = hz_q2HazMap(base, "any")
  const denom = hz_q2DenomMap
  const crops = new Set([...Array.from(denom.keys()), ...base.map(d => d?.crop).filter(Boolean)])

  for (const crop of crops) {
    const tot = Number(denom.get(crop) || 0)
    const any = Number(anyMap.get(crop) || 0)
    const nh = Math.max(0, tot - any)
    base.push({ hazard: "no hazard", crop, total: nh })
  }
  return base
}

// Exclusive compound hazards (stackable): dry/heat/wet as "(only)" + their combinations + no hazard
hz_q2CompoundExclusive = (rows) => {
  const out = []
  for (const r of (rows ?? [])) {
    const h0 = String(r?.hazard ?? "")
    const crop = r?.crop
    if (!crop) continue
    const v = Number(r?.total ?? 0)

    if (h0 === "dry")  out.push({ hazard: "dry (only)", crop, total: v })
    else if (h0 === "heat") out.push({ hazard: "heat (only)", crop, total: v })
    else if (h0 === "wet")  out.push({ hazard: "wet (only)", crop, total: v })
    else if (h0 === "dry+heat" || h0 === "dry+wet" || h0 === "heat+wet" || h0 === "dry+heat+wet") out.push({ hazard: h0, crop, total: v })
    else if (h0 === "no hazard") out.push({ hazard: "no hazard", crop, total: v })
    // ignore "any" here (not stackable with exclusive classes)
  }
  return out
}

// Simplified compound hazards: 1 hazard / 2 hazards / 3 hazards + no hazard
hz_q2CompoundSimplified = (rows) => {
  const bucket = (h) => {
    if (h === "no hazard") return "no hazard"
    const h0 = String(h).replace(" (only)", "")
    const n = h0.split("+").filter(Boolean).length
    if (n === 1) return "1 hazard"
    if (n === 2) return "2 hazards"
    if (n === 3) return "3 hazards"
    return null
  }

  const agg = new Map() // key: crop|bucket
  for (const r of (rows ?? [])) {
    const crop = r?.crop
    if (!crop) continue
    const b = bucket(String(r?.hazard ?? ""))
    if (!b) continue
    const key = `${crop}|${b}`
    const v = Number(r?.total ?? 0)
    agg.set(key, (agg.get(key) || 0) + (Number.isFinite(v) ? v : 0))
  }

  const out = []
  for (const [key, total] of agg.entries()) {
    const [crop, hazard] = key.split("|")
    out.push({ hazard, crop, total })
  }
  return out
}

// Non-compound (overlapping) hazard buckets: dry(any), heat(any), wet(any), any + no hazard
hz_q2NonCompoundBuckets = (rows) => {
  const byCrop = new Map()

  const add = (crop, hazard, v) => {
    const key = `${crop}|${hazard}`
    byCrop.set(key, (byCrop.get(key) || 0) + v)
  }

  for (const r of (rows ?? [])) {
    const h = String(r?.hazard ?? "")
    const crop = r?.crop
    if (!crop) continue
    const v = Number(r?.total ?? 0)
    if (!Number.isFinite(v)) continue

    if (h === "no hazard") add(crop, "no hazard", v)
    if (h === "any") add(crop, "any", v)

    // Build overlapping buckets from exclusive hazards only (ignore "any" / "no hazard")
    if (h && h !== "any" && h !== "no hazard") {
      if (h.includes("dry"))  add(crop, "dry (any)", v)
      if (h.includes("heat")) add(crop, "heat (any)", v)
      if (h.includes("wet"))  add(crop, "wet (any)", v)
    }
  }

  const out = []
  for (const [key, total] of byCrop.entries()) {
    const [crop, hazard] = key.split("|")
    out.push({ hazard, crop, total })
  }
  return out
}

// Build merged hazard×crop rows (Shiny haz_merge style): total1/total2/diff and percent fields (when denom exists)
hz_q2HazMerge = (rowsL, rowsR) => {
  const key = (d) => `${d?.crop ?? ""}||${d?.hazard ?? ""}`
  const mapL = new Map((rowsL ?? []).map(d => [key(d), Number(d?.total ?? 0)]))
  const mapR = new Map((rowsR ?? []).map(d => [key(d), Number(d?.total ?? 0)]))
  const keys = Array.from(new Set([...mapL.keys(), ...mapR.keys()]))

  const denom = hz_q2DenomMap

  const out = keys.map(k => {
    const [crop, hazard] = k.split("||")
    const v1 = Number(mapL.get(k) || 0)
    const v2 = Number(mapR.get(k) || 0)
    const tot = Number(denom.get(crop) || 0)
    const p1 = tot ? (100 * v1 / tot) : 0
    const p2 = tot ? (100 * v2 / tot) : 0
    return {
      crop,
      hazard,
      total1: v1,
      total2: v2,
      diff: v2 - v1,
      perc1: p1,
      perc2: p2,
      perc_diff: p2 - p1
    }
  })

  return out
}

// Derived hazard sets (ready for Patch 2 charts)
hz_q2Set_compound_full = hz_q2HazMerge(hz_q2CompoundExclusive(hz_q2RowsL_withNoHazard), hz_q2CompoundExclusive(hz_q2RowsR_withNoHazard))
hz_q2Set_compound_simple = hz_q2HazMerge(hz_q2CompoundSimplified(hz_q2CompoundExclusive(hz_q2RowsL_withNoHazard)), hz_q2CompoundSimplified(hz_q2CompoundExclusive(hz_q2RowsR_withNoHazard)))
hz_q2Set_noncompound = hz_q2HazMerge(hz_q2NonCompoundBuckets(hz_q2RowsL_withNoHazard), hz_q2NonCompoundBuckets(hz_q2RowsR_withNoHazard))

// Keep existing Q2 totals chart alive: rank crops by ANY hazard (union)
hz_q2Rows = {
  const anyL = hz_q2HazMap(hz_q2DataL, "any")
  const anyR = hz_q2HazMap(hz_q2DataR, "any")
  const crops = Array.from(new Set([...anyL.keys(), ...anyR.keys()]))

  const rows = crops.map(crop => ({
    crop,
    total1: anyL.get(crop) || 0,
    total2: anyR.get(crop) || 0
  }))

  rows.sort((a,b) => (b.total2 - a.total2) || (b.total1 - a.total1))
  return rows.slice(0, Number(hz_q2_topN || 25))
}


// Labels (Q2-specific)
hz_q2_geoLabel = hz_makeGeoLabel(hz_q2_geoFilter)
hz_q2_commodityLabel = hz_makeComLabel(hz_q2_selectedCommoditiesForReq ?? [])

// Chart (Q2-specific)
hz_q2Chart = {
  const set = hz_q2_showCompound
    ? (hz_q2_simplifyCompound ? hz_q2Set_compound_simple : hz_q2Set_compound_full)
    : hz_q2Set_noncompound

  const includeNoHazard = !!hz_q2_includeNoHazard
  const includeDecreases = !!hz_q2_includeDecreases

  const hazLevels = hz_q2_showCompound
    ? (hz_q2_simplifyCompound
        ? ["no hazard", "1 hazard", "2 hazards", "3 hazards"]
        : ["no hazard", "dry (only)", "heat (only)", "wet (only)", "dry+heat", "dry+wet", "heat+wet", "dry+heat+wet"])
    : ["no hazard", "dry (any)", "heat (any)", "wet (any)", "any"]
  const hazLevelsChart = includeNoHazard ? hazLevels : hazLevels.filter((h) => String(h) !== "no hazard")


  const rows = Array.isArray(set) ? set : []
  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`

  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })
  const fmtPct = (x) => `${hz_formatNumber(x, { digits: 2 })}%`

  // Match Shiny plot_inputs(): pick value columns based on Show % and Show differences
  const valLeft  = hz_q2_relative ? "perc1" : "total1"
  const valRight = hz_q2_relative ? "perc2" : "total2"
  const valDiff  = hz_q2_relative ? "perc_diff" : "diff"

  // Shiny q2_fun() ranks crops by total exposure excluding "no hazard";
  // in diff mode it uses only positive changes to rank the Y axis.
  const rankBy = (valKey, onlyPositive = false) => {
    const m = new Map()
    for (const r of rows) {
      const crop = r?.crop
      if (!crop) continue
      if (String(r?.hazard ?? "") === "no hazard") continue
      const v = Number(r?.[valKey] ?? 0)
      if (!Number.isFinite(v)) continue
      if (onlyPositive && v <= 0) continue
      m.set(crop, (m.get(crop) || 0) + v)
    }
    return Array.from(m.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([c]) => c)
  }

  const n = Math.max(1, Number(hz_q2_topN ?? 25) || 25)

  const crops = (() => {
    if (hz_q2_difference) {
      return rankBy(valDiff, true).slice(0, n)
    }
    const topL = rankBy(valLeft, false).slice(0, n)
    const topR = rankBy(valRight, false).slice(0, n)
    return Array.from(new Set([...topL, ...topR]))
  })()

  // Stable ordering across panels: combined (Right + Left)
  const score = (crop) => {
    let s = 0
    for (const r of rows) {
      if (r?.crop !== crop) continue
      if (String(r?.hazard ?? "") === "no hazard") continue
      s += Number(r?.[valRight] ?? 0) + Number(r?.[valLeft] ?? 0)
    }
    return s
  }
  crops.sort((a, b) => score(b) - score(a))

  const perCrop = hz_q2_showCompound ? 26 : Math.max(34, hazLevelsChart.length * 14 + 18)

  const height = Math.max(
    360,
    crops.length * perCrop,
    Number(hz_q2_chartHeight ?? 520)
  )

  const plotW =
    (hz_plotWidth ?? 0) >= 980
      ? Math.floor((hz_plotWidth - 16) / 2)
      : hz_plotWidth

  const color = { domain: hazLevelsChart, scheme: "tableau10", legend: false }
  const legend = Plot.legend({ color: { domain: hazLevelsChart, scheme: "tableau10" }, columns: 4 })

  const xLabelAbs = (hz_varLabelAbs ?? "Exposure")
  const xLabel = hz_q2_relative ? "%" : xLabelAbs
  const tickFmt = hz_q2_relative ? (x) => fmtPct(x) : (x) => fmtAbs(x)

  const makeSidePlot = (title, sideKey) => {
    const valKey = sideKey === "left" ? valLeft : valRight

    const data = rows
      .filter(r => crops.includes(r?.crop) && hazLevelsChart.includes(String(r?.hazard ?? "")))
      .map(r => ({
        crop: r.crop,
        hazard: String(r.hazard),
        value: Number(r?.[valKey] ?? 0)
      }))

    const groupedMarks = (rows, hazards) => {
      const n = hazards.length
      const step = 12 // px spacing between hazard bars within the same crop band
      return hazards.map((h, i) => Plot.barX(
        rows.filter(d => d.hazard === h),
        {
          x: "value",
          y: "crop",
          fill: "hazard",
          dy: (i - (n - 1) / 2) * step,
          insetTop: 5,
          insetBottom: 5,
          tip: {
            format: { crop: true, hazard: true, value: hz_q2_relative ? fmtPct : fmtAbs }
          }
        }
      ))
    }

    const marks = hz_q2_showCompound
      ? [
          Plot.barX(data, Plot.stackX({
            x: "value",
            y: "crop",
            fill: "hazard",
            tip: {
              format: { crop: true, hazard: true, value: hz_q2_relative ? fmtPct : fmtAbs }
            }
          }))
        ]
      : groupedMarks(data, hazLevelsChart)


    return html`
      <div class="hz-mini hz-mini--stack">
        <div class="hz-mini__title">${title}</div>
        ${Plot.plot({
          height,
          width: plotW,
          marginLeft: 180,
          marginRight: 18,
          marginTop: 10,
          marginBottom: 30,
          x: { label: xLabel, grid: true, tickFormat: tickFmt },
          y: { domain: crops, label: null },
          color,
              marks: [Plot.ruleX([0]), ...marks]
        })}
      </div>
    `
  }

  if (!hz_q2_difference) {
    return html`
      <div class="hz-legendRow">${legend}</div>
      <div class="hz-grid2 hz-grid2--equal">
        ${makeSidePlot("Left", "left")}
        ${makeSidePlot("Right", "right")}
      </div>
    `
  }

  // Difference mode (single plot)
  const diffData = rows
    .filter(r => crops.includes(r?.crop) && hazLevelsChart.includes(String(r?.hazard ?? "")))
    .map(r => ({
      crop: r.crop,
      hazard: String(r.hazard),
      value: Number(r?.[valDiff] ?? 0)
    }))
    .filter(d => includeDecreases || (Number.isFinite(d.value) && d.value > 0))
const xLabelDiff = hz_q2_relative
    ? "Δ percentage points (Right − Left)"
    : "Δ exposure (Right − Left)"

  const groupedMarks = (rows, hazards) => {


    const n = hazards.length


    const step = 12 // px spacing between hazard bars within the same crop band


    return hazards.map((h, i) => Plot.barX(


      rows.filter(d => d.hazard === h),


      {


        x: "value",


        y: "crop",


        fill: "hazard",


        dy: (i - (n - 1) / 2) * step,


        insetTop: 5,


        insetBottom: 5,


        tip: {


          format: { crop: true, hazard: true, value: hz_q2_relative ? fmtPct : fmtAbs }


        }


      }


    ))


  }


  


  const diffMarks = hz_q2_showCompound
      ? (() => {
          const pos = (diffData ?? []).filter(d => Number(d?.value ?? 0) > 0)
          const neg = (diffData ?? []).filter(d => Number(d?.value ?? 0) < 0)
          const mk = []
          const tipFmt = { crop: true, hazard: true, value: hz_q2_relative ? fmtPct : fmtAbs }
          if (pos.length) {
            mk.push(Plot.barX(pos, Plot.stackX({
              x: "value",
              y: "crop",
              fill: "hazard",
              tip: { format: tipFmt }
            })))
          }
          if (neg.length) {
            mk.push(Plot.barX(neg, Plot.stackX({
              x: "value",
              y: "crop",
              fill: "hazard",
              tip: { format: tipFmt }
            })))
          }
          return mk
        })()
      : groupedMarks(diffData, hazLevelsChart)
return html`
    <div class="hz-legendRow">${legend}</div>
    ${Plot.plot({
      height,
      marginLeft: 180,
      marginRight: 18,
      marginTop: 10,
      marginBottom: 30,
      x: { label: xLabelDiff, grid: true, tickFormat: tickFmt },
      y: { domain: crops, label: null },
      color,
      marks: [Plot.ruleX([0]), ...diffMarks]
    })}
  `
}
```

```{ojs}
//| output: false
// ----------------------------
// Q2 — summary table (AtlasTable, same style as Q1)
// ----------------------------
hz_q2TableView = {
  const rows = Array.isArray(hz_q2Rows) ? hz_q2Rows : []
  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const sum1 = rows.reduce((s,r) => s + (r.total1 || 0), 0)
  const sum2 = rows.reduce((s,r) => s + (r.total2 || 0), 0)

  const showPct = !!hz_q2_relative

  const fmtAbsFull = (v) => hz_formatNumber(v, { digits: 2, compact: false })
  const fmtPct = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
  }

  const fmtPP = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    const sign = x > 0 ? "+" : ""
    return `${sign}${hz_formatNumber(x, { digits: 2, compact: false })} pp`
  }

  const tableData = rows.map((r) => {
    const p1 = sum1 ? (100 * r.total1 / sum1) : 0
    const p2 = sum2 ? (100 * r.total2 / sum2) : 0
    return ({
      "Crop": r.crop,
      "Left (abs)": r.total1,
      "Right (abs)": r.total2,
      "Δ (abs)": (r.total2 - r.total1),
      "Left (%)": p1,
      "Right (%)": p2,
      "Δ (pp)": (p2 - p1)
    })
  })

  return hz_atlasTable(tableData, {
    columns: showPct
      ? ["Crop", "Left (%)", "Right (%)", "Δ (pp)"]
      : ["Crop", "Left (abs)", "Right (abs)", "Δ (abs)"],
    format: {
      "Left (abs)": fmtAbsFull,
      "Right (abs)": fmtAbsFull,
      "Δ (abs)": fmtAbsFull,
      "Left (%)": fmtPct,
      "Right (%)": fmtPct,
      "Δ (pp)": fmtPP
    },
    rows: 12,
    height: "540px",
    width: {
      "Crop": 240,
      "Left (abs)": 140,
      "Right (abs)": 140,
      "Δ (abs)": 140,
      "Left (%)": 120,
      "Right (%)": 120,
      "Δ (pp)": 120
    }
  })
}
```


```{ojs}
//| output: false
// ----------------------------
// Q2 — Dynamic Insights (prototype parity)
// ----------------------------
hz_q2InsightView = {
  const ok = !!hz_q2Meta?.ok
  if (!ok) {
    const err = hz_q2Meta?.error ?? "Missing required inputs."
    return html`<div class="hz-muted">Insights unavailable: ${err}</div>`
  }

  const denomMap = hz_q2DenomMap ?? new Map()
  const rowsL = Array.isArray(hz_q2DataL) ? hz_q2DataL : []
  const rowsR = Array.isArray(hz_q2DataR) ? hz_q2DataR : []

  const safe = (x) => {
    const v = Number(x)
    return Number.isFinite(v) ? v : 0
  }

  const prettyHaz = (h) => {
    const raw = String(h ?? "").trim()
    if (!raw) return "—"
    const h0 = raw.replace(/\s*\(.*?\)\s*/g, "").trim()
    if (!h0) return "—"
    const low = h0.toLowerCase()
    if (low === "no hazard") return "No hazard"
    if (low === "any") return "Any hazard"

    const cap = (s) => {
      const t = String(s ?? "").trim().toLowerCase()
      if (!t) return ""
      if (t === "dry") return "Dry"
      if (t === "heat") return "Heat"
      if (t === "wet") return "Wet"
      return t.charAt(0).toUpperCase() + t.slice(1)
    }

    return h0.split("+").map(cap).join("+")
  }

  const anyMap = (rows) => {
    const m = new Map()
    for (const r of (rows ?? [])) {
      if (String(r?.hazard ?? "") !== "any") continue
      const crop = r?.crop
      if (!crop) continue
      m.set(crop, safe(r?.total ?? 0))
    }
    return m
  }

  const pickTopHaz = (rows, crop, pred) => {
    let bestH = null
    let bestV = -Infinity
    for (const r of (rows ?? [])) {
      if (r?.crop !== crop) continue
      const h = String(r?.hazard ?? "")
      if (!pred(h)) continue
      const v = safe(r?.total ?? 0)
      if (v > bestV) {
        bestV = v
        bestH = h
      }
    }
    return { hazard: bestH, value: (bestV === -Infinity ? 0 : bestV) }
  }

  const calcScenarioTable = (rows, label) => {
    const any = anyMap(rows)
    const crops = Array.from(new Set([...any.keys(), ...Array.from(denomMap.keys())]))

    const data = crops.map((crop) => {
      const denom = safe(denomMap.get(crop) || 0)
      const unit = safe(any.get(crop) || 0)
      const pct = denom > 0 ? (100 * unit / denom) : null

      const topAlone = pickTopHaz(rows, crop, (h) => {
        if (!h) return false
        if (h === "any" || h === "no hazard") return false
        return !h.includes("+")
      })

      const topComp = pickTopHaz(rows, crop, (h) => {
        if (!h) return false
        if (h === "any" || h === "no hazard") return false
        return h.includes("+")
      })

      const pctAlone = denom > 0 ? (100 * safe(topAlone.value) / denom) : null
      const pctComp = denom > 0 ? (100 * safe(topComp.value) / denom) : null

      const pctStr = (x) => (x == null ? "—" : `${hz_formatNumber(x, { digits: 1, compact: false })}%`)
      const topAloneStr = topAlone.hazard ? `${prettyHaz(topAlone.hazard)} ${pctStr(pctAlone)}` : "—"
      const topCompStr = topComp.hazard ? `${prettyHaz(topComp.hazard)} ${pctStr(pctComp)}` : "—"

      return { crop, unit, pct: (pct ?? 0), topAloneStr, topCompStr }
    })

    data.sort((a, b) => (b.unit - a.unit))
    const top = data.slice(0, 5)

    const table = top.map((d) => ({
      "Commodity": d.crop,
      "Unit": d.unit,
      "%": d.pct,
      "Top Alone": d.topAloneStr,
      "Top Compound": d.topCompStr
    }))

    return { label, table }
  }

  const s1 = hz_s1?.label ?? "Left"
  const s2 = hz_s2?.label ?? "Right"
  const sev = hz_severityLabel ?? "selected"
  const nSel = (hz_selectedCommoditiesForReq ?? []).length
  const selTxt = nSel ? `${nSel}` : "your"

  const left = calcScenarioTable(rowsL, s1)
  const right = calcScenarioTable(rowsR, s2)

  const calcDiffTable = () => {
    const anyL = anyMap(rowsL)
    const anyR = anyMap(rowsR)
    const crops = Array.from(new Set([...anyL.keys(), ...anyR.keys(), ...Array.from(denomMap.keys())]))

    const byKey = (crop, h) => `${crop}||${h}`
    const mapL = new Map((rowsL ?? []).map((r) => [byKey(r?.crop ?? "", String(r?.hazard ?? "")), safe(r?.total ?? 0)]))
    const mapR = new Map((rowsR ?? []).map((r) => [byKey(r?.crop ?? "", String(r?.hazard ?? "")), safe(r?.total ?? 0)]))

    const diffRows = crops.map((crop) => {
      const denom = safe(denomMap.get(crop) || 0)
      const u1 = safe(anyL.get(crop) || 0)
      const u2 = safe(anyR.get(crop) || 0)
      const dU = u2 - u1
      const p1 = denom > 0 ? (100 * u1 / denom) : 0
      const p2 = denom > 0 ? (100 * u2 / denom) : 0
      const dP = p2 - p1

      const allHaz = new Set()
      for (const r of (rowsL ?? [])) if (r?.crop === crop) allHaz.add(String(r?.hazard ?? ""))
      for (const r of (rowsR ?? [])) if (r?.crop === crop) allHaz.add(String(r?.hazard ?? ""))

      const bestDelta = (pred) => {
        let bestH = null
        let bestAbs = -Infinity
        let bestDU = 0

        for (const h of allHaz) {
          if (!pred(h)) continue
          if (h === "any" || h === "no hazard") continue
          const v1 = safe(mapL.get(byKey(crop, h)) || 0)
          const v2 = safe(mapR.get(byKey(crop, h)) || 0)
          const du = v2 - v1
          const abs = Math.abs(du)
          if (abs > bestAbs) {
            bestAbs = abs
            bestH = h
            bestDU = du
          }
        }

        const dpp = denom > 0 ? (100 * bestDU / denom) : 0
        return { hazard: bestH, dpp }
      }

      const alone = bestDelta((h) => !String(h).includes("+"))
      const comp = bestDelta((h) => String(h).includes("+"))

      const fmtPP = (x) => {
        const v = Number(x)
        if (!Number.isFinite(v)) return "—"
        const sign = v > 0 ? "+" : ""
        return `${sign}${hz_formatNumber(v, { digits: 1, compact: false })} pp`
      }

      const topAlone = alone.hazard ? `${prettyHaz(alone.hazard)} ${fmtPP(alone.dpp)}` : "—"
      const topComp = comp.hazard ? `${prettyHaz(comp.hazard)} ${fmtPP(comp.dpp)}` : "—"

      return { crop, dU, dP, topAlone, topComp }
    })

    diffRows.sort((a, b) => (Math.abs(b.dU) - Math.abs(a.dU)))
    const top = diffRows.slice(0, 5)

    return top.map((d) => ({
      "Commodity": d.crop,
      "Δ Unit": d.dU,
      "Δ %": d.dP,
      "Top Δ Alone": d.topAlone,
      "Top Δ Compound": d.topComp
    }))
  }

  const diffTable = calcDiffTable()

  const fmtAbs = (v) => hz_formatNumber(v, { digits: 2, compact: false })
  const fmtPct = (v) => `${hz_formatNumber(v, { digits: 1, compact: false })}%`
  const fmtAbsSigned = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    const sign = x > 0 ? "+" : ""
    return `${sign}${hz_formatNumber(x, { digits: 2, compact: false })}`
  }
  const fmtPP = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    const sign = x > 0 ? "+" : ""
    return `${sign}${hz_formatNumber(x, { digits: 1, compact: false })} pp`
  }

  return html`<div>
    ${md`**Dynamic Insights**

Of ${selTxt} selected commodities, the most exposed commodities (in absolute terms) to **${sev}** hazards are:`}

    <div class="hz-insightSubhead">${left.label}</div>
    ${hz_atlasTable(left.table, {
      columns: ["Commodity", "Unit", "%", "Top Alone", "Top Compound"],
      rows: 5,
      height: "260px",
      format: { "Unit": fmtAbs, "%": fmtPct }
    })}

    <div class="hz-insightSubhead" style="margin-top:0.6rem">${right.label}</div>
    ${hz_atlasTable(right.table, {
      columns: ["Commodity", "Unit", "%", "Top Alone", "Top Compound"],
      rows: 5,
      height: "260px",
      format: { "Unit": fmtAbs, "%": fmtPct }
    })}

    ${md`These crops show the greatest absolute changes in **${sev}** exposure between **${s1}** and **${s2}**.`}

    ${hz_atlasTable(diffTable, {
      columns: ["Commodity", "Δ Unit", "Δ %", "Top Δ Alone", "Top Δ Compound"],
      rows: 5,
      height: "260px",
      format: { "Δ Unit": fmtAbsSigned, "Δ %": fmtPP }
    })}
  </div>`
}
```



```{ojs}
//| output: false
// ----------------------------
// Q3 — hazard by crop
// ----------------------------
hz_q3ReqExtra = ({ top_hazards: 10, top_crops: 12 })

hz_q3RespL = (hz_activeQuestion === "q3")
  ? await hz_apiDebouncedCached("q3L", "/api/v1/hz/hazard-by-crop", hz_sideReq(hz_src1, hz_s1, hz_q3ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q3RespR = (hz_activeQuestion === "q3")
  ? await hz_apiDebouncedCached("q3R", "/api/v1/hz/hazard-by-crop", hz_sideReq(hz_src2, hz_s2, hz_q3ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q3DataL = hz_q3RespL?.data ?? []
hz_q3DataR = hz_q3RespR?.data ?? []

hz_q3Meta = ({
  ok: !!(hz_q3RespL?.ok && hz_q3RespR?.ok),
  cached: !!(hz_q3RespL?.cached && hz_q3RespR?.cached),
  t_ms: Math.max(Number(hz_q3RespL?.t_ms || 0), Number(hz_q3RespR?.t_ms || 0)),
  error: hz_q3RespL?.error || hz_q3RespR?.error || null
})

hz_q3Chart = {
  const L = hz_q3DataL ?? []
  const R = hz_q3DataR ?? []
  if (!L.length && !R.length) return html`<div class="hz-muted">No data.</div>`

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`
  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })

  // Top crops by combined exposure (Left + Right)
  const cropTotals = new Map()
  const bump = (crop, v) => cropTotals.set(crop, (cropTotals.get(crop) || 0) + Number(v || 0))
  for (const d of R) bump(d.crop, d.total)
  for (const d of L) bump(d.crop, d.total)

  const maxCrops = Math.min(10, Number(hz_topN || 10))
  const crops = Array.from(cropTotals.entries())
    .sort((a,b) => b[1] - a[1])
    .slice(0, maxCrops)
    .map(([c]) => c)

  const hazards = Array.from(new Set([...L.map(d => d.hazard), ...R.map(d => d.hazard)])).sort()

  const filter = (data) =>
    data
      .filter(d => crops.includes(d.crop) && hazards.includes(d.hazard))
      .map(d => ({ crop: d.crop, hazard: d.hazard, total: Number(d.total || 0) }))

  // Shared categorical color scale (keeps left/right colors aligned)
  const color = { type: "categorical", domain: hazards, scheme: "tableau10", legend: false }
  const legend = Plot.legend({ color: { domain: hazards, scheme: "tableau10" }, columns: 3 })

  const plotStack = (data, title) => html`
    <div class="hz-mini hz-mini--stack">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(320, crops.length * 26, Number(hz_chartHeight ?? 520)),
        marginLeft: 160,
        marginRight: 18,
        marginTop: 10,
        marginBottom: 28,
        x: { label: (hz_varLabelAbs ?? "Exposure"), grid: true },
        y: { domain: crops, label: null },
        color,
          marks: [
          Plot.barX(filter(data), Plot.stackX({
            x: "total",
            y: "crop",
            fill: "hazard",
            tip: {
              format: {
                crop: true,
                hazard: true,
                total: fmtAbs
              }
            }
          })),
          Plot.ruleX([0])
        ]
      })}
    </div>
  `

  return html`
    <div class="hz-legendRow">${legend}</div>
    <div class="hz-grid2 hz-grid2--equal">
      ${plotStack(L, "Left")}
      ${plotStack(R, "Right")}
    </div>
  `
}

```

```{ojs}
//| output: false
// ----------------------------
// Q4 — totals by admin area
// ----------------------------
hz_q4ReqExtra = ({ group_child: false })

hz_q4RespL = (hz_activeQuestion === "q4")
  ? await hz_apiDebouncedCached("q4L", "/api/v1/hz/by-admin", hz_sideReq(hz_src1, hz_s1, hz_q4ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q4RespR = (hz_activeQuestion === "q4")
  ? await hz_apiDebouncedCached("q4R", "/api/v1/hz/by-admin", hz_sideReq(hz_src2, hz_s2, hz_q4ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q4DataL = hz_q4RespL?.data ?? []
hz_q4DataR = hz_q4RespR?.data ?? []

hz_q4Meta = ({
  ok: !!(hz_q4RespL?.ok && hz_q4RespR?.ok),
  cached: !!(hz_q4RespL?.cached && hz_q4RespR?.cached),
  t_ms: Math.max(Number(hz_q4RespL?.t_ms || 0), Number(hz_q4RespR?.t_ms || 0)),
  error: hz_q4RespL?.error || hz_q4RespR?.error || null
})

hz_q4Rows = {
  const mapL = new Map(hz_q4DataL.map(d => [(d.admin_name ?? d.admin), Number(d.total)]))
  const mapR = new Map(hz_q4DataR.map(d => [(d.admin_name ?? d.admin), Number(d.total)]))
  const names = Array.from(new Set([...mapL.keys(), ...mapR.keys()]))
  const rows = names.map(name => ({ name, total1: mapL.get(name) || 0, total2: mapR.get(name) || 0 }))
  rows.sort((a,b) => (b.total2 - a.total2) || (b.total1 - a.total1))
  return rows.slice(0, hz_topN)
}

hz_q4Chart = {
  const rows = hz_q4Rows ?? []
  const xLabel = hz_rel ? "Percent of side total (%)" : hz_varLabelAbs

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`

  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const sum1 = rows.reduce((s,r) => s + (r.total1 || 0), 0)
  const sum2 = rows.reduce((s,r) => s + (r.total2 || 0), 0)

  const v1 = (d) => hz_rel ? (sum1 ? (100 * d.total1 / sum1) : 0) : d.total1
  const v2 = (d) => hz_rel ? (sum2 ? (100 * d.total2 / sum2) : 0) : d.total2

  if (hz_compareMode === "diff") {
    const diff = rows.map(d => ({ name: d.name, delta: v2(d) - v1(d) }))
    return Plot.plot({
      height: Math.max(280, diff.length * 22, Number(hz_chartHeight ?? 520)),
      marginLeft: 180,
      x: { grid: true, label: hz_rel ? "Δ percentage points (Right − Left)" : "Δ exposure (Right − Left)" },
      y: { domain: diff.map(d => d.name) },
      marks: [
        Plot.ruleX([0]),
        Plot.barX(diff, { x: "delta", y: "name", tip: true })
      ]
    })
  }

  const names = rows.map(d => d.name)
  const left = rows.map(d => ({ name: d.name, value: v1(d) }))
  const right = rows.map(d => ({ name: d.name, value: v2(d) }))

  const plotSide = (data, title) => html`
    <div class="hz-mini">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(280, names.length * 22, Number(hz_chartHeight ?? 520)),
        marginLeft: 180,
        x: { grid: true, label: xLabel },
        y: { domain: names },
          marks: [
          Plot.barX(data, { x: "value", y: "name", tip: true }),
          Plot.ruleX([0])
        ]
      })}
    </div>
  `
  return html`<div class="hz-grid2">${plotSide(left, "Left")}${plotSide(right, "Right")}</div>`
}
```

```{ojs}
//| output: false

// ------------------------------------------------------------
// View mode toggle (Chart / Dashboard / Summary / Map / Raw records)
// (Copied from original hazardExposure.qmd to restore missing cell)
// ------------------------------------------------------------
viewof hz_viewMode = {
  // Q1 only: Chart + Summary table
  const form = Inputs.radio(
    ["chart", "table"],
    {
      label: "",
      value: "chart",
      format: (v) => ({ chart: "Chart", table: "Summary table" }[v] ?? v),
    }
  )

  form.classList.add("hz-viewToggle")

  const getScroller = () =>
    document.scrollingElement ||
    document.querySelector("#quarto-content") ||
    document.documentElement ||
    document.body

  const preserveAnchor = () => {
    const sc = getScroller()
    const y0 = sc.scrollTop
    const anchor = document.getElementById("q1")
    const a0 = anchor ? anchor.getBoundingClientRect().top : 0

    const restore = () => {
      const sc2 = getScroller()
      const anchor2 = document.getElementById("q1")
      const a1 = anchor2 ? anchor2.getBoundingClientRect().top : 0
      sc2.scrollTop = y0 + (a1 - a0)
    }

    // Restore after reactive reflow
    setTimeout(() => {
      restore()
      requestAnimationFrame(restore)
      requestAnimationFrame(restore)
    }, 0)
  }

  form.addEventListener(
    "change",
    () => {
      try {
        document.activeElement?.blur?.()
      } catch (_) {}
      preserveAnchor()
    },
    true
  )

  return form
}
// ------------------------------------------------------------
// Records-view controls (pager + sort). (Copied from the stable v3 notebook.)
// ------------------------------------------------------------
viewof hz_recordsSide = {
  const options = [
    { value: "left",  label: "Left" },
    { value: "right", label: "Right" }
  ];

  const root = document.createElement("div");
  root.className = "hz-tabs hz-tabs--small";

  const buttons = new Map();
  const paint = (v) => {
    for (const [val, btn] of buttons.entries()) btn.classList.toggle("is-active", val === v);
  };

  const set = (v, { silent = false } = {}) => {
    if (root.value === v) return;
    root.value = v;
    paint(v);
    if (!silent) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  for (const op of options) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "hz-tab";
    btn.textContent = op.label;
    btn.onclick = () => set(op.value);
    buttons.set(op.value, btn);
    root.appendChild(btn);
  }

  set("left", { silent: true });
  return root;
}

viewof hz_recordsSort = {
  const options = ["value_desc", "value_asc"]
  const labelMap = { value_desc: "Value ↓", value_asc: "Value ↑" }
  const sel = Inputs.select(options, {
    value: "value_desc",
    label: null,
    format: (d) => labelMap[d] ?? String(d)
  });
  sel.classList.add("hz-select");
  return sel;
}

viewof hz_recordsPageSize = {
  const options = [50, 100, 200, 500]
  const sel = Inputs.select(options, {
    value: 100,
    label: null,
    format: (d) => `${d} rows`
  });
  sel.classList.add("hz-select");
  return sel;
}

viewof hz_recordsPage = {
  const root = document.createElement("div");
  root.className = "hz-pager";
  root.value = 1;

  const prev = document.createElement("button");
  prev.type = "button";
  prev.className = "hz-btn hz-btn--sm";
  prev.textContent = "Prev";

  const label = document.createElement("div");
  label.className = "hz-pager__label";

  const next = document.createElement("button");
  next.type = "button";
  next.className = "hz-btn hz-btn--sm";
  next.textContent = "Next";

  const paint = () => { label.textContent = `Page ${root.value}`; };

  const set = (v, { silent = false } = {}) => {
    const n = Math.max(1, Number(v || 1));
    if (root.value === n) return;
    root.value = n;
    paint();
    if (!silent) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  prev.onclick = () => set(root.value - 1);
  next.onclick = () => set(root.value + 1);

  root.appendChild(prev);
  root.appendChild(label);
  root.appendChild(next);

  paint();
  return root;
}
```

```{ojs}
//| output: false
// Render main shell
hz_controlsMount = html`<div class="hz-mount"><div class="hz-loading">Loading controls…</div></div>`
hz_dashMount = html`<div class="hz-mount"><div class="hz-loading">Loading dashboard…</div></div>`

hz_chartHost  = html`<div class="hz-chartWrap"><div class="hz-loading">Loading chart…</div></div>`
hz_q1_insightHost = html`<div class="hz-qOverview hz-qInsight"><div class="hz-loading">Loading insight…</div></div>`
hz_q2_insightHost = html`<div class="hz-qOverview hz-qInsight"><div class="hz-loading">Loading insights…</div></div>`
hz_tableActionsHost = html`<div class="hz-actions"></div>`

hz_q1_downloadMount = {
  try {
    const rows = Array.isArray(hz_chartRows) ? hz_chartRows : []
    const data = rows.map((r) => ({
      "Hazard": r?.hazard ?? "",
      "Historic (Total)": r?.total1 ?? null,
      "Scenario (Total)": r?.total2 ?? null,
      "Difference (Total)": r?.total_diff ?? null,
      "Historic (%)": r?.perc1 ?? null,
      "Scenario (%)": r?.perc2 ?? null,
      "Difference (%)": r?.pct_diff ?? null
    }))
    hz_tableActionsHost.replaceChildren(downloadButton(data, "hazardExposure_q1_summary"))
  } catch (_) {}
  return null
}

hz_tableHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading table…</div></div>`
hz_mapHost  = html`<div class="hz-mapWrap"><div class="hz-loading">Loading map…</div></div>`
hz_recordsActionsHost = html`<div class="hz-actions"></div>`
hz_recordsHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading records…</div></div>`
hz_debugHost  = html``
hz_pathHost   = html``
hz_schemaHost = html``

// Register UI elements for cross-cell updates
hz_registerUi = {
  const ui = (globalThis.__ATLAS_HZ_UI__ ??= {})
  ui.chartWrap = hz_chartHost
  ui.tableWrap = hz_tableHost
  ui.mapWrap = hz_mapHost
  ui.recordsWrap = hz_recordsHost

  ui._busyCount = ui._busyCount ?? 0
  ui.setBusy = (on) => {
    ui._busyCount = Math.max(0, ui._busyCount + (on ? 1 : -1))
    const busy = ui._busyCount > 0
    try { ui.chartWrap?.classList.toggle("hz-chartWrap--busy", busy) } catch (_) {}
    try { ui.tableWrap?.classList.toggle("hz-tableWrap--busy", busy) } catch (_) {}
    try { ui.mapWrap?.classList.toggle("hz-mapWrap--busy", busy) } catch (_) {}
    try { ui.recordsWrap?.classList.toggle("hz-tableWrap--busy", busy) } catch (_) {}
  }

  return null
}

// Dashboard UI (static shell) — avoid re-rendering the whole card on view toggle.
hz_q1_settingsWrap = {
  const el = html`
  <div class="hz-qToolbar__right">
    <div class="hz-inlineToggles">
      <div class="hz-miniSetting"><span>Show %</span>${viewof hz_relative}</div>
      <div class="hz-miniSetting"><span>Difference</span>${viewof hz_difference}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Height</span>${viewof hz_q1ChartHeight}</div>
    </div>
  </div>
`;
  try { el.style.visibility = "visible" } catch (_) {}
  return el
}

hz_q1_chartCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header">
    <div class="hz-sideCard__title">Chart</div>
  </div>
  <div class="hz-sideCard__body">${hz_chartHost}</div>
</div>`

hz_q1_tableCard = {
  const el = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header">
    <div class="hz-sideCard__title">Summary table</div>
    <div class="hz-sideCard__right">${hz_tableActionsHost}</div>
  </div>
  <div class="hz-sideCard__body">${hz_tableHost}</div>
</div>`;
  try { el.style.display = "none" } catch (_) {}
  return el
}

// Wrap both result cards; we toggle visibility (display) instead of swapping nodes.
hz_q1_resultsWrap = {
  const wrap = html`<div class="hz-qResults"></div>`
  wrap.append(hz_q1_chartCard, hz_q1_tableCard)
  return wrap
}

// Apply current view mode without rebuilding the whole Q1 card.
hz_q1_applyView = {
  const mode = (hz_viewMode || "chart")
  try { hz_q1_chartCard.style.display = (mode === "chart") ? "" : "none" } catch (_) {}
  try { hz_q1_tableCard.style.display = (mode === "table") ? "" : "none" } catch (_) {}
  try { hz_q1_settingsWrap.style.visibility = "visible" } catch (_) {}
  return null
}

// Dashboard shell renders once; inner parts update via hz_q1_applyView + mount cells.
hz_dashboardShell = html`
  <div class="hz-card">
    <div class="hz-card__body">
      <div class="hz-qToolbar">
        <div class="hz-qToolbar__left">${viewof hz_viewMode}</div>
        ${hz_q1_settingsWrap}
      </div>

      <div class="hz-vizWrap">
        ${hz_q1_resultsWrap}
      </div>
      ${hz_q1_insightHost}
    </div>
  </div>
`;


// --------------------------
// Q2–Q4: independent controls
// --------------------------
// (These are not yet connected to queries/outputs; they exist now so each question has its own state.)

viewof hz_q2_viewMode = Inputs.radio(["chart", "table"], {
  label: "",
  value: "chart",
  format: (v) => ({ chart: "Chart", table: "Summary table" }[v] ?? v)
})
hz_q2_viewMode.classList?.add?.("hz-viewToggle")

viewof hz_q2_relative = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q2_difference = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q2_showCompound = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q2_simplifyCompound = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))

viewof hz_q2_includeNoHazard = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q2_includeDecreases = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q2_topN = Inputs.range([5, 50], { label: "", step: 1, value: 25 })

viewof hz_q2_chartHeight = Inputs.range([360, 900], { label: "", step: 10, value: 520 })


viewof hz_q3_relative = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q3_showCompound = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q3_simplifyCompound = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q3_includeNoHazard = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q3_includeDecreases = hz_noJumpInput(Inputs.toggle({ label: "", value: false }))
viewof hz_q3_topN = Inputs.range([5, 50], { label: "", step: 1, value: 8 })
viewof hz_q3_chartHeight = Inputs.range([360, 900], { label: "", step: 10, value: 520 })
viewof hz_q4_viewMode = Inputs.radio(["chart", "both", "table", "map"], {
  label: "",
  value: "both",
  format: (v) => ({ chart: "Chart", both: "Dashboard", table: "Summary", map: "Map" }[v] ?? v)
})
viewof hz_q4_chartHeight = Inputs.range([360, 900], { label: "Chart height:", step: 10, value: 520 })

// Dataset / scenarios (duplicated for now, independent per question)
viewof hz_q2_varShort = Inputs.select(hz_varShortOptions ?? [], { label: "Hazard variable", value: (hz_varShortOptions ?? [])[0], format: hz_formatVarShort })
viewof hz_q2_period = Inputs.select(hz_periodOptions ?? [], { label: "Period", value: (hz_periodOptions ?? [])[0], format: hz_formatPeriod })
viewof hz_q2_severity = Inputs.select(hz_severityOptions ?? [], { label: "Severity", value: (hz_severityOptions ?? [])[0], format: hz_formatSeverity })

viewof hz_q2_scen1 = Inputs.select(hz_scenOptions ?? [], { label: "Left", value: (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q2_scen2 = Inputs.select(hz_scenOptions ?? [], { label: "Right", value: (hz_scenOptions ?? [])[1] ?? (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q2_compareMode = Inputs.radio(["side", "diff"], { label: "Compare", value: "side", format: (v) => ({ side: "Side-by-side", diff: "Δ (Right − Left)" }[v] ?? v) })
viewof hz_q2_method = Inputs.select(hz_methodOptions ?? [], { label: "Method", value: (hz_methodOptions ?? [])[0] ?? "auto" })

// Commodities (enhanced multiselect, climateRationale-style)
viewof hz_q2_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], { label: "Group", value: "crops", format: hz_commodityGroupLabel })
hz_q2_commodityOptions = {
  const g = hz_q2_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  return [...(hz_spamCodes?.crops ?? []), ...(hz_livestock ?? [])].filter(Boolean).sort()
}

hz_safeEnhancedMultiSelect = (options, cfg = {}) => {
  const label = cfg.label ?? "Select"
  const placeholder = cfg.placeholder ?? "Search…"
  const disabled = !!cfg.disabled

  // Normalize selected values to plain strings
  const value = (Array.isArray(cfg.value) ? cfg.value : [])
    .map(v => (v && typeof v === "object") ? (v.value ?? v.name ?? v.label ?? v.id ?? v) : v)
    .map(v => String(v ?? "").trim())
    .filter(Boolean)

  // Normalize options into {value,label} with *string* values.
  const rows = (options ?? [])
    .map((o) => {
      if (o == null) return null
      if (typeof o === "string" || typeof o === "number") {
        const v = String(o).trim()
        if (!v) return null
        const lbl = (typeof cfg.format === "function") ? String(cfg.format(v)) : v
        return { value: v, label: lbl }
      }
      if (typeof o === "object") {
        const v = String(o.value ?? o.id ?? o.key ?? o.name ?? "").trim()
        if (!v) return null
        const lbl = String(o.label ?? o.name ?? o.value ?? v)
        return { value: v, label: lbl }
      }
      return null
    })
    .filter(Boolean)

  const map = new Map(rows.map(r => [r.value, r.label]))
  const values = Array.from(new Set(rows.map(r => r.value)))

  const format = (v) => map.get(String(v)) ?? String(v)

  const viewofSelect = Inputs.select(values, {
    label,
    multiple: true,
    value,
    disabled,
    format
  })

  return enhancedMultiSelect(viewofSelect, {
    placeholder,
    requireAtLeastOne: false,
    maxHeight: cfg.maxHeight ?? 200,
    width: cfg.width ?? "100%"
  })
}

viewof hz_q2_commodities = hz_safeEnhancedMultiSelect(
  (hz_q2_commodityOptions ?? []).map(v => ({ value: v, label: hz_commodityLabelOf(v) })),
  { label: "Commodities", value: [] , placeholder: "Search commodities…" }
)

// Geography UI (exact Atlas boundary UI)
viewof hz_q2_admin0 = renderA0Multi({ key: "q2", maxSelections: 8 })
viewof hz_q2_admin1 = renderA1Multi({ key: "q2", a0: viewof hz_q2_admin0, maxSelections: 12 })
viewof hz_q2_admin2 = renderA2Multi({ key: "q2", a0: viewof hz_q2_admin0, a1: viewof hz_q2_admin1, maxSelections: 20 })
hz_q2_geoUI = inputTemplate()([viewof hz_q2_admin0, viewof hz_q2_admin1, viewof hz_q2_admin2])

hz_normSel2 = (x) => {
  const arr = x == null ? [] : (Array.isArray(x) ? x : [x])
  const toStr = (d) => {
    if (d == null) return ""
    if (typeof d === "string" || typeof d === "number") return String(d)
    if (typeof d === "object") {
      if ("admin2_name" in d) return d.admin2_name == null ? "" : String(d.admin2_name)
      if ("admin1_name" in d) return d.admin1_name == null ? "" : String(d.admin1_name)
      if ("admin0_name" in d) return d.admin0_name == null ? "" : String(d.admin0_name)
      return String(d.value ?? d.name ?? d.label ?? d.id ?? "")
    }
    return String(d)
  }
  return arr.map(toStr).map((s) => String(s).trim()).filter((s) => s.length > 0)
}
hz_q2_geoFilter = ({ admin0: hz_normSel2(hz_q2_admin0), admin1: hz_normSel2(hz_q2_admin1), admin2: hz_normSel2(hz_q2_admin2) })

hz_makeGeoLabel = (gf) => {
  const a0 = Array.isArray(gf?.admin0) ? gf.admin0.filter(Boolean) : []
  const a1 = Array.isArray(gf?.admin1) ? gf.admin1.filter(Boolean) : []
  const a2 = Array.isArray(gf?.admin2) ? gf.admin2.filter(Boolean) : []
  const hasAll = a0.length === 0 || a0.includes("all")
  const fmt = (arr, max = 2) => {
    const xs = arr.slice(0, max)
    const more = arr.length > max ? ` +${arr.length - max}` : ""
    return xs.join(", ") + more
  }
  if (hasAll) return "All"
  if (a2.length) return `ADM2: ${fmt(a2)}`
  if (a1.length) return `ADM1: ${fmt(a1)}`
  return `ADM0: ${fmt(a0)}`
}

hz_makeComLabel = (arr) => {
  const xs = (arr ?? []).map(v => (v?.value ?? v)).filter(Boolean)
  if (!xs.length) return "All"
  const head = xs.slice(0, 2).map(hz_commodityLabelOf).join(", ")
  const more = xs.length > 2 ? ` +${xs.length - 2}` : ""
  return head + more
}

// ------------------------------------------------------------
// Q3/Q4 dataset + commodities + geography (independent controls)
// ------------------------------------------------------------
viewof hz_q3_varShort = Inputs.select(hz_varShortOptions ?? [], { label: "Hazard variable", value: (hz_varShortOptions ?? [])[0], format: hz_formatVarShort })
viewof hz_q3_period = Inputs.select(hz_periodOptions ?? [], { label: "Period", value: (hz_periodOptions ?? [])[0], format: hz_formatPeriod })
viewof hz_q3_severity = Inputs.select(hz_severityOptions ?? [], { label: "Severity", value: (hz_severityOptions ?? [])[0], format: hz_formatSeverity })
viewof hz_q3_scen1 = Inputs.select(hz_scenOptions ?? [], { label: "Left", value: (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q3_scen2 = Inputs.select(hz_scenOptions ?? [], { label: "Right", value: (hz_scenOptions ?? [])[1] ?? (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q3_compareMode = Inputs.radio(["side", "diff"], { label: "Compare", value: "side", format: (v) => ({ side: "Side-by-side", diff: "Δ (Right − Left)" }[v] ?? v) })
viewof hz_q3_method = Inputs.select(hz_methodOptions ?? [], { label: "Method", value: (hz_methodOptions ?? [])[0] ?? "auto" })

viewof hz_q3_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], { label: "Group", value: "crops", format: hz_commodityGroupLabel })
hz_q3_commodityOptions = {
  const g = hz_q3_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  return [...(hz_spamCodes?.crops ?? []), ...(hz_livestock ?? [])].filter(Boolean).sort()
}
viewof hz_q3_commodities = hz_safeEnhancedMultiSelect(
  (hz_q3_commodityOptions ?? []).map(v => ({ value: v, label: hz_commodityLabelOf(v) })),
  { label: "Commodities", value: [], placeholder: "Search commodities…" }
)

viewof hz_q3_admin0 = renderA0Multi({ key: "q3", maxSelections: 8 })
viewof hz_q3_admin1 = renderA1Multi({ key: "q3", a0: viewof hz_q3_admin0, maxSelections: 12 })
viewof hz_q3_admin2 = renderA2Multi({ key: "q3", a0: viewof hz_q3_admin0, a1: viewof hz_q3_admin1, maxSelections: 20 })
hz_q3_geoUI = inputTemplate()([viewof hz_q3_admin0, viewof hz_q3_admin1, viewof hz_q3_admin2])
hz_q3_geoFilter = ({ admin0: hz_normSel2(hz_q3_admin0), admin1: hz_normSel2(hz_q3_admin1), admin2: hz_normSel2(hz_q3_admin2) })

viewof hz_q4_varShort = Inputs.select(hz_varShortOptions ?? [], { label: "Hazard variable", value: (hz_varShortOptions ?? [])[0], format: hz_formatVarShort })
viewof hz_q4_period = Inputs.select(hz_periodOptions ?? [], { label: "Period", value: (hz_periodOptions ?? [])[0], format: hz_formatPeriod })
viewof hz_q4_severity = Inputs.select(hz_severityOptions ?? [], { label: "Severity", value: (hz_severityOptions ?? [])[0], format: hz_formatSeverity })
viewof hz_q4_scen1 = Inputs.select(hz_scenOptions ?? [], { label: "Left", value: (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q4_scen2 = Inputs.select(hz_scenOptions ?? [], { label: "Right", value: (hz_scenOptions ?? [])[1] ?? (hz_scenOptions ?? [])[0], format: hz_formatScenXTime })
viewof hz_q4_compareMode = Inputs.radio(["side", "diff"], { label: "Compare", value: "side", format: (v) => ({ side: "Side-by-side", diff: "Δ (Right − Left)" }[v] ?? v) })
viewof hz_q4_method = Inputs.select(hz_methodOptions ?? [], { label: "Method", value: (hz_methodOptions ?? [])[0] ?? "auto" })

viewof hz_q4_commodityGroup = Inputs.select(hz_commodityGroupOptions ?? [], { label: "Group", value: "crops", format: hz_commodityGroupLabel })
hz_q4_commodityOptions = {
  const g = hz_q4_commodityGroup
  if (g === "livestock") return hz_livestock ?? []
  if (g === "crops") return (hz_spamCodes?.crops ?? [])
  if (g === "cereals") return (hz_spamCodes?.groups?.cereals ?? [])
  if (g === "legumes") return (hz_spamCodes?.groups?.legumes ?? [])
  if (g === "roots_tubers") return (hz_spamCodes?.groups?.roots_tubers ?? [])
  return [...(hz_spamCodes?.crops ?? []), ...(hz_livestock ?? [])].filter(Boolean).sort()
}
viewof hz_q4_commodities = hz_safeEnhancedMultiSelect(
  (hz_q4_commodityOptions ?? []).map(v => ({ value: v, label: hz_commodityLabelOf(v) })),
  { label: "Commodities", value: [], placeholder: "Search commodities…" }
)

viewof hz_q4_admin0 = renderA0Multi({ key: "q4", maxSelections: 8 })
viewof hz_q4_admin1 = renderA1Multi({ key: "q4", a0: viewof hz_q4_admin0, maxSelections: 12 })
viewof hz_q4_admin2 = renderA2Multi({ key: "q4", a0: viewof hz_q4_admin0, a1: viewof hz_q4_admin1, maxSelections: 20 })
hz_q4_geoUI = inputTemplate()([viewof hz_q4_admin0, viewof hz_q4_admin1, viewof hz_q4_admin2])
hz_q4_geoFilter = ({ admin0: hz_normSel2(hz_q4_admin0), admin1: hz_normSel2(hz_q4_admin1), admin2: hz_normSel2(hz_q4_admin2) })

hz_q2_controlsSummary = {
  const left = hz_parseScenarioPick(hz_q2_scen1)?.label ?? String(hz_q2_scen1 ?? "")
  const right = hz_parseScenarioPick(hz_q2_scen2)?.label ?? String(hz_q2_scen2 ?? "")
  const geo = hz_makeGeoLabel(hz_q2_geoFilter)
  const com = hz_makeComLabel(hz_q2_commodities ?? [])
  return `${hz_formatVarShort(hz_q2_varShort)} · ${hz_formatPeriod(hz_q2_period)} · ${hz_formatSeverity(hz_q2_severity)} · ${left} vs ${right} · Geo: ${geo} · Com: ${com}`
}

hz_q2_controlsPanel = html`
  <div class="hz-controlsCompact hz-controlsPanel">
    <div class="hz-controlsGrid2">
      <div class="hz-field">${viewof hz_q2_varShort}</div>
      <div class="hz-field">${viewof hz_q2_period}</div>

      <div class="hz-field">${viewof hz_q2_severity}</div>
      <div class="hz-field">${viewof hz_q2_method}</div>

      <div class="hz-field">${viewof hz_q2_scen1}</div>
      <div class="hz-field">${viewof hz_q2_scen2}</div>

      <div class="hz-field hz-field--full">
        <div class="hz-inlineRow hz-inlineRow--commodities">
          <div class="hz-inlineRow__small">${viewof hz_q2_commodityGroup}</div>
          <div class="hz-inlineRow__grow">${viewof hz_q2_commodities}</div>
        </div>
      </div>
      <div class="hz-field hz-field--full">${hz_q2_geoUI}</div>
    </div>
  </div>
`;

hz_q2_settingsWrap = html`
  <div class="hz-qToolbar__right">
    <div class="hz-inlineToggles">
      <div class="hz-miniSetting"><span>Show %</span>${viewof hz_q2_relative}</div>
      <div class="hz-miniSetting"><span>Show differences</span>${viewof hz_q2_difference}</div>
      <div class="hz-miniSetting"><span>Show compound hazards</span>${viewof hz_q2_showCompound}</div>
      <div class="hz-miniSetting"><span>Simplify compound hazards</span>${viewof hz_q2_simplifyCompound}</div>
      <div class="hz-miniSetting"><span>Include no hazard</span>${viewof hz_q2_includeNoHazard}</div>
      ${hz_q2_difference ? html`<div class="hz-miniSetting"><span>Include decreases</span>${viewof hz_q2_includeDecreases}</div>` : ""}
      <div class="hz-miniSetting hz-miniSetting--range"><span>Number of commodities</span>${viewof hz_q2_topN}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Height</span>${viewof hz_q2_chartHeight}</div>
    </div>
  </div>
`
;

hz_q2_chartHost = html`<div class="hz-chartWrap hz-chartHost"><div class="hz-loading">Loading chart…</div></div>`
hz_q2_tableHost = html`<div class="hz-tableWrap hz-tableHost"><div class="hz-loading">Loading table…</div></div>`
// Q2 busy overlay controller (mirrors Q1 “Updating…” overlay).
hz_q2_ui = {
  const ui = (globalThis.__ATLAS_HZ_UI_Q2__ ??= {})
  ui.chartWrap = hz_q2_chartHost
  ui.tableWrap = hz_q2_tableHost
  ui._busyCount = ui._busyCount ?? 0
  ui.setBusy = (on) => {
    ui._busyCount = Math.max(0, ui._busyCount + (on ? 1 : -1))
    const busy = ui._busyCount > 0
    try { ui.chartWrap?.classList.toggle("hz-chartWrap--busy", busy) } catch (_) {}
    try { ui.tableWrap?.classList.toggle("hz-tableWrap--busy", busy) } catch (_) {}
  }
  return null
}


hz_q2_chartCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header"><div class="hz-sideCard__title">Chart</div></div>
  <div class="hz-sideCard__body">${hz_q2_chartHost}</div>
</div>`;

hz_q2_tableCard = html`<div class="hz-sideCard">
  <div class="hz-sideCard__header"><div class="hz-sideCard__title">Summary table</div></div>
  <div class="hz-sideCard__body">${hz_q2_tableHost}</div>
</div>`;

hz_q2_applyView = {
  const mode = (hz_q2_viewMode || "chart");
  try { hz_q2_chartCard.style.display = (mode === "chart") ? "" : "none"; } catch (_) {}
  try { hz_q2_tableCard.style.display = (mode === "table") ? "" : "none"; } catch (_) {}
  try { hz_q2_settingsWrap.style.visibility = "visible"; } catch (_) {}
  return null;
};


// Mount Q2 outputs into stable hosts (prevents scroll jumps on toggle changes)
hz_q2_mountChart = {
  hz_q2_chartHost.replaceChildren(hz_q2Chart)
  return null
}

hz_q2_mountTable = {
  hz_q2_tableHost.replaceChildren(hz_q2TableView)
  return null
}


hz_q2_mountInsight = {
  hz_q2_insightHost.replaceChildren(hz_q2InsightView)
  return null
}

hz_q2_dashboardCard = hz_noJumpRoot(html`
<div class="hz-card">
  <div class="hz-card__body">
    <div class="hz-qOverview">${md`${q2DetailText}`}</div>

        <div class="hz-qToolbar">
      <div class="hz-qToolbar__left">${viewof hz_q2_viewMode}</div>
      ${hz_q2_settingsWrap}
    </div>

    <div class="hz-vizWrap">
      <div class="hz-qResults">
        ${hz_q2_chartCard}
        ${hz_q2_tableCard}
      </div>
    </div>

    ${hz_q2_insightHost}
  </div>
</div>
`);

// ------------------------------------------------------------
// Q3/Q4 Controls (incremental dev placeholders)
// ------------------------------------------------------------
hz_q3_controlsPanel = html`
  <div class="hz-controlsCompact hz-controlsPanel">
    <div class="hz-controlsGrid2">
      <div class="hz-field">${viewof hz_q3_varShort}</div>
      <div class="hz-field">${viewof hz_q3_period}</div>

      <div class="hz-field">${viewof hz_q3_severity}</div>
      <div class="hz-field">${viewof hz_q3_method}</div>

      <div class="hz-field">${viewof hz_q3_scen1}</div>
      <div class="hz-field">${viewof hz_q3_scen2}</div>

      <div class="hz-field">${viewof hz_q3_compareMode}</div>
      <div class="hz-field"></div>

      <div class="hz-field hz-field--full">
        <div class="hz-inlineRow hz-inlineRow--commodities">
          <div class="hz-inlineRow__small">${viewof hz_q3_commodityGroup}</div>
          <div class="hz-inlineRow__grow">${viewof hz_q3_commodities}</div>
        </div>
      </div>
      <div class="hz-field hz-field--full">${hz_q3_geoUI}</div>
    </div>
  </div>
`;

hz_q4_controlsPanel = html`
  <div class="hz-controlsCompact hz-controlsPanel">
    <div class="hz-controlsGrid2">
      <div class="hz-field">${viewof hz_q4_varShort}</div>
      <div class="hz-field">${viewof hz_q4_period}</div>

      <div class="hz-field">${viewof hz_q4_severity}</div>
      <div class="hz-field">${viewof hz_q4_method}</div>

      <div class="hz-field">${viewof hz_q4_scen1}</div>
      <div class="hz-field">${viewof hz_q4_scen2}</div>

      <div class="hz-field">${viewof hz_q4_compareMode}</div>
      <div class="hz-field"></div>

      <div class="hz-field hz-field--full">
        <div class="hz-inlineRow hz-inlineRow--commodities">
          <div class="hz-inlineRow__small">${viewof hz_q4_commodityGroup}</div>
          <div class="hz-inlineRow__grow">${viewof hz_q4_commodities}</div>
        </div>
      </div>
      <div class="hz-field hz-field--full">${hz_q4_geoUI}</div>
    </div>
  </div>
`;


// ------------------------------------------------------------
// Q3 — Hazard overlap (UpSet)
// Uses /api/v1/hz/q2 and builds intersections by splitting hazard on "+".
// Notes:
// - "no hazard" is excluded from intersections by design (can be shown as KPI).
// - Q3 makes its own call using groupKey "q3" so it can show its own Updating… overlay.
// ------------------------------------------------------------
hz_q3_chartHost = html`<div class="hz-chartWrap hz-chartHost"><div class="hz-loading">Loading chart…</div></div>`

// Q3 busy overlay controller (mirrors Q1/Q2 “Updating…” overlay).
hz_q3_ui = {
  const ui = (globalThis.__ATLAS_HZ_UI_Q3__ ??= {})
  ui.chartWrap = hz_q3_chartHost
  ui._busyCount = ui._busyCount ?? 0
  ui.setBusy = (on) => {
    ui._busyCount = Math.max(0, ui._busyCount + (on ? 1 : -1))
    const busy = ui._busyCount > 0
    try { ui.chartWrap?.classList.toggle("hz-chartWrap--busy", busy) } catch (_) {}
  }
  return null
}


hz_q3_settingsWrap = html`
  <div class="hz-qToolbar__right">
    <div class="hz-inlineToggles">
      <div class="hz-miniSetting"><span>Show %</span>${viewof hz_q3_relative}</div>
      <div class="hz-miniSetting"><span>Show compound hazards</span>${viewof hz_q3_showCompound}</div>
      <div class="hz-miniSetting"><span>Simplify compound hazards</span>${viewof hz_q3_simplifyCompound}</div>
      <div class="hz-miniSetting"><span>Include no hazard</span>${viewof hz_q3_includeNoHazard}</div>
      <div class="hz-miniSetting"><span>Include decreases in Δ</span>${viewof hz_q3_includeDecreases}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>No. commodities Q3</span>${viewof hz_q3_topN}</div>
      <div class="hz-miniSetting hz-miniSetting--range"><span>Height</span>${viewof hz_q3_chartHeight}</div>
    </div>
  </div>
`

hz_q3ReqBody = (() => {
  // Reuse the same guard logic as Q2 (shared dataset + geo payload)
  if (!hz_q2ReqOk.ok) return { ok: false, error: hz_q2ReqOk.error, body: null }

  const left = {
    dataset_url: hz_src1?.url,
    scen: { scenario: hz_s1?.scenario, timeframe: hz_s1?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
    top_crops: 999,
    bucket_other: false
  }

  const right = {
    dataset_url: hz_src2?.url,
    scen: { scenario: hz_s2?.scenario, timeframe: hz_s2?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
    top_crops: 999,
    bucket_other: false
  }

  const denom = {
    denom_url: hz_denomUrl,
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    exposure: hz_denomSpec?.exposure ?? null,
    unit: hz_denomSpec?.unit ?? null,
    exposure_unit: hz_denomSpec?.unit ?? hz_varShort
  }

  return { ok: true, error: null, body: { left, right, denom } }
})()

hz_q3Resp = hz_q3ReqBody.ok
  ? await hz_keepScroll(
      hz_apiDebouncedCached("q3", "/api/v1/hz/q2", hz_q3ReqBody.body, { ttlMs: 5 * 60 * 1000, debounceMs: 250 })
    )
  : ({ ok: false, error: (hz_q3ReqBody.error ?? "Missing required inputs"), left: [], right: [], denom_by_crop: [] })

hz_q3RowsL = hz_q3Resp.left ?? []
hz_q3RowsR = hz_q3Resp.right ?? []
hz_q3DenomByCrop = hz_q3Resp.denom_by_crop ?? []
hz_q3DenomTotal = (hz_q3DenomByCrop ?? []).reduce((s, d) => s + (Number(d?.value_tot) || 0), 0)

hz_q3_upsetPrep = (rows, denomTotal, { maxIntersections = 15 } = {}) => {
  const totalsByHaz = new Map()
  let anyTotal = 0

  for (const r of (rows ?? [])) {
    const hazRaw = r?.hazard
    const haz = (hazRaw == null) ? "" : String(hazRaw).trim()
    const v = Number(r?.total ?? 0)
    if (!haz || !Number.isFinite(v)) continue
    if (haz === "any") { anyTotal += v; continue }
    totalsByHaz.set(haz, (totalsByHaz.get(haz) ?? 0) + v)
  }

  // Atomic hazard sets from combinations (excluding "no hazard").
  const atomicSet = new Set()
  for (const haz of totalsByHaz.keys()) {
    if (haz === "no hazard") continue
    for (const a of haz.split("+")) {
      const t = a.trim()
      if (t) atomicSet.add(t)
    }
  }

  // Prefer dry/heat/wet ordering when present.
  const pref = ["dry", "heat", "wet"]
  const atomic = Array.from(atomicSet).sort((a, b) => {
    const ia = pref.indexOf(a), ib = pref.indexOf(b)
    if (ia !== -1 || ib !== -1) return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib)
    return a.localeCompare(b)
  })

  // Intersections (combinations), excluding "no hazard".
  let intersections = Array.from(totalsByHaz.entries())
    .filter(([haz]) => haz && haz !== "no hazard")
    .map(([haz, size]) => ({
      intersection: haz,
      sets: haz.split("+").map((s) => s.trim()).filter(Boolean),
      size: Number(size) || 0
    }))
    .filter((d) => d.sets.length > 0)

  intersections.sort((a, b) => (b.size - a.size) || a.intersection.localeCompare(b.intersection))
  intersections = intersections.slice(0, Math.max(1, Number(maxIntersections) || 15))

  // “Set size” bars (computed from displayed intersections)
  const setSizes = atomic.map((set) => {
    let size = 0
    for (const inter of intersections) if (inter.sets.includes(set)) size += inter.size
    return { set, size }
  })

  const denom = Number(denomTotal) || 0
  const noHazTotal = Math.max(0, denom - (Number(anyTotal) || 0))

  return {
    atomic,
    intersections,
    setSizes,
    anyTotal: Number(anyTotal) || 0,
    noHazTotal,
    denomTotal: denom
  }
}

hz_q3_upsetDelta = (L, R, { maxIntersections = 15 } = {}) => {
  const left = L ?? { atomic: [], intersections: [], anyTotal: 0, noHazTotal: 0, denomTotal: 0 }
  const right = R ?? { atomic: [], intersections: [], anyTotal: 0, noHazTotal: 0, denomTotal: 0 }

  const atomic = Array.from(new Set([...(left.atomic ?? []), ...(right.atomic ?? [])]))

  const mapL = new Map((left.intersections ?? []).map((d) => [d.intersection, d]))
  const mapR = new Map((right.intersections ?? []).map((d) => [d.intersection, d]))
  const keys = Array.from(new Set([...mapL.keys(), ...mapR.keys()]))

  let intersections = keys.map((k) => {
    const a = mapL.get(k)
    const b = mapR.get(k)
    const sets = (b?.sets ?? a?.sets ?? String(k).split("+").map((s) => s.trim()).filter(Boolean))
    const size = (Number(b?.size) || 0) - (Number(a?.size) || 0)
    return { intersection: String(k), sets, size }
  }).filter((d) => d.sets.length > 0)

  intersections.sort((a, b) => (Math.abs(b.size) - Math.abs(a.size)) || a.intersection.localeCompare(b.intersection))
  intersections = intersections.slice(0, Math.max(1, Number(maxIntersections) || 15))

  const setSizes = atomic.map((set) => {
    let size = 0
    for (const inter of intersections) if (inter.sets.includes(set)) size += inter.size
    return { set, size }
  })

  return {
    atomic,
    intersections,
    setSizes,
    anyTotal: (Number(right.anyTotal) || 0) - (Number(left.anyTotal) || 0),
    noHazTotal: (Number(right.noHazTotal) || 0) - (Number(left.noHazTotal) || 0),
    denomTotal: (Number(right.denomTotal) || 0) - (Number(left.denomTotal) || 0)
  }
}

hz_q3_fmt = (v) => {
  const n = Number(v) || 0
  const a = Math.abs(n)
  if (a >= 1e9) return `${(n / 1e9).toFixed(2)}B`
  if (a >= 1e6) return `${(n / 1e6).toFixed(2)}M`
  if (a >= 1e3) return `${(n / 1e3).toFixed(2)}k`
  return `${Math.round(n)}`
}

hz_q3_upsetFigure = (prep, { width = 900, height = 520, title = "", isDelta = false } = {}) => {
  const p = prep ?? { atomic: [], intersections: [], setSizes: [], anyTotal: 0, noHazTotal: 0, denomTotal: 0 }
  const sets = (p.atomic ?? [])
  const intersections = (p.intersections ?? [])
  const setSizes = (p.setSizes ?? [])

  if (!sets.length || !intersections.length) {
    return html`<div class="hz-loading">No overlap data available for the current filters.</div>`
  }

  const gap = 10
  const sideW = Math.min(240, Math.max(180, Math.round(width * 0.25)))
  const mainW = Math.max(360, width - sideW - gap)
  const upperH = Math.max(150, Math.round(height * 0.42))
  const lowerH = Math.max(220, height - upperH - 10)

  // index for columns
  const ix = intersections.map((d, i) => ({ ...d, i: i + 1 }))

  const dotsAll = []
  for (const inter of ix) {
    const s = new Set(inter.sets)
    for (const h of sets) dotsAll.push({ i: inter.i, hazard: h, on: s.has(h) })
  }
  const dotsOn = dotsAll.filter((d) => d.on)

  const lines = ix.map((inter) => {
    const present = sets.filter((h) => inter.sets.includes(h))
    if (present.length < 2) return null
    return { i: inter.i, y1: present[0], y2: present[present.length - 1] }
  }).filter(Boolean)

  const upper = Plot.plot({
    width: mainW,
    height: upperH,
    marginLeft: 44,
    marginRight: 8,
    marginTop: 10,
    marginBottom: 10,
    x: { label: null, axis: null, domain: ix.map((d) => d.i) },
    y: { label: null, grid: true },
    marks: [
      Plot.ruleY([0]),
      Plot.barY(ix, {
        x: "i",
        y: "size",
        title: (d) => `${d.intersection}\n${isDelta ? "Δ" : "Total"}: ${hz_q3_fmt(d.size)}`
      })
    ]
  })

  const matrix = Plot.plot({
    width: mainW,
    height: lowerH,
    marginLeft: 44,
    marginRight: 8,
    marginTop: 0,
    marginBottom: 30,
    x: { label: null, axis: null, domain: ix.map((d) => d.i) },
    y: { label: null, domain: sets, axis: "left" },
    marks: [
      Plot.ruleX(lines, { x: "i", y1: "y1", y2: "y2", strokeOpacity: 0.4 }),
      Plot.dot(dotsAll, { x: "i", y: "hazard", r: 4, fillOpacity: 0.2 }),
      Plot.dot(dotsOn, { x: "i", y: "hazard", r: 4.5 })
    ]
  })

  const setBars = Plot.plot({
    width: sideW,
    height: lowerH,
    marginLeft: 8,
    marginRight: 34,
    marginTop: 0,
    marginBottom: 30,
    x: { label: null, axis: "top", grid: true },
    y: { label: null, domain: sets, axis: "right" },
    marks: [
      Plot.ruleX([0]),
      Plot.barX(setSizes, {
        y: "set",
        x: "size",
        title: (d) => `${d.set}\n${isDelta ? "Δ" : "Total"}: ${hz_q3_fmt(d.size)}`
      })
    ]
  })

  const showNoHaz = Boolean(hz_q3_includeNoHazard)
  const denom = Number(p.denomTotal) || 0
  const anyPct = (!isDelta && denom > 0) ? (Number(p.anyTotal) || 0) / denom * 100 : null
  const noPct = (!isDelta && denom > 0) ? (Number(p.noHazTotal) || 0) / denom * 100 : null

  return html`<div style="display:flex;flex-direction:column;gap:10px;">
    ${title ? html`<div class="hz-miniTitle">${title}</div>` : null}
    <div style="overflow-x:auto;">${upper}</div>
    <div style="display:grid;grid-template-columns: 1fr ${sideW}px;gap:${gap}px;align-items:start;overflow-x:auto;">
      <div>${matrix}</div>
      <div>${setBars}</div>
    </div>
    <div class="hz-muted" style="display:flex;gap:14px;flex-wrap:wrap;">
      <span><strong>${isDelta ? "Δ Any hazard" : "Any hazard"}</strong>: ${hz_q3_fmt(p.anyTotal)}${anyPct != null ? ` (${anyPct.toFixed(1)}%)` : ""}</span>
      ${showNoHaz ? html`<span><strong>${isDelta ? "Δ No hazard" : "No hazard"}</strong>: ${hz_q3_fmt(p.noHazTotal)}${noPct != null ? ` (${noPct.toFixed(1)}%)` : ""}</span>` : null}
    </div>
  </div>`
}

hz_q3Charts = {
  if (!hz_q3Resp?.ok) {
    return html`<div class="hz-loading"><strong>Unable to load Q3.</strong> ${hz_q3Resp?.error ?? "Unknown error"}</div>`
  }

  const num = (x) => {
    const v = Number(x)
    return Number.isFinite(v) ? v : 0
  }
  const clampPct = (x) => Math.max(-100, Math.min(100, x))
  const prettyHaz = (h) => {
    const s = String(h ?? "")
    if (!s) return "—"
    return s
      .replace(" (any)", "")
      .replace(" (only)", " only")
      .replace(/\+/g, " + ")
  }

  const leftRows = Array.isArray(hz_q3RowsL) ? hz_q3RowsL : []
  const rightRows = Array.isArray(hz_q3RowsR) ? hz_q3RowsR : []
  const denomByCrop = Array.isArray(hz_q3DenomByCrop) ? hz_q3DenomByCrop : []
  const denomMap = new Map(denomByCrop.map(d => [d?.crop, num(d?.value_tot)]))
  const denomTotal = num(hz_q3DenomTotal) || Array.from(denomMap.values()).reduce((a,b) => a + b, 0)

  // Helper maps: crop -> any exposure
  const anyMap = (rows) => {
    const m = new Map()
    for (const r of rows) {
      if (String(r?.hazard ?? "") !== "any") continue
      const crop = r?.crop
      if (!crop) continue
      m.set(crop, num(r?.total))
    }
    return m
  }
  const anyL = anyMap(leftRows)
  const anyR = anyMap(rightRows)

  // Add "no hazard" (per crop): total production - any hazard exposure
  const withNoHazard = (rows, any) => {
    const out = rows.slice()
    const crops = new Set([...Array.from(denomMap.keys()), ...rows.map(r => r?.crop).filter(Boolean)])
    for (const crop of crops) {
      const tot = num(denomMap.get(crop))
      const exposed = num(any.get(crop))
      out.push({ hazard: "no hazard", crop, total: Math.max(0, tot - exposed) })
    }
    return out
  }
  const L0 = withNoHazard(leftRows, anyL)
  const R0 = withNoHazard(rightRows, anyR)

  const toExclusive = (rows) => {
    const out = []
    for (const r of rows) {
      const h0 = String(r?.hazard ?? "")
      const crop = r?.crop
      if (!crop) continue
      const v = num(r?.total)
      if (h0 === "any") continue
      if (h0 === "dry") out.push({ hazard: "dry (only)", crop, total: v })
      else if (h0 === "heat") out.push({ hazard: "heat (only)", crop, total: v })
      else if (h0 === "wet") out.push({ hazard: "wet (only)", crop, total: v })
      else if (h0 === "no hazard") out.push({ hazard: "no hazard", crop, total: v })
      else if (h0 === "dry+heat" || h0 === "dry+wet" || h0 === "heat+wet" || h0 === "dry+heat+wet") out.push({ hazard: h0, crop, total: v })
    }
    return out
  }

  const simplifyExclusive = (rows) => {
    const bucket = (h) => {
      if (h === "no hazard") return "no hazard"
      const core = String(h ?? "").replace(" (only)", "")
      const n = core.split("+").filter(Boolean).length
      if (n === 1) return "1 hazard"
      if (n === 2) return "2 hazards"
      if (n === 3) return "3 hazards"
      return null
    }
    const agg = new Map()
    for (const r of rows) {
      const crop = r?.crop
      if (!crop) continue
      const b = bucket(String(r?.hazard ?? ""))
      if (!b) continue
      const key = `${crop}||${b}`
      agg.set(key, (agg.get(key) || 0) + num(r?.total))
    }
    const out = []
    for (const [key, total] of agg.entries()) {
      const [crop, hazard] = key.split("||")
      out.push({ crop, hazard, total })
    }
    return out
  }

  // Overlapping hazard buckets (any): dry/heat/wet based on intersections (excluding "any"/"no hazard")
  const toOverlapping = (rows) => {
    const agg = new Map()
    const add = (crop, haz, v) => {
      const key = `${crop}||${haz}`
      agg.set(key, (agg.get(key) || 0) + v)
    }
    for (const r of rows) {
      const crop = r?.crop
      if (!crop) continue
      const h = String(r?.hazard ?? "")
      const v = num(r?.total)
      if (!h) continue
      if (h === "no hazard") { add(crop, "no hazard", v); continue }
      if (h === "any") continue
      if (h.includes("dry")) add(crop, "dry (any)", v)
      if (h.includes("heat")) add(crop, "heat (any)", v)
      if (h.includes("wet")) add(crop, "wet (any)", v)
    }
    const out = []
    for (const [key, total] of agg.entries()) {
      const [crop, hazard] = key.split("||")
      out.push({ crop, hazard, total })
    }
    return out
  }

  const showCompound = !!hz_q3_showCompound
  const simplify = !!hz_q3_simplifyCompound
  const showNoHaz = !!hz_q3_includeNoHazard
  const includeDecreases = !!hz_q3_includeDecreases

  const L = showCompound ? toExclusive(L0) : toOverlapping(L0)
  const R = showCompound ? toExclusive(R0) : toOverlapping(R0)

  const Lb = (showCompound && simplify) ? simplifyExclusive(L) : L
  const Rb = (showCompound && simplify) ? simplifyExclusive(R) : R

  const hazardCore = showCompound
    ? (simplify
        ? ["1 hazard", "2 hazards", "3 hazards"]
        : ["dry (only)", "heat (only)", "wet (only)", "dry+heat", "dry+wet", "heat+wet", "dry+heat+wet"])
    : ["dry (any)", "heat (any)", "wet (any)"]

  const hazardDomain = showNoHaz ? hazardCore.concat(["no hazard"]) : hazardCore.slice()

  // Merge left/right by crop×hazard
  const key = (crop, hazard) => `${crop}||${hazard}`
  const mapSide = (rows) => {
    const m = new Map()
    for (const r of rows) {
      const crop = r?.crop
      const haz = String(r?.hazard ?? "")
      if (!crop || !haz) continue
      if (!hazardDomain.includes(haz)) continue
      m.set(key(crop, haz), num(r?.total))
    }
    return m
  }
  const mL = mapSide(Lb)
  const mR = mapSide(Rb)

  const cropsAll = new Set([
    ...Array.from(denomMap.keys()),
    ...Lb.map(r => r?.crop).filter(Boolean),
    ...Rb.map(r => r?.crop).filter(Boolean)
  ])

  // Top-N crops by combined ANY exposure (stable across hazards), plus Other.
  const score = (crop) => num(anyL.get(crop)) + num(anyR.get(crop))
  const topN = Math.max(5, Math.min(50, Number(hz_q3_topN) || 8))
  const topCrops = Array.from(cropsAll)
    .sort((a,b) => score(b) - score(a))
    .slice(0, topN)

  const cropDomain = topCrops.concat(["Other"])
  const topSet = new Set(topCrops)

  const toDisplayAbs = (v) => hz_q3_relative ? clampPct(denomTotal ? (100 * v / denomTotal) : 0) : v

  // Build plot records for each hazard panel
  const makePanelData = (haz) => {
    let tot1 = 0, tot2 = 0
    for (const crop of cropsAll) {
      tot1 += num(mL.get(key(crop, haz)))
      tot2 += num(mR.get(key(crop, haz)))
    }

    const rows = []
    let other1 = 0, other2 = 0, otherDPos = 0, otherDNeg = 0

    for (const crop of cropsAll) {
      const v1 = num(mL.get(key(crop, haz)))
      const v2 = num(mR.get(key(crop, haz)))
      const d = v2 - v1
      const pos = Math.max(0, d)
      const neg = Math.min(0, d)

      if (topSet.has(crop)) {
        rows.push({
          hazard: haz,
          scenario: "S1",
          crop,
          value: toDisplayAbs(v1),
          pos: toDisplayAbs(v1),
          neg: 0,
          signed: v1
        })
        rows.push({
          hazard: haz,
          scenario: "S2",
          crop,
          value: toDisplayAbs(v2),
          pos: toDisplayAbs(v2),
          neg: 0,
          signed: v2
        })
        rows.push({
          hazard: haz,
          scenario: "Δ",
          crop,
          value: toDisplayAbs(d),
          pos: toDisplayAbs(pos),
          neg: includeDecreases ? toDisplayAbs(neg) : 0,
          signed: d
        })
      } else {
        other1 += v1
        other2 += v2
        otherDPos += pos
        otherDNeg += neg
      }
    }

    rows.push({
      hazard: haz,
      scenario: "S1",
      crop: "Other",
      value: toDisplayAbs(other1),
      pos: toDisplayAbs(other1),
      neg: 0,
      signed: other1
    })
    rows.push({
      hazard: haz,
      scenario: "S2",
      crop: "Other",
      value: toDisplayAbs(other2),
      pos: toDisplayAbs(other2),
      neg: 0,
      signed: other2
    })
    rows.push({
      hazard: haz,
      scenario: "Δ",
      crop: "Other",
      value: toDisplayAbs(otherDPos + otherDNeg),
      pos: toDisplayAbs(otherDPos),
      neg: includeDecreases ? toDisplayAbs(otherDNeg) : 0,
      signed: otherDPos + otherDNeg
    })

    return { rows, tot1, tot2, diff: (tot2 - tot1) }
  }

  const panels = hazardDomain.map(h => ({ haz: h, ...makePanelData(h) }))

  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })
  const fmtPct = (x) => `${hz_formatNumber(x, { digits: 2 })}%`
  const yLabel = hz_q3_relative ? "% of total production value" : (hz_varLabelAbs ?? "Exposure")

  // Dynamic insight (prototype style)
  const hazardTotals = panels
    .filter(p => p.haz !== "no hazard")
    .map(p => ({
      hazard: p.haz,
      total1: p.tot1,
      total2: p.tot2,
      diff: p.diff
    }))

  const topL = hazardTotals.slice().sort((a,b) => b.total1 - a.total1)[0]
  const topR = hazardTotals.slice().sort((a,b) => b.total2 - a.total2)[0]
  const topD = hazardTotals.slice().sort((a,b) => Math.abs(b.diff) - Math.abs(a.diff))[0]

  const pctOfTotal = (v) => denomTotal ? (100 * v / denomTotal) : 0

  const insight = md`
**Dynamic Insight**

For **${hz_s1.label}**, the largest hazard contribution is **${prettyHaz(topL?.hazard)}** at **${fmtAbs(topL?.total1 ?? 0)} ${hz_varShort ?? ""}** (~${fmtPct(pctOfTotal(topL?.total1 ?? 0))} of total production value).

For **${hz_s2.label}**, the largest hazard contribution is **${prettyHaz(topR?.hazard)}** at **${fmtAbs(topR?.total2 ?? 0)} ${hz_varShort ?? ""}** (~${fmtPct(pctOfTotal(topR?.total2 ?? 0))}).

The biggest scenario shift is **${prettyHaz(topD?.hazard)}**, which **${(topD?.diff ?? 0) >= 0 ? "increases" : "decreases"}** by **${fmtAbs(Math.abs(topD?.diff ?? 0))} ${hz_varShort ?? ""}** (~${fmtPct(Math.abs(pctOfTotal(topD?.diff ?? 0)))}) between Left and Right.
`

  // Panel plotting
  const w = Number(hz_plotWidth) || 920
  const gap = 12
  const minCol = 280
  const cols = Math.max(1, Math.floor((w + gap) / (minCol + gap)))
  const colW = Math.max(minCol, Math.floor((w - gap * (cols - 1)) / cols))
  const h = Math.max(360, Number(hz_q3_chartHeight) || 520)

  const allVals = []
  for (const p of panels) {
    for (const r of p.rows) {
      allVals.push(num(r.pos))
      if (includeDecreases) allVals.push(num(r.neg))
    }
  }
  const yMax = Math.max(0, ...allVals)
  const yMin = includeDecreases ? Math.min(0, ...allVals) : 0
  const yPadMax = yMax > 0 ? yMax * 1.08 : 1
  const yPadMin = yMin < 0 ? yMin * 1.08 : 0
  const yDomain = [yPadMin, yPadMax]

  const legend = Plot.legend({ color: { domain: cropDomain, scheme: "tableau10" }, columns: 4 })

  const buildPanel = (panel, i) => {
    const showY = i % cols === 0
    const data = panel.rows
    const tipFmt = {
      scenario: true,
      crop: true,
      value: hz_q3_relative ? fmtPct : fmtAbs,
      signed: (x) => hz_q3_relative ? fmtPct(x) : fmtAbs(x)
    }

    const posMark = Plot.barY(data, Plot.stackY({
      x: "scenario",
      y: "pos",
      fill: "crop",
      tip: { format: tipFmt }
    }))

    const negMark = includeDecreases
      ? Plot.barY(data, Plot.stackY({
          x: "scenario",
          y: "neg",
          fill: "crop",
          tip: { format: tipFmt }
        }))
      : null

    return html`
      <div class="hz-sideCard">
        <div class="hz-sideCard__body">
          <div class="hz-mini__title">${prettyHaz(panel.haz)}</div>
          ${Plot.plot({
            width: colW,
            height: h,
            marginLeft: showY ? 58 : 14,
            marginRight: 10,
            marginTop: 10,
            marginBottom: 28,
            x: { domain: ["S1","S2","Δ"], label: null },
            y: { label: showY ? yLabel : null, grid: true, axis: showY ? "left" : null, domain: yDomain },
            color: { domain: cropDomain, scheme: "tableau10", legend: false },
            marks: [
              Plot.ruleY([0]),
              posMark,
              ...(negMark ? [negMark] : [])
            ]
          })}
        </div>
      </div>
    `
  }

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`

  return html`
    <div class="hz-legendRow">${legend}</div>
    <div style="display:grid;gap:${gap}px;grid-template-columns:repeat(${cols}, 1fr);">
      ${panels.map((p,i) => buildPanel(p, i))}
    </div>
    <div class="hz-upsetCaption">${subtitle}</div>
    <div class="hz-qInsight">${insight}</div>
  `
}
hz_q3_mountChart = {
  hz_q3_chartHost.replaceChildren(hz_q3Charts)
  return null
}

hz_q3_dashboardCard = hz_noJumpRoot(html`
<div class="hz-card">
  <div class="hz-card__body">
    <div class="hz-qOverview">${md`${q3DetailText}`}</div>

    <div class="hz-qToolbar">
      <div class="hz-qToolbar__left"></div>
      ${hz_q3_settingsWrap}
    </div>

    <div class="hz-vizWrap">
      <div class="hz-qResults">
        ${hz_q3_chartHost}
      </div>
    </div>
  </div>
</div>
`);
hz_q4_dashboardCard = html`
<div class="hz-card">
  <div class="hz-card__head">
    <div>
      <div class="hz-card__title">Q4 — Scenario comparison</div>
    </div>
  </div>

  <div class="hz-card__body">
    <div class="hz-qOverview">
      Side-by-side scenario differences for the selected dataset and commodities. (Outputs will be wired after Q1 layout and controls are final.)
    </div>

        <div class="hz-qToolbar">
      <div class="hz-qToolbar__left">
        ${viewof hz_q4_viewMode}
      </div>
      ${
        (hz_q4_viewMode === "chart" || hz_q4_viewMode === "both")
          ? html`<div class="hz-qToolbar__right"><div class="hz-inlineRange">${viewof hz_q4_chartHeight}</div></div>`
          : ""
      }
    </div>

    <div class="hz-sideCard">
      <div class="hz-sideCard__header"><div class="hz-sideCard__title">Placeholder</div></div>
      <div class="hz-sideCard__body"><div class="hz-muted">Q4 chart/table/map will render here.</div></div>
    </div>
  </div>
</div>
`;

// Q1 wrapper: controls live in the Q1 section (not in a global Controls panel)
hz_q1_block = html`<section id="q1" class="hz-question">${hz_dashboardShell}</section>`
hz_questionsStack = html`
  <div class="hz-stack hz-stack--questions">
    ${hz_q1_block}

    <section id="q2" class="hz-question">
      <h1 class="anchored" data-anchor-id="q2">${q2Title}</h1>
      <div class="hz-sectionIntro">${md`${q2IntroText}`}</div>
      ${hz_q2_dashboardCard}
    </section>

    <section id="q3" class="hz-question">
      <h1 class="anchored" data-anchor-id="q3">${q3Title}</h1>
      <div class="hz-sectionIntro">${md`${q3IntroText}`}</div>
      ${hz_q3_dashboardCard}
    </section>
  </div>
`

hz_mountDash = {
  try {
    // Preserve scroll position even if Quarto makes a wrapper scroll container.
    const scroller =
      document.scrollingElement ||
      document.querySelector("#quarto-content") ||
      document.querySelector(".page-columns") ||
      document.documentElement ||
      document.body

    const y = scroller?.scrollTop ?? window.scrollY
    const x = scroller?.scrollLeft ?? window.scrollX

    // Avoid focus-driven jump when the radio/checkbox inputs are recreated.
    try { document.activeElement?.blur?.() } catch (e) {}

    hz_dashMount.replaceChildren(hz_questionsStack)

    const restore = () => {
      if (scroller) {
        scroller.scrollTop = y
        scroller.scrollLeft = x
      } else {
        window.scrollTo(x, y)
      }
    }

    // Restore twice to beat post-layout focus adjustments.
    requestAnimationFrame(() => {
      restore()
      requestAnimationFrame(restore)
    })
  } catch (e) {
    hz_dashMount.replaceChildren(html`<div class="warn"><b>Dashboard failed to render:</b><br>${String(e)}</div>`)
  }
  return html``
}

// ------------------------------------------------------------
// Table rendering (Grid.js) + CSV export
// ------------------------------------------------------------
hz_loadCssOnce = (id, href) => {
  if (document.getElementById(id)) return Promise.resolve(true)
  return new Promise((resolve, reject) => {
    const el = document.createElement("link")
    el.id = id
    el.rel = "stylesheet"
    el.href = href
    el.onload = () => resolve(true)
    el.onerror = (e) => reject(e)
    document.head.appendChild(el)
  })
}

hz_loadScriptOnce = (id, src) => {
  if (document.getElementById(id)) return Promise.resolve(true)
  return new Promise((resolve, reject) => {
    const el = document.createElement("script")
    el.id = id
    el.src = src
    el.async = true
    el.onload = () => resolve(true)
    el.onerror = (e) => reject(e)
    document.head.appendChild(el)
  })
}

hz_loadGridjs = async () => {
  await hz_loadCssOnce("hz-gridjs-theme", "https://unpkg.com/gridjs/dist/theme/mermaid.min.css")
  await hz_loadScriptOnce("hz-gridjs-lib", "https://cdnjs.cloudflare.com/ajax/libs/gridjs/6.2.0/gridjs.production.min.js")
  return window.gridjs
}

hz_csvEscape = (v) => {
  const s = String(v ?? "")
  if (/[",\n]/.test(s)) return `"${s.replaceAll('"', '""')}"`
  return s
}

hz_downloadCsv = (filename, rows) => {
  const lines = rows.map(r => r.map(hz_csvEscape).join(",")).join("\n")
  const blob = new Blob([lines], { type: "text/csv;charset=utf-8" })
  const a = document.createElement("a")
  a.href = URL.createObjectURL(blob)
  a.download = filename || "table.csv"
  document.body.appendChild(a)
  a.click()
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove() }, 250)
}

hz_mountGrid = (host, key, cfg) => {
  const g = window.gridjs
  if (!g?.Grid) throw new Error("Grid.js not loaded")
  const store = (globalThis.__ATLAS_HZ_GRIDS__ ??= {})
  try { store[key]?.destroy?.() } catch (_) {}
  host.replaceChildren()
  const grid = new g.Grid(cfg)
  store[key] = grid
  grid.render(host)
  return grid
}

// Build chart *safely* (catch DuckDB/Arrow/Plot errors so UI still renders)
hz_updateChart = {
  const q = (hz_activeQuestion || "q1")
  const view = (hz_viewMode || "both")
  const wantsChart = (view === "chart" || view === "both")
  const wantsTable = (view === "table" || view === "both")
  const wantsRecords = (view === "records")
  const errors = []

  // Records-only view: status pill reflects /records endpoint; rendering handled by hz_updateRecords.
  if (wantsRecords) {
    const r = hz_recordsResp
    if (!r) {
      return html``
    }
    if (!r.ok) {
      return html``
    }
    return html``
  }

  // Map view: choropleth by admin (uses by-admin endpoint + getAdminBoundaries)
  if (hz_viewMode === "map") {
    const meta = hz_mapMeta || { loading: true, ok: false }

    // Loading
    if (meta.loading) {
      hz_mapHost.replaceChildren(html`<div class="hz-loading">Loading map…</div>`)
      return html``
    }

    // Error
    if (!meta.ok) {
      const err = html`<div class="warn"><b>Map error:</b><br>${String(meta.error || "Map query failed")}</div>`
      hz_mapHost.replaceChildren(err)
      return html``
    }

    // Ready
    hz_mapHost.replaceChildren(hz_mapPlot)
    return html``
  }

  const pick = () => {
    if (q === "q1") return { meta: hz_q1Meta, chart: hz_q1Chart }
    if (q === "q2") return { meta: hz_q2Meta, chart: hz_q2Chart }
    if (q === "q3") return { meta: hz_q3Meta, chart: hz_q3Chart }
    if (q === "q4") return { meta: hz_q4Meta, chart: hz_q4Chart }
    return { meta: hz_q1Meta, chart: hz_q1Chart }
  }

  const { meta, chart } = pick()

  if (!meta?.ok) {
    errors.push({ side: "api", error: meta?.error || "API call failed" })
  }

  // Status pill
  if (errors.length) {
  } else {
    const tag = meta?.cached ? "Cached" : "Ready"
    const ms = Number.isFinite(meta?.t_ms) ? ` (${meta.t_ms} ms)` : ""
  }

  // Chart area
  if (wantsChart) {
    if (errors.length) {
      hz_chartHost.replaceChildren(
        html`<div class="warn"><b>Chart failed</b><br/><div class="hz-muted">${errors[0].error}</div></div>`
      )
    } else {
      try {
        hz_chartHost.replaceChildren(chart)
      } catch (e) {
        hz_chartHost.replaceChildren(
          html`<div class="warn"><b>Plot error</b><br/><div class="hz-muted">${String(e)}</div></div>`
        )
      }
    }
  } else {
    hz_chartHost.replaceChildren(html`<div class="hz-muted">Chart hidden.</div>`)
  }


  // -------------------------
  // Q1 Dynamic Insight (text)
  // -------------------------
  try {
    if ((hz_activeQuestion || "q1") === "q1") {
      if (errors.length) {
        hz_q1_insightHost.replaceChildren(html`<div class="hz-muted">Insight unavailable because the API request failed.</div>`)
        // still allow chart/table error rendering above
      }
      const merged = Array.isArray(hz_merged) ? hz_merged : []
      const norm = (h) => String(h ?? "").trim().toLowerCase()
      const isAny = (h) => {
        const n = norm(h)
        return n === "any" || n === "any hazard" || n === "total" || n === "all"
      }
      const isNoHaz = (h) => {
        const n = norm(h)
        return n === "no hazard" || n === "no_hazard" || n === "none"
      }
      const isIntersection = (h) => {
        const n = norm(h)
        if (!n) return false
        if (isAny(h) || isNoHaz(h) || n === "other") return false
        return true
      }

      const rows = merged.map((r) => {
        const hazard = r.hazard ?? r.Hazard ?? r.name ?? r.key ?? "Unknown"
        const total1 = Number(r.total1 ?? r.left ?? r.value1 ?? r.total_left ?? 0)
        const total2 = Number(r.total2 ?? r.right ?? r.value2 ?? r.total_right ?? 0)
        return { hazard, total1, total2 }
      })

      if (!rows.length) {
        hz_q1_insightHost.replaceChildren(html`<div class="hz-muted">No data for the current filters.</div>`)
      } else {
        const anyRow = rows.find((r) => isAny(r.hazard))
        const sumIntersections = (k) =>
          rows
            .filter((r) => isIntersection(r.hazard))
            .reduce((a, r) => a + Number(r[k] ?? 0), 0)

        const total1 = anyRow ? Number(anyRow.total1 ?? 0) : sumIntersections("total1")
        const total2 = anyRow ? Number(anyRow.total2 ?? 0) : sumIntersections("total2")

        const isCompound = (h) => String(h ?? "").replace(/\s+/g, "").includes("+")
        const compound1 =
          rows
            .filter((r) => isIntersection(r.hazard) && isCompound(r.hazard))
            .reduce((a, r) => a + Number(r.total1 ?? 0), 0)
        const compound2 =
          rows
            .filter((r) => isIntersection(r.hazard) && isCompound(r.hazard))
            .reduce((a, r) => a + Number(r.total2 ?? 0), 0)

        const share1 = total1 > 0 ? (compound1 / total1) * 100 : 0
        const share2 = total2 > 0 ? (compound2 / total2) * 100 : 0

        const dTotal = total2 - total1
        const dShare = share2 - share1

        const fmtV = (x) => hz_formatNumber(x, { digits: 2 })
        const fmtPct = (x) => `${hz_formatNumber(x, { digits: 1 })}%`
        const unit = hz_varLabel || "Value"

        const s1 = hz_s1?.label ?? "Baseline"
        const s2 = hz_s2?.label ?? "Future"

        const totalVerb = dTotal >= 0 ? "increased" : "decreased"
        const shareVerb = dShare >= 0 ? "increased" : "decreased"

        hz_q1_insightHost.replaceChildren(
          md`**Dynamic insight**

- Under **${s1}**, total exposure is **${fmtV(total1)}** (${unit}), with **${fmtV(compound1)}** (**${fmtPct(share1)}**) from **compound hazards**.
- Under **${s2}**, total exposure is **${fmtV(total2)}** (${unit}), with **${fmtV(compound2)}** (**${fmtPct(share2)}**) from **compound hazards**.
- Overall, total exposure **${totalVerb}** by **${fmtV(Math.abs(dTotal))}**, and the compound-hazard share **${shareVerb}** by **${fmtPct(Math.abs(dShare))}**.`
        )
      }
    } else {
      hz_q1_insightHost.replaceChildren()
    }
  } catch (e) {
    try {
      hz_q1_insightHost.replaceChildren(html`<div class="hz-muted">Insight unavailable.</div>`)
    } catch (_) {}
  }

  // Table area
  const clearTable = (msg) => {
    try { hz_tableActionsHost.replaceChildren() } catch (_) {}
    hz_tableHost.replaceChildren(html`<div class="hz-muted">${msg}</div>`)
  }

  if (!wantsTable) {
    clearTable("Table hidden.")
    return html``
  }

  if (errors.length) {
    clearTable("Table unavailable because the API request failed.")
    return html``
  }

  // Load Grid.js (once)
  let gridOk = true
  try { await hz_loadGridjs() } catch (e) { gridOk = false }
  if (!gridOk) {
    clearTable("Table library failed to load (Grid.js). Check network/CSP and reload.")
    return html``
  }

  const showPct = !!(hz_relative || hz_rel)
  const fmtAbs = (v) => hz_formatNumber(v, { digits: 2, compact: true })
  const fmtAbsFull = (v) => hz_formatNumber(v, { digits: 2, compact: false })
  const fmtPct = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
  }

  const payload = (() => {
    if (q === "q1") {
      const rows = Array.isArray(hz_chartRows) ? hz_chartRows : []
      const headers = ["Hazard","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => [
        r.hazard,
        Number(r.total1 ?? 0),
        Number(r.total2 ?? 0),
        Number(r.total_diff ?? (Number(r.total2 ?? 0) - Number(r.total1 ?? 0))),
        Number(r.perc1 ?? 0),
        Number(r.perc2 ?? 0),
        Number(r.pct_diff ?? (Number(r.perc2 ?? 0) - Number(r.perc1 ?? 0)))
      ])

      const columns = [
        { name: "Hazard" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q1_by_hazard.csv", headers, data, columns }
    }

    if (q === "q2") {
      const rows = Array.isArray(hz_q2Rows) ? hz_q2Rows : []
      const sum1 = rows.reduce((a,r) => a + Number(r.total1 ?? 0), 0)
      const sum2 = rows.reduce((a,r) => a + Number(r.total2 ?? 0), 0)
      const headers = ["Crop","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => {
        const t1 = Number(r.total1 ?? 0), t2 = Number(r.total2 ?? 0)
        const p1 = sum1 ? (t1/sum1*100) : 0
        const p2 = sum2 ? (t2/sum2*100) : 0
        return [r.crop, t1, t2, (t2 - t1), p1, p2, (p2 - p1)]
      })
      const columns = [
        { name: "Crop" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q2_by_crop.csv", headers, data, columns }
    }

    if (q === "q3") {
      // Match chart selection: top crops by (Left+Right)
      const L = Array.isArray(hz_q3DataL) ? hz_q3DataL : []
      const R = Array.isArray(hz_q3DataR) ? hz_q3DataR : []
      const cropTotals = new Map()
      const bump = (crop, v) => cropTotals.set(crop, (cropTotals.get(crop) || 0) + Number(v || 0))
      for (const d of R) bump(d.crop, d.total)
      for (const d of L) bump(d.crop, d.total)

      const maxCrops = Math.min(10, Number(hz_topN || 10))
      const crops = Array.from(cropTotals.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, maxCrops)
        .map(([c]) => c)

      // Top hazards by combined total (keeps table compact)
      const hazTotals = new Map()
      const bumpH = (haz, v) => hazTotals.set(haz, (hazTotals.get(haz) || 0) + Number(v || 0))
      for (const d of R) bumpH(d.hazard, d.total)
      for (const d of L) bumpH(d.hazard, d.total)

      const maxHaz = Math.min(12, Array.from(hazTotals.keys()).length)
      const hazards = Array.from(hazTotals.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, maxHaz)
        .map(([h]) => h)

      const key = (crop, hazard) => `${crop}|||${hazard}`
      const mapL = new Map(L.filter(d => crops.includes(d.crop) && hazards.includes(d.hazard)).map(d => [key(d.crop, d.hazard), Number(d.total || 0)]))
      const mapR = new Map(R.filter(d => crops.includes(d.crop) && hazards.includes(d.hazard)).map(d => [key(d.crop, d.hazard), Number(d.total || 0)]))

      const pairs = []
      for (const c of crops) for (const h of hazards) pairs.push([c,h])

      const headers = ["Crop","Hazard","Left total","Right total","Δ (abs)"]
      const data = pairs.map(([crop, hazard]) => {
        const t1 = mapL.get(key(crop,hazard)) || 0
        const t2 = mapR.get(key(crop,hazard)) || 0
        return [crop, hazard, t1, t2, (t2 - t1)]
      }).sort((a,b) => (b[3] - a[3]) || (b[2] - a[2]))

      const columns = [
        { name: "Crop" },
        { name: "Hazard" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) }
      ]
      return { filename: "q3_hazard_x_crop.csv", headers, data, columns }
    }

    if (q === "q4") {
      const rows = Array.isArray(hz_q4Rows) ? hz_q4Rows : []
      const sum1 = rows.reduce((a,r) => a + Number(r.total1 ?? 0), 0)
      const sum2 = rows.reduce((a,r) => a + Number(r.total2 ?? 0), 0)

      const headers = ["Admin","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => {
        const t1 = Number(r.total1 ?? 0), t2 = Number(r.total2 ?? 0)
        const p1 = sum1 ? (t1/sum1*100) : 0
        const p2 = sum2 ? (t2/sum2*100) : 0
        return [r.admin_name, t1, t2, (t2 - t1), p1, p2, (p2 - p1)]
      })

      const columns = [
        { name: "Admin" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q4_by_admin.csv", headers, data, columns }
    }

    return null
  })()

  if (!payload) {
    clearTable("No table available for this view yet.")
    return html``
  }

  // Actions: download CSV
  const dl = document.createElement("button")
  dl.className = "hz-btn"
  dl.textContent = "Download CSV"
  dl.onclick = () => hz_downloadCsv(payload.filename, [payload.headers, ...payload.data])

  const rowsMeta = document.createElement("div")
  rowsMeta.className = "hz-muted"
  rowsMeta.style.marginRight = "10px"
  rowsMeta.textContent = `${payload.data.length.toLocaleString()} rows`

  const actionsWrap = document.createElement("div")
  actionsWrap.style.display = "flex"
  actionsWrap.style.alignItems = "center"
  actionsWrap.style.gap = "10px"
  actionsWrap.appendChild(rowsMeta)
  actionsWrap.appendChild(dl)

  hz_tableActionsHost.replaceChildren(actionsWrap)

  // Mount Grid
  // Q1: render summary with shared Atlas table component (instead of Grid.js)
  if (q === "q1") {
    const rows = Array.isArray(hz_chartRows) ? hz_chartRows : []

    const fmtPP = (v) => {
      const x = Number(v)
      if (!Number.isFinite(x)) return "—"
      const sign = x > 0 ? "+" : ""
      return `${sign}${hz_formatNumber(x, { digits: 2, compact: false })} pp`
    }

    const tableData = rows.map((r) => ({
      "Hazard": r.hazard,
      "Left (abs)": r.total1,
      "Right (abs)": r.total2,
      "Δ (abs)": r.total_diff,
      "Left (%)": r.perc1,
      "Right (%)": r.perc2,
      "Δ (pp)": r.pct_diff
    }))

    const view = hz_atlasTable(tableData, {
      columns: showPct
        ? ["Hazard", "Left (%)", "Right (%)", "Δ (pp)"]
        : ["Hazard", "Left (abs)", "Right (abs)", "Δ (abs)"],
      format: {
        "Left (abs)": fmtAbsFull,
        "Right (abs)": fmtAbsFull,
        "Δ (abs)": fmtAbsFull,
        "Left (%)": fmtPct,
        "Right (%)": fmtPct,
        "Δ (pp)": fmtPP
      },
      rows: 12,
      height: "540px",
      width: {
        "Hazard": 240,
        "Left (abs)": 140,
        "Right (abs)": 140,
        "Δ (abs)": 140,
        "Left (%)": 120,
        "Right (%)": 120,
        "Δ (pp)": 120
      }
    })

    hz_tableHost.replaceChildren(view)
    return html``
  }

  const tableDiv = document.createElement("div")
  hz_tableHost.replaceChildren(tableDiv)
  hz_mountGrid(tableDiv, "hz_table", {
    columns: payload.columns,
    data: payload.data,
    search: true,
    sort: true,
    pagination: { enabled: true, limit: 12 },
    fixedHeader: true,
    height: "540px"
  })



  return html``
}

// ------------------------------------------------------------
// Raw records (paged) — server-backed
// ------------------------------------------------------------

hz_recordsReq = {
  if (hz_viewMode !== "records") return null

  const side = (hz_recordsSide || "left")
  const src = (side === "right") ? hz_src2 : hz_src1
  const scen = (side === "right") ? hz_s2 : hz_s1

  const req = {
    dataset_url: src?.url,
    scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
    geo: hz_geoFilterApi,
    commodities: hz_selectedCommoditiesForReq ?? [],
    hazard_vars: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
    page: Number(hz_recordsPage || 1)
  }

  const ps = Number(hz_recordsPageSize)
  if (Number.isFinite(ps) && ps > 0) req.page_size = ps

  const s = hz_recordsSort
  if (typeof s === "string" && s) req.sort = s

  return req
}

hz_recordsResp = (hz_recordsReq)
  ? await hz_apiDebouncedCached("records", "/api/v1/hz/records", hz_recordsReq, { ttlMs: 30000, debounceMs: 150 })
  : null

hz_recordsRows = hz_recordsResp?.rows ?? []
hz_recordsHasMore = !!hz_recordsResp?.has_more

hz_recordsPagerSync = {
  const pager = globalThis.__ATLAS_HZ_REC_PAGER__
  if (pager) {
    pager.prev.disabled = Number(hz_recordsPage || 1) <= 1
    pager.next.disabled = !hz_recordsHasMore
    pager.label.textContent = `Page ${Number(hz_recordsPage || 1)}`
  }
  return html``
}

hz_recordsResetPage = {
  if (hz_viewMode !== "records") return html``

  // When these change, jump back to page 1
  hz_recordsSide
  hz_recordsSort
  hz_recordsPageSize

  const pager = globalThis.__ATLAS_HZ_REC_PAGER__
  if (pager?.set) pager.set(1, { silent: false })
  return html``
}

hz_exportRecordsCsv = async ({ scope = "all" } = {}) => {
  const req = hz_recordsReq
  if (!req) return

  // "all" means: let the server export up to its EXPORT_MAX_ROWS guardrail (default 200k).
  const body = (scope === "all")
    ? { ...req, page: 1, page_size: 200000 }
    : req

  const url = hz_apiBaseUrl + "/api/v1/hz/records_csv"
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  })

  if (!res.ok) {
    const txt = await res.text()
    throw new Error(txt || ("HTTP " + res.status))
  }

  const blob = await res.blob()
  const stamp = new Date().toISOString().slice(0,19).replaceAll(":","").replace("T","_")
  const name = `records_export_${stamp}.csv`

  const a = document.createElement("a")
  a.href = URL.createObjectURL(blob)
  a.download = name
  document.body.appendChild(a)
  a.click()
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove() }, 300)
}

hz_updateRecords = {
  if (hz_viewMode !== "records") return html``

  // Ensure Grid.js is available
  try { await hz_loadGridjs() } catch (e) {
    hz_recordsActionsHost.replaceChildren()
    hz_recordsHost.replaceChildren(
      html`<div class="warn"><b>Records table failed</b><br/><div class="hz-muted">Could not load Grid.js. ${String(e)}</div></div>`
    )
    return html``
  }

  const resp = hz_recordsResp
  if (!resp?.rows || !resp?.ok) {
    hz_recordsActionsHost.replaceChildren()
    const msg = resp?.error || "No data"
    hz_recordsHost.replaceChildren(
      html`<div class="warn"><b>Could not load records</b><br/><div class="hz-muted">${String(msg)}</div></div>`
    )
    return html``
  }

  // Actions
  const actions = document.createElement("div")
  actions.style.display = "flex"
  actions.style.gap = "8px"
  actions.style.flexWrap = "wrap"
  actions.style.justifyContent = "flex-end"
  actions.style.alignItems = "center"

  const badge = document.createElement("div")
  badge.className = "hz-muted"
  badge.style.fontWeight = "900"
  badge.style.fontSize = "12px"
  badge.textContent = `Rows: ${hz_recordsRows.length}${hz_recordsHasMore ? "+" : ""}`

  const btnAll = document.createElement("button")
  btnAll.className = "hz-btn hz-btn--sm"
  btnAll.textContent = "Export (server, max 200k)"
  btnAll.onclick = async () => {
    try {
      btnAll.disabled = true
      btnAll.textContent = "Exporting…"
      await hz_exportRecordsCsv({ scope: "all" })
    } catch (e) {
      alert(`Export failed: ${String(e?.message || e)}`)
    } finally {
      btnAll.disabled = false
      btnAll.textContent = "Export (server, max 200k)"
    }
  }

  actions.appendChild(badge)
  actions.appendChild(btnAll)
  hz_recordsActionsHost.replaceChildren(actions)

  const columns = [
    { name: "admin0" },
    { name: "admin1" },
    { name: "admin2" },
    { name: "scenario" },
    { name: "timeframe" },
    { name: "hazard" },
    { name: "hazard_vars" },
    { name: "crop" },
    { name: "value", sort: true, formatter: (c) => hz_formatNumber(c, { digits: 2, compact: true }) }
  ]

  const data = hz_recordsRows.map(r => [
    r.admin0_name ?? null,
    r.admin1_name ?? null,
    r.admin2_name ?? null,
    r.scenario ?? null,
    r.timeframe ?? null,
    r.hazard ?? null,
    r.hazard_vars ?? null,
    r.crop ?? null,
    (r.value === null || r.value === undefined) ? null : Number(r.value)
  ])

  const host = document.createElement("div")
  hz_recordsHost.replaceChildren(host)

  hz_mountGrid(host, "records", {
    columns,
    data,
    search: true,
    sort: true,
    fixedHeader: true,
    height: "560px"
  })

  return html``
}
// Bootstrap cell: forces mounts + updates to execute without blocking hz_main.
hz_bootstrap = {
  hz_mountDash
  hz_registerUi
  hz_recordsPagerSync
  hz_recordsResetPage
  await hz_updateChart
  await hz_updateRecords
  return html``
}

hz_main = html`
  <div class="hz-stack hz-stack--page">
    ${hz_dashMount}
  </div>
`;
// Mount the app into the markdown placeholder (keeps the page free of Observable inspector "HTMLElement {}" output)
hz_renderApp = {
  const host = document.getElementById("hz-dashboard")
  if (!host) return null

  // Mount once to avoid scroll jumps on reactive updates.
  const ui = (globalThis.__ATLAS_HZ_UI__ ??= {})
  if (ui.__appMounted) return null

  host.replaceChildren(hz_main)
  ui.__appMounted = true
  return null
}

// Bootstrap: mount sub-panels and update the chart (debounced/cached API)
hz_run = {
  hz_renderApp
  await hz_bootstrap
  return null
}

hz_run
```


::: {.hidden}

### Methods

# Source code {#source-code}

<!-- Add .hidden back in to hide -->

## Text and Language Translations

::: {.hidden}
{{< include /components/_lang.qmd >}}
:::



## Styling

```{ojs}
//| output: false
function NavbarLangSelector(language_obj, masterLanguage) {
  // Try to mount the language selector into the top navbar (like notebook.qmd).
  // If the navbar isn't present, fall back to a small floating selector at the top-right.
  const existing = document.getElementById("nav-lang-selector");
  if (existing) return;

  const lang_sel = Inputs.bind(
    Inputs.radio(language_obj, {
      label: "",
      format: (d) => d.label
    }),
    viewof masterLanguage
  );
  lang_sel.id = "nav-lang-selector";

  // Hack the css together for the observable inputs (matches notebook.qmd)
  lang_sel.style.display = "flex";
  lang_sel.style.alignItems = "center";
  lang_sel.style.marginLeft = "10px";
  const lang_div = lang_sel.querySelector("div");
  if (lang_div) {
    lang_div.style.display = "flex";
    lang_div.style.flexDirection = "column";
  }

  const navList = document.querySelector(".navbar-nav.ms-auto");
  if (navList) {
    navList.appendChild(lang_sel);
    return;
  }

  const navEnd = document.querySelector(".navbar-nav.ms-auto .nav-item.compact");
  if (navEnd && navEnd.parentNode) {
    navEnd.parentNode.appendChild(lang_sel);
    return;
  }

  // Fallback: floating mount (keeps the selector at the top even without a navbar)
  let mount = document.getElementById("atlas-lang-float");
  if (!mount) {
    mount = document.createElement("div");
    mount.id = "atlas-lang-float";
    mount.style.position = "fixed";
    mount.style.top = "12px";
    mount.style.right = "12px";
    mount.style.zIndex = "1030";
    mount.style.padding = "6px 10px";
    mount.style.borderRadius = "999px";
    mount.style.border = "1px solid rgba(0,0,0,.12)";
    mount.style.background = "rgba(255,255,255,.92)";
    mount.style.boxShadow = "0 10px 26px rgba(0,0,0,.10)";
    document.body.appendChild(mount);
  }
  mount.appendChild(lang_sel);
}

NavbarLangSelector(languages, masterLanguage)
```



```{ojs}
// This cell contains the notebook title + section headings, driven by nbText.json
nbTitle = _lang({
  en: "Atlas Hazard Exposure Explorer",
  fr: "Explorateur d’exposition aux aléas de l’Atlas",
});

nbText = await FileAttachment("/data/hazardExposure/nbText.json").json();

heading1 = _lang({ en: "Overview", fr: "Aperçu", pt: "Visão geral" });
q1Title = _lang(nbText.sections?.q1?.title);
q1DetailText = _lang(nbText.sections?.q1?.detailText);

heading2 = q1Title;
q2Title = _lang(nbText.sections?.q2?.title);

q2IntroText = _lang(nbText.sections?.q2?.introText);

q2DetailText = _lang(nbText.sections?.q2?.detailText);


q3Title = _lang(nbText.sections?.q3?.title);

q3IntroText = _lang(nbText.sections?.q3?.introText);

q3DetailText = _lang(nbText.sections?.q3?.detailText);

heading3 = q2Title;

```

## Admin Regions Selectors

{{< include /components/_adminSelectorsMulti.qmd >}}
:::
