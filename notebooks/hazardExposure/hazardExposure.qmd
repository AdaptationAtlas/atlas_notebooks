---
pagetitle: "Atlas Hazard Exposure"
nb-authors:
  - Brayden Youngberg
  - Pete Stewart
  - Joseph Chemutt
date-created: "2025-02-19"
date-edited: today
---
{{< include /components/_lang.qmd >}}

```{ojs}
//| output: false
import { atlasTOC, atlasHero } from "/helpers/uiComponents.ojs";
import { enahncedMultiSelect } from "/helpers/enhancedMultiSelect.ojs";

hero_url = "./../../images/default_crop.webp";
// This ^^ must be relative path due to an issue
// with how Quarto resolves certain paths if local image.
// It can also be a url.
nbTitle = _lang({
  en: "Atlas Hazard Exposure Explorer",
  fr: "Explorateur d’exposition aux aléas de l’Atlas",
});

```

```{ojs}
//| output: false
import { Inputs } from "@observablehq/inputs"
import { DuckDBClient } from "@observablehq/duckdb"
```
{{< include /components/_atlasBoundaries.qmd >}}


```{ojs}
//| output: false
// Observable Plot (ESM) + CSV parser (ESM)
// Use dynamic import 
Plot = await import("https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.14/+esm")
csvParse = (await import("https://cdn.jsdelivr.net/npm/d3-dsv@3/+esm")).csvParse
```

```{ojs}
//| output: false
// ------------------------------------------------------------------
// Core helpers
// ------------------------------------------------------------------
hz_isHttpUrl = (x) => /^https?:\/\//i.test(String(x ?? ""))

hz_s3ToHttps = (s3) => {
  const s = String(s3 ?? "")
  const m = /^s3:\/\/([^\/]+)\/?(.*)$/.exec(s)
  if (!m) return s3
  const bucket = m[1]
  const key = (m[2] ?? "").replace(/^\/+/, "")
  if (!key) return `https://${bucket}.s3.amazonaws.com/`
  if (bucket === "digital-atlas") return `https://digital-atlas.s3.amazonaws.com/${key}`
  return `https://${bucket}.s3.amazonaws.com/${key}`
}

hz_toServedUrl = (p) => {
  const s = String(p ?? "").trim()
  if (!s) return s
  if (/^s3:\/\//i.test(s)) return hz_s3ToHttps(s)
  if (hz_isHttpUrl(s)) return s
  // Normalize Windows paths/backslashes to URL-style
  return s.replace(/\\/g, "/").replace(/^\.\//, "")
}

hz_resolvePath = (entry) => {
  if (!entry) return { ok: false, raw: null, url: null, source: "missing" }
  const local = entry.local_path ?? entry.localPath ?? null
  const s3 = entry.s3_path ?? entry.s3 ?? entry.path ?? null
  const url0 = entry.url ?? null

  if (local && String(local).trim() !== "") {
    const raw = String(local)
    return { ok: true, raw, url: hz_toServedUrl(raw), source: "local_path" }
  }
  if (s3 && String(s3).trim() !== "") {
    const raw = String(s3)
    const url = hz_isHttpUrl(raw) ? raw : hz_s3ToHttps(raw)
    return { ok: true, raw, url, source: hz_isHttpUrl(raw) ? "https" : "s3_path" }
  }
  if (url0 && String(url0).trim() !== "") {
    const raw = String(url0)
    return { ok: true, raw, url: hz_isHttpUrl(raw) ? raw : hz_toServedUrl(raw), source: "url" }
  }
  return { ok: false, raw: null, url: null, source: "missing" }
}

// Quick URL sanity check: helps avoid confusing DuckDB errors when a URL returns
hz_validateParquetUrl = async (url) => {
  const u = String(url ?? "").trim()
  if (!u || !hz_isHttpUrl(u)) return { ok: true }
  try {
    const r = await fetch(u, { headers: { Range: "bytes=0-3" } })
    if (!r.ok) return { ok: false, error: `HTTP ${r.status} ${r.statusText}` }
    const buf = new Uint8Array(await r.arrayBuffer())
    const magic = String.fromCharCode(...buf)
    if (magic !== "PAR1") return { ok: false, error: `Not a Parquet file (magic=${magic})` }
    return { ok: true }
  } catch (e) {
    // If the check fails due to CORS/network quirks, don't block — DuckDB will still try.
    return { ok: true, warn: String(e) }
  }
}

hz_formatNumber = (v, { digits = 0, compact = true } = {}) => {
  const x = Number(v)
  if (!Number.isFinite(x)) return "—"
  const opts = compact
    ? { notation: "compact", compactDisplay: "short", maximumFractionDigits: digits, minimumFractionDigits: 0 }
    : { maximumFractionDigits: digits, minimumFractionDigits: 0 }
  return new Intl.NumberFormat(undefined, opts).format(x)
}

hz_titleCase = (s) =>

  String(s ?? "")
    .replace(/[-_]+/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase())
```

```{ojs}
//| output: false
// hazardExposure_{varShort}_{period}_{model}_{severity}[_{suffix}]
hz_parseKeyParts = (key) => {
  const s = String(key ?? "").trim()
  const out = { raw: s, ok: false, varShort: null, period: null, model: null, severity: null, suffix: null, scenario: null, timeframe: null }
  if (!s) return out
  const parts = s.split("_")
  if (parts.length < 5 || parts[0] !== "hazardExposure") return out

  out.varShort = parts[1]
  out.period = parts[2]
  out.severity = parts[parts.length - 1]

  // model may include underscores (e.g., ssp585_2041-2060)
  const mid = parts.slice(3, parts.length - 1)
  out.model = mid.join("_") || null

  const knownSuffixes = new Set(["generic", "crop-specific", "crop_specific", "auto", "best"])
  if (out.model) {
    const mparts = out.model.split("_")
    const last = mparts[mparts.length - 1]
    if (knownSuffixes.has(last)) {
      out.suffix = last
      out.model = mparts.slice(0, -1).join("_") || null
    }
  }

  // derive scenario/timeframe from model
  if (out.model) {
    const mod = out.model
    if (mod === "historic" || mod === "Historical") {
      out.scenario = "historic"
      out.timeframe = "historic"
    } else {
      const mm = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(mod)
      if (mm) {
        out.scenario = mm[1]
        out.timeframe = mm[2]
      } else {
        out.scenario = mod
        out.timeframe = null
      }
    }
  }

  out.ok = true
  return out
}
```

```{ojs}
//| output: false
// Responsive width sensor for Plot
viewof hz_plotWidth = {
  const el = html`<div class="hz-width-sensor"></div>`
  el.value = 900
  const ro = new ResizeObserver(() => {
    const w = Math.floor(el.getBoundingClientRect().width || 900)
    if (w && w !== el.value) {
      el.value = w
      el.dispatchEvent(new Event("input", {bubbles:true}))
    }
  })
  ro.observe(el)
  return el
}
```

```{ojs}
//| output: false
// Create a DuckDB client
hz_db = DuckDBClient.of()
```

```{ojs}
//| output: false
// Normalize DuckDB query results across runtimes.
hz_rows = {
  function rows(res) {
    if (!res) return []
    if (typeof res.toArray === "function") return rows(res.toArray())
    if (Array.isArray(res)) return res
    if (res.data && Array.isArray(res.data)) return res.data
    // Last resort: try iterable
    try { return Array.from(res) } catch (e) { return res }
  }
  return rows
}

// Convenience wrapper
hz_query = async (sql) => {
  try {
    return hz_rows(await hz_db.query(sql))
  } catch (e) {
    try { hz_addError("hz_query", e, { sql }) } catch (e2) {}
    if (typeof console !== "undefined") console.error("hz_query failed", e, sql)
    return []
  }
}
```

```{ojs}
//| output: false
hz_hero = atlasHero(nbTitle, hero_url)
```


```{ojs}
//| output: false
// Hero is mounted into #hz-hero by the final bootstrap cell.
null
```

```{=html}
<style>
html, body{
overflow-x: hidden;
}

.page-columns, .content{
overflow-x: hidden;
}

:root{
--card-bg:#fff;
  --card-bd:rgba(0,0,0,.08);
  --muted:rgba(0,0,0,.65);
  --muted2:rgba(0,0,0,.52);
  --shadow:0 10px 26px rgba(0,0,0,.07);
  --radius:16px;
}

.hero{
display:grid;
  grid-template-columns:1.2fr .8fr;
  gap:18px;
  align-items:stretch;
  background:linear-gradient(180deg, rgba(0,0,0,.035), rgba(0,0,0,.015));
  border:1px solid var(--card-bd);
  border-radius:var(--radius);
  padding:16px;
  box-shadow:var(--shadow);
  margin:10px 0 18px 0;
}

.chip{
display:inline-flex; align-items:center; gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid var(--card-bd);
  background:rgba(255,255,255,.75);
  font-size:.86rem;
}

.card{
background:var(--card-bg);
  border:1px solid var(--card-bd);
  border-radius:var(--radius);
  padding:14px;
  box-shadow:var(--shadow);
}

.card h3{
margin:0 0 6px 0; font-weight:800; font-size:1.05rem;
}

.card .sub{
color:var(--muted); margin:0 0 10px 0; font-size:.9rem;
}

.grid2{
display:grid; grid-template-columns:1fr 1fr; gap:12px;
}

@media (max-width: 900px){
.grid2{
grid-template-columns:1fr;
}
}

.kpi .k{
font-size:.82rem; color:var(--muted2);
}

.kpi .v{
font-size:1.05rem; font-weight:800; margin-top:2px; overflow:hidden; text-overflow:ellipsis;
}

.warn{
border:1px solid rgba(220,53,69,.35);
  background:rgba(220,53,69,.06);
  border-radius:14px;
  padding:10px 12px;
}

.ok{
border:1px solid rgba(25,135,84,.35);
  background:rgba(25,135,84,.06);
  border-radius:14px;
  padding:10px 12px;
}

.hz-card{
background:var(--card-bg);
  border:1px solid var(--card-bd);
  border-radius:18px;
  box-shadow:var(--shadow);
  padding:14px 14px 12px 14px;
}

.hz-card__head{
display:flex;
  gap:12px;
  align-items:flex-start;
  justify-content:space-between;
  padding-bottom:10px;
  border-bottom:1px solid rgba(0,0,0,.06);
  margin-bottom:12px;
}

.hz-card__title{
font-weight:900; font-size:1.05rem; line-height:1.1;
}

.hz-card__sub{
color:var(--muted); font-size:.88rem; margin-top:2px;
}

.hz-pill{
padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(0,0,0,.08);
  background:rgba(0,0,0,.02);
  font-size:.82rem;
  white-space:nowrap;
  display:inline-flex;
  align-items:center;
  gap:8px;
}

.hz-pill--error{
  background:rgba(220,38,38,.10);
  border-color:rgba(220,38,38,.25);
  color:rgba(185,28,28,1);
}
.hz-pill--loading{
  background:rgba(59,130,246,.10);
  border-color:rgba(59,130,246,.25);
  color:rgba(30,64,175,1);
}

.hz-tabs{
display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:10px;
  align-items:center;
}

.hz-tabs--small{
gap:6px; margin-top:6px;
}

.hz-tab{
appearance:none;
  cursor:pointer;
  border:1px solid rgba(15,23,42,.14);
  background:rgba(255,255,255,.85);
  color:#0f172a;
  padding:8px 12px;
  border-radius:999px;
  font-weight:800;
  font-size:.84rem;
  line-height:1;
  letter-spacing:.01em;
  transition:transform .06s ease,background .15s ease,border-color .15s ease,box-shadow .15s ease;
}

.hz-tab:hover{
background:rgba(2,132,199,.06); border-color:rgba(2,132,199,.35);
}

.hz-tab:active{
transform:translateY(1px);
}

.hz-tab.is-active{
background:rgba(2,132,199,.12);
  border-color:rgba(2,132,199,.55);
  box-shadow:0 1px 0 rgba(2,132,199,.18);
}



/* View toggle (segmented control) — visually distinct from the Q1/Q2/Q3/Q4 tabs */
.hz-viewToggle{
  display:flex;
  align-items:center;
  gap:10px;
  margin-left:auto;
}
.hz-viewToggle__label{
  font-weight:900;
  font-size:.78rem;
  color:rgba(15,23,42,.72);
  letter-spacing:.02em;
  text-transform:uppercase;
}
.hz-viewToggle__group{
  display:inline-flex;
  align-items:stretch;
  border:1px solid rgba(15,23,42,.16);
  background:rgba(255,255,255,.72);
  border-radius:999px;
  overflow:hidden;
  box-shadow:0 8px 18px rgba(0,0,0,.04);
}
.hz-viewBtn{
  appearance:none;
  border:0;
  background:transparent;
  padding:7px 10px;
  display:inline-flex;
  align-items:center;
  gap:7px;
  cursor:pointer;
  font-weight:850;
  font-size:.82rem;
  color:#0f172a;
  line-height:1;
  transition:background .15s ease, transform .06s ease, box-shadow .15s ease;
}
.hz-viewBtn + .hz-viewBtn{
  border-left:1px solid rgba(15,23,42,.12);
}
.hz-viewBtn__ic{
  font-size:.95rem;
  opacity:.9;
}
.hz-viewBtn.is-active{
  background:rgba(2,132,199,.14);
  box-shadow:inset 0 0 0 1px rgba(2,132,199,.22);
}
.hz-viewBtn:active{
  transform:translateY(1px);
}
.hz-viewBtn:focus{
  outline:none;
  box-shadow:0 0 0 3px rgba(2,132,199,.18);
}
@media (max-width: 992px){
  .hz-viewToggle{
    width:100%;
    margin-left:0;
    justify-content:space-between;
  }
  .hz-viewToggle__group{
    flex:1;
    justify-content:space-between;
  }
  .hz-viewBtn{
    flex:1;
    justify-content:center;
  }
  .hz-viewBtn__tx{
    display:none; /* icons-only on small screens */
  }
}


/* Navigation bar: makes “Breakdown” tabs and “View” toggle feel distinct and intuitive */
.hz-navBar{
  display:flex;
  gap:14px;
  align-items:flex-end;
  flex-wrap:wrap;
  margin-top:10px;
}
.hz-navBar__group{
  display:flex;
  flex-direction:column;
  gap:6px;
  min-width:0;
}
.hz-navBar__group--right{
  margin-left:auto;
  align-items:flex-end;
}
.hz-navBar__label{
  font-weight:950;
  font-size:.76rem;
  color:rgba(15,23,42,.70);
  letter-spacing:.03em;
  text-transform:uppercase;
}

/* Make the question tabs look like a “tab strip” instead of another segmented control */
.hz-tabs{
  margin-top:0;
  gap:6px;
  padding:6px;
  border-radius:14px;
  border:1px solid rgba(15,23,42,.10);
  background:rgba(15,23,42,.04);
}
.hz-tab{
  border:0;
  background:transparent;
  padding:8px 10px;
  border-radius:12px;
  font-weight:900;
  font-size:.82rem;
}
.hz-tab.is-active{
  background:rgba(255,255,255,.92);
  box-shadow:0 1px 0 rgba(15,23,42,.12);
  outline:1px solid rgba(2,132,199,.28);
}
.hz-tab:hover{
  background:rgba(255,255,255,.75);
}

/* Make view toggle slightly more compact so it reads like a toolbar */
.hz-viewToggle{
  margin-left:0;
}
.hz-viewToggle__group{
  border-radius:14px;
}
.hz-viewBtn{
  font-size:.80rem;
  padding:7px 9px;
}

/* On small screens, stack nicely */
@media (max-width: 680px){
  .hz-navBar__group--right{ width:100%; align-items:flex-start; }
  .hz-viewToggle{ width:100%; justify-content:space-between; }
  .hz-viewToggle__group{ width:100%; justify-content:space-between; }
  .hz-viewBtn{ flex:1; justify-content:center; }
}
.hz-tab:focus{
outline:none; box-shadow:0 0 0 3px rgba(2,132,199,.20);
}

.hz-grid2{
display:grid;grid-template-columns:1fr 1fr;gap:12px
}

@media (max-width: 900px){
.hz-grid2{
grid-template-columns:1fr
}
}

.hz-legendRow{
display:flex;
  justify-content:flex-end;
  align-items:center;
  margin:6px 0 10px;
}

.hz-legendRow .plot-legend{
font-size:.82rem;
}

.hz-grid2--equal{
align-items:start;
}

.hz-mini{
background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:12px
}

.hz-mini__title{
font-size:12px;color:#cbd5e1;margin:0 0 8px 2px;font-weight:600;letter-spacing:.02em;text-transform:uppercase
}

.hz-card__tabs{
margin-top:8px
}

.hz-pill{
display:inline-flex; align-items:center; gap:8px; position:relative;
}

.hz-pill__spin{
width:12px; height:12px; border-radius:999px;
  border:2px solid rgba(0,0,0,.18);
  border-top-color: rgba(0,0,0,.55);
  animation: hzSpin .8s linear infinite;
  flex:0 0 auto;
}

@keyframes hzSpin{
to{
transform: rotate(360deg);
}
}

.hz-chartWrap{
position:relative; min-height:340px;
}

.hz-chartWrap--busy::before{
content:"";
  position:absolute; inset:0;
  background:rgba(255,255,255,.62);
  backdrop-filter: blur(2px);
  border-radius:14px;
  z-index: 10;
}

.hz-chartWrap--busy::after{
content:"Updating chart…";
  position:absolute; left:50%; top:50%;
  transform:translate(-50%,-50%);
  padding:10px 14px;
  border-radius:999px;
  border:1px solid rgba(0,0,0,.12);
  background:rgba(255,255,255,.9);
  box-shadow:0 10px 26px rgba(0,0,0,.10);
  font-weight:900;
  font-size:.9rem;
  z-index: 11;
}

.hz-grid{
display:grid; gap:14px;
}

.hz-grid--2{
grid-template-columns:1fr 1fr;
}

@media (max-width: 980px){
.hz-grid--2{
grid-template-columns:1fr;
}
}

.hz-grid--auto{
grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); align-items:end;
}

.hz-grid--tight{
gap:10px;
}

.hz-subtitle{
font-weight:900; font-size:.82rem; color:rgba(0,0,0,.72); margin: 10px 0 6px 0;
}

.hz-geoInline{
margin-top:10px; padding-top:10px; border-top:1px dashed rgba(0,0,0,.12);
}

.hz-section{
border:1px solid rgba(0,0,0,.06);
  background:rgba(0,0,0,.012);
  border-radius:16px;
  padding:12px;
}

.hz-section__title{
font-weight:900;
  font-size:.92rem;
  margin:0 0 8px 0;
}

.hz-field{
margin:8px 0;
}

.hz-muted{
color:var(--muted); font-size:.86rem; margin-top:8px;
}

.hz-card select, .hz-card input[type="text"], .hz-card input[type="number"]{
width:100%;
  max-width:100%;
  box-sizing:border-box;
}

.hz-card select{
border:1px solid rgba(0,0,0,.12);
  border-radius:12px;
  padding:8px 10px;
  background:#fff;
}

.hz-card select[multiple]{
min-height:180px;
  max-height:260px;
  overflow:auto;
}

.hz-card input[type="text"], .hz-card input[type="number"]{
border:1px solid rgba(0,0,0,.12);
  border-radius:12px;
  padding:8px 10px;
}

.hz-btn{
border:1px solid rgba(0,0,0,.12);
  background:rgba(0,0,0,.02);
  border-radius:999px;
  padding:8px 12px;
  font-weight:800;
  cursor:pointer;
}

.hz-btn:hover{
background:rgba(0,0,0,.04);
}


.hz-btn--sm{
  padding:6px 10px;
  font-size:12px;
}

.hz-select{
  border:1px solid rgba(0,0,0,.12);
  background:rgba(255,255,255,.85);
  border-radius:999px;
  padding:6px 10px;
  font-weight:800;
  font-size:12px;
}

.hz-select:focus{
  outline:none;
  box-shadow:0 0 0 3px rgba(59,130,246,.18);
}

.hz-recordsBar{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  margin:10px 0 10px 0;
  flex-wrap:wrap;
}

.hz-recordsBar__left{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
}

.hz-recordsBar__right{
  display:flex;
  gap:8px;
  align-items:center;
}

.hz-pager{
  display:flex;
  gap:8px;
  align-items:center;
}

.hz-pager__label{
  font-weight:900;
  font-size:12px;
  color:rgba(0,0,0,.72);
}


.hz-split{
display:grid; grid-template-columns: 1fr 1fr; gap:12px;
}

@media (max-width: 900px){
.hz-split{
grid-template-columns: 1fr;
}
}

.hz-sideCard{
border:1px solid var(--card-bd);
  border-radius:14px;
  padding:12px;
  background:rgba(255,255,255,.7);
}

.hz-sideCard__title{
font-weight:700; font-size:13px; margin-bottom:8px;
}

.hz-sideCard__sub{
color:var(--muted); font-size:12px; margin-top:6px;
}

.hz-sideCard__kv{
display:grid; grid-template-columns: 96px 1fr; gap:6px 10px; margin-top:8px;
}

.hz-sideCard__kv .k{
color:var(--muted); font-size:12px;
}

.hz-sideCard__kv .v{
font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}

.hz-card select, .hz-card input[type="text"], .hz-card input[type="search"], .hz-card input[type="url"]{
width:100% !important;
  max-width:100%;
}

.hz-ms{
display:flex; flex-direction:column; gap:10px;
}

.hz-ms__top{
display:flex; gap:8px; align-items:center; flex-wrap:nowrap;
}

@media (max-width: 900px){
.hz-ms__top{
flex-wrap:wrap;
}
}

.hz-ms__search{
flex:1;
  min-width: 180px;
  padding:10px 12px;
  border:1px solid var(--card-bd);
  border-radius:12px;
  background:#fff;
}

.hz-btn{
border:1px solid var(--card-bd);
  background:rgba(0,0,0,.02);
  border-radius:12px;
  padding:8px 10px;
  cursor:pointer;
}

.hz-btn:hover{
box-shadow:0 2px 10px rgba(0,0,0,.06);
}

.hz-ms__chips{
display:flex; gap:6px; flex-wrap:wrap;
}

.hz-chip{
display:inline-flex; align-items:center; gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid var(--card-bd);
  background:rgba(255,255,255,.9);
  font-size:12px;
}

.hz-chip button{
border:none; background:transparent; cursor:pointer;
  font-size:14px; line-height:1; padding:0 2px; opacity:.7;
}

.hz-chip button:hover{
opacity:1;
}

.hz-ms__list{
border:1px solid var(--card-bd);
  border-radius:14px;
  padding:8px;
  max-height: 260px;
  overflow:auto;
  background:#fff;
}

.hz-ms__item{
display:flex; align-items:center; gap:10px;
  padding:8px 8px;
  border-radius:10px;
  cursor:pointer;
}

.hz-ms__item:hover{
background:rgba(0,0,0,.03);
}

.hz-ms__item input{
width:16px; height:16px;
}

.hz-ms__meta{
color:var(--muted); font-size:12px; margin-left:auto;
}

.hz-ms__empty{
color:var(--muted); padding:10px;
}

.hz-width-sensor{
width:100%; height:0; overflow:hidden;
}

html, body{
max-width:100%; overflow-x:hidden;
}

main.content, .content{
max-width:100%;
}

.app{
max-width: min(1240px, 100%);
  margin: 0 auto;
  padding: 0 14px;
}

.app__stack{
display:flex; flex-direction:column; gap:14px;
}

.hz-card, .card{
max-width:100%; min-width:0;
}

.hz-grid, .hz-split{
min-width:0;
}

.hz-grid--2{
grid-template-columns: repeat(2, minmax(0, 1fr));
}

.hz-split{
display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap:12px;
}

@media (max-width: 980px){
.hero{
grid-template-columns: 1fr;
}

.hz-grid--2{
grid-template-columns: 1fr;
}

.hz-split{
grid-template-columns: 1fr;
}
}

.hz-width-sensor{
width:100%; height:1px;
}

pre, code{
max-width:100%;
}

pre{
overflow:auto;
}

.hz-sideCard__kv code, .hz-kv__v code{
word-break: break-word; white-space: normal;
}

.hz-topnav{
position: sticky;
  top: 0;
  z-index: 50;
  display:flex;
  gap:10px;
  align-items:center;
  padding:10px 12px;
  margin: 0 0 12px 0;
  background: rgba(255,255,255,.82);
  backdrop-filter: blur(10px);
  border: 1px solid var(--card-bd);
  border-radius: 999px;
  box-shadow: 0 8px 18px rgba(0,0,0,.06);
}

.hz-topnav a{
text-decoration:none;
  font-weight:600;
  font-size:13px;
  color: rgba(0,0,0,.78);
  padding:8px 10px;
  border-radius:999px;
}

.hz-topnav a:hover{
background: rgba(0,0,0,.05);
}

.hz-topnav .hz-topnav__spacer{
flex:1;
}

.hz-topnav .hz-pill{
margin-left:auto;
}

.hz-ms{
border:1px solid var(--card-bd);
  background: rgba(255,255,255,.75);
  border-radius: 14px;
  padding:10px;
}

.hz-ms__top{
display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:nowrap;
}

@media (max-width: 900px){
.hz-ms__top{
flex-wrap:wrap;
}
}

.hz-ms__search{
flex: 1 1 260px;
  padding:10px 12px;
  border-radius: 12px;
  border: 1px solid var(--card-bd);
  background: #fff;
}

.hz-ms__search:focus{
outline: 2px solid rgba(0,0,0,.18); outline-offset: 2px;
}

.hz-ms__chips{
display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:10px;
}

.hz-chip{
display:inline-flex;
  align-items:center;
  gap:10px;
  padding:8px 10px;
  border-radius: 999px;
  border: 1px solid var(--card-bd);
  background: rgba(0,0,0,.03);
}

.hz-chip button{
border:none;
  background: rgba(0,0,0,.08);
  width:22px; height:22px;
  border-radius: 999px;
  cursor:pointer;
}

.hz-chip button:hover{
background: rgba(0,0,0,.14);
}

.hz-ms__list{
margin-top:10px;
  border-top: 1px dashed rgba(0,0,0,.12);
  padding-top:10px;
  max-height: 260px;
  overflow:auto;
}

.hz-ms__item{
display:flex;
  align-items:center;
  gap:10px;
  padding:8px 8px;
  border-radius: 10px;
}

.hz-ms__item:hover{
background: rgba(0,0,0,.04);
}

.hz-ms__item input{
transform: scale(1.05);
}

:root{
--hz-font-sm: 12.5px;
  --hz-font-md: 13.5px;
  --hz-font-lg: 14.5px;
  --hz-control-pad-y: 8px;
  --hz-control-pad-x: 10px;
}

.hz-field form{
width:100%;
}

.hz-field form > label,
.hz-field label{
display:block;
  font-size: var(--hz-font-sm);
  font-weight: 800;
  letter-spacing: .01em;
  color: rgba(0,0,0,.72);
  margin: 0 0 6px 0;
}

.hz-field select,
.hz-field input[type="text"],
.hz-field input[type="search"],
.hz-field input[type="number"]{
width: 100%;
  font-size: var(--hz-font-md);
  line-height: 1.25;
  padding: var(--hz-control-pad-y) var(--hz-control-pad-x);
  border-radius: 14px;
  border: 1px solid rgba(0,0,0,.12);
  background: rgba(255,255,255,.9);
}

.hz-field select{
appearance: none;
  background-image:
    linear-gradient(45deg, transparent 50%, rgba(0,0,0,.55) 50%),
    linear-gradient(135deg, rgba(0,0,0,.55) 50%, transparent 50%);
  background-position:
    calc(100% - 16px) calc(50% - 2px),
    calc(100% - 11px) calc(50% - 2px);
  background-size: 6px 6px, 6px 6px;
  background-repeat: no-repeat;
  padding-right: 30px;
}

.hz-field select option{
font-size: var(--hz-font-md);
}

.hz-ms{
font-size: var(--hz-font-md);
}

.hz-ms__top{
gap: 8px;
}

.hz-ms__label{
font-size: var(--hz-font-sm);
  font-weight: 800;
  color: rgba(0,0,0,.72);
}

.hz-ms__search{
font-size: var(--hz-font-md);
  padding: var(--hz-control-pad-y) var(--hz-control-pad-x);
  border-radius: 14px;
}

.hz-ms__btns{
gap: 8px;
}

.hz-btn{
font-size: var(--hz-font-sm);
  padding: 7px 10px;
  border-radius: 999px;
  border: 1px solid rgba(0,0,0,.12);
  background: rgba(255,255,255,.9);
}

.hz-btn:hover{
filter: brightness(0.98);
}

.hz-btn:active{
transform: translateY(1px);
}

.hz-ms__chips{
display:flex;
  flex-wrap:wrap;
  gap: 6px;
  padding: 6px 6px;
  margin-top: 8px;
  border-radius: 14px;
  border: 1px dashed rgba(0,0,0,.16);
  background: rgba(255,255,255,.7);
  min-height: 34px;
  max-height: 92px;
  overflow:auto;
}

.hz-chip{
font-size: 11.5px;
  padding: 6px 8px;
  border-radius: 999px;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(0,0,0,.04);
}

.hz-chip button{
width: 18px;
  height: 18px;
  border-radius: 999px;
}

.hz-ms__list{
margin-top: 10px;
  padding: 8px;
  border-radius: 16px;
}

.hz-ms__item{
padding: 6px 6px;
  border-radius: 12px;
  font-size: var(--hz-font-md);
}

.hz-ms__item input{
width: 16px;
  height: 16px;
}

@media (min-width: 980px){
.hz-ms__list{
display:grid;
    grid-template-columns: repeat(2, minmax(220px, 1fr));
    gap: 6px 12px;
    align-items:start;
}

.hz-ms__item{
margin: 0;
}
}

.hz-card__sub{
font-size: 13px;
}



/* --- Dashboard tabs row (Question tabs + View mode) --- */
.hz-card__tabs--row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  flex-wrap:wrap;
}
.hz-tabsWrap{display:flex; align-items:center;}
.hz-tabsWrap--right{justify-content:flex-end;}

/* --- Wider split for Chart + Table --- */
.hz-split--wide{
  grid-template-columns: 1.35fr 1fr;
}

/* --- Table host --- */
.hz-tableWrap{
  position:relative;
  min-height: 560px;
  padding: 6px;
}
.hz-tableWrap--busy::before{
  content:"";
  position:absolute; inset:0;
  background:rgba(255,255,255,.62);
  backdrop-filter: blur(2px);
  border-radius:14px;
  z-index: 10;
}
.hz-tableWrap--busy::after{
  content:"Updating table…";
  position:absolute;
  top:14px; right:14px;
  background:rgba(15,23,42,.85);
  color:#fff;
  font-size:12px;
  font-weight:800;
  padding:6px 10px;
  border-radius:999px;
  z-index: 11;
}

/* Grid.js tweaks (subtle) */
.hz-tableWrap .gridjs-container{
  box-shadow:none;
}
.hz-tableWrap .gridjs-head{
  background:rgba(248,250,252,.8);
}

.hz-stack{
  display:flex;
  flex-direction:column;
  gap:12px;
}

.hz-tableWrap{
  font-size:12px;
}
.hz-tableWrap .gridjs-table th,
.hz-tableWrap .gridjs-table td{
  font-size:12px;
  line-height:1.25;
  padding:6px 8px;
}
.hz-tableWrap .gridjs-search input,
.hz-tableWrap .gridjs-pagination,
.hz-tableWrap .gridjs-summary{
  font-size:12px;
}
</style>
```

```{=html}
<div id="hz-app"></div>
```

```{ojs}
//| output: false

// Runtime diagnostics (browser)

hz_diagInit = {
  try {
    if (typeof window === "undefined") return null
    if (window.__hzDiag) return window.__hzDiag

    const state = { errors: [], seen: new Set() }

    const addError = (context, err, details=null) => {
      try {
        const msg = String(err?.message ?? err)
        const stack = err?.stack ? String(err.stack) : ""
        const id = `${context}::${msg}`

        if (!state.seen.has(id)) {
          state.seen.add(id)
          state.errors.push({
            time: new Date().toISOString(),
            context,
            message: msg,
            stack,
            details
          })

          window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
        }
      } catch (e) {
        state.errors.push({
          time: new Date().toISOString(),
          context: "hz:addError",
          message: String(e?.message ?? e),
          stack: e?.stack ? String(e.stack) : "",
          details: null
        })
        window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
      }
    }

    window.__hzDiag = { state, addError }

    // Hook global errors once
    if (!window.__hzRuntimeHooked) {
      window.__hzRuntimeHooked = true
      window.addEventListener("error", (ev) => {
        addError("window.error", ev?.error ?? ev?.message ?? ev, {
          filename: ev?.filename, lineno: ev?.lineno, colno: ev?.colno
        })
      })
      window.addEventListener("unhandledrejection", (ev) => {
        addError("window.unhandledrejection", ev?.reason ?? ev)
      })
    }

    // Initial broadcast
    window.dispatchEvent(new CustomEvent("hz:diag", { detail: state.errors.slice() }))
    return window.__hzDiag
  } catch (e) {
    if (typeof console !== "undefined") console.error("hz_diagInit failed", e)
    return null
  }
}

hz_addError = (context, err, details=null) => {
  try {
    if (typeof window !== "undefined" && window.__hzDiag?.addError) {
      window.__hzDiag.addError(context, err, details)
    } else if (typeof console !== "undefined") {
      console.error(`[${context}]`, err, details ?? "")
    }
  } catch (e) {
    if (typeof console !== "undefined") console.error("hz_addError failed", e)
  }
}

// Reactive stream of errors for display
hz_errors = Generators.observe((notify) => {
  // ensure diagnostics are initialized
  hz_diagInit
  if (typeof window === "undefined") {
    notify([])
    return () => {}
  }

  const handler = (ev) => notify(ev?.detail ?? [])
  window.addEventListener("hz:diag", handler)

  // seed with current state (if any)
  const existing = window.__hzDiag?.state?.errors ?? []
  notify(existing.slice())

  return () => window.removeEventListener("hz:diag", handler)
})

hz_renderErrors = (errors) => {
  const esc = (s) => String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")

  if (!errors || errors.length === 0) {
    return html`<div class="callout callout-note"><strong>No runtime errors captured.</strong></div>`
  }

  return html`<div class="callout callout-warning">
    <strong>Runtime diagnostics (${errors.length})</strong>
    <ol style="margin-top:0.5rem;">
      ${errors.map(e => html`<li style="margin-bottom:0.75rem;">
        <div><strong>${esc(e.context)}</strong> <span style="opacity:.75;">${esc(e.time)}</span></div>
        <div style="white-space:pre-wrap;">${esc(e.message)}</div>

        ${e.details ? html`<details style="margin-top:0.25rem;">
          <summary>details</summary>
          <pre style="white-space:pre-wrap; margin:0.5rem 0 0 0;">${esc(JSON.stringify(e.details, null, 2))}</pre>
        </details>` : null}

        ${e.stack ? html`<details style="margin-top:0.25rem;">
          <summary>stack</summary>
          <pre style="white-space:pre-wrap; margin:0.5rem 0 0 0;">${esc(e.stack)}</pre>
        </details>` : null}
      </li>`)}
    </ol>
  </div>`
}

// nbData.json loader + normalizer

hz_loadJson = async (path) => {
  try {
    const res = await fetch(path)
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`)
    return await res.json()
  } catch (e) {
    hz_addError(`loadJson(${path})`, e)
    throw e
  }
}

// Make nbData tolerant to different JSON shapes
// Expected final: Array of dataset objects [{key, local_path|s3_path, sql, ...}, ...]
hz_normalizeNbData = (raw) => {
  if (Array.isArray(raw)) return { ok:true, data: raw, note: "root is array" }

  if (raw && typeof raw === "object") {
    // Common wrapper fields
    const candidates = ["data", "datasets", "items", "resources", "catalog", "tables"]
    for (const k of candidates) {
      const v = raw[k]
      if (Array.isArray(v)) return { ok:true, data: v, note: `using raw.${k}` }
      if (v && typeof v === "object" && Array.isArray(v.data)) {
        return { ok:true, data: v.data, note: `using raw.${k}.data` }
      }
    }

    // Object-of-objects → values()
    const vals = Object.values(raw)
    if (vals.length && vals.every(v => v && typeof v === "object")) {
      const looksLike = vals.some(v =>
        ("key" in v) || ("sql" in v) || ("local_path" in v) || ("s3_path" in v)
      )
      if (looksLike) return { ok:true, data: vals, note: "using Object.values(raw)" }
    }

    return {
      ok: false,
      data: null,
      note: "root object not recognized",
      rawKeys: Object.keys(raw).slice(0, 50)
    }
  }

  return { ok:false, data:null, note: `unsupported JSON type: ${typeof raw}` }
}

// Load dataset index
hz_nbMeta = {
  try {
    const raw = await hz_loadJson("/data/hazardExposure/nbData.json")
    const norm = hz_normalizeNbData(raw)

    if (!norm.ok || !Array.isArray(norm.data)) {
      const err = new Error(`nbData.json did not parse to an array. ${norm.note || ""}`)
      hz_addError("nbData.json shape", err, { norm, rawType: typeof raw })
      return {
        ok: false,
        reason: err.message,
        data: [],
        rawType: typeof raw,
        rawKeys: norm.rawKeys ?? (raw && typeof raw === "object" ? Object.keys(raw).slice(0, 50) : [])
      }
    }

    return {
      ok: true,
      reason: norm.note,
      data: norm.data,
      rawType: typeof raw,
      rawKeys: raw && typeof raw === "object" ? Object.keys(raw).slice(0, 50) : []
    }
  } catch (e) {
    hz_addError("Load nbData.json", e)
    return {
      ok: false,
      reason: "Failed to load nbData.json: " + String(e?.message ?? e),
      data: [],
      rawType: null,
      rawKeys: []
    }
  }
}
```

```{ojs}
//| output: false
hz_nbMeta.ok
  ? html`<div class="callout callout-note">
      <strong>nbData.json:</strong> Loaded ${hz_nbMeta.data.length} entries <span style="opacity:.75;">(${hz_nbMeta.reason})</span>
    </div>`
  : html`<div class="callout callout-important">
      <strong>nbData.json:</strong> ${hz_nbMeta.reason}
      <div style="margin-top:.25rem; white-space:pre-wrap; opacity:.85;">
        Raw keys: ${JSON.stringify(hz_nbMeta.rawKeys)}
      </div>
    </div>`
```



```{ojs}
//| output: false
// Build a lookup map for fast key -> entry access
hz_nbIndex = {
  const m = new Map()
  for (const d of hz_nbMeta.data ?? []) m.set(d.key, d)
  return m
}
```

```{ojs}
//| output: false
// Parse available hazard exposure datasets from keys like: hazardExposure_usd15_annual_historic_moderate
hz_hazEntries = {
  const out = []
  const methodSuffixes = new Set(["generic", "crop_specific"])
  for (const d of hz_nbMeta.data ?? []) {
    if (!d.key?.startsWith("hazardExposure_")) continue
    const parts = d.key.split("_").filter(Boolean)
    if (parts.length < 5) continue

    const maybeMethod = parts[parts.length - 1]
    const hasMethod = methodSuffixes.has(maybeMethod)

    const severity = hasMethod ? parts[parts.length - 2] : parts[parts.length - 1]
    const method = hasMethod ? maybeMethod : null
    const modelParts = parts.slice(3, hasMethod ? (parts.length - 2) : (parts.length - 1))
    const model = modelParts.join("_")

    if (!model || !severity) continue

    out.push({
      key: d.key,
      varShort: parts[1],     // usd15 / intld15 etc.
      period: parts[2],       // annual / jagermeyr etc.
      model,                 // historical / ensemble / ssp245_2041-2060 etc.
      severity,              // moderate / severe / extreme etc.
      method,                // generic / crop_specific (optional)
      entry: d
    })
  }
  return out
}
```

```{ojs}
//| output: false
// Options derived from nbData.json (hazard exposure datasets)

hz_parseHazKey = (key) => {
  try {
    const s = String(key ?? "")
    if (!s.startsWith("hazardExposure_")) return null

    const parts = s.split("_")
    if (parts.length < 5) return null

    const varShort = parts[1]
    const period = parts[2]

    const knownMethods = new Set(["generic","crop_specific"])
    let method = null
    let severity = null
    let model = null

    if (knownMethods.has(parts[parts.length - 1])) {
      method = parts[parts.length - 1]
      severity = parts[parts.length - 2]
      model = parts.slice(3, parts.length - 2).join("_")
    } else {
      severity = parts[parts.length - 1]
      model = parts.slice(3, parts.length - 1).join("_")
    }

    return { key: s, varShort, period, model, severity, method }
  } catch (e) {
    hz_addError("hz_parseHazKey", e, { key })
    return null
  }
}

hz_parsed = {
  const parsed = hz_hazEntries
    .map(d => hz_parseHazKey(d.key))
    .filter(Boolean)

  if (hz_nbMeta.ok && hz_hazEntries.length > 0 && parsed.length === 0) {
    hz_addError(
      "Key parsing",
      new Error("No keys matched expected pattern hazardExposure_{varShort}_{period}_{model}_{severity}"),
      { exampleKeys: hz_hazEntries.slice(0, 10).map(d => d.key) }
    )
  }

  return parsed
}

hz_varShorts = Array.from(new Set(hz_parsed.map(d => d.varShort))).sort()
hz_periods   = Array.from(new Set(hz_parsed.map(d => d.period))).sort()
hz_models    = Array.from(new Set(hz_parsed.map(d => d.model))).sort()
hz_severities= Array.from(new Set(hz_parsed.map(d => d.severity))).sort()

hz_formatVarShort = (v) => {
  const s = String(v ?? "")
  if (s === "vop") return "Value of production (vop)"
  if (s === "prod") return "Production (prod)"
  if (s === "area") return "Area (area)"
  return s
}

// Friendly label for the selected exposure value
hz_varLabel = (() => {
  const s = String(hz_varShort ?? "")
  if (s === "intld15") return "International Dollars (2015)"
  if (s === "usd15") return "USD (2015)"
  if (s === "people") return "People"
  return hz_formatVarShort(s)
})()


// Absolute axis label used by charts (when not in Relative % mode)
hz_varLabelAbs = (() => {
  const base = String(hz_varLabel ?? '').trim()
  if (!base) return 'Exposure'
  // If hz_varLabel already reads like a full label, keep it.
  if (/exposure/i.test(base)) return base
  return `Exposure (${base})`
})()

hz_formatPeriod = (p) => {
  const s = String(p ?? "")
  if (s === "annual") return "Annual"
  if (s.toLowerCase().includes("jaeger") || s.toLowerCase().includes("jager")) return "Jägermeyr"
  return s
}

hz_formatSeverity = (sev) => {
  const s = String(sev ?? "")
  if (s === "all") return "All"
  return s.toUpperCase()
}

hz_formatModel = (m) => {
  const s = String(m ?? "")
  if (/hist|historic/i.test(s)) return "Historical"
  // ssp245_2050 -> SSP245 (2050)
  const mm = /^ssp(\d{3})_(\d{4})$/.exec(s)
  if (mm) return `SSP${mm[1]} (${mm[2]})`
  return s
}

hz_varShortOptions  = hz_varShorts.map(v => ({ label: hz_formatVarShort(v), value: v }))
hz_periodOptions    = hz_periods.map(p => ({ label: hz_formatPeriod(p), value: p }))
hz_severityOptions  = hz_severities.map(s => ({ label: hz_formatSeverity(s), value: s }))
hz_scenOptions      = hz_models.map(m => ({ label: hz_formatModel(m), value: m }))

hz_defaultVarShort = hz_varShorts.find(v => /usd15/i.test(String(v))) ?? hz_varShorts.find(v => /intld15/i.test(String(v))) ?? hz_varShorts[0] ?? null
hz_defaultPeriod    = hz_periods.includes("annual") ? "annual" : (hz_periods[0] ?? null)
hz_defaultSeverity = hz_severities.find(s => String(s).toLowerCase() === "severe") ?? hz_severities.find(s => String(s).toLowerCase() === "extreme") ?? hz_severities[0] ?? null

hz_defaultModel1 = hz_models.find(m => /historic/i.test(String(m))) ?? hz_models[0] ?? null
hz_defaultModel2 = hz_models.find(m => /ensemble/i.test(String(m))) ?? hz_models.find(m => String(m) !== String(hz_defaultModel1)) ?? hz_defaultModel1

({
  varShorts: hz_varShorts,
  periods: hz_periods,
  models: hz_models,
  severities: hz_severities
})
```

```{ojs}
//| output: false
// View controls
viewof hz_varShort = Inputs.select(hz_varShorts, {
  label: "Exposure value:",
  format: hz_formatVarShort,
  value: hz_defaultVarShort
})
```

```{ojs}
//| output: false
viewof hz_period = Inputs.select(hz_periods, {
  label: "Period:",
  format: hz_formatPeriod,
  value: hz_defaultPeriod
})
```

```{ojs}
//| output: false
viewof hz_severity = Inputs.select(hz_severities, {
  label: "Severity:",
  format: hz_formatSeverity,
  value: hz_defaultSeverity
})
```

```{ojs}
//| output: false
// Scenario/timeframe label formatter + parser 
hz_formatScenXTime = (scenTime) => {
  const s = String(scenTime ?? "").trim()
  if (!s) return ""
  if (s === "historic" || s === "Historical") return "Historical"
  const m = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(s)
  if (m) return `${m[1].toUpperCase()} ${m[2]}`
  return s
}

hz_parseScenXTime = (scenTime) => {
  const s = String(scenTime ?? "").trim()
  if (!s || s === "historic" || s === "Historical") {
    return { scenTime: "historic", scenario: "historic", timeframe: "historic", model: "historic" }
  }
  const m = /^([A-Za-z0-9]+)_(\d{4}-\d{4})$/.exec(s)
  if (m) return { scenTime: s, scenario: m[1], timeframe: m[2], model: "ENSEMBLE" }
  return { scenTime: s, scenario: s, timeframe: null, model: s }
}
```

```{ojs}
//| output: false
viewof hz_scen1 = Inputs.select(hz_scenXTime, {
  label: "Scenario A:",
  format: hz_formatScenXTime,
  value: "historic"
})
```

```{ojs}
//| output: false
viewof hz_scen2 = Inputs.select(hz_scenXTime, {
  label: "Scenario B:",
  format: hz_formatScenXTime,
  value: "ssp585_2041-2060"
})

hz_scenXTime = [
  "historic",
  "ssp126_2021-2040","ssp126_2041-2060","ssp126_2061-2080",
  "ssp245_2021-2040","ssp245_2041-2060","ssp245_2061-2080",
  "ssp370_2021-2040","ssp370_2041-2060","ssp370_2061-2080",
  "ssp585_2021-2040","ssp585_2041-2060","ssp585_2061-2080"
]
// Default  values:
// scenario1 = historic; scenario2 = ssp585_2041-2060
```

```{ojs}
//| output: false
// Chart toggles
viewof hz_relative = Inputs.toggle({ label: "Show % (relative values)", value: false })
```

```{ojs}
//| output: false
viewof hz_difference = Inputs.toggle({ label: "Show difference (Right − Left)", value: false })
```

```{ojs}
//| output: false
// Hazard dataset method (suffix) selector
hz_methodOptions = ["auto", "generic", "crop_specific"]
hz_methodLabel = (v) => ({
  auto: "Auto (best available)",
  generic: "Generic (all commodities aggregated)",
  crop_specific: "Crop-specific (SPAM crops + GLW livestock)"
}[v] ?? v)

viewof hz_method = Inputs.radio(hz_methodOptions, {
  label: "Hazard method:",
  value: "generic",
  format: hz_methodLabel
})
```

```{ojs}
//| output: false
// Commodity metadata from SPAM (crops) and GLW4 (livestock)
hz_spamCodesUrl = "https://raw.githubusercontent.com/AdaptationAtlas/hazards_prototype/main/metadata/SpamCodes.csv"

hz_spamCodes = {
  try {
    const txt = await (await fetch(hz_spamCodesUrl)).text()
    const rows = csvParse(txt)

    const norm = (s) => String(s ?? "")
      .trim()
      .toLowerCase()
      .replaceAll("/", "-")
      .replaceAll("&", "and")
      .replaceAll(" ", "-")
      .replaceAll("--", "-")

    const crops = rows
      .map(r => r.Fullname ?? r.fullname ?? r.NAME ?? r.name ?? "")
      .filter(Boolean)
      .map(norm)

    // A light categorization
    const cereals = new Set([
      "maize","rice","wheat","barley","sorghum","millet","oats","rye","triticale","teff"
    ])
    const legumes = new Set([
      "beans","cowpea","chickpea","lentil","pigeonpea","soybean","groundnuts","peas","bambara-beans"
    ])
    const rootsTubers = new Set([
      "cassava","potato","sweet-potato","yam","taro","cocoyam"
    ])

    const group = (name) => (c) => {
      if (name === "cereals") return cereals.has(c)
      if (name === "legumes") return legumes.has(c)
      if (name === "roots_tubers") return rootsTubers.has(c)
      return true
    }

    return {
      ok: true,
      crops: Array.from(new Set(crops)).sort(),
      groups: {
        cereals: Array.from(new Set(crops.filter(group("cereals")))).sort(),
        legumes: Array.from(new Set(crops.filter(group("legumes")))).sort(),
        roots_tubers: Array.from(new Set(crops.filter(group("roots_tubers")))).sort()
      }
    }
  } catch (e) {
    hz_addError("Load SpamCodes.csv", e)
    return { ok:false, crops: [], groups: { cereals: [], legumes: [], roots_tubers: [] } }
  }
}

// GLW4 livestock list 
hz_livestock = [
  "cattle","chicken","duck","goat","pig","sheep"
]
```

```{ojs}
//| output: false
// Union of crops + livestock
hz_allCommodities = {
  const crops = hz_spamCodes?.crops ?? []
  const livestock = hz_livestock ?? []
  const set = new Set([...crops, ...livestock].filter(Boolean))
  return Array.from(set).sort((a,b) => String(a).localeCompare(String(b)))
}
```

```{ojs}
//| output: false
// Commodity selectors
hz_commodityGroupOptions = ["all", "crops", "livestock", "cereals", "legumes", "roots_tubers", "custom"]
hz_commodityGroupLabel = (v) => ({
  all: "All (crops + livestock)",
  crops: "Crops (SPAM2020)",
  livestock: "Livestock (GLW4)",
  cereals: "Cereals",
  legumes: "Legumes",
  roots_tubers: "Roots & tubers",
  custom: "Custom (pick manually)"
}[v] ?? v)

viewof hz_commodityGroup = Inputs.select(hz_commodityGroupOptions, {
  label: "Group",
  value: "crops",
  format: hz_commodityGroupLabel
})
```

```{ojs}
//| output: false
hz_selectedCommodGroup = hz_commodityGroup
```

```{ojs}
//| output: false
hz_commodityOptions = {
  const g = hz_commodityGroup
  if (g === "livestock") return hz_livestock
  if (g === "crops") return hz_spamCodes.crops
  if (g === "cereals") return hz_spamCodes.groups.cereals
  if (g === "legumes") return hz_spamCodes.groups.legumes
  if (g === "roots_tubers") return hz_spamCodes.groups.roots_tubers
  // default list for "all" and "custom"
  return [...hz_spamCodes.crops, ...hz_livestock].filter(Boolean).sort()
}

hz_commodityLabelOf = (v) => hz_titleCase(v)

//multi-select: search + chips + checklist
viewof hz_commodities = {
  const disabled = (hz_commodityGroup === "all")
  const options = (hz_commodityOptions ?? []).map(v => ({
    value: v,
    label: hz_commodityLabelOf(v)
  }))

  const form = html`<form class="hz-ms">
    <div class="hz-ms__top">
      <input class="hz-ms__search" type="search" placeholder="Search commodities (e.g., maize, cattle, cassava)..." ${disabled ? "disabled" : ""}/>
      <button class="hz-btn" type="button" data-act="all" ${disabled ? "disabled" : ""}>Select all</button>
      <button class="hz-btn" type="button" data-act="none" ${disabled ? "disabled" : ""}>Clear</button>
    </div>
    <div class="hz-ms__chips"></div>
    <div class="hz-ms__list"></div>
    ${disabled ? html`<div class="hz-muted">All commodities selected. Choose a commodity group other than “All” to filter.</div>` : ""}
  </form>`

  const $search = form.querySelector(".hz-ms__search")
  const $chips = form.querySelector(".hz-ms__chips")
  const $list = form.querySelector(".hz-ms__list")
  const $btnAll = form.querySelector('[data-act="all"]')
  const $btnNone = form.querySelector('[data-act="none"]')

  let selected = new Set([])

  const emit = () => {
    form.value = Array.from(selected)
    form.dispatchEvent(new Event("input", { bubbles: true }))
  }

  const renderChips = () => {
    $chips.replaceChildren()
    if (selected.size === 0) return

    for (const v of Array.from(selected)) {
      const chip = html`<span class="hz-chip">
        <span>${hz_commodityLabelOf(v)}</span>
        <button type="button" aria-label="Remove">×</button>
      </span>`
      chip.querySelector("button").onclick = () => {
        selected.delete(v)
        render()
        emit()
      }
      $chips.appendChild(chip)
    }
  }

  const renderList = () => {
    const q = String($search?.value ?? "").trim().toLowerCase()
    const filtered = !q ? options : options.filter(o =>
      o.label.toLowerCase().includes(q) || o.value.toLowerCase().includes(q)
    )

    $list.replaceChildren()

    if (filtered.length === 0) {
      $list.appendChild(html`<div class="hz-ms__empty">No matches.</div>`)
      return
    }

    for (const o of filtered) {
      const checked = selected.has(o.value)
      const row = html`<div class="hz-ms__item">
        <input type="checkbox" ${checked ? "checked" : ""}/>
        <div>${o.label}</div>
      </div>`

      const cb = row.querySelector("input")
      const toggle = () => {
        if (cb.checked) selected.add(o.value)
        else selected.delete(o.value)
        renderChips()
        emit()
      }
      cb.onchange = toggle
      row.onclick = (e) => {
        if (e.target === cb) return
        cb.checked = !cb.checked
        toggle()
      }

      $list.appendChild(row)
    }
  }

  const render = () => {
    if (disabled) {
      selected = new Set([])
      renderChips()
      renderList()
      emit()
      return
    }
    renderChips()
    renderList()
  }

  if ($btnAll) $btnAll.onclick = () => {
    const q = String($search?.value ?? "").trim().toLowerCase()
    const filtered = !q ? options : options.filter(o =>
      o.label.toLowerCase().includes(q) || o.value.toLowerCase().includes(q)
    )
    for (const o of filtered) selected.add(o.value)
    render()
    emit()
  }

  if ($btnNone) $btnNone.onclick = () => {
    selected.clear()
    render()
    emit()
  }

  if ($search) $search.oninput = () => renderList()

  render()
  emit()
  return form
}
```

```{ojs}
//| output: false
// Final set of commodities used in SQL filter (array of crop strings)
hz_selectedCommodities = {
  const g = hz_commodityGroup
  const picked = (hz_commodities ?? []).filter(Boolean)

  if (g === "all") return hz_allCommodities

  // If user picked explicitly (custom / or after toggling group), trust that.
  if (picked.length) return picked

  // Group defaults when nothing is manually picked
  if (g === "livestock") return hz_livestock
  if (g === "crops") return hz_spamCodes.crops
  if (g === "cereals") return hz_spamCodes.groups.cereals
  if (g === "legumes") return hz_spamCodes.groups.legumes
  if (g === "roots_tubers") return hz_spamCodes.groups.roots_tubers

  // Custom with nothing picked → all commodities
  return hz_allCommodities
}
```

```{ojs}
//| output: false
// Display controls
// Compare mode affects Q2/Q4 when comparing Left vs Right.
viewof hz_compareMode = {
  const options = [
    { value: 'side', label: 'Side-by-side' },
    { value: 'diff', label: 'Δ Right − Left' }
  ]
  const root = document.createElement('div')
  root.className = 'hz-tabs hz-tabs--small'
  const buttons = new Map()

  const set = (v) => {
    root.value = v
    for (const [val, btn] of buttons.entries()) btn.classList.toggle('is-active', val === v)
    root.dispatchEvent(new Event('input', { bubbles: true }))
  }

  for (const opt of options) {
    const b = document.createElement('button')
    b.type = 'button'
    b.className = 'hz-tab'
    b.textContent = opt.label
    b.onclick = () => set(opt.value)
    root.appendChild(b)
    buttons.set(opt.value, b)
  }

  set('side')
  return root
}

viewof hz_topN = Inputs.range([5, 50], { label: "Top items (Top N):", step: 1, value: 25 })
viewof hz_groupOther = Inputs.toggle({ label: 'Group remaining hazards into "Other" (Q1)', value: false })
viewof hz_rel = Inputs.toggle({ label: "Relative (%)", value: false })
hz_isRelative = !!hz_rel
viewof hz_chartHeight = Inputs.range([360, 900], { label: "Chart height:", step: 10, value: 520 })
```



```{ojs}
//| output: false
// Friendly labels for the UI
hz_geoLabel = {
  const gf = hz_geoFilter ?? {}
  const a0 = Array.isArray(gf.admin0) ? gf.admin0.filter(Boolean) : []
  const a1 = Array.isArray(gf.admin1) ? gf.admin1.filter(Boolean) : []
  const a2 = Array.isArray(gf.admin2) ? gf.admin2.filter(Boolean) : []

  const hasAll = a0.length === 0 || a0.includes("all")
  const fmt = (arr, max = 2) => {
    const xs = arr.slice(0, max)
    const more = arr.length > max ? ` +${arr.length - max}` : ""
    return xs.join(", ") + more
  }

  if (hasAll) return "admin0: all"
  if (a2.length) return `admin2: ${fmt(a2)} (${a2.length})`
  if (a1.length) return `admin1: ${fmt(a1)} (${a1.length})`
  return `admin0: ${fmt(a0)} (${a0.length})`
}

hz_commodityLabel = {
  const g = hz_commodityGroup
  const picked = (hz_commodities ?? []).filter(Boolean)
  const n = (hz_selectedCommodities ?? []).length

  if (g === "all") return `Commodities: all (${n})`
  if (g === "crops") return `Commodities: crops (${n})`
  if (g === "livestock") return `Commodities: livestock (${n})`
  if (g === "custom") return picked.length ? `Commodities: custom (${n})` : `Commodities: custom (all) (${n})`

  const label = hz_commodityGroupOptions?.[g] ?? String(g)
  return `Commodities: ${label} (${n})`
}
```

```{ojs}
//| output: false
hz_parseScenario = (s) => {
  const raw = String(s ?? "")
  if (!raw) return { raw: "", model: "", scenario: null, timeframe: null, label: "" }

  const parts = raw.split("_").filter(Boolean)
  const scenario = parts[0] ?? null
  const timeframe = parts.length > 1 ? parts.slice(1).join("_") : null

  // In this notebook, the dataset key uses the FULL model token as stored in nbData keys
  // (e.g., historical, ensemble, ssp245_2041-2060). We keep that as `model`.
  return { raw, model: raw, scenario, timeframe, label: hz_formatModel(raw) }
}
hz_parseScenarioPick = (x) => {
  const p = hz_parseScenXTime(x)
  const isHist = (p?.scenTime === "historic") || (p?.scenario === "historic")
  const model = isHist ? "historic" : "ENSEMBLE"
  const label = isHist ? "historic" : `${String(p.scenario ?? "").toUpperCase()} ${p.timeframe ?? ""}`.trim()
  return { ...p, model, label }
}
hz_s1 = (() => hz_parseScenarioPick(hz_scen1))()
hz_s2 = (() => hz_parseScenarioPick(hz_scen2))()

```

```{ojs}
//| output: false
// Resolve a dataset key from selected controls (note: model determined by scenario pick)
hz_keyBaseFor = ({ varShort, period, model, severity }) => {
  // Base key: hazardExposure_{varShort}_{period}_{model}_{severity}
  return `hazardExposure_${varShort}_${period}_${model}_${severity}`
}

hz_keyCandidatesFor = ({ varShort, period, model, severity, method }) => {
  const base = hz_keyBaseFor({ varShort, period, model, severity })

  // Method is modeled as an optional suffix on the key:
  // ..._{severity}_{generic|crop_specific}
  if (!method || method === "auto") {
    // Try base first, then known method suffixes
    return [base, `${base}_generic`, `${base}_crop_specific`]
  }

  return [`${base}_${method}`, base]
}

hz_computeShinyInteractionUrl = ({ varShort, period, model, severity } = {}) => {
  const u = String(varShort ?? "")
  const variable = (/usd15|intld15/i.test(u)) ? `vop_${u}` : u
  const per = String(period ?? "annual")
  const mod =
    /hist/i.test(String(model ?? "")) ? "historic" :
    /ens/i.test(String(model ?? "")) ? "ENSEMBLE" :
    String(model ?? "")
  const sev = String(severity ?? "severe").toLowerCase()
  if (!variable || !per || !mod || !sev) return null
  return `https://digital-atlas.s3.amazonaws.com/hazard_exposure/v0.4.2/exported_data/${variable}/${per}/model=${mod}/severity=${sev}/interaction.parquet`
}

hz_resolveFromCandidates = (candidates) => {
  const cands = Array.isArray(candidates) ? candidates : [String(candidates ?? "")]
  for (const k of cands) {
    if (hz_nbIndex?.has(k)) {
      const entry = hz_nbIndex.get(k)
      const r = hz_resolvePath(entry)
      return { ...r, resolvedKey: k, candidates: cands }
    }
  }

  const first = cands[0]
  const parts = hz_parseKeyParts(first)
  const computedUrl = hz_computeShinyInteractionUrl(parts)

  const entry = hz_nbIndex?.get(first) ?? null
  const r = hz_resolvePath(entry)

  const out = { ...r }
  if (!out.url && computedUrl) out.url = computedUrl
  if (!out.path && computedUrl) out.path = computedUrl
  if (computedUrl && (!out.pathSource || out.pathSource === "none")) out.pathSource = "computed"

  return { ...out, resolvedKey: first, candidates: cands }
}

 // Base keys (no suffix)
hz_key1 = hz_keyBaseFor({ varShort: hz_varShort, period: hz_period, model: hz_s1.model, severity: hz_severity })
hz_key2 = hz_keyBaseFor({ varShort: hz_varShort, period: hz_period, model: hz_s2.model, severity: hz_severity })

// Candidates that incorporate the selected method preference
hz_keyCandidates1 = hz_keyCandidatesFor({ varShort: hz_varShort, period: hz_period, model: hz_s1.model, severity: hz_severity, method: hz_method })
hz_keyCandidates2 = hz_keyCandidatesFor({ varShort: hz_varShort, period: hz_period, model: hz_s2.model, severity: hz_severity, method: hz_method })

// Resolve path/url using nbData.json
hz_src1 = hz_resolveFromCandidates(hz_keyCandidates1)
hz_src2 = hz_resolveFromCandidates(hz_keyCandidates2)

// Handy aliases for display
hz_key1Resolved = hz_src1.resolvedKey
hz_key2Resolved = hz_src2.resolvedKey
```

```{ojs}
//| output: false
// (debug) suppressed
null
```

```{ojs}
//| output: false
// Controls panel UI
hz_controlsPanelReal = html`
  <div class="hz-card">
    <div class="hz-card__head">
      <div>
        <div class="hz-card__title">Controls</div>
        <div class="hz-card__sub">
          ${hz_geoLabel} · ${hz_commodityLabel}
        </div>
      </div>
      <div class="hz-pill">Method: <b>${hz_method}</b></div>
    </div>

    <section class="hz-section">
      <div class="hz-section__title">Dataset · Commodities · Geography</div>

      <div class="hz-subtitle">Dataset</div>
      <div class="hz-grid hz-grid--auto hz-grid--tight">
        <div class="hz-field">${viewof hz_varShort}</div>
        <div class="hz-field">${viewof hz_period}</div>
        <div class="hz-field">${viewof hz_severity}</div>
        <div class="hz-field">${viewof hz_method}</div>
      </div>

      <div class="hz-subtitle">Commodities</div>
      <div class="hz-grid hz-grid--2 hz-grid--tight">
        <div class="hz-field">${viewof hz_commodityGroup}</div>
        <div class="hz-field">${viewof hz_commodities}</div>
      </div>

      <div class="hz-subtitle">Geography</div>
      <div class="hz-grid hz-grid--auto hz-grid--tight">
        <div class="hz-field">${viewof hz_admin0}</div>
        <div class="hz-field">${viewof hz_admin1}</div>
        <div class="hz-field">${viewof hz_admin2}</div>
      </div>

      <div class="hz-muted hz-geoInline">
        <b>Resolved:</b> ${hz_geoResolvedLevel} · <b>Selections:</b> ${hz_geoSelectionCount}<br/>
        <b>Selected:</b>
        ${(Array.isArray(hz_admin0) && (hz_admin0.length === 0 || hz_admin0.includes("all"))) ? "All countries" : (hz_admin0 ?? []).join(", ")}
        ${(hz_admin1 ?? []).length ? html`<br/><b>Admin1:</b> ${(hz_admin1 ?? []).join(", ")}` : ""}
        ${(hz_admin2 ?? []).length ? html`<br/><b>Admin2:</b> ${(hz_admin2 ?? []).join(", ")}` : ""}
      </div>
    </section>

    <section class="hz-section">
      <div class="hz-section__title">Scenario comparison</div>
      <div class="hz-split">
        <div class="hz-sideCard">
          <div class="hz-sideCard__head">
            <div class="hz-sideCard__title">Left (A)</div>
            <div class="hz-sideCard__sub">Baseline / Scenario A</div>
          </div>
          <div class="hz-field">${viewof hz_scen1}</div>
          <div class="hz-field"></div>
          <div class="hz-sideCard__kv">
            <div class="k">Key</div><div class="v"><code>${hz_key1Resolved}</code></div>
          </div>
        </div>

        <div class="hz-sideCard">
          <div class="hz-sideCard__head">
            <div class="hz-sideCard__title">Right (B)</div>
            <div class="hz-sideCard__sub">Future / Scenario B</div>
          </div>
          <div class="hz-field">${viewof hz_scen2}</div>
          <div class="hz-field"></div>
          <div class="hz-sideCard__kv">
            <div class="k">Key</div><div class="v"><code>${hz_key2Resolved}</code></div>
          </div>
        </div>
      </div>

    </section>

    <section class="hz-section">
      <div class="hz-section__title">Chart</div>

    <div class=\"hz-muted\" style=\"margin-top:8px;\"></div>

    <div class=\"hz-grid hz-grid--2\">
        <div class="hz-field">${viewof hz_relative}</div>
        <div class="hz-field">${viewof hz_difference}</div>
        <div class="hz-field">${viewof hz_topN}</div>
        <div class="hz-field">${viewof hz_groupOther}</div>
      </div>
      <div class="hz-field">${viewof hz_chartHeight}</div>
    </section>
  </div>
`;
```



```{ojs}
//| output: false
// Admin name tuples (admin0/admin1/admin2) for cascading selectors.
// Uses the shared local component: components/_atlasBoundaries.ojs
// (No remote parquet needed.)
hz_adminNames = {
  try {
    const { admin2 } = await getAdminBoundaries([2])
    const feats = admin2?.features ?? []

    const pick = (p, keys) => {
      for (const k of keys) {
        const v = p?.[k]
        if (v != null && String(v).trim() !== "") return v
      }
      return null
    }

    const rows = feats.map((f) => {
      const p = f?.properties ?? {}
      
      const admin0_name = pick(p, ["admin0_name","ADM0_NAME","NAME_0","adm0_name","country","COUNTRY","admin0","name0"])
      const admin1_name = pick(p, ["admin1_name","ADM1_NAME","NAME_1","adm1_name","admin1","name1"])
      const admin2_name = pick(p, ["admin2_name","ADM2_NAME","NAME_2","adm2_name","admin2","name2"])
      return { admin0_name, admin1_name, admin2_name }
    }).filter((d) => d.admin0_name != null)

    
    const seen = new Set()
    const out = []
    for (const d of rows) {
      const k = `${d.admin0_name ?? ""}||${d.admin1_name ?? ""}||${d.admin2_name ?? ""}`
      if (!seen.has(k)) { seen.add(k); out.push(d) }
    }

    return out
  } catch (e) {
    return [{ error: `Failed to load admin names from components/_atlasBoundaries.ojs: ${e}` }]
  }
}

```

```{ojs}
//| output: false
// Build choice lists
hz_admin0Choices = {
  const isErr = hz_adminNames?.[0]?.error
  if (isErr) return ["all"]
  const vals = Array.from(new Set(hz_adminNames.map(d => d.admin0_name).filter(Boolean))).sort()
  return vals.includes("all") ? vals : ["all", ...vals]
}
```

```{ojs}
//| output: false
// multi-select (chips + search + checklist).
hz_makeMultiSelect = ({
  label = "Select",
  options = [],
  value = [],
  placeholder = "Search…",
  disabled = false,
  actions = [{ id: "none", label: "Clear" }],
  exclusive = null,         // e.g., "all" (cannot coexist with others)
  maxHeight = 240,
  maxRender = 600
} = {}) => {
  const form = html`<form class="hz-ms" style="opacity:${disabled ? 0.65 : 1}; pointer-events:${disabled ? "none" : "auto"}">
    <label class="hz-ms__label">${label}</label>
    <div class="hz-ms__top">
      <input class="hz-ms__search" type="search" placeholder="${placeholder}" />
      <div class="hz-ms__btns"></div>
    </div>
    <div class="hz-ms__chips" aria-label="Selected"></div>
    <div class="hz-ms__list" style="max-height:${maxHeight}px;"></div>
    <div class="hz-ms__meta"></div>
  </form>`

  const search = form.querySelector(".hz-ms__search")
  const chips = form.querySelector(".hz-ms__chips")
  const list  = form.querySelector(".hz-ms__list")
  const btns  = form.querySelector(".hz-ms__btns")
  const meta  = form.querySelector(".hz-ms__meta")

  const norm = (arr) => Array.from(new Set((arr ?? []).filter((d) => d != null && String(d).trim() !== "")))

  const setExclusiveRules = (selSet) => {
    if (!exclusive) return selSet
    if (selSet.size === 0) { selSet.add(exclusive); return selSet }
    if (selSet.has(exclusive) && selSet.size > 1) selSet.delete(exclusive)
    return selSet
  }

  const selected = new Set(norm(value))
  setExclusiveRules(selected)

  form.value = Array.from(selected)

  const emit = () => {
    // Apply exclusive rules + keep stable order based on options list
    setExclusiveRules(selected)
    const optIndex = new Map(options.map((d, i) => [String(d), i]))
    const ordered = Array.from(selected).sort((a, b) => (optIndex.get(String(a)) ?? 1e9) - (optIndex.get(String(b)) ?? 1e9))
    form.value = ordered
    form.dispatchEvent(new Event("input", { bubbles: true }))
    renderChips()
    renderList()
  }

  const renderChips = () => {
    chips.replaceChildren()
    const vals = Array.from(selected)
    if (!vals.length) return
    for (const v of vals) {
      const chip = html`<span class="hz-chip" title="${v}">
        <span>${v}</span>
        <button type="button" aria-label="Remove">×</button>
      </span>`
      chip.querySelector("button").onclick = () => { selected.delete(v); emit() }
      chips.appendChild(chip)
    }
  }

  const filteredOptions = () => {
    const q = (search.value ?? "").trim().toLowerCase()
    if (!q) return options
    return options.filter((d) => String(d).toLowerCase().includes(q))
  }

  const renderList = () => {
    list.replaceChildren()
    const filt = filteredOptions()
    const shown = filt.slice(0, maxRender)

    meta.replaceChildren(
      html`<span class="hz-ms__metaText">
        ${filt.length.toLocaleString()} match(es) · showing ${shown.length.toLocaleString()}
        ${filt.length > maxRender ? html` <span class="hz-ms__metaWarn">(refine search to see more)</span>` : ""}
      </span>`
    )

    for (const v of shown) {
      const row = html`<label class="hz-ms__item">
        <input type="checkbox" />
        <span class="hz-ms__itemText">${v}</span>
      </label>`
      const cb = row.querySelector("input")
      cb.checked = selected.has(v)
      cb.onchange = () => {
        if (cb.checked) {
          if (exclusive && v === exclusive) {
            selected.clear()
            selected.add(exclusive)
          } else {
            selected.add(v)
            if (exclusive) selected.delete(exclusive)
          }
        } else {
          selected.delete(v)
          setExclusiveRules(selected)
        }
        emit()
      }
      list.appendChild(row)
    }

    if (!shown.length) {
      list.appendChild(html`<div class="hz-ms__empty">No matches.</div>`)
    }
  }

  // Build action buttons
  btns.replaceChildren()
  for (const a of (actions ?? [])) {
    const b = html`<button type="button" class="hz-ms__btn">${a.label}</button>`
    b.onclick = () => {
      if (a.id === "none") {
        selected.clear()
        if (exclusive) selected.add(exclusive)
        emit()
      } else if (a.id === "all") {
        if (exclusive) {
          selected.clear()
          selected.add(exclusive)
        } else {
          selected.clear()
          for (const v of options) selected.add(v)
        }
        emit()
      }
    }
    btns.appendChild(b)
  }

  search.oninput = () => renderList()

  // initial paint
  renderChips()
  renderList()

  return form
}
```

```{ojs}
//| output: false
viewof hz_admin0 = hz_makeMultiSelect({
  label: "Admin0 (country)",
  options: hz_admin0Choices,
  value: ["Kenya"],
  placeholder: "Search countries…",
  actions: [
    { id: "all", label: "All" },
    { id: "none", label: "Clear" }
  ],
  exclusive: "all",
  maxHeight: 260,
  maxRender: 400
})
```

```{ojs}
//| output: false
hz_admin1Choices = {
  const isErr = hz_adminNames?.[0]?.error
  if (isErr) return []
  const a0 = new Set(hz_admin0 ?? [])
  if (a0.size === 1 && a0.has("all")) return []
  return Array.from(new Set(
    hz_adminNames
      .filter(d => a0.has(d.admin0_name))
      .map(d => d.admin1_name)
      .filter(v => v != null && v !== "")
  )).sort()
}
```

```{ojs}
//| output: false
viewof hz_admin1 = hz_makeMultiSelect({
  label: "Admin1 (optional)",
  options: hz_admin1Choices,
  value: [],
  placeholder: hz_admin1Choices.length ? "Search admin1…" : "Select Admin0 first…",
  actions: [{ id: "none", label: "Clear" }],
  disabled: hz_admin1Choices.length === 0,
  maxHeight: 260,
  maxRender: 500
})
```

```{ojs}
//| output: false
hz_admin2Choices = {
  const isErr = hz_adminNames?.[0]?.error
  if (isErr) return []
  const a0 = new Set((hz_admin0 ?? []).filter((d) => d !== "all"))
  const a1 = new Set((hz_admin1 ?? []).filter(Boolean))
  if (a0.size === 0) return []
  if (a1.size === 0) return []
  const rows = hz_adminNames.filter((d) => a0.has(d.admin0_name) && a1.has(d.admin1_name))
  return Array.from(new Set(
    rows.map((d) => d.admin2_name).filter((v) => v != null && String(v).trim() !== "")
  )).sort()
}
```

```{ojs}
//| output: false
viewof hz_admin2 = hz_makeMultiSelect({
  label: "Admin2 (optional)",
  options: hz_admin2Choices,
  value: [],
  placeholder: hz_admin2Choices.length ? "Search admin2…" : "Select Admin1 first…",
  actions: [{ id: "none", label: "Clear" }],
  disabled: hz_admin2Choices.length === 0,
  maxHeight: 260,
  maxRender: 600
})
```

```{ojs}
//| output: false
hz_geoFilter = ({
  admin0: (hz_admin0 ?? []),
  admin1: (hz_admin1 ?? []),
  admin2: (hz_admin2 ?? [])
})

hz_geoResolvedLevel = {
  const a0 = hz_geoFilter.admin0 ?? []
  const hasAll = a0.length === 0 || a0.includes("all")
  if (hasAll) return "admin0"
  if ((hz_geoFilter.admin2 ?? []).length) return "admin2"
  if ((hz_geoFilter.admin1 ?? []).length) return "admin1"
  return "admin0"
}

hz_geoSelectionCount = {
  const lvl = hz_geoResolvedLevel
  const a0 = (hz_geoFilter.admin0 ?? []).filter((d) => d != null && String(d).trim() !== "" && d !== "all")
  if (lvl === "admin2") return (hz_geoFilter.admin2 ?? []).length
  if (lvl === "admin1") return (hz_geoFilter.admin1 ?? []).length
  return (hz_geoFilter.admin0 ?? []).includes("all") || (hz_geoFilter.admin0 ?? []).length === 0 ? 1 : a0.length
}

```

```{ojs}
//| output: false
// Geo filter preview
hz_geoTable = {
  const gf = hz_geoFilter ?? {admin0: [], admin1: [], admin2: []}
  const a0raw = Array.isArray(gf.admin0) ? gf.admin0.filter(Boolean) : []
  const hasAll = a0raw.length === 0 || a0raw.includes("all")
  const a0 = hasAll ? ["all"] : a0raw.filter((d) => d !== "all")
  const a1 = hasAll ? [] : (Array.isArray(gf.admin1) ? gf.admin1.filter(Boolean) : [])
  const a2 = hasAll ? [] : (Array.isArray(gf.admin2) ? gf.admin2.filter(Boolean) : [])

  const chipRow = (arr, max = 10) => {
    const shown = arr.slice(0, max)
    const more = arr.length > max ? arr.length - max : 0
    return html`<div style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;">
      ${shown.map((d) => html`<span class="hz-chip"><span>${d}</span></span>`)}
      ${more ? html`<span class="hz-chip"><span>+${more} more</span></span>` : ""}
    </div>`
  }

  return html`<div class="hz-card" style="margin-top:10px;">
    <div class="hz-card__head">
      <div>
        <div class="hz-card__title">Geography summary</div>
        <div class="hz-card__sub">Resolved level: <b>${hz_geoResolvedLevel}</b> · selections: <b>${hz_geoSelectionCount}</b></div>
      </div>
    </div>
    <div class="hz-muted" style="margin-top:4px;">Admin0</div>
    ${chipRow(a0)}
    <div class="hz-muted" style="margin-top:10px;">Admin1</div>
    ${a1.length ? chipRow(a1) : html`<div class="hz-muted">—</div>`}
    <div class="hz-muted" style="margin-top:10px;">Admin2</div>
    ${a2.length ? chipRow(a2) : html`<div class="hz-muted">—</div>`}
  </div>`
}

hz_geoPanelReal = html`
  <div>
    <div class="hz-card">
      <div class="hz-card__head">
        <div>
          <div class="hz-card__title">Geography</div>
          <div class="hz-card__sub">Geography selection is in <a href="#controls">Controls</a>. This section shows a summary.</div>
        </div>
        <a class="hz-pill" href="#controls" style="text-decoration:none">Change selection</a>
      </div>
      <div class="hz-muted">Tip: If you need to confirm what’s being queried, use the chips below (resolved level + selected admin names).</div>
    </div>

    <div style="height:12px"></div>
    ${hz_geoTable}

    ${
      hz_adminNames?.[0]?.error
        ? html`<div class="warn" style="margin-top:10px"><b>Admin names load failed:</b><br>${hz_adminNames[0].error}</div>`
        : ""
    }
  </div>
`
```

```{ojs}
//| output: false
// WHERE clause builder for the hazard exposure parquet schema
hz_q = (s) => "'" + String(s).replaceAll("'", "''") + "'"

// Crop WHERE helper (safe SQL quoting; supports UI sentinel "all")
hz_cropWhere = (commodities) => {
  const list = Array.isArray(commodities) ? commodities.filter((d) => d != null && String(d).trim() !== "") : []
  const hasAll = list.length === 0 || list.includes("all")
  if (hasAll) return "TRUE"
  const vals = list.filter((d) => d !== "all")
  if (!vals.length) return "TRUE"
  return `crop IN (${vals.map(hz_q).join(", ")})`
}

// hazard_vars lists
// - generic: NDWS (drought) + NTx35 / THI-max (heat) + NDWL0 (flood)
// - crop_specific: PTOT-L (drought) + NTxS / THI-max (heat) + PTOT-G (flood)
hz_interactions = ({
  generic: [
    "NDWS+NTx35+NDWL0",
    "NDWS+THI-max+NDWL0"
  ],
  crop_specific: [
    "PTOT-L+NTxS+PTOT-G",
    "PTOT-L+THI-max+PTOT-G"
  ]
})

// hazard_vars WHERE helper
hz_hazardVarsWhere = (method, commodGroup) => {
  const m = String(method ?? "").toLowerCase()
  const cg = String(commodGroup ?? "").toLowerCase()

  const vars =
    (m === "generic") ? hz_interactions.generic :
    (m === "crop-specific" || m === "crop_specific") ? hz_interactions.crop_specific :
    // auto (best available): default to crop_specific unless we're aggregating "all"
    ((cg === "all" || cg === "" || cg === "total") ? hz_interactions.generic : hz_interactions.crop_specific)

  return `hazard_vars IN (${vars.map(hz_q).join(", ")})`
}

// Exposure value/unit WHERE helper
hz_unitWhere = (varShort) => {
  return "TRUE"
}

// Severity WHERE helper
hz_sevWhere = (severity) => {
  return "TRUE"
}

hz_geoWhere = (geoFilter) => {
  const gf = geoFilter ?? {}
  const admin0 = Array.isArray(gf.admin0) ? gf.admin0.filter((d) => d != null && String(d).trim() !== "") : []
  const admin1 = Array.isArray(gf.admin1) ? gf.admin1.filter((d) => d != null && String(d).trim() !== "") : []
  const admin2 = Array.isArray(gf.admin2) ? gf.admin2.filter((d) => d != null && String(d).trim() !== "") : []

  
  const hasAll = admin0.length === 0 || admin0.includes("all")
  const a0 = hasAll ? [] : admin0.filter((d) => d !== "all")
  const a1 = hasAll ? [] : admin1
  const a2 = hasAll ? [] : admin2

  const q = (s) => `'${String(s).replaceAll("'", "''")}'`
  const inList = (vals) => vals.map(q).join(", ")

  const wh = []

  // Only constrain admin0 when user chose specific countries
  if (a0.length > 0) {
    wh.push(`admin0_name IN (${inList(a0)})`)
  }

  if (a2.length > 0) {
    // Admin2 totals: admin0 + (optional admin1) + admin2
    if (a1.length > 0) wh.push(`admin1_name IN (${inList(a1)})`)
    wh.push(`admin2_name IN (${inList(a2)})`)
  } else if (a1.length > 0) {
    // Admin1 totals: admin0 + admin1, and admin2 NULL
    wh.push(`admin1_name IN (${inList(a1)})`)
    wh.push(`admin2_name IS NULL`)
  } else {
    // Admin0 totals: admin1/admin2 NULL
    wh.push(`admin1_name IS NULL`)
    wh.push(`admin2_name IS NULL`)
  }

  return wh.join("\n      AND ")
}

hz_scenWhere = (sc) => {
  const p = (typeof sc === "string") ? hz_parseScenXTime(sc) : (sc ?? {})
  const scenario = p.scenario
  const timeframe = p.timeframe ?? (scenario === "historic" ? "historic" : null)
  if (!scenario || !timeframe) return "FALSE"
  return `scenario = ${hz_q(scenario)} AND timeframe = ${hz_q(timeframe)}`
}
```

```{ojs}
//| output: false
viewof hz_loadSchema = Inputs.toggle(false, { label: "Load schema tables (debug, slower)" })
```



```{ojs}
//| output: false
// -----------------------------
// FAST API PATH (v3): call the FastAPI + Redis service for all heavy queries.

// API base URL
hz_apiBaseUrl = (() => {
  try {
    const u = new URL(window.location.href)
    const p = u.searchParams.get('api')
    if (p) return p.replace(/\/+$/, '')
  } catch (_) {}
  return (globalThis.__ATLAS_HZ_API_BASE__ ??= 'https://atlasapi.jcdevops.com')
})()

// Tiny client cache + debounce state (persists across reactive runs)
hz_apiState = globalThis.__ATLAS_HZ_API_STATE__ ??= {
  cache: new Map(),       // key -> { t:number, v:any }
  order: [],              // insertion order for LRU
  inflight: new Map(),    // key -> Promise
  timers: new Map(),      // group -> timeout id
  aborts: new Map(),      // group -> AbortController
  tokens: new Map(),      // group -> number
  maxEntries: 40
}

hz_stableStringify = (v) => {
  const seen = new WeakSet()
  const norm = (x) => {
    if (x === null || x === undefined) return x
    if (typeof x !== 'object') return x
    if (seen.has(x)) return null
    seen.add(x)
    if (Array.isArray(x)) return x.map(norm)
    const out = {}
    for (const k of Object.keys(x).sort()) out[k] = norm(x[k])
    return out
  }
  return JSON.stringify(norm(v))
}

hz_lruGet = (key, ttlMs) => {
  const hit = hz_apiState.cache.get(key)
  if (!hit) return null
  if (ttlMs > 0 && (Date.now() - hit.t) > ttlMs) {
    hz_apiState.cache.delete(key)
    return null
  }
  // refresh LRU position
  const i = hz_apiState.order.indexOf(key)
  if (i >= 0) hz_apiState.order.splice(i, 1)
  hz_apiState.order.push(key)
  return hit.v
}

hz_lruSet = (key, val) => {
  if (hz_apiState.cache.has(key)) {
    hz_apiState.cache.delete(key)
    const i = hz_apiState.order.indexOf(key)
    if (i >= 0) hz_apiState.order.splice(i, 1)
  }
  hz_apiState.cache.set(key, { t: Date.now(), v: val })
  hz_apiState.order.push(key)
  while (hz_apiState.order.length > hz_apiState.maxEntries) {
    const oldest = hz_apiState.order.shift()
    if (oldest) hz_apiState.cache.delete(oldest)
  }
  return val
}

hz_apiPostJson = async (path, body, { signal } = {}) => {
  const url = hz_apiBaseUrl + path
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body ?? {}),
    signal
  })
  const isJson = (res.headers.get('content-type') || '').includes('application/json')
  const payload = isJson ? await res.json() : { ok: false, detail: await res.text() }
  if (!res.ok) {
    const msg = payload?.detail || payload?.error || payload?.message || ('' + res.status)
    throw new Error(msg)
  }
  return payload
}

// Debounced + cached API call.
hz_apiDebouncedCached = async (groupKey, path, body, { ttlMs = 60000, debounceMs = 250 } = {}) => {
  const key = `${path}|${hz_stableStringify(body)}`

  // local cache hit
  const cached = hz_lruGet(key, ttlMs)
  if (cached != null) return cached

  // share inflight identical requests
  if (hz_apiState.inflight.has(key)) return await hz_apiState.inflight.get(key)

  // cancel previous in this group
  try { clearTimeout(hz_apiState.timers.get(groupKey)) } catch (_) {}
  try { hz_apiState.aborts.get(groupKey)?.abort() } catch (_) {}

  const token = (hz_apiState.tokens.get(groupKey) || 0) + 1
  hz_apiState.tokens.set(groupKey, token)

  const ac = new AbortController()
  hz_apiState.aborts.set(groupKey, ac)

  const p = new Promise((resolve) => {
    const t = setTimeout(async () => {
      let busyOn = false
      try {
        // If a newer request has superseded this one before it even starts, skip.
        if (hz_apiState.tokens.get(groupKey) !== token) return resolve([])

        // UI: show an 'Updating…' overlay ONLY when the network call actually starts.
        try { globalThis.__ATLAS_HZ_UI__?.setBusy?.(true) ; busyOn = true } catch (_) { busyOn = false }

        const out = await hz_apiPostJson(path, body, { signal: ac.signal })
        // Only accept latest
        if (hz_apiState.tokens.get(groupKey) !== token) return resolve([])
        resolve(hz_lruSet(key, out))
      } catch (e) {
        if (String(e).includes('AbortError')) return resolve([])
        resolve({ ok: false, error: String(e) })
      } finally {
        // Always clear the busy overlay if we turned it on.
        try { if (busyOn) globalThis.__ATLAS_HZ_UI__?.setBusy?.(false) } catch (_) {}
        hz_apiState.inflight.delete(key)
      }
    }, debounceMs)
    hz_apiState.timers.set(groupKey, t)
  })

  hz_apiState.inflight.set(key, p)
  return await p
}

```

```{ojs}
//| output: false
// Build a single "Q1" request that returns everything needed for the main chart.
hz_isBroadGeo = (geo) => {
  const a0 = Array.isArray(geo?.admin0) ? geo.admin0.filter((d) => d && d !== "all") : []
  // If no specific admin0 selected, it's broad.
  if (a0.length === 0) return true
  // If the UI includes "all" explicitly, treat as broad.
  if (Array.isArray(geo?.admin0) && geo.admin0.includes("all")) return true
  return false
}

hz_q1Req = (() => {
  if (hz_isBroadGeo?.(hz_geoFilter)) {
    return { ok: false, error: 'Select at least an Admin0 (or Admin1/Admin2). Broad selection is intentionally blocked for speed.' }
  }

  if (!(hz_src1?.ok && hz_src2?.ok)) {
    return { ok: false, error: 'Dataset URLs not resolved yet.' }
  }

  const left = {
    dataset_url: hz_src1.url,
    scen: { scenario: hz_s1?.scenario, timeframe: hz_s1?.timeframe },
    geo: hz_geoFilter,
    commodities: hz_selectedCommodities ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
  }

  const right = {
    dataset_url: hz_src2.url,
    scen: { scenario: hz_s2?.scenario, timeframe: hz_s2?.timeframe },
    geo: hz_geoFilter,
    commodities: hz_selectedCommodities ?? [],
    hazard_vars: null,
    hazards: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
  }

  const denom = null
return { ok: true, body: { left, right, denom } }
})()

```

```{ojs}
//| output: false
// Call the API (debounced + cached)

hz_q1Resp = (hz_activeQuestion === "q1" && hz_q1Req?.ok)
  ? await hz_apiDebouncedCached("q1", "/api/v1/hz/q1", hz_q1Req.body, { ttlMs: 60000, debounceMs: 250 })
  : { ok: false, error: hz_q1Req?.error || "Inactive", left: [], right: [], merged: [], denom: { ok: false, denom: null }, relative_label: "% of hazard sum" }

// Expose the same variables the rest of the notebook already expects
hz_tot1 = hz_q1Resp?.left ?? []
hz_tot2 = hz_q1Resp?.right ?? []
hz_merged = hz_q1Resp?.merged ?? []
hz_denom = hz_q1Resp?.denom ?? { ok: false, denom: null, error: "No denom" }
hz_relativeLabel = hz_q1Resp?.relative_label ?? "% of hazard sum"

// Meta object expected by hz_updateChart
hz_q1Meta = ({
  ok: !!(hz_q1Resp?.ok),
  cached: !!(hz_q1Resp?.cached),
  t_ms: Number(hz_q1Resp?.t_ms || 0),
  error: hz_q1Resp?.error || null
})


// Normalize + rank rows for chart/table (Q1)
hz_chartRows = {
  const src = Array.isArray(hz_merged) ? hz_merged : []

  const rows = src.map((r) => {
    const hazard = r.hazard ?? r.Hazard ?? r.name ?? r.key ?? "Unknown"
    const total1 = Number(r.total1 ?? r.left ?? r.value1 ?? r.total_left ?? 0)
    const total2 = Number(r.total2 ?? r.right ?? r.value2 ?? r.total_right ?? 0)
    const total_diff = Number(r.total_diff ?? (total2 - total1))
    return { ...r, hazard, total1, total2, total_diff }
  })

  const sumAll1 = rows.reduce((a, r) => a + Number(r.total1 ?? 0), 0)
  const sumAll2 = rows.reduce((a, r) => a + Number(r.total2 ?? 0), 0)
  const pct = (v, denom) => (denom ? (100 * Number(v ?? 0)) / denom : 0)

  for (const r of rows) {
    r.perc1 = Number(r.perc1 ?? pct(r.total1, sumAll1))
    r.perc2 = Number(r.perc2 ?? pct(r.total2, sumAll2))
    r.pct_diff = Number(r.pct_diff ?? (r.perc2 - r.perc1))
  }

  if (hz_compareMode === "diff") {
    const metric = hz_relative ? "pct_diff" : "total_diff"
    rows.sort((a, b) =>
      Math.abs(Number(b[metric] ?? 0)) - Math.abs(Number(a[metric] ?? 0))
    )
  } else {
    const m2 = hz_relative ? "perc2" : "total2"
    const m1 = hz_relative ? "perc1" : "total1"
    rows.sort((a, b) =>
      (Number(b[m2] ?? 0) - Number(a[m2] ?? 0)) ||
      (Number(b[m1] ?? 0) - Number(a[m1] ?? 0))
    )
  }

  const topN = Math.max(1, Number(hz_topN ?? 15) || 15)
  let head = rows.slice(0, topN)

  if (hz_groupOther && rows.length > topN) {
    const rest = rows.slice(topN)
    const sum = (k) => rest.reduce((a, r) => a + Number(r[k] ?? 0), 0)

    const otherTotal1 = sum("total1")
    const otherTotal2 = sum("total2")
    const otherDiff = otherTotal2 - otherTotal1

    head = head.concat([{
      hazard: "Other",
      total1: otherTotal1,
      total2: otherTotal2,
      total_diff: otherDiff,
      perc1: pct(otherTotal1, sumAll1),
      perc2: pct(otherTotal2, sumAll2),
      pct_diff: pct(otherTotal2, sumAll2) - pct(otherTotal1, sumAll1)
    }])
  }

  return head.map((r) => {
    const total1 = Number(r.total1 ?? 0)
    const total2 = Number(r.total2 ?? 0)
    const total_diff = Number(r.total_diff ?? (total2 - total1))
    const perc1 = pct(total1, sumAll1)
    const perc2 = pct(total2, sumAll2)
    const pct_diff = perc2 - perc1
    return { ...r, hazard: r.hazard ?? "Unknown", total1, total2, total_diff, perc1, perc2, pct_diff }
  })
}
```

```{ojs}
//| output: false
// Build Plot chart
hz_q1Chart = {
  const data = Array.isArray(hz_chartRows) ? hz_chartRows : []
  if (!data.length) return html`<div class="hz-empty">No data for the current filters.</div>`

  const absLabel = hz_varLabel || "Value"
  const pctLabel = hz_relativeLabel || "%"
  const xLabel = hz_relative ? pctLabel : absLabel

  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })
  const fmtPct = (x) => `${hz_formatNumber(x, { digits: 2 })}%`

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`

  if (!hz_difference) {
    const side = data.flatMap(d => ([
      { hazard: d.hazard, scenario: hz_s1.label, value: hz_relative ? d.perc1 : d.total1, raw: d.total1, pct: d.perc1 },
      { hazard: d.hazard, scenario: hz_s2.label, value: hz_relative ? d.perc2 : d.total2, raw: d.total2, pct: d.perc2 }
    ]))

    return Plot.plot({
      width: Math.max(520, (hz_plotWidth ?? 900) - 24),
      height: hz_chartHeight,
      marginLeft: 210,
      marginRight: 24,
      marginTop: 36,
      marginBottom: 40,
      x: {
        label: xLabel,
        grid: true,
        tickFormat: hz_relative ? fmtPct : fmtAbs
      },
      y: { label: null },
      color: { legend: true },
      caption: subtitle,
      marks: [
        Plot.ruleX([0]),
        Plot.barX(side, {
          x: "value",
          y: "hazard",
          fill: "scenario",
          inset: 0.5,
          tip: {
            format: {
              hazard: true,
              scenario: true,
              value: hz_relative ? fmtPct : fmtAbs,
              raw: hz_relative ? fmtAbs : null,
              pct: hz_relative ? null : fmtPct
            }
          }
        })
      ]
    })
  }

  // Difference mode
  return Plot.plot({
    height: hz_chartHeight,
    marginLeft: 210,
    marginRight: 24,
    marginTop: 36,
    marginBottom: 40,
    x: {
      label: xLabel,
      grid: true,
      tickFormat: hz_relative ? fmtPct : fmtAbs
    },
    y: { label: null },
    color: { legend: true },
    caption: subtitle,
    marks: [
      Plot.ruleX([0]),
      Plot.barX(data, {
        x: hz_relative ? "pct_diff" : "total_diff",
        y: "hazard",
        fill: (d) => (Number(d.total_diff ?? 0) >= 0 ? "Increase" : "Decrease"),
        inset: 0.5,
        tip: {
          format: {
            hazard: true,
            value: hz_relative ? fmtPct : fmtAbs
          }
        }
      })
    ]
  })
}
```

```{ojs}
//| output: false
// Dashboard question selector (tabs)
viewof hz_question = {
  const options = [
    { value: "q1", label: "Hazards" },
    { value: "q2", label: "Commodities" },
    { value: "q3", label: "Hazard × commodity" },
    { value: "q4", label: "Geography" }
  ];

  const root = document.createElement("div");
  root.className = "hz-tabs";

  const buttons = new Map();
  const paint = (v) => {
    for (const [val, btn] of buttons.entries()) btn.classList.toggle("is-active", val === v);
  };

  const set = (v, { silent = false } = {}) => {
    if (root.value === v) return; // prevents duplicate requests on re-click
    root.value = v;
    paint(v);
    if (!silent) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  for (const opt of options) {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "hz-tab";
    b.textContent = opt.label;
    b.onclick = () => set(opt.value);
    root.appendChild(b);
    buttons.set(opt.value, b);
  }

  // Initial value is set WITHOUT emitting an input event.
  // Observable reads the initial value from root.value when the view is created.
  root.value = "q1";
  paint("q1");

  return root;
}


viewof hz_viewMode = {
  const options = [
    { value: "chart",   label: "Chart",        icon: "📈" },
    { value: "table",   label: "Summary Table",        icon: "▦" },
    { value: "both",    label: "Chart+ Summary",  icon: "▤" },
    { value: "records", label: "Raw Records",      icon: "🗃️" }
  ];

  const root = document.createElement("div");
  root.className = "hz-viewToggle";
  root.setAttribute("role", "radiogroup");

  const lbl = document.createElement("div");
  lbl.className = "hz-viewToggle__label";
  lbl.textContent = "View";
  root.appendChild(lbl);

  const group = document.createElement("div");
  group.className = "hz-viewToggle__group";
  root.appendChild(group);

  const buttons = new Map();

  const set = (v, emit = true) => {
    root.value = v;
    paint(v);
    if (emit) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  const paint = (v) => {
    for (const [val, btn] of buttons.entries()) {
      const on = (val === v);
      btn.classList.toggle("is-active", on);
      btn.setAttribute("aria-checked", on ? "true" : "false");
      btn.setAttribute("tabindex", on ? "0" : "-1");
    }
  };

  for (const op of options) {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "hz-viewBtn";
    b.setAttribute("role", "radio");
    b.setAttribute("aria-checked", "false");
    b.innerHTML = `<span class="hz-viewBtn__ic">${op.icon}</span><span class="hz-viewBtn__tx">${op.label}</span>`;
    b.onclick = () => set(op.value);
    b.onkeydown = (e) => {
      if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;
      e.preventDefault();
      const vals = options.map(o => o.value);
      const i = Math.max(0, vals.indexOf(root.value));
      const j = (e.key === "ArrowRight") ? Math.min(vals.length - 1, i + 1) : Math.max(0, i - 1);
      set(vals[j]);
      buttons.get(vals[j])?.focus?.();
    };
    buttons.set(op.value, b);
    group.appendChild(b);
  }

  // Default: Chart (as requested)
  root.value = "chart";
  paint("chart");

  return root;
}

viewof hz_recordsSide = {
  const options = [
    { value: "left",  label: "Left" },
    { value: "right", label: "Right" }
  ];

  const root = document.createElement("div");
  root.className = "hz-tabs hz-tabs--small";

  const buttons = new Map();
  const paint = (v) => {
    for (const [val, btn] of buttons.entries()) btn.classList.toggle("is-active", val === v);
  };

  const set = (v, { silent = false } = {}) => {
    if (root.value === v) return;
    root.value = v;
    paint(v);
    if (!silent) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  for (const op of options) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "hz-tab";
    btn.textContent = op.label;
    btn.onclick = () => set(op.value);
    buttons.set(op.value, btn);
    root.appendChild(btn);
  }

  set("left", { silent: true });
  return root;
}

viewof hz_recordsSort = {
  const options = ["value_desc", "value_asc"]
  const labelMap = { value_desc: "Value ↓", value_asc: "Value ↑" }
  const sel = Inputs.select(options, {
    value: "value_desc",
    label: null,
    format: (d) => labelMap[d] ?? String(d)
  });
  sel.classList.add("hz-select");
  return sel;
}

viewof hz_recordsPageSize = {
  const options = [50, 100, 200, 500]
  const sel = Inputs.select(options, {
    value: 100,
    label: null,
    format: (d) => `${d} rows`
  });
  sel.classList.add("hz-select");
  return sel;
}

viewof hz_recordsPage = {
  const root = document.createElement("div");
  root.className = "hz-pager";
  root.value = 1;

  const prev = document.createElement("button");
  prev.type = "button";
  prev.className = "hz-btn hz-btn--sm";
  prev.textContent = "Prev";

  const label = document.createElement("div");
  label.className = "hz-pager__label";

  const next = document.createElement("button");
  next.type = "button";
  next.className = "hz-btn hz-btn--sm";
  next.textContent = "Next";

  const paint = () => { label.textContent = `Page ${root.value}`; };

  const set = (v, { silent = false } = {}) => {
    const n = Math.max(1, Number(v || 1));
    if (root.value === n) return;
    root.value = n;
    paint();
    if (!silent) root.dispatchEvent(new Event("input", { bubbles: true }));
  };

  prev.onclick = () => set(root.value - 1);
  next.onclick = () => set(root.value + 1);

  root.appendChild(prev);
  root.appendChild(label);
  root.appendChild(next);

  paint();

  globalThis.__ATLAS_HZ_REC_PAGER__ = { prev, next, label, set };
  return root;
}


hz_activeQuestion = (hz_question ?? "q1")

hz_dashTitle = ({
  q1: "Total exposure by hazard",
  q2: "Total exposure by crop",
  q3: "Hazard composition by crop",
  q4: "Exposure by administrative area"
})[hz_activeQuestion] || "Dashboard"

hz_dashSub = ({
  q1: "Compare Left vs Right (side-by-side or Δ). Filters: scenarios, geography, commodities, severity.",
  q2: "Which commodities contribute most to exposure in the selected geography?",
  q3: "For the top crops, how is exposure split across hazards? (stacked)",
  q4: "Which admin areas contribute most to exposure under the current geography?"
})[hz_activeQuestion] || ""
// Common request payload for single-side endpoints
hz_sideReq = (src, scen, extra = {}) => ({
  dataset_url: src?.url,
  scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
  geo: hz_geoFilter,
  commodities: hz_selectedCommodities ?? [],
  hazard_vars: null,
  hazards: null,
  method: hz_method,
  commodity_group: hz_selectedCommodGroup,
  ...extra
})
```

```{ojs}
//| output: false
// ----------------------------
// Q2 — totals by crop
// ----------------------------
hz_q2RespL = (hz_activeQuestion === "q2")
  ? await hz_apiDebouncedCached("q2L", "/api/v1/hz/totals-by-crop", hz_sideReq(hz_src1, hz_s1), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q2RespR = (hz_activeQuestion === "q2")
  ? await hz_apiDebouncedCached("q2R", "/api/v1/hz/totals-by-crop", hz_sideReq(hz_src2, hz_s2), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q2DataL = hz_q2RespL?.data ?? []
hz_q2DataR = hz_q2RespR?.data ?? []

hz_q2Meta = ({
  ok: !!(hz_q2RespL?.ok && hz_q2RespR?.ok),
  cached: !!(hz_q2RespL?.cached && hz_q2RespR?.cached),
  t_ms: Math.max(Number(hz_q2RespL?.t_ms || 0), Number(hz_q2RespR?.t_ms || 0)),
  error: hz_q2RespL?.error || hz_q2RespR?.error || null
})

hz_q2Rows = {
  const mapL = new Map(hz_q2DataL.map(d => [d.crop, Number(d.total)]))
  const mapR = new Map(hz_q2DataR.map(d => [d.crop, Number(d.total)]))
  const crops = Array.from(new Set([...mapL.keys(), ...mapR.keys()]))
  const rows = crops.map(crop => ({ crop, total1: mapL.get(crop) || 0, total2: mapR.get(crop) || 0 }))
  rows.sort((a,b) => (b.total2 - a.total2) || (b.total1 - a.total1))
  return rows.slice(0, hz_topN)
}

hz_q2Chart = {
  const rows = hz_q2Rows ?? []
  const labelAbs = hz_varLabelAbs
  const xLabel = hz_rel ? "Percent of side total (%)" : labelAbs

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`

  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const sum1 = rows.reduce((s,r) => s + (r.total1 || 0), 0)
  const sum2 = rows.reduce((s,r) => s + (r.total2 || 0), 0)

  const v1 = (d) => hz_rel ? (sum1 ? (100 * d.total1 / sum1) : 0) : d.total1
  const v2 = (d) => hz_rel ? (sum2 ? (100 * d.total2 / sum2) : 0) : d.total2

  if (hz_compareMode === "diff") {
    const diff = rows.map(d => ({ crop: d.crop, delta: v2(d) - v1(d) }))
    return Plot.plot({
      height: Math.max(280, diff.length * 22, Number(hz_chartHeight ?? 520)),
      marginLeft: 160,
      x: { grid: true, label: hz_rel ? "Δ percentage points (Right − Left)" : "Δ exposure (Right − Left)" },
      y: { domain: diff.map(d => d.crop) },
      caption: subtitle,
      marks: [
        Plot.ruleX([0]),
        Plot.barX(diff, { x: "delta", y: "crop", tip: true })
      ]
    })
  }

  const crops = rows.map(d => d.crop)
  const left = rows.map(d => ({ crop: d.crop, value: v1(d) }))
  const right = rows.map(d => ({ crop: d.crop, value: v2(d) }))

  const plotSide = (data, title) => html`
    <div class="hz-mini">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(280, crops.length * 22, Number(hz_chartHeight ?? 520)),
        marginLeft: 160,
        x: { grid: true, label: xLabel },
        y: { domain: crops },
        caption: subtitle,
        marks: [
          Plot.barX(data, { x: "value", y: "crop", tip: true }),
          Plot.ruleX([0])
        ]
      })}
    </div>
  `

  return html`<div class="hz-grid2">${plotSide(left, "Left")}${plotSide(right, "Right")}</div>`
}
```

```{ojs}
//| output: false
// ----------------------------
// Q3 — hazard by crop
// ----------------------------
hz_q3ReqExtra = ({ top_hazards: 10, top_crops: 12 })

hz_q3RespL = (hz_activeQuestion === "q3")
  ? await hz_apiDebouncedCached("q3L", "/api/v1/hz/hazard-by-crop", hz_sideReq(hz_src1, hz_s1, hz_q3ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q3RespR = (hz_activeQuestion === "q3")
  ? await hz_apiDebouncedCached("q3R", "/api/v1/hz/hazard-by-crop", hz_sideReq(hz_src2, hz_s2, hz_q3ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q3DataL = hz_q3RespL?.data ?? []
hz_q3DataR = hz_q3RespR?.data ?? []

hz_q3Meta = ({
  ok: !!(hz_q3RespL?.ok && hz_q3RespR?.ok),
  cached: !!(hz_q3RespL?.cached && hz_q3RespR?.cached),
  t_ms: Math.max(Number(hz_q3RespL?.t_ms || 0), Number(hz_q3RespR?.t_ms || 0)),
  error: hz_q3RespL?.error || hz_q3RespR?.error || null
})

hz_q3Chart = {
  const L = hz_q3DataL ?? []
  const R = hz_q3DataR ?? []
  if (!L.length && !R.length) return html`<div class="hz-muted">No data.</div>`

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`
  const fmtAbs = (x) => hz_formatNumber(x, { digits: 2 })


  // Top crops by combined exposure (Left + Right)
  const cropTotals = new Map()
  const bump = (crop, v) => cropTotals.set(crop, (cropTotals.get(crop) || 0) + Number(v || 0))
  for (const d of R) bump(d.crop, d.total)
  for (const d of L) bump(d.crop, d.total)

  const maxCrops = Math.min(10, Number(hz_topN || 10))
  const crops = Array.from(cropTotals.entries())
    .sort((a,b) => b[1] - a[1])
    .slice(0, maxCrops)
    .map(([c]) => c)

  const hazards = Array.from(new Set([...L.map(d => d.hazard), ...R.map(d => d.hazard)])).sort()

  const filter = (data) =>
    data
      .filter(d => crops.includes(d.crop) && hazards.includes(d.hazard))
      .map(d => ({ crop: d.crop, hazard: d.hazard, total: Number(d.total || 0) }))

  // Shared categorical color scale (keeps left/right colors aligned)
  const color = { type: "categorical", domain: hazards, scheme: "tableau10", legend: false }
  const legend = Plot.legend({ color: { domain: hazards, scheme: "tableau10" }, columns: 3 })

  const plotStack = (data, title) => html`
    <div class="hz-mini hz-mini--stack">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(320, crops.length * 26, Number(hz_chartHeight ?? 520)),
        marginLeft: 160,
        marginRight: 18,
        marginTop: 10,
        marginBottom: 28,
        x: { label: (hz_varLabelAbs ?? "Exposure"), grid: true },
        y: { domain: crops, label: null },
        color,
        caption: subtitle,
        marks: [
          Plot.barX(filter(data), {
            ...Plot.stackX({ x: "total", y: "crop", fill: "hazard" }),
            tip: {
              format: {
                crop: true,
                hazard: true,
                total: fmtAbs
              }
            }
          }),
          Plot.ruleX([0])
        ]
      })}
    </div>
  `

  return html`
    <div class="hz-legendRow">${legend}</div>
    <div class="hz-grid2 hz-grid2--equal">
      ${plotStack(L, "Left")}
      ${plotStack(R, "Right")}
    </div>
  `
}

```

```{ojs}
//| output: false
// ----------------------------
// Q4 — totals by admin area
// ----------------------------
hz_q4ReqExtra = ({ group_child: false })

hz_q4RespL = (hz_activeQuestion === "q4")
  ? await hz_apiDebouncedCached("q4L", "/api/v1/hz/by-admin", hz_sideReq(hz_src1, hz_s1, hz_q4ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q4RespR = (hz_activeQuestion === "q4")
  ? await hz_apiDebouncedCached("q4R", "/api/v1/hz/by-admin", hz_sideReq(hz_src2, hz_s2, hz_q4ReqExtra), { ttlMs: 300000, debounceMs: 250 })
  : null

hz_q4DataL = hz_q4RespL?.data ?? []
hz_q4DataR = hz_q4RespR?.data ?? []

hz_q4Meta = ({
  ok: !!(hz_q4RespL?.ok && hz_q4RespR?.ok),
  cached: !!(hz_q4RespL?.cached && hz_q4RespR?.cached),
  t_ms: Math.max(Number(hz_q4RespL?.t_ms || 0), Number(hz_q4RespR?.t_ms || 0)),
  error: hz_q4RespL?.error || hz_q4RespR?.error || null
})

hz_q4Rows = {
  const mapL = new Map(hz_q4DataL.map(d => [(d.admin_name ?? d.admin), Number(d.total)]))
  const mapR = new Map(hz_q4DataR.map(d => [(d.admin_name ?? d.admin), Number(d.total)]))
  const names = Array.from(new Set([...mapL.keys(), ...mapR.keys()]))
  const rows = names.map(name => ({ name, total1: mapL.get(name) || 0, total2: mapR.get(name) || 0 }))
  rows.sort((a,b) => (b.total2 - a.total2) || (b.total1 - a.total1))
  return rows.slice(0, hz_topN)
}

hz_q4Chart = {
  const rows = hz_q4Rows ?? []
  const xLabel = hz_rel ? "Percent of side total (%)" : hz_varLabelAbs

  const subtitle = `${hz_geoLabel} • ${hz_commodityLabel} • Left: ${hz_s1.label} • Right: ${hz_s2.label}`

  if (!rows.length) return html`<div class="hz-muted">No data.</div>`

  const sum1 = rows.reduce((s,r) => s + (r.total1 || 0), 0)
  const sum2 = rows.reduce((s,r) => s + (r.total2 || 0), 0)

  const v1 = (d) => hz_rel ? (sum1 ? (100 * d.total1 / sum1) : 0) : d.total1
  const v2 = (d) => hz_rel ? (sum2 ? (100 * d.total2 / sum2) : 0) : d.total2

  if (hz_compareMode === "diff") {
    const diff = rows.map(d => ({ name: d.name, delta: v2(d) - v1(d) }))
    return Plot.plot({
      height: Math.max(280, diff.length * 22, Number(hz_chartHeight ?? 520)),
      marginLeft: 180,
      x: { grid: true, label: hz_rel ? "Δ percentage points (Right − Left)" : "Δ exposure (Right − Left)" },
      y: { domain: diff.map(d => d.name) },
      caption: subtitle,
      marks: [
        Plot.ruleX([0]),
        Plot.barX(diff, { x: "delta", y: "name", tip: true })
      ]
    })
  }

  const names = rows.map(d => d.name)
  const left = rows.map(d => ({ name: d.name, value: v1(d) }))
  const right = rows.map(d => ({ name: d.name, value: v2(d) }))

  const plotSide = (data, title) => html`
    <div class="hz-mini">
      <div class="hz-mini__title">${title}</div>
      ${Plot.plot({
        height: Math.max(280, names.length * 22, Number(hz_chartHeight ?? 520)),
        marginLeft: 180,
        x: { grid: true, label: xLabel },
        y: { domain: names },
        caption: subtitle,
        marks: [
          Plot.barX(data, { x: "value", y: "name", tip: true }),
          Plot.ruleX([0])
        ]
      })}
    </div>
  `
  return html`<div class="hz-grid2">${plotSide(left, "Left")}${plotSide(right, "Right")}</div>`
}
```



```{ojs}
//| output: false
// Render main shell
hz_controlsMount = html`<div class=\"hz-mount\"><div class=\"hz-loading\">Loading controls…</div></div>`
hz_dashMount = html`<div class=\"hz-mount\"><div class=\"hz-loading\">Loading dashboard…</div></div>`

hz_statusPill = html`<span class=\"hz-pill\">Loading…</span>`
hz_chartHost  = html`<div class="hz-chartWrap"><div class="hz-loading">Loading chart…</div></div>`
hz_tableActionsHost = html`<div class="hz-actions"></div>`
hz_tableHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading table…</div></div>`
hz_recordsActionsHost = html`<div class="hz-actions"></div>`
hz_recordsHost  = html`<div class="hz-tableWrap"><div class="hz-loading">Loading records…</div></div>`
hz_debugHost  = html``
hz_pathHost   = html``
hz_schemaHost = html``


// Register UI elements for cross-cell updates
hz_registerUi = {
  const ui = (globalThis.__ATLAS_HZ_UI__ ??= {})
  ui.statusPill = hz_statusPill
  ui.chartWrap = hz_chartHost
  ui.tableWrap = hz_tableHost
  ui.recordsWrap = hz_recordsHost

  ui._busyCount = ui._busyCount ?? 0
  ui.setBusy = (on, msg = "Updating…") => {
    try {
      if (!ui.statusPill) return

      if (on) {
        ui._busyCount += 1
        // pill: spinner + label
        ui.statusPill.replaceChildren(
          html`<span class="hz-pill__spin" aria-hidden="true"></span><span>${msg || "Updating…"}</span>`
        )
        try { ui.chartWrap?.classList?.add?.("hz-chartWrap--busy") } catch (_) {}
        try { ui.tableWrap?.classList?.add?.("hz-tableWrap--busy") } catch (_) {}
        try { ui.recordsWrap?.classList?.add?.("hz-tableWrap--busy") } catch (_) {}
        return
      }

      ui._busyCount = Math.max(0, ui._busyCount - 1)
      if (ui._busyCount === 0) {
        try { ui.chartWrap?.classList?.remove?.("hz-chartWrap--busy") } catch (_) {}
        try { ui.tableWrap?.classList?.remove?.("hz-tableWrap--busy") } catch (_) {}
        try { ui.recordsWrap?.classList?.remove?.("hz-tableWrap--busy") } catch (_) {}
      }
    } catch (e) {}
  }

  return null
}

// Dashboard shell renders immediately (chart + heavy queries mount later)
hz_dashboardShell = html`
  <div>
    ${viewof hz_plotWidth}
    <div class=\"hz-card\">
      <div class=\"hz-card__head\">
        <div>
          <div class=\"hz-card__title\">${hz_dashTitle}</div>
          <div class=\"hz-card__sub\">${hz_dashSub}</div>
          <div class="hz-navBar">
            <div class="hz-navBar__group">
              <div class="hz-navBar__label">Breakdown</div>
              <div class="hz-navBar__control">${viewof hz_question}</div>
            </div>
            <div class="hz-navBar__group hz-navBar__group--right">
              <div class="hz-navBar__control">${viewof hz_viewMode}</div>
            </div>
          </div>
        </div>
        ${hz_statusPill}
      </div>

      ${
        (hz_viewMode === "records")
          ? html`<div class="hz-sideCard">
              <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px">
                <div class="hz-sideCard__title" style="margin:0">Records</div>
                ${hz_recordsActionsHost}
              </div>
              <div class="hz-recordsBar">
                <div class="hz-recordsBar__left">
                  ${viewof hz_recordsSide}
                  ${viewof hz_recordsSort}
                  ${viewof hz_recordsPageSize}
                </div>
                <div class="hz-recordsBar__right">
                  ${viewof hz_recordsPage}
                </div>
              </div>
              ${hz_recordsHost}
            </div>`
          : (hz_viewMode === "chart")
            ? html`<div class="hz-sideCard">${hz_chartHost}</div>`
            : (hz_viewMode === "table")
              ? html`<div class="hz-sideCard">
                  <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px">
                    <div class="hz-sideCard__title" style="margin:0">Table</div>
                    ${hz_tableActionsHost}
                  </div>
                  ${hz_tableHost}
                </div>`
              : html`<div class="hz-stack">
                  <div class="hz-sideCard">
                    <div class="hz-sideCard__title">Chart</div>
                    ${hz_chartHost}
                  </div>
                  <div class="hz-sideCard">
                    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
                      <div class="hz-sideCard__title" style="margin:0">Table</div>
                      ${hz_tableActionsHost}
                    </div>
                    ${hz_tableHost}
                  </div>
                </div>`
      }
    </div>
  </div>
`

hz_mountControls = {
  try {
    hz_controlsMount.replaceChildren(hz_controlsPanelReal)
  } catch (e) {
    hz_controlsMount.replaceChildren(html`<div class=\"warn\"><b>Controls failed to render:</b><br>${String(e)}</div>`)
  }
  return html``
}


hz_mountDash = {
  try {
    hz_dashMount.replaceChildren(hz_dashboardShell)
  } catch (e) {
    hz_dashMount.replaceChildren(html`<div class=\"warn\"><b>Dashboard failed to render:</b><br>${String(e)}</div>`)
  }
  return html``
}



// ------------------------------------------------------------
// Table rendering (Grid.js) + CSV export
// ------------------------------------------------------------
hz_loadCssOnce = (id, href) => {
  if (document.getElementById(id)) return Promise.resolve(true)
  return new Promise((resolve, reject) => {
    const el = document.createElement("link")
    el.id = id
    el.rel = "stylesheet"
    el.href = href
    el.onload = () => resolve(true)
    el.onerror = (e) => reject(e)
    document.head.appendChild(el)
  })
}

hz_loadScriptOnce = (id, src) => {
  if (document.getElementById(id)) return Promise.resolve(true)
  return new Promise((resolve, reject) => {
    const el = document.createElement("script")
    el.id = id
    el.src = src
    el.async = true
    el.onload = () => resolve(true)
    el.onerror = (e) => reject(e)
    document.head.appendChild(el)
  })
}

hz_loadGridjs = async () => {
  await hz_loadCssOnce("hz-gridjs-theme", "https://unpkg.com/gridjs/dist/theme/mermaid.min.css")
  await hz_loadScriptOnce("hz-gridjs-lib", "https://cdnjs.cloudflare.com/ajax/libs/gridjs/6.2.0/gridjs.production.min.js")
  return window.gridjs
}

hz_csvEscape = (v) => {
  const s = String(v ?? "")
  if (/[",\n]/.test(s)) return `"${s.replaceAll('"', '""')}"`
  return s
}

hz_downloadCsv = (filename, rows) => {
  const lines = rows.map(r => r.map(hz_csvEscape).join(",")).join("\n")
  const blob = new Blob([lines], { type: "text/csv;charset=utf-8" })
  const a = document.createElement("a")
  a.href = URL.createObjectURL(blob)
  a.download = filename || "table.csv"
  document.body.appendChild(a)
  a.click()
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove() }, 250)
}

hz_mountGrid = (host, key, cfg) => {
  const g = window.gridjs
  if (!g?.Grid) throw new Error("Grid.js not loaded")
  const store = (globalThis.__ATLAS_HZ_GRIDS__ ??= {})
  try { store[key]?.destroy?.() } catch (_) {}
  host.replaceChildren()
  const grid = new g.Grid(cfg)
  store[key] = grid
  grid.render(host)
  return grid
}


// Build chart *safely* (catch DuckDB/Arrow/Plot errors so UI still renders)
hz_updateChart = {
  const q = (hz_activeQuestion || "q1")
  const view = (hz_viewMode || "both")
  const wantsChart = (view === "chart" || view === "both")
  const wantsTable = (view === "table" || view === "both")
  const wantsRecords = (view === "records")
  const errors = []

  // Records-only view: status pill reflects /records endpoint; rendering handled by hz_updateRecords.
  if (wantsRecords) {
    const r = hz_recordsResp
    if (!r) {
      hz_statusPill.textContent = "Loading"
      hz_statusPill.classList.add("hz-pill--loading")
      hz_statusPill.classList.remove("hz-pill--error")
    hz_statusPill.classList.remove("hz-pill--loading")
      return html``
    }
    if (!r.ok) {
      hz_statusPill.textContent = "Error"
      hz_statusPill.classList.add("hz-pill--error")
    hz_statusPill.classList.remove("hz-pill--loading")
      hz_statusPill.classList.remove("hz-pill--loading")
      return html``
    }
    hz_statusPill.classList.remove("hz-pill--error")
    hz_statusPill.classList.remove("hz-pill--loading")
    const tag = r.cached ? "Cached" : "Ready"
    const ms = Number.isFinite(r.t_ms) ? ` (${r.t_ms} ms)` : ""
    hz_statusPill.textContent = tag + ms
    return html``
  }


  const pick = () => {
    if (q === "q1") return { meta: hz_q1Meta, chart: hz_q1Chart }
    if (q === "q2") return { meta: hz_q2Meta, chart: hz_q2Chart }
    if (q === "q3") return { meta: hz_q3Meta, chart: hz_q3Chart }
    if (q === "q4") return { meta: hz_q4Meta, chart: hz_q4Chart }
    return { meta: hz_q1Meta, chart: hz_q1Chart }
  }

  const { meta, chart } = pick()

  if (!meta?.ok) {
    errors.push({ side: "api", error: meta?.error || "API call failed" })
  }

  // Status pill
  if (errors.length) {
    hz_statusPill.textContent = "Error"
    hz_statusPill.classList.add("hz-pill--error")
  } else {
    hz_statusPill.classList.remove("hz-pill--error")
    const tag = meta?.cached ? "Cached" : "Ready"
    const ms = Number.isFinite(meta?.t_ms) ? ` (${meta.t_ms} ms)` : ""
    hz_statusPill.textContent = tag + ms
  }

  // Chart area
  if (wantsChart) {
    if (errors.length) {
      hz_chartHost.replaceChildren(
        html`<div class="warn"><b>Chart failed</b><br/><div class="hz-muted">${errors[0].error}</div></div>`
      )
    } else {
      try {
        hz_chartHost.replaceChildren(chart)
      } catch (e) {
        hz_chartHost.replaceChildren(
          html`<div class="warn"><b>Plot error</b><br/><div class="hz-muted">${String(e)}</div></div>`
        )
      }
    }
  } else {
    hz_chartHost.replaceChildren(html`<div class="hz-muted">Chart hidden.</div>`)
  }

  // Table area
  const clearTable = (msg) => {
    try { hz_tableActionsHost.replaceChildren() } catch (_) {}
    hz_tableHost.replaceChildren(html`<div class="hz-muted">${msg}</div>`)
  }

  if (!wantsTable) {
    clearTable("Table hidden.")
    return html``
  }

  if (errors.length) {
    clearTable("Table unavailable because the API request failed.")
    return html``
  }

  // Load Grid.js (once)
  let gridOk = true
  try { await hz_loadGridjs() } catch (e) { gridOk = false }
  if (!gridOk) {
    clearTable("Table library failed to load (Grid.js). Check network/CSP and reload.")
    return html``
  }

  const showPct = !!(hz_relative || hz_rel)
  const fmtAbs = (v) => hz_formatNumber(v, { digits: 2, compact: true })
  const fmtAbsFull = (v) => hz_formatNumber(v, { digits: 2, compact: false })
  const fmtPct = (v) => {
    const x = Number(v)
    if (!Number.isFinite(x)) return "—"
    return `${hz_formatNumber(x, { digits: 2, compact: false })}%`
  }

  const payload = (() => {
    if (q === "q1") {
      const rows = Array.isArray(hz_chartRows) ? hz_chartRows : []
      const headers = ["Hazard","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => [
        r.hazard,
        Number(r.total1 ?? 0),
        Number(r.total2 ?? 0),
        Number(r.total_diff ?? (Number(r.total2 ?? 0) - Number(r.total1 ?? 0))),
        Number(r.perc1 ?? 0),
        Number(r.perc2 ?? 0),
        Number(r.pct_diff ?? (Number(r.perc2 ?? 0) - Number(r.perc1 ?? 0)))
      ])

      const columns = [
        { name: "Hazard" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q1_by_hazard.csv", headers, data, columns }
    }

    if (q === "q2") {
      const rows = Array.isArray(hz_q2Rows) ? hz_q2Rows : []
      const sum1 = rows.reduce((a,r) => a + Number(r.total1 ?? 0), 0)
      const sum2 = rows.reduce((a,r) => a + Number(r.total2 ?? 0), 0)
      const headers = ["Crop","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => {
        const t1 = Number(r.total1 ?? 0), t2 = Number(r.total2 ?? 0)
        const p1 = sum1 ? (t1/sum1*100) : 0
        const p2 = sum2 ? (t2/sum2*100) : 0
        return [r.crop, t1, t2, (t2 - t1), p1, p2, (p2 - p1)]
      })
      const columns = [
        { name: "Crop" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q2_by_crop.csv", headers, data, columns }
    }

    if (q === "q3") {
      // Match chart selection: top crops by (Left+Right)
      const L = Array.isArray(hz_q3DataL) ? hz_q3DataL : []
      const R = Array.isArray(hz_q3DataR) ? hz_q3DataR : []
      const cropTotals = new Map()
      const bump = (crop, v) => cropTotals.set(crop, (cropTotals.get(crop) || 0) + Number(v || 0))
      for (const d of R) bump(d.crop, d.total)
      for (const d of L) bump(d.crop, d.total)

      const maxCrops = Math.min(10, Number(hz_topN || 10))
      const crops = Array.from(cropTotals.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, maxCrops)
        .map(([c]) => c)

      // Top hazards by combined total (keeps table compact)
      const hazTotals = new Map()
      const bumpH = (haz, v) => hazTotals.set(haz, (hazTotals.get(haz) || 0) + Number(v || 0))
      for (const d of R) bumpH(d.hazard, d.total)
      for (const d of L) bumpH(d.hazard, d.total)

      const maxHaz = Math.min(12, Array.from(hazTotals.keys()).length)
      const hazards = Array.from(hazTotals.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, maxHaz)
        .map(([h]) => h)

      const key = (crop, hazard) => `${crop}|||${hazard}`
      const mapL = new Map(L.filter(d => crops.includes(d.crop) && hazards.includes(d.hazard)).map(d => [key(d.crop, d.hazard), Number(d.total || 0)]))
      const mapR = new Map(R.filter(d => crops.includes(d.crop) && hazards.includes(d.hazard)).map(d => [key(d.crop, d.hazard), Number(d.total || 0)]))

      const pairs = []
      for (const c of crops) for (const h of hazards) pairs.push([c,h])

      const headers = ["Crop","Hazard","Left total","Right total","Δ (abs)"]
      const data = pairs.map(([crop, hazard]) => {
        const t1 = mapL.get(key(crop,hazard)) || 0
        const t2 = mapR.get(key(crop,hazard)) || 0
        return [crop, hazard, t1, t2, (t2 - t1)]
      }).sort((a,b) => (b[3] - a[3]) || (b[2] - a[2]))

      const columns = [
        { name: "Crop" },
        { name: "Hazard" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) }
      ]
      return { filename: "q3_hazard_x_crop.csv", headers, data, columns }
    }

    if (q === "q4") {
      const rows = Array.isArray(hz_q4Rows) ? hz_q4Rows : []
      const sum1 = rows.reduce((a,r) => a + Number(r.total1 ?? 0), 0)
      const sum2 = rows.reduce((a,r) => a + Number(r.total2 ?? 0), 0)

      const headers = ["Admin","Left total","Right total","Δ (abs)","Left %","Right %","Δ (pp)"]
      const data = rows.map(r => {
        const t1 = Number(r.total1 ?? 0), t2 = Number(r.total2 ?? 0)
        const p1 = sum1 ? (t1/sum1*100) : 0
        const p2 = sum2 ? (t2/sum2*100) : 0
        return [r.admin_name, t1, t2, (t2 - t1), p1, p2, (p2 - p1)]
      })

      const columns = [
        { name: "Admin" },
        { name: "Left", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Right", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Δ", sort: true, formatter: (c) => fmtAbs(c) },
        { name: "Left %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Right %", sort: true, formatter: (c) => fmtPct(c) },
        { name: "Δ (pp)", sort: true, formatter: (c) => fmtPct(c) }
      ]
      return { filename: "q4_by_admin.csv", headers, data, columns }
    }

    return null
  })()

  if (!payload) {
    clearTable("No table available for this view yet.")
    return html``
  }

  // Actions: download CSV
  const dl = document.createElement("button")
  dl.className = "hz-btn"
  dl.textContent = "Download CSV"
  dl.onclick = () => hz_downloadCsv(payload.filename, [payload.headers, ...payload.data])

  const rowsMeta = document.createElement("div")
  rowsMeta.className = "hz-muted"
  rowsMeta.style.marginRight = "10px"
  rowsMeta.textContent = `${payload.data.length.toLocaleString()} rows`

  const actionsWrap = document.createElement("div")
  actionsWrap.style.display = "flex"
  actionsWrap.style.alignItems = "center"
  actionsWrap.style.gap = "10px"
  actionsWrap.appendChild(rowsMeta)
  actionsWrap.appendChild(dl)

  hz_tableActionsHost.replaceChildren(actionsWrap)

  // Mount Grid
  const tableDiv = document.createElement("div")
  hz_tableHost.replaceChildren(tableDiv)
  hz_mountGrid(tableDiv, "hz_table", {
    columns: payload.columns,
    data: payload.data,
    search: true,
    sort: true,
    pagination: { enabled: true, limit: 12 },
    fixedHeader: true,
    height: "540px"
  })

  return html``
}






// ------------------------------------------------------------
// Raw records (paged) — server-backed
// ------------------------------------------------------------

hz_recordsReq = {
  if (hz_viewMode !== "records") return null

  const side = (hz_recordsSide || "left")
  const src = (side === "right") ? hz_src2 : hz_src1
  const scen = (side === "right") ? hz_s2 : hz_s1

  const req = {
    dataset_url: src?.url,
    scen: { scenario: scen?.scenario, timeframe: scen?.timeframe },
    geo: hz_geoFilter,
    commodities: hz_selectedCommodities ?? [],
    hazard_vars: null,
    method: hz_method,
    commodity_group: hz_selectedCommodGroup,
    page: Number(hz_recordsPage || 1)
  }

  const ps = Number(hz_recordsPageSize)
  if (Number.isFinite(ps) && ps > 0) req.page_size = ps

  const s = hz_recordsSort
  if (typeof s === "string" && s) req.sort = s

  return req
}

hz_recordsResp = (hz_recordsReq)
  ? await hz_apiDebouncedCached("records", "/api/v1/hz/records", hz_recordsReq, { ttlMs: 30000, debounceMs: 150 })
  : null

hz_recordsRows = hz_recordsResp?.rows ?? []
hz_recordsHasMore = !!hz_recordsResp?.has_more

hz_recordsPagerSync = {
  const pager = globalThis.__ATLAS_HZ_REC_PAGER__
  if (pager) {
    pager.prev.disabled = Number(hz_recordsPage || 1) <= 1
    pager.next.disabled = !hz_recordsHasMore
    pager.label.textContent = `Page ${Number(hz_recordsPage || 1)}`
  }
  return html``
}

hz_recordsResetPage = {
  if (hz_viewMode !== "records") return html``

  // When these change, jump back to page 1
  hz_recordsSide
  hz_recordsSort
  hz_recordsPageSize

  const pager = globalThis.__ATLAS_HZ_REC_PAGER__
  if (pager?.set) pager.set(1, { silent: false })
  return html``
}

hz_exportRecordsCsv = async ({ scope = "all" } = {}) => {
  const req = hz_recordsReq
  if (!req) return

  // "all" means: let the server export up to its EXPORT_MAX_ROWS guardrail (default 200k).
  const body = (scope === "all")
    ? { ...req, page: 1, page_size: 200000 }
    : req

  const url = hz_apiBaseUrl + "/api/v1/hz/records_csv"
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  })

  if (!res.ok) {
    const txt = await res.text()
    throw new Error(txt || ("HTTP " + res.status))
  }

  const blob = await res.blob()
  const stamp = new Date().toISOString().slice(0,19).replaceAll(":","").replace("T","_")
  const name = `records_export_${stamp}.csv`

  const a = document.createElement("a")
  a.href = URL.createObjectURL(blob)
  a.download = name
  document.body.appendChild(a)
  a.click()
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove() }, 300)
}

hz_updateRecords = {
  if (hz_viewMode !== "records") return html``

  // Ensure Grid.js is available
  try { await hz_loadGridjs() } catch (e) {
    hz_recordsActionsHost.replaceChildren()
    hz_recordsHost.replaceChildren(
      html`<div class="warn"><b>Records table failed</b><br/><div class="hz-muted">Could not load Grid.js. ${String(e)}</div></div>`
    )
    return html``
  }

  const resp = hz_recordsResp
  if (!resp?.rows || !resp?.ok) {
    hz_recordsActionsHost.replaceChildren()
    const msg = resp?.error || "No data"
    hz_recordsHost.replaceChildren(
      html`<div class="warn"><b>Could not load records</b><br/><div class="hz-muted">${String(msg)}</div></div>`
    )
    return html``
  }

  // Actions
  const actions = document.createElement("div")
  actions.style.display = "flex"
  actions.style.gap = "8px"
  actions.style.flexWrap = "wrap"
  actions.style.justifyContent = "flex-end"
  actions.style.alignItems = "center"

  const badge = document.createElement("div")
  badge.className = "hz-muted"
  badge.style.fontWeight = "900"
  badge.style.fontSize = "12px"
  badge.textContent = `Rows: ${hz_recordsRows.length}${hz_recordsHasMore ? "+" : ""}`

  const btnAll = document.createElement("button")
  btnAll.className = "hz-btn hz-btn--sm"
  btnAll.textContent = "Export (server, max 200k)"
  btnAll.onclick = async () => {
    try {
      btnAll.disabled = true
      btnAll.textContent = "Exporting…"
      await hz_exportRecordsCsv({ scope: "all" })
    } catch (e) {
      alert(`Export failed: ${String(e?.message || e)}`)
    } finally {
      btnAll.disabled = false
      btnAll.textContent = "Export (server, max 200k)"
    }
  }

  actions.appendChild(badge)
  actions.appendChild(btnAll)
  hz_recordsActionsHost.replaceChildren(actions)

  const columns = [
    { name: "admin0" },
    { name: "admin1" },
    { name: "admin2" },
    { name: "scenario" },
    { name: "timeframe" },
    { name: "hazard" },
    { name: "hazard_vars" },
    { name: "crop" },
    { name: "value", sort: true, formatter: (c) => hz_formatNumber(c, { digits: 2, compact: true }) }
  ]

  const data = hz_recordsRows.map(r => [
    r.admin0_name ?? null,
    r.admin1_name ?? null,
    r.admin2_name ?? null,
    r.scenario ?? null,
    r.timeframe ?? null,
    r.hazard ?? null,
    r.hazard_vars ?? null,
    r.crop ?? null,
    (r.value === null || r.value === undefined) ? null : Number(r.value)
  ])

  const host = document.createElement("div")
  hz_recordsHost.replaceChildren(host)

  hz_mountGrid(host, "records", {
    columns,
    data,
    search: true,
    sort: true,
    fixedHeader: true,
    height: "560px"
  })

  return html``
}
// Bootstrap cell: forces mounts + updates to execute without blocking hz_main.
hz_bootstrap = {
  hz_mountControls
  hz_mountDash
  hz_registerUi
  hz_recordsPagerSync
  hz_recordsResetPage
  await hz_updateChart
  await hz_updateRecords
  return html``
}

hz_main = html`
  <div class=\"app\">
    <nav class=\"hz-topnav\" aria-label=\"Quick navigation\">
      <a href=\"#controls\">Controls</a>
            <a href=\"#dashboard\">Dashboard</a>
      <span class=\"hz-topnav__spacer\"></span>
      <span class=\"hz-pill\">Atlas Hazard Exposure</span>
    </nav>
    <div class=\"app__stack\">
      ${hz_hero}
      <div id=\"controls\">${hz_controlsMount}</div>
            <div id=\"dashboard\">${hz_dashMount}</div>
    </div>
  </div>
`;
// Mount the app into the markdown placeholder (keeps the page free of Observable inspector "HTMLElement {}" output)
hz_renderApp = {
  const host = document.getElementById("hz-app")
  if (host) host.replaceChildren(hz_main)
  return null
}

// Bootstrap: mount sub-panels and update the chart (debounced/cached API)
hz_run = {
  hz_renderApp
  await hz_bootstrap
  return null
}

hz_run
```