---
pagetitle: "Atlas Loss and Damage Notebook"
nb-authors:
  - Zia Mehrabi
  - Ginni Braich
  - Brayden Youngberg
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
import { atlasHero } from "/helpers/uiComponents.ojs";
import { atlasTOC } from "/helpers/toc.ojs";

hypq = import("https://cdn.jsdelivr.net/npm/hyparquet/+esm");
hypq_compress = import(
  "https://cdn.jsdelivr.net/npm/hyparquet-compressors/+esm"
);

hero_url = "./../../images/default_crop.webp";

atlasHero(nbTitle, hero_url);

atlasTOC({
  skip: ["notebook-title", "appendix", "source-code"], // These should be the section headings in the {# headings}
  heading: `<b>${Lang.toSentenceCase(_lang(general_translations.toc))}</b>`,
});
```

# `{ojs} heading1` {#example-heading1}

Agriculture supports the livelihoods of over 2.5 billion people, mostly in
low-income developing countries. Food production is largely dependent on
weather, and the variability of heat and rain in the growing season can lead to
high yields or conversely, damaged plants and poor harvests. Agriculture,
relative to other industries, bears a disproportionate
[63% share of loss and damage](https://openknowledge.fao.org/server/api/core/bitstreams/30c0d98d-1c21-48ef-b5d9-8d988e6fa6f2/content)
from disasters such as drought, flooding, pest and disease.
[These losses, between 2008-2018, represent 108.5B USD lost due to declines in crop and livestock production in LMICs following disasters, with over 30B lost in Africa alone](https://openknowledge.fao.org/server/api/core/bitstreams/30c0d98d-1c21-48ef-b5d9-8d988e6fa6f2/content).
Of these disasters, drought and floods represent the largest source of
agricultural losses at
[34% and 19% respectively](https://openknowledge.fao.org/server/api/core/bitstreams/30c0d98d-1c21-48ef-b5d9-8d988e6fa6f2/content).

Farmers are not often well equipped to deal with these losses and it can
represent a significant source of economic hardship, particularly in the global
south where crop insurance and farmer assistance programs are lacking. Given the
variability in weather and affected farms, it is also not always abundantly
clear which farms are most impacted and where. The scale of the systems required
for making these payouts is poorly understood, but critical for implementation
down the road. This includes improvements in payment systems and recovery
supports needed as well better forecasting the size of programs needed for
adaptation and risk reduction, given future climate scenarios.

In this notebook we estimate the number of farms that will likely face losses or
lost revenue due to extreme events as well as what states/provinces in African
countries will be most impacted, using farm size distributions and historical
and future extreme event occurence. We also estimate the average number of farms
that will need paying out, numbers that are crucial for the development of
programs and policies to address these challenges and inequities.

# `{ojs} heading2` {#example-heading2}

Agriculture is a key industry in Africa, where
[50% of the region's workforce](https://www.fao.org/4/i2490e/i2490e01b.pdf)
engages in farming and it accounts for
[15% of the continent's GDP](https://openknowledge.fao.org/server/api/core/bitstreams/b33cbb8d-eb27-487c-acab-6e7a705b3ac9/content).
Smallholders, small-scale farmers that manage areas varying from less than 1
hectare to 20 hectares, make up the majority of Africa's farms and provide
[up to 80%](https://www.fao.org/fileadmin/templates/nr/sustainability_pathways/docs/Factsheet_SMALLHOLDERS.pdf)
of the food supply to the continent. The number of farms by farm class size
differ by countries across Africa, and there are expected shifts in the
distribution by 2050. Here you can explore the number of farms by farm class
size across the countries and sub-national regions in Africa and how they are
predicted to change by 2050.

```{ojs}
viewof fig1_inputs = renderS1_inputs();

plotMap(fig1a_spatial, "value", ["GID_0", "NAME_0", "NAME_1"]);

renderS1_insight();
```

# `{ojs} heading3` {#example-heading3}

As shown there is largely variability in the number of farms and farm size
across the African continent. Farms are differently affected by natural hazards
such as drought and floods, some of which can be attributed to the size of the
farm. The predicted probability of loss and predicted probability of lost
revenue, we show, is related to farm size as well as the type of hazard. Using
the dropdowns you can explore these relationships between farm size and loss or
lost revenue by type of hazard.

```{ojs}
viewof fig2_inputs = renderS2_inputs();

renderS2_plot();

renderS2_insight();
```

# `{ojs} heading4` {#example-heading4}

To estimate the potential loss and lost revenue by farm size both historically
and in the future for African farms, we need to determine the occurrence and
frequency of extreme events. To determine these events we use the Standardized
Precipitation-Evapotranspiration Index (SPEI), which is a multi-scalar drought
index which can be used to determine very dry and very wet conditions. Extreme
events were defined as years when SPEI values exceeded ±1, corresponding to very
wet or very dry conditions. These modeled events were validated against the
EM-DAT disaster database to confirm that the SPEI-based approach captured the
timing and spatial distribution of major historical droughts and floods. Five
models from the 6th Coupled Model Intercomparison Project (CMIP6) which have
been
[identified](https://link.springer.com/article/10.1007/s40808-025-02560-3#Sec5)
as having high performance for simulating climate in Africa were used to develop
an ensemble average for the historical period (1995-2014) as well as two
[future scenarios](https://www.carbonbrief.org/explainer-how-shared-socioeconomic-pathways-explore-future-climate-change/)
(2040-2060): SPP245, a middle of the road emissions scenario and SSP585, a high
emissions scenario. We show the ensemble means, which we use to estimate loss
and lost revenue in the next section, are remarkably conservative compared to
the CMIP6 model outputs for both very wet and very dry conditions.

```{ojs}
renderS3_plot();
```

### Quick Insights for Extreme Events

The number of very dry events are expected to **increase** by 2040–2060 for both
SSP245 and SSP585.

The number of very wet events are expected to **decrease** by 2040–2060 for both
SSP245 and SSP585.

The number of very dry and very wet events are **lower** for the ensemble
average compared to individual models, with high model variability.

# `{ojs} heading5` {#example-heading5}

As we have outlined above, agriculture in critical to Africa and there is
diversity in terms of the number of farms by farm size class across the country.
Extreme weather such as droughts and floods, which are exacerbated by climate
change as we show above, can cause losses on farms which in turn results in lost
revenue, and both of these vary by farm size class. Below the map illusrates the
average number of farms that experience extreme events (very wet or very dry)
over the time period. We can also explore the number of farms that have likely
been affected by losses due to extreme events such as very dry and very wet
conditions in our baseline period (1995-2014) and could be potentially be
impacted under future climate scenarios (SSP245 or SSP585). Furthermore, you can
also explore the amount of revenue that could potentially be lost on these farms
under either the baseline period or future climate scenarios for very dry and
very wet events without additional adaptation.

```{ojs}
viewof fig4_inputs = genFig4_inputs();

plotMap(fig4a_spatial, "high_fs");

renderS4b_plot();

renders4b_insight();
```

# `{ojs} nbSummary` {#summary}

Climate change will significantly impact farms, their productivity and farmer's
livelihoods on the African continent. This will have weighty implications for
food security, economic development, human health, and vulnerable rural
communities. Disaster events are worsening and the impact of climate
change-driven extreme events such as droughts and floods depend not only on the
climate scenarios, such as forcing and warming under SSP245 or SSP585, but also
on different farm size classes. Overall, although losses worsen for both very
dry and very wet conditions for larger farm sizes, the proportion of revenue
lost is highest for the smallest farms who usually have the least ability to
weather such economic shocks. Looking to the future, we see that the incidence
of loss and damage to farms in Africa is expected to increase with higher
probabilities of extreme events and a greater number of farms. There are a
number of solutions that have been proposed to address this challenge of
increasing climate-change driven losses on farms, including improved farmer
assistance programs, broadening crop insurance programs and their payouts,
expanding irrigation infrastructure and through improved seeds and training.
Multi-party funds meant to directly address loss and damage through adaptation
programs.

# Methods

## Farm size projections

We integrate spatial, demographic, and agricultural datasets to generate
harmonized projections of African farm size distributions from 2000 to 2060.
Spatial farm structure data from the CIAT/LUGE Smallholder Map were combined
with demographic projections from Mehrabi et al. 2023 and validated against the
FAO World Census of Agriculture, alongside auxiliary sources such as Ricciardi
et al. (2018) and Aliber & Hart (2009). For each country and administrative
unit, representative farm sizes were sampled from uniform or log-normal
distributions by size class, weighted by farm counts, and corrected via a
mean-shift algorithm to align with projected agricultural area totals. Corrected
samples were rebinned into standardized size categories and adjusted according
to one of three data availability cases—full data (spatial + demographic),
demographic-only, or spatial-only—using proportional scaling, dependent on data
availability. Missing values were filled using country or continental means, and
all outputs were validated to ensure consistency with farm totals, agricultural
area, and realistic distributional shapes. The resulting harmonized dataset
provides subnational farm size distributions for all African countries at
decadal intervals through 2000-2060.

## Loss and proportion of lost reveneue probabilities

We examine how agricultural production losses from climate shocks (droughts and
floods) vary as a function of farm size using harmonized household survey data
from 17 countries across Africa, Asia, and Latin America. The study employs a
dataset developed by Mehrabi, Fortin, and Ramankutty, which integrates
household-level farm size, reported production losses, and corresponding
climatic indicators. Two main model types were implemented: (1) binary loss
models estimating the probability of experiencing a climate-induced production
loss, and (2) continuous loss models quantifying the percentage of revenue lost.
Both models incorporated interactions between log-transformed farm size and
event type (drought or flood) and used multilevel random effects structures to
account for nested spatial hierarchies (country and administrative units).
Models were further filtered for high SPEI thresholds (< –0.99 for drought, >
0.99 for flood) to isolate the effects of severe climatic events. Diagnostic
checks, including residual simulation and bootstrapping, were used to check
model assumptions,  with alternative robust models being run to check robustness
of inference on the relationship between farm size and vulnerability to climate
shocks.

## Historical and CMIP6 estimates of loss by farm type

We estimate the number of extreme climate events and their impacts on African
farms by integrating climate, disaster, and agricultural datasets. Annual
growing-season extremes of the Standardized Precipitation Evapotranspiration
Index (SPEI) were computed at the subnational level across Africa for the
historical period (1995–2015) and for future projections (2040–2060) under
SSP245 and SSP585 scenarios, using ensemble means derived from five CMIP6 global
climate models (GFDL-ESM4, EC-Earth3, MPI-ESM1-HR, MRI-ESM2-0, NorESM2-LM).
Extreme events were defined as years when SPEI values exceeded ±1, corresponding
to very wet or very dry conditions. These modeled events were validated against
the EM-DAT disaster database to confirm that the SPEI-based approach captured
the timing and spatial distribution of major historical droughts and floods.
Once validated, the frequency of extreme events was used in combination with the
above empirically derived loss functions and 2020-2050 farm projections linking
farm size to production and revenue losses. For each administrative unit and
farm size class, the probability of farms experiencing loss was estimated for
each year and climate scenario, and corresponding revenue losses were calculated
as proportional reductions in farm income. The outputs include both yearly
averages and cumulative totals of farms and % of revenue affected, allowing
comparison of historical and future exposure to extreme climate events across
Africa.

## Additional methods

More information on methods for farm projections estimates are available at this
[repository](https://github.com/Better-Planet-Laboratory/africafarmprojections).

More information on methods for loss functions are available at this
[repository](https://github.com/Better-Planet-Laboratory/farm-loss-farmsize).

More information on methods including SPEI-derived wet and dry events and
estimates of farms experiencing losses and the proportion of lost revenue by
farm size are available at this
[repository](https://github.com/Better-Planet-Laboratory/climatepayouts).

Full methodological details will also be contained in the forthcoming paper:

Mehrabi, Z., Braich, G., Fortin, J., Ramankutty, N., 2025. Climate payouts to
smallholder farmers. LUGE lab/Better Planet Laboratory.

## Citation

To cite this notebook : Mehrabi, Z., Braich, G. 2025. Climate payouts to
smallholders. Africa Agriculture Adaptation Atlas. CGIAR.

## Acknowledgements

This notebook was developed in partnership with the
[Better Planet Labratory](https://betterplanetlab.com/). We also acknowledge
Brayden Youngberg for translating the original R Shiny notebook to JavaScript.

# `{ojs} appendix` {#appendix}

# Source code {#source-code .hidden}

<!--
NOTE:Everything below this point will not appear in the notebook.
This is useful to hide all of the code, master selectors (language, admin level, etc.),
and other things that are needed for the notebook to run but would be messy if
actually appearing in the notebook.
-->

<!-- Text and Language Translations -->

```{ojs}
// This cell is to contain all the headings and the notebook title
nbTitle = _lang({
  en: "Climate Payouts to Smallholders",
  fr: "",
});
// key_insights = _lang({en: "Key Insights", fr: "Résumé"})
heading1 = _lang({ en: "Overview", fr: "Titre 1" });
heading2 = _lang({ en: "Farmers & Farm Size in Africa", fr: "Titre 2" });
heading3 = _lang({ en: "Loss from Extreme Events", fr: "Titre 3" });
heading4 = _lang({
  en: "Model Ensembles are Conservative Estimates of Extreme Events",
  fr: "Titre 4",
});
heading5 = _lang({
  en: "Loss by Farm Type: Historical and Future",
  fr: "Titre 5",
});
nbSummary = _lang({ en: "Summary", fr: "Résumé" });
appendix = _lang(general_translations.appendix);
```

{{< include /components/_lang.qmd >}}

## Data

```{ojs}
bound_arrayBuf = await FileAttachment(
  "/data/lossDamageNb/bounds.parquet",
).arrayBuffer();

getBounds = async (country) => {
  const bounds = await hypq.parquetQuery({
    file: bound_arrayBuf,
    compressors: hypq_compress.compressors,
    columns: ["GID_0", "NAME_0", "NAME_1", "nm_slc0", "geometry"],
    filter: !country
      ? null
      : {
          nm_slc0: {
            $eq: country,
          },
        },
  });
  return {
    type: "FeatureCollection",
    features: bounds.map(({ geometry, ...properties }) => ({
      type: "Feature",
      geometry: turfRewind(geometry, { reverse: true }),
      properties,
    })),
  };
};

fig1_mapBounds = await getBounds(fig1_inputs.country);
fig4_mapBounds = await getBounds(fig4_inputs.country);
```

## Section code

```{ojs}
fmtVal = (d) => Intl.NumberFormat("en", { notation: "compact" }).format(d);
```

### Section 1 code

```{ojs}
fig1_arrayBuf = await FileAttachment(
  "/data/lossDamageNb/fig1_allshps.parquet",
  // "/data/lossDamageNb/fig1_farmsizelookup.parquet",
).arrayBuffer();

fig1_selVars = (async () => {
  const _data = await hypq.parquetQuery({
    file: fig1_arrayBuf,
    compressors: hypq_compress.compressors,
    columns: ["nm_slc0", "GID_0", "NAME_0", "farm_sz2", "variable"],
  });

  // const map = new Map();

  // for (const d of _data) {
  //   map.set(d.GID_0, d.nm_slc0);
  // }

  // const result = Array.from(map, ([value, label]) => ({
  //   iso3: value,
  //   label,
  // }));

  return {
    iso3: Array.from(new Set(_data.map((d) => d.GID_0))),
    country: Array.from(new Set(_data.map((d) => d.nm_slc0))),
    // country: result,
    admin1_name: Array.from(new Set(_data.map((d) => d.NAME_0))),
    farm_sz2: Array.from(new Set(_data.map((d) => d.farm_sz2))),
    variable: Array.from(new Set(_data.map((d) => d.variable))),
  };
})();
```

```{ojs}
renderS1_inputs = () => {
  return Inputs.form(
    {
      country: Inputs.select(fig1_selVars.country, {
        label: "Country",
        value: "Sub-Saharan Africa",
      }),
      fSize: Inputs.select(fig1_selVars.farm_sz2, {
        label: "Farm Size",
        value: "All Farms",
      }),
      time: Inputs.select(fig1_selVars.variable, {
        label: "Time",
        value: "Current Farms",
      }),
    },
    {
      template: (inputs) =>
        html`<div style="display: flex; gap: 3em"> ${Object.values(inputs)} </div>`,
    },
  );
};
```

```{ojs}
fig1a_filtered = await hypq.parquetQuery({
  file: fig1_arrayBuf,
  compressors: hypq_compress.compressors,
  filter: {
    nm_slc0: {
      $eq: fig1_inputs.country,
    },
    farm_sz2: {
      $eq: fig1_inputs.fSize,
    },
    variable: {
      $eq: fig1_inputs.time,
    },
  },
});

fig1a_spatial = joinGeo({
  data: fig1a_filtered,
  dataKeys: ["GID_0", "NAME_0", "NAME_1", "nm_slc0"],
  geojson: fig1_mapBounds,
  geoKeys: ["GID_0", "NAME_0", "NAME_1", "nm_slc0"],
  valueKeys: ["value"],
});
```

```{ojs}
fig1b_filtered = await hypq.parquetQuery({
  file: await FileAttachment(
    "/data/lossDamageNb/fig1_farmsizelookup.parquet",
  ).arrayBuffer(),
  compressors: hypq_compress.compressors,
  filter: {
    nm_slc0: {
      $eq: fig1_inputs.country,
    },
    farm_sz2: {
      $eq: fig1_inputs.fSize,
    },
    // variable: {
    //   $eq: fig1_inputs.time,
    // },
  },
});
```

```{ojs}
renderS1_insight = () => {
  const _data = fig1b_filtered;
  const _present = _data.filter((d) => d.variable === "Current Farms");
  const _future = _data.filter((d) => d.variable === "Farms 2050");

  const sum = (arr) => arr.reduce((a, b) => a + b, 0);

  // baseline
  const sumpr = sum(_present.map((d) => d.value));

  // future
  const sumfr = sum(_future.map((d) => d.value));

  const pct = ((sumfr - sumpr) / sumpr) * 100;
  const trend = pct > 0 ? "an increase" : "a decrease";
  const _country = fig1_inputs.country;

  return html`
  <div>
    <h4>Quick Insights for ${_country}</h4>
    <b>${_country}</b> has a total of
    <b>${fmtVal(sumpr)}</b> farms in the
    <b>${fig1_inputs.fSize}</b> farm size class for the baseline year, circa 2020.
    <br><br>
    The total number of farms is expected to change to
    <b>${fmtVal(sumfr)}</b> by 2050, under SSP 245.
    This represents <b>${trend}</b> of <b>${pct.toFixed(1)}%</b>.
  </div>
`;
};
```

### Section 2 code

```{ojs}
fig2_dat = await FileAttachment(
  "/data/lossDamageNb/fig2_joined_eff.json",
).json();
```

```{ojs}
// Inputs
fig2_groups = Array.from(new Set(fig2_dat.map((d) => d.group)));
fig2_mod = Array.from(new Set(fig2_dat.map((d) => d.title)));

renderS2_inputs = () => {
  return Inputs.form(
    [
      Inputs.select(fig2_groups, {
        label: "Event Type",
        value: "Drought",
      }),
      Inputs.select(fig2_mod, {
        label: "Loss",
        value: "Predicted Probabilities of Loss",
      }),
    ],
    {
      template: (inputs) =>
        html`<div style="display: flex; gap: 3em"> ${inputs} </div>`,
    },
  );
};
```

```{ojs}
figure2_filtered = (() => {
  const [group_sel, mod_sel] = fig2_inputs;

  const _data = fig2_dat.filter(
    (d) => d.group === group_sel && d.title === mod_sel,
  );

  return _data;
})();

renderS2_plot = () => {
  const [group_sel, mod_sel] = fig2_inputs;
  return Plot.plot({
    width,
    height: 450,
    marginLeft: 50,

    title: mod_sel,

    x: {
      label: "Log Farm Size",
      grid: true,
    },

    y: {
      label: figure2_filtered[0].yax,
      tickFormat: (d) => `${Math.round(d * 100)}%`,
      grid: true,
    },

    marks: [
      // Confidence ribbon (geom_ribbon)
      Plot.areaY(figure2_filtered, {
        x: "x",
        y1: "conf.low",
        y2: "conf.high",
        fill: group_sel === "Drought" ? "red" : "blue",
        fillOpacity: 0.3,
      }),

      // Predicted line (geom_line)
      Plot.line(figure2_filtered, {
        x: "x",
        y: "predicted",
        // stroke: pal,
        strokeWidth: 2,
        // channels: {
        //   x: {
        //     value: "x",
        //     label: "X label",
        //   },
        // },
        tip: {
          format: {
            y: (d) => `${Math.round(d * 100)}%`,
          },
        },
      }),
    ],
  });
};

renderS2_insight = () => {
  const _loss = fig2_inputs[1];
  const _event = fig2_inputs[0];
  const _trend = figure2_filtered[0].trend;
  return md`### Quick Insights for ${_loss}  \n
The **${_loss.toLowerCase()}** from ${_event.toLowerCase()} **${_trend}** as farm sizes get larger.
  `;
};
```

### Section 3 code

```{ojs}
fig3_data = await FileAttachment("/data/lossDamageNb/figure3_spei.json").json();
```

```{ojs}
ensemble2 = fig3_data.filter((d) => d.gcm === "Ensemble Average");
joint3 = fig3_data.filter((d) => d.gcm !== "Ensemble Average");

renderS3_plot = () => {
  return Plot.plot({
    width,
    height: 500,

    marginLeft: 90,

    x: {
      label: "Number of Events",
    },

    y: {
      label: null,
    },

    fy: {
      label: null,
      axis: "left",
      tickRotate: -90,
      tickPadding: 80,
    },

    color: {
      legend: true,
    },

    marks: [
      // Ensemble Average bars (geom_col)
      Plot.barX(ensemble2, {
        x: "count",
        fy: "model",
        y: "variable",
        fill: (d) => (d.variable === "Very Dry" ? "#F6A8A8" : "#A8D0F6"),
        channels: {
          scenario: {
            value: (d) => d.model,
            label: "Scenario",
          },
          hazard: {
            value: (d) => d.variable,
            label: "Hazard",
          },
        },
        tip: {
          format: {
            fy: false,
            x: true,
            y: true,
            scenario: true,
            fill: false,
            hazard: true,
          },
        },
      }),

      // Individual GCM points (geom_point)
      Plot.dot(joint3, {
        x: "count",
        fy: "model",
        y: "variable",
        stroke: "gcm",
        r: 4,
        strokeOpacity: 0.7,
        channels: {
          scenario: {
            value: (d) => d.model,
            label: "Scenario",
          },
          hazard: {
            value: (d) => d.variable,
            label: "Hazard",
          },
        },
        tip: {
          format: {
            fy: false,
            x: true,
            y: true,
            scenario: true,
            stroke: true,
            hazard: true,
          },
        },
      }),
    ],
  });
};
```

### Section 4 code

#### 4a code

```{ojs}
fig4a_arrayBuf = await FileAttachment(
  "/data/lossDamageNb/fig4_map_fin_spei12_high.parquet",
).arrayBuffer();

fig4_selVars = (async () => {
  const _data = await hypq.parquetQuery({
    file: fig4a_arrayBuf,
    compressors: hypq_compress.compressors,
    columns: [
      "nm_slc0",
      "GID_0",
      "NAME_0",
      "farm_sz2",
      "variable",
      "extEvent",
      "model",
    ],
  });

  return {
    iso3: Array.from(new Set(_data.map((d) => d.GID_0))),
    country: Array.from(new Set(_data.map((d) => d.nm_slc0))),
    admin1_name: Array.from(new Set(_data.map((d) => d.NAME_0))),
    farm_sz2: Array.from(new Set(_data.map((d) => d.farm_sz2))),
    variable: Array.from(new Set(_data.map((d) => d.variable))),
    event: Array.from(new Set(_data.map((d) => d.extEvent))),
    model: Array.from(new Set(_data.map((d) => d.model))),
  };
})();

genFig4_inputs = () => {
  return Inputs.form(
    {
      country: Inputs.select(fig4_selVars.country, {
        label: "Country",
        value: "Sub-Saharan Africa",
      }),
      fSize: Inputs.select(fig4_selVars.farm_sz2, {
        label: "Farm Size",
        value: "All Farms",
      }),
      event: Inputs.select(fig4_selVars.event, {
        label: "Event",
        value: "Very Dry",
      }),
      time: Inputs.select(fig4_selVars.model, {
        label: "Model",
        value: "baseline",
      }),
    },
    {
      template: (inputs) =>
        html`<div style="display: flex; gap: 3em"> ${Object.values(inputs)} </div>`,
    },
  );
};
```

```{ojs}
fig4a_filtered = await hypq.parquetQuery({
  file: fig4a_arrayBuf,
  compressors: hypq_compress.compressors,
  filter: {
    nm_slc0: {
      $eq: fig4_inputs.country,
    },
    farm_sz2: {
      $eq: fig4_inputs.fSize,
    },
    extEvent: {
      $eq: fig4_inputs.event,
    },
    model: {
      $eq: fig4_inputs.time,
    },
  },
  //TODO: Select only the applicable columns to boost perf.
});

fig4a_spatial = joinGeo({
  data: fig4a_filtered,
  dataKeys: ["GID_0", "NAME_0", "NAME_1", "nm_slc0"],
  geojson: fig4_mapBounds,
  geoKeys: ["GID_0", "NAME_0", "NAME_1", "nm_slc0"],
  valueKeys: ["high_fs"],
});
```

#### 4b code

```{ojs}
fig4b_arrayBuf = await FileAttachment(
  "/data/lossDamageNb/fig4b.parquet",
).arrayBuffer();

fig4b_filtered = await hypq.parquetQuery({
  file: fig4b_arrayBuf,
  compressors: hypq_compress.compressors,
  filter: {
    nm_slc0: {
      $eq: fig4_inputs.country,
    },
    farm_sz2: {
      $eq: fig4_inputs.fSize,
    },
    Event: {
      $eq: fig4_inputs.event,
    },
    // losstype: {
    //   $eq: "Loss",
    // },
    model: {
      $eq: fig4_inputs.time,
    },
  },
  //TODO: Select only the applicable columns to boost perf.
});
```

```{ojs}
renderS4b_plot = () => {
  const domainOrder =
    fig4_inputs.event === "Very Dry"
      ? ["Farms Likely Impacted", "40% lost revenue", "50% lost revenue"]
      : ["Farms Likely Impacted", "30% lost revenue", "40% lost revenue"];
  return Plot.plot({
    width,
    height: 420,
    marginLeft: 50,

    x: {
      label: "Year",
      tickFormat: "d",
    },

    y: {
      label: "Number of Farms",
      grid: true,
      tickFormat: (d) => numFormat.format(d),
    },

    fx: {
      label: null,
    },

    color: {
      legend: true,
      label: "Threshold",
      domain: domainOrder,
      // domain: ["baseline", "SSP245", "SSP585"],
      range: ["#4E79A7", "#F28E2C", "#E15759"],
    },

    marks: [
      Plot.line(fig4b_filtered, {
        x: "year",
        // y: "numberofarms",
        y: "cum_sum",
        fx: "losstype",
        stroke: "threshold",
        // stroke: "model",
        strokeWidth: 2,
        opacity: 0.85,
        channels: {
          type: {
            value: "losstype",
            label: "Loss Type",
          },
        },
        tip: {
          format: {
            x: "d",
            y: (d) => (d !== 0 ? numFormat.format(d) : "No Extreme Events"),
            type: true,
            stroke: false, //HACK: Keep false for now while additional "threshold", field keeps appearing
            fx: false,
          },
        },
      }),
    ],
  });
};

renders4b_insight = () => {
  const _data = fig4b_filtered;
  const years = _data.map((d) => d.year);
  const minyear = Math.min(...years);
  const maxyear = Math.max(...years);

  const maxYearData = _data.filter((d) => d.year === maxyear);

  const maxLoss = maxYearData.find((d) => d.losstype === "Loss");

  const revenueAtMax = maxYearData.filter((d) => d.losstype === "Revenue");

  const minThreshold = revenueAtMax.reduce((a, b) =>
    a.threshold2 < b.threshold2 ? a : b,
  );

  const maxThreshold = revenueAtMax.reduce((a, b) =>
    a.threshold2 > b.threshold2 ? a : b,
  );

  const payout = maxLoss.cum_sum / (maxyear - minyear);

  const _event = fig4_inputs.event.toLowerCase();
  const _country = fig4_inputs.country;
  const _ssp = fig4_inputs.time;

  return md`
### Quick Insights for ${_country}

Between ${minyear} and ${maxyear}, an estimated
**${fmtVal(maxLoss.cum_sum)}**
cumulative number of farms (${fig4_inputs.fSize} farm size class) will likely experience losses due to
**${_event}**
conditions in
**${_country}**
under the ${_ssp} model. This represents the potential need to
**payout**
an average of
**${fmtVal(payout)}**
farms per year.

Of the farms likely impacted, a cumulative
**${fmtVal(minThreshold.cum_sum)}**
farms could lose more than
**${minThreshold.threshold2}%**
of their revenue and approximately
**${fmtVal(maxThreshold.cum_sum)}**
cumulative farms could lose more than
**${maxThreshold.threshold2}%**
of their revenue due to
**${_event}**
conditions in
**${_country}**
under the ${_ssp} model.
`;
};
```

### Helpers

```{ojs}
numFormat = new Intl.NumberFormat(undefined, {
  notation: "compact",
  compactDisplay: "short",
});
```

### Geo helpers

```{ojs}
function makeKeyFrom(obj, keys, sep = "|") {
  return keys.map((k) => obj?.[k] ?? "").join(sep);
}

function joinGeo({ data, dataKeys, geojson, geoKeys, valueKeys }) {
  const lookup = new Map(
    data.map((d) => [
      makeKeyFrom(d, dataKeys),
      Object.fromEntries(valueKeys.map((k) => [k, d[k]])),
    ]),
  );

  return {
    ...geojson,
    features: geojson.features.map((f) => {
      const key = makeKeyFrom(f.properties, geoKeys);
      const values = lookup.get(key);
      return values ? { ...f, properties: { ...f.properties, ...values } } : f;
    }),
  };
}

turfRewind = require("@turf/turf").then((t) => t.rewind);

function plotMap(
  geojson,
  fillColumn,
  { height = 500, scheme = "YlGnBu" } = {},
) {
  return Plot.plot({
    width,
    height,
    projection: {
      type: "azimuthal-equal-area",
      domain: geojson,
    },
    color: {
      scheme,
      legend: true,
      tickFormat: (d) => numFormat.format(d),
      label: "Number of Farms",
    },
    marks: [
      Plot.geo(geojson, {
        fill: (d) => d.properties[fillColumn],
        stroke: "#fff",
        strokeWidth: 0.5,
      }),
      Plot.geo(
        geojson,
        Plot.pointer(
          Plot.centroid({
            stroke: "#333",
            strokeWidth: 1.5,
          }),
        ),
      ),
      Plot.tip(
        geojson.features,
        Plot.pointer(
          Plot.centroid({
            channels: {
              value: {
                value: (d) => d.properties[fillColumn],
                label: "Number of Farms",
              },
              gid_0: {
                value: (d) => d.properties.GID_0,
                label: "iso3",
              },
              country: {
                value: (d) =>
                  d.properties.nm_slc0 === "Sub-Saharan Africa"
                    ? d.properties.NAME_0
                    : d.properties.nm_slc0,
                label: "Country",
              },
              region: {
                value: (d) =>
                  d.properties.nm_slc0 === "Sub-Saharan Africa"
                    ? null
                    : d.properties.NAME_0,
                label: "Region",
              },
            },
            format: {
              value: (d) =>
                d !== 0 ? numFormat.format(d) : "No Extreme Events",
              country: true,
              region: true,
              gid_0: true,
            },
          }),
        ),
      ),
    ],
  });
}
```
