---
pagetitle: "Formulate A Climate Rational"
nb-authors:
  - Brayden Youngberg
  - Pete Stewart
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
import {
  atlasTOC,
  atlasHero,
  dataTable,
  downloadButton,
} from "/helpers/uiComponents.ojs";

atlasHero(nbTitle, hero_url);
```

# `{ojs} heading1` {#overview}

```{ojs}
md`${_lang(nbText.sections.intro.text)}`; // wrapped in md for lists to work
```

# `{ojs} heading2` {#keyFacts}

`{ojs} _lang(nbText.sections.keyFacts.introText)`

# `{ojs} heading3` {#recentChanges}

`{ojs} _lang(nbText.sections.recentChanges.introText)`

```{ojs}
adminForm();
climateForm();
viewof viewRecentChanges = Inputs.radio(["divergingBar", "warmingStripes", "table"], {
  label: "View Type",
  value: "divergingBar",
});
```

```{ojs}
loaderDiv("plotRecentChanges");
```

```{ojs}
//| output: false
{
  const _displayType = viewRecentChanges;
  const div = document.getElementById("plotRecentChanges");
  div.innerHTML = "";
  let viz;
  if (_displayType === "divergingBar") {
    viz = barplot_recentChanges();
  } else if (_displayType === "warmingStripes") {
    viz = warmingStripes_recentChanges();
  } else if (_displayType === "table") {
    viz = dataTable(recentChanges_plotData, 500);
  }
  div.appendChild(viz);
}
```

`{ojs} downloadButton(recentChanges_plotData, "recentChanges")`

# `{ojs} heading4` {#futureProjections}

`{ojs} _lang(nbText.sections.futureProjections.introText)`

```{ojs}
adminForm();
climateForm();
viewof viewFutureChanges = Inputs.radio(["plot", "table"], {
  label: "View Type",
  value: "plot",
});
```

```{ojs}
loaderDiv("plotFutureProjections");
```

```{ojs}
//| output: false
{
  const _displayType = viewFutureChanges;
  const div = document.getElementById("plotFutureProjections");
  div.innerHTML = "";
  let viz;
  if (_displayType === "plot") {
    viz = timeseries_futureProjections();
  } else if (_displayType === "table") {
    viz = dataTable(futureProjections_plotData, 500);
  }
  div.appendChild(viz);
}
```

`{ojs} downloadButton(futureProjections_plotData, "futureProjections")`

# `{ojs} heading5` {#hazardExposure}

`{ojs} _lang(nbText.sections.hazardExposure.introText)`

```{ojs}
loaderDiv("plotHazardExposure");
```

# `{ojs} summary` {#summary}

{{< lipsum 1 >}}

# `{ojs} appendix` {#appendix}

```{ojs}
toc_bottom = atlasTOC({
  skip: ["notebook-title", "appendix", "source-code"], // These should be the section headings in the {# headings}
  heading: `<b>${Lang.toSentenceCase(_lang(general_translations.toc))}</b>`,
});

htl.html`
  <div class='floating-toc'>
    ${toc_bottom}
  </div>
`;
```

# Source code {#source-code}

<!-- Add .hidden back in to hide -->

## Text and Language Translations

```{ojs}
// This cell is to contain all the headings and the notebook title
nbTitle = _lang({
  en: "Formulate A Climate Rational",
  fr: "Formuler une justification climatique",
});

heading1 = _lang(general_translations.overview);
heading2 = _lang(nbText.sections.keyFacts.title);
heading3 = _lang(nbText.sections.recentChanges.title);
heading4 = _lang(nbText.sections.futureProjections.title);
heading5 = _lang(nbText.sections.hazardExposure.title);
summary = _lang(general_translations.summary);
appendix = _lang(general_translations.appendix);
```

```{ojs}
import { lang as Lang } from "/helpers/lang.js";

nbText = await FileAttachment("/data/climateRationale/nbText.json").json();

general_translations = await FileAttachment(
  "/data/shared/generalTranslations.json",
).json();

languages = [
  { key: "en", label: "English", locale: 'en-US' },
  { key: "fr", label: "FranÃ§ais", locale: 'fr-FR' }
]

defaultLangKey = {
  const name = "lang";
  const list = languages.map((d) => d.key);
  const defaultKey = "en";
  const queryParam = await Lang.getParamFromList({ name, list });
  return queryParam ?? defaultKey;
}

_lang = Lang.lg(masterLanguage.key)

viewof masterLanguage = Inputs.radio(languages, {
  label: "Main language toggle",
  format: (d) => d.key,
  value: languages.find((x) => x.key === defaultLangKey),
})
```

## General

### formatters

```{ojs}
//TODO: Move to shared helpers
// format number, short notation
formatNumCompactShort = ({ locale = "en-US" } = {}) =>
  new Intl.NumberFormat(locale, {
    notation: "compact",
    compactDisplay: "short",
  }).format;

// format number, to significant figures
formatNumCompactSigFigs = ({ locale = "en-US", sigFigs = 3 } = {}) => {
  // Return a formatting function
  return (number) => {
    // Adjust number to specified significant figures
    const formattedNumber = Number(number).toLocaleString(locale, {
      maximumSignificantDigits: sigFigs,
      notation: "compact",
      compactDisplay: "short",
    });

    return formattedNumber;
  };
};

function formatUSD({ locale = "en-US" } = {}) {
  const formatter = formatNumCompactShort({ locale });

  return (number) => {
    const formattedNum = formatter(number);
    return "$" + formattedNum;
  };
}
```

```{ojs}
// template for observable input forms
inputTemplate = ({ gap = "2em" } = {}) => {
  // template for input display
  return (inputs) =>
    html`<div style="display: flex; gap: ${gap};">${inputs}</div>`;
};

// create where clause that handles null cases
sqlWhereNull = ({ value, field } = {}) => {
  return value === null ? `and ${field} is null` : `and ${field} = '${value}'`;
};

// alphabetic sort, nulls first
sortByField = (a, b, { field } = {}) => {
  const av = a[field];
  const bv = b[field];

  // nulls first
  if (av === null || bv === null) {
    if (av === bv) return 0;
    return av === null ? -1 : 1;
  }

  // alphabetical compare
  return av.localeCompare(bv);
};
```

## Styling

```{ojs}
// import { NavbarLangSelector } from "/helpers/uiComponents.ojs"
function NavbarLangSelector(language_obj, masterLanguage) {
  let navEnd = document.querySelector(".navbar-nav.ms-auto .nav-item.compact");
  if (navEnd) {
    let existingLangSelector = document.getElementById("nav-lang-selector");
    if (!existingLangSelector) {
      let lang_sel = Inputs.bind(
        Inputs.radio(language_obj, {
          label: "",
          format: (d) => d.label
        }),
        viewof masterLanguage
      );
      lang_sel.id = "nav-lang-selector";
      
      // Hack the css together for the observable inputs
      lang_sel.style.display = "flex";
      lang_sel.style.alignItems = "center";
      lang_sel.style.marginLeft = "10px";
      let lang_div = lang_sel.querySelector("div");
      lang_div.style.display = "flex";
      lang_div.style.flexDirection = "column";

      // Insert the new item after the GitHub icon and other elements
      navEnd.parentNode.appendChild(lang_sel);
    }
  }
}

NavbarLangSelector(languages, masterLanguage)
```

```{ojs}
prettyLanguageView = {
  return Inputs.bind(
    Inputs.radio(languages, {
      label: _lang(general_translations.language),
      format: (d) => d.label
    }),
    viewof masterLanguage
  );
}
```

## Data

```{ojs}
import { cleanAdminInput_SQL } from "/helpers/data.js";
```

### Database

```{ojs}
generateDB = async (data_obj) => {
  let data = data_obj;
  const _db = await DuckDBClient.of();

  // loop through datasets
  for (const d of data) {
    if (!d.key || d.key.trim() === "") continue;
    let path = d.s3_path || d.local_path;
    let view = d.sql.table ? "TABLE" : "VIEW";
    let query = d.sql.query;
    if (!query) {
      // use default query
      query = `CREATE ${view} "${d.key}" AS SELECT * FROM read_parquet("${path}");`;
    } else {
      query = `CREATE ${view} "${d.key}" AS ${query};`;
    }
    await _db.query(query);
  }

  return await _db;
};
```

```{ojs}
data_obj = {
  const obj = await FileAttachment("/data/climateRationale/nbData.json").json();
  return obj.data
}
data_obj;
first = new Array(data_obj[0]);
db = await generateDB(
  // Future projection data is big, so split into different database
  data_obj.filter((d) => !d.sections.includes("FutureProjections")),
);
```

```{ojs}
dbFutureHive = {
    const fut = data_obj.filter((d) => d.sections.includes("FutureProjections"));
    const _db = await DuckDBClient.of();
    _db.query(`
      CREATE VIEW futureProjections as
        SELECT *, period as timeperiod
        FROM parquet_scan([
          ${fut.map((d) => `'${d.s3_path}'`).join(", ")}
        ],filename=true, hive_partitioning = 1)
    `)
  return _db
}
```

### Sections

#### recentChanges

```{ojs}
recentChanges_plotData = {
  document.body.style.cursor = "wait";
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;
  const _variable = climateVarSelect.id;

  const resp = await db.query(`
  SELECT
    iso3,
    admin0_name,
    admin1_name,
    season,
    year,
    hazard,
    mean,
    mean_anomaly
  FROM historic_climate_timeseries
    where 1=1
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
    ${sqlWhereNull({ field: "season", value: _season })}
    ${sqlWhereNull({ field: "hazard", value: _variable })}
  `);

  const data = resp.map(row => ({
  ...row,
  adminName: row.admin1_name
    ? `${row.admin1_name} (${row.iso3})`
    : row.iso3
  }));

  document.body.style.cursor = "";
  return data;
}

recentChanges_plotData
```

#### futureProjections

```{ojs}
futureProjections_plotData = {
  document.body.style.cursor = "wait";
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;
  const _variable = climateVarSelect.id;

  const resp = await dbFutureHive.query(`
  SELECT
    iso3,
    admin0_name,
    admin1_name,
    season,
    scenario,
    year,
    timeperiod,
    hazard,
    mean,
    mean_anomaly,
    max,
    max_anomaly,
    min,
    min_anomaly
  FROM futureProjections
    where 1=1
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
    ${sqlWhereNull({ field: "season", value: _season })}
    ${sqlWhereNull({ field: "hazard", value: _variable })}
    AND timeperiod in (${["2021-2040", "2041-2060"].map((t) => `'${t}'`).join(", ")})
    AND scenario in (${["ssp245", "ssp585"].map((t) => `'${t}'`).join(", ")})
  `);

  const data = resp.map(row => ({
    ...row,
    adminName: row.admin1_name
      ? `${row.admin1_name} (${row.iso3})`
      : row.iso3
  }));

  document.body.style.cursor = "";
  return data;
}
```

#### hazardExposure

```{ojs}
hazardExposure_plotData = {
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;

  const resp = await db.query(`
  SELECT *
  FROM hazard_exposure
    where 1=1
    AND admin2_name IS NULL
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
  `);
  
  return resp
}

hazardExposure_plotData
```

```{ojs}
exposure_plotData = {
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;

  const resp = await db.query(`
  SELECT *
  FROM exposure
    WHERE 1=1
    AND admin2_name IS NULL
    AND tech = 'all'
    AND exposure = 'vop'
    AND unit_full = 'nominal-usd-2021'
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
  `);

  const data = resp.map(row => ({
    ...row,
    adminName: row.admin1_name
      ? `${row.admin1_name} (${row.iso3})`
      : row.iso3
  }));


  
  return data
}

exposure_plotData
```

```{ojs}
{
  const _data = exposure_plotData;

  return Plot.plot({
    width,
    marginLeft: 120,
    marginBottom: 50,
    marginTop: 30,

    x: {
      axis: "bottom",
      grid: true,
      percent: true,
      label: "Value of Production",
      tickFormat: formatUSD(),
    },

    y: {
      label: "Crop",
    },

    facet: {
      data: _data,
      x: "adminName",
    },

    color: {
      type: "linear",
      range: ["#F7D732","#216729"],
      domain: d3.extent(_data, d => d.value)
    },

    marks: [
      Plot.barX(_data, {
        x: "value",
        y: "crop",
        fill: "value",
        sort: {y: "x", reverse: true},
        tip: true
      })
    ]
  });
}
```

### Global Selectors

#### Admin Regions

```{ojs}
// ADMIN 0
countries = {
  const country_list = await FileAttachment("/data/shared/atlas_countries.json").json();
  const filteredCountries = country_list
    .filter((c) => c.include && c.iso3c !== "SDN")
    .map(({ include, ...rest }) => rest);
  return filteredCountries;
};

viewof admin0Select = Inputs.select(
  countries,
  {
    format: (d) => d.iso3c,
  },
)
```

```{ojs}
// Admin1
dataAdmin1 = {
  const regions = await db.query(`
    SELECT DISTINCT admin0_name, admin1_name, iso3
    FROM historic_climate_timeseries
    WHERE admin1_name IS NOT null
    and iso3 = '${admin0Select.iso3c}'
  `);
  
  return [
    {
      admin0_name: admin0Select.admin0_name,
      admin1_name: null,
      iso3: admin0Select.iso3c
    },
    ...regions
  ]
  // return regions
  // AND iso3 in ('${countryMain.join("', '")}')
}

dataAdmin1

viewof admin1Select = Inputs.select(
  dataAdmin1,
    {
      format: (d) => d.admin1_name
    }
)
```

```{ojs}
// Admin form generator
adminForm = () => {
  const admin0 = Inputs.bind(
    Inputs.select(
        countries,
        {
          label: _lang(general_translations.country),
          format: (d) => _lang(d.translation),
        }
      ),
    viewof admin0Select
  )

  const admin1 = Inputs.bind(
    Inputs.select(
        dataAdmin1,
        {
          label: _lang(general_translations.region),
          format: (d) => d.admin1_name,
        }
      ),
    viewof admin1Select
  )

  return Inputs.form(
    [
      admin0,
      admin1
    ],
    {
      template: inputTemplate()
    }
  )
}

adminForm()
```

#### Climate data

```{ojs}
seasons = new Array(
  { season: "annual", season_rank: null, season_string: "Annual Average" },
  { season: "JFM", season_rank: 0, season_string: "Jan-Feb-Mar" },
  { season: "FMA", season_rank: 1, season_string: "Feb-Mar-Apr" },
  { season: "MAM", season_rank: 2, season_string: "Mar-Apr-May" },
  { season: "AMJ", season_rank: 3, season_string: "Apr-May-Jun" },
  { season: "MJJ", season_rank: 4, season_string: "May-Jun-Jul" },
  { season: "JJA", season_rank: 5, season_string: "Jun-Jul-Aug" },
  { season: "JAS", season_rank: 6, season_string: "Jul-Aug-Sep" },
  { season: "ASO", season_rank: 7, season_string: "Aug-Sep-Oct" },
  { season: "SON", season_rank: 8, season_string: "Sep-Oct-Nov" },
  { season: "OND", season_rank: 9, season_string: "Oct-Nov-Dec" },
  { season: "NDJ", season_rank: 10, season_string: "Nov-Dec-Jan" },
  { season: "DJF", season_rank: 11, season_string: "Dec-Jan-Feb" },
);

viewof seasonSelect = Inputs.select(seasons, {
  format: (d) => d.season,
});
```

```{ojs}
hazards_obj = {
  const input = general_translations.hazardVariables;

  const hazard_lookup = new Object({
    "ndwl0": "NDWL0",
    "ndws": "NDWS",
    "ntx35": "NTx35",
    "ntx40": "NTx40",
    "ptot": "PTOT",
    "tavg": "TAVG",
    "thi": "THI-max",
    "tmax": "TMAX",
    "hsh": "HSH-max"
  })
  return Object.entries(input).map(([id, data]) => ({
    id: hazard_lookup[id],
    ...data
  }));
}

viewof climateVarSelect = Inputs.select(hazards_obj, {format: (d) => d.id});
```

```{ojs}
climateForm()

climateForm = () => {
  let season = Inputs.bind(
    Inputs.select(seasons, {
      format: (d) => d.season_string,
      label: _lang(general_translations.season),
    }),
    viewof seasonSelect
  );

  const climateVar = Inputs.bind(
    Inputs.select(hazards_obj, {
      format: (d) => _lang(d.name),
      label: _lang(general_translations.climateVar),
    }),
    viewof climateVarSelect
  )

  return Inputs.form(
    [
      season,
      climateVar
    ],
    {
      template: inputTemplate()
    }
  )
};
```

## Content

### Recent changes

```{ojs}
barplot_recentChanges = () => {
  const _data = recentChanges_plotData;
  const _season = seasonSelect.season_string;
  const _variableName = _lang(climateVarSelect.name);
  const _variableAxis = _lang(climateVarSelect.labelAxis);
  const _admin1 = admin1Select.admin1_name;
  const _admin0 = _lang(admin0Select.translation);

  const _mainTitle = `${_variableName} (${_lang(general_translations.anomaly)})`;

  const _reverse = ["PTOT"].includes(climateVarSelect.id);

  // 1. Determine the min and max for consistent axis scaling
  const maxAnomaly = Math.max(..._data.map((d) => d.mean_anomaly));
  const minAnomaly = Math.min(..._data.map((d) => d.mean_anomaly));
  const absMax = Math.max(Math.abs(minAnomaly), Math.abs(maxAnomaly));

  const chart = Plot.plot({
    // --- General Configuration ---
    width,
    height: 400,
    marginTop: 30,
    title: _mainTitle,
    subtitle: `Season: ${_season}`,

    // --- Axis Scales ---
    x: {
      label: "Year",
      tickFormat: "d",
    },
    y: {
      // Ensure the Y-axis is also symmetric around 0 for visual balance
      domain: [-absMax, absMax],
      grid: true,
      label: _variableAxis,
    },
    facet: { data: _data, y: "adminName", label: null },

    // --- Color Scale ---
    color: {
      scheme: "BuRd",
      type: "diverging",
      reverse: _reverse,
      legend: true,
      label: `${_variableAxis} (${_lang(general_translations.anomaly)})`,
    },
    // --- Marks ---
    marks: [
      // A single bar mark is used, with 'fill' set to the anomaly value
      Plot.barY(_data, {
        x: "year",
        y: "mean_anomaly",
        // The color scale defined above will automatically color and grade the bars
        fill: "mean_anomaly",
        tip: true,
        channels: {
          Admin: "adminName",
        },
        tip: {
          format: {
            y: false,
            fy: false,
            Admin: true,
            x: (d) => d,
            color: true,
          },
        },
      }),

      // Add a black line at y=0 for a clear baseline
      Plot.ruleY([0], { stroke: "black", strokeWidth: 1.5 }),
    ],
  });
  return chart;
};
```

```{ojs}
warmingStripes_recentChanges = () => {
  const _data = recentChanges_plotData;
  const _season = seasonSelect.season_string;
  const _variableName = _lang(climateVarSelect.name);
  const _variableAxis = _lang(climateVarSelect.labelAxis);
  const _admin1 = admin1Select.admin1_name;
  const _admin0 = _lang(admin0Select.translation);
  const _showAnomaly = true;
  const _anomalyText = _showAnomaly
    ? `(${_lang(general_translations.anomaly)})`
    : "";

  const _mainTitle = `${_variableName}${_anomalyText}`;
  const plotValue = _showAnomaly ? "mean_anomaly" : "mean";
  const lineColor = "#000";

  const yMax = d3.max(_data, (d) => d[plotValue]);
  const yMin = d3.min(_data, (d) => d[plotValue]);
  const yExtent = Math.abs(yMax - yMin);
  const yBufferPerc = 0.05;
  const yBuffer = yExtent * yBufferPerc;
  const yDomain = [yMin - yBuffer, yMax + yBuffer];
  const _reverse = ["PTOT"].includes(climateVarSelect.id);

  const warmingStripes = Plot.plot({
    width,
    height: 350,
    title: _mainTitle,
    subtitle: `Season: ${_season}`,
    // caption: caption,
    x: {
      label: "Year",
      tickFormat: "d",
      padding: 0,
    },
    y: {
      // axis: ws_iToggleLine ? "left" : null,
      label: `${_variableAxis} ${_anomalyText}`,
      domain: yDomain,
    },
    facet: { data: _data, y: "adminName", label: null },
    color: {
      scheme: _showAnomaly ? "BuRd" : "Reds",
      legend: true,
      label: _variableAxis,
      reverse: _reverse,
    },
    marks: [
      // stripes
      Plot.barY(_data, {
        x: "year",
        y1: yDomain[0],
        y2: yDomain[1],
        fill: (d) => d[plotValue],
      }),
      // zero line
      Plot.ruleY(_showAnomaly ? [0] : [], {
        strokeDasharray: [5],
        stroke: lineColor,
      }),
      // line
      Plot.line(_data, {
        x: "year",
        y: (d) => d[plotValue],
        stroke: lineColor,
      }),
      // dots
      Plot.dot(_data, {
        x: "year",
        y: (d) => d[plotValue],
        fill: lineColor,
      }),
      // tooltip
      Plot.tip(
        _data,
        Plot.pointerX({
          x: "year",
          y: (d) => yMin,
          tip: true,
          channels: {
            Admin: "adminName",
            varMean: {
              label: _variableAxis,
              value: (d) => d.mean,
            },
            varMeanAnomaly: {
              label: _lang(general_translations.anomaly),
              value: (d) => d.mean_anomaly,
            },
          },
          format: {
            y: false,
            fy: false,
            Admin: true,
            x: (d) => d,
            varMean: true,
            varMeanAnomaly: true,
          },
          lineWidth: Infinity,
        }),
      ),
    ],
  });

  return warmingStripes;
};
```

```{ojs}
scenarioColors = new Object({
  SSP126: "#4FB5B7",
  SSP245: "#F4BB21",
  SSP370: "#EE624F",
  SSP585: "#B34E65",
});

timeseries_futureProjections = () => {
  const _data = futureProjections_plotData;
  const _season = seasonSelect.season_string;
  const _variableName = _lang(climateVarSelect.name);
  const _variableAxis = _lang(climateVarSelect.labelAxis);
  const _admin1 = admin1Select.admin1_name;
  const _admin0 = _lang(admin0Select.translation);
  const _showAnomaly = true;
  const _anomalyText = _showAnomaly
    ? ` (${_lang(general_translations.anomaly)})`
    : "";

  const _mainTitle = `${_variableName}${_anomalyText}`;
  const plotValue_mean = _showAnomaly ? "mean_anomaly" : "mean";
  const plotValue_max = _showAnomaly ? "max_anomaly" : "max";
  const plotValue_min = _showAnomaly ? "min_anomaly" : "min";

  const formatScenario = (d) => d?.toUpperCase();
  const scenariosInData = [
    ...new Set(_data.map((d) => formatScenario(d.scenario))),
  ];

  return Plot.plot({
    width,
    title: _mainTitle,
    // caption: caption,
    x: {
      tickFormat: "d",
      label: null,
    },
    y: {
      axis: "right",
      grid: true,
      label: _variableAxis,
      tickSize: 0,
    },
    facet: { data: _data, y: "adminName", label: null },
    color: {
      domain: scenariosInData,
      range: scenariosInData.map((s) => scenarioColors[s]),
      legend: true,
    },
    marks: [
      Plot.ruleY(_showAnomaly ? [0] : [], {
        strokeDasharray: [5],
      }),
      Plot.line(_data, {
        x: "year",
        y: plotValue_mean,
        stroke: (d) => formatScenario(d.scenario),
      }),
      Plot.areaY(_data, {
        x: "year",
        y1: plotValue_max,
        y2: plotValue_min,
        fill: (d) => formatScenario(d.scenario),
        fillOpacity: 0.2,
      }),
      Plot.dot(_data, {
        x: "year",
        y: plotValue_mean,
        fill: (d) => formatScenario(d.scenario),
        // tip: true
        tip: {
          channels: {
            scenario: {
              label: _lang(general_translations.scenario),
              value: (d) => formatScenario(d.scenario),
            },
            year: {
              label: _lang(general_translations.year),
              value: (d) => d3.format("d")(d.year),
            },
            Admin: "adminName",
            varMean: {
              label: _variableAxis,
              value: (d) => d.mean,
            },
            varMeanAnomaly: {
              label: _lang(general_translations.anomaly),
              value: (d) => d.mean_anomaly,
            },
          },
          format: {
            Admin: true,
            scenario: true,
            year: true,
            varMean: true,
            varMeanAnomaly: true,
            // value: d => `${d} ${plotField.unit}`,
            x: false,
            y: false,
            fy: false,
            fill: false,
          },
        },
      }),
      Plot.linearRegressionY(false ? _data : [], {
        x: "year",
        y: plotValue_mean,
        stroke: (d) => formatScenario(d.scenario),
        strokeDasharray: [5],
        fill: null,
      }),
    ],
  });
};
```

```{ojs}
function loaderDiv(id) {
  return html`
  <div id="${id}">
    <div style="
        min-height: 500px;
        display: flex;
        justify-content: center;
        align-items: center;"
    >
      <div style="
        width: 40px;
        height: 40px;
        border: 4px solid #ccc;
        border-top-color: var(--atlasGreen);
        border-radius: 50%;
        animation: spin 0.9s linear infinite;
      "></div>

      <style>
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
      </style>
    </div>
  </div>
  `;
}
```
