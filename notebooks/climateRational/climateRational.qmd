---
pagetitle: "Formulate A Climate Rational"
nb-authors:
  - Brayden Youngberg
  - Pete Stewart
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
import {
  atlasTOC,
  atlasHero,
  dataTable,
  downloadButton,
} from "/helpers/uiComponents.ojs";

atlasHero(nbTitle, hero_url);
```

# `{ojs} heading1` {#overview}

```{ojs}
md`${_lang(nbText.sections.intro.text)}`; // wrapped in md for lists to work
```

# `{ojs} heading2` {#keyFacts}

`{ojs} _lang(nbText.sections.keyFacts.introText)`

```{ojs}
admin01Form();

gdpBar_keyFacts();

landuse_plotData

areaBar_keyFacts();

viewof prod_type = Inputs.select([null, ...Object.keys(exposure_groups)], {format: (d) => d || "All Commodities"});

exposureBars_keyFacts();

exposure_plotData
```

`{ojs} downloadButton(exposure_plotData, "commodityProduction")`

# `{ojs} heading3` {#recentChanges}

`{ojs} _lang(nbText.sections.recentChanges.introText)`

```{ojs}
admin01Form();
climateForm();
viewof viewRecentChanges = Inputs.radio(["divergingBar", "warmingStripes", "table"], {
  label: "View Type",
  value: "divergingBar",
});
```

```{ojs}
loaderDiv("plotRecentChanges");
```

```{ojs}
//| output: false
{
  const _displayType = viewRecentChanges;
  const div = document.getElementById("plotRecentChanges");
  div.innerHTML = "";
  let viz;
  if (_displayType === "divergingBar") {
    viz = barplot_recentChanges();
  } else if (_displayType === "warmingStripes") {
    viz = warmingStripes_recentChanges();
  } else if (_displayType === "table") {
    viz = dataTable(recentChanges_plotData, 500);
  }
  div.appendChild(viz);
}
```

`{ojs} downloadButton(recentChanges_plotData, "recentChanges")`

# `{ojs} heading4` {#futureProjections}

`{ojs} _lang(nbText.sections.futureProjections.introText)`

```{ojs}
admin01Form();
climateForm();
viewof viewFutureChanges = Inputs.radio(["plot", "table"], {
  label: "View Type",
  value: "plot",
});
```

```{ojs}
loaderDiv("plotFutureProjections");
```

```{ojs}
//| output: false
{
  const _displayType = viewFutureChanges;
  const div = document.getElementById("plotFutureProjections");
  div.innerHTML = "";
  let viz;
  if (_displayType === "plot") {
    viz = timeseries_futureProjections();
  } else if (_displayType === "table") {
    viz = dataTable(futureProjections_plotData, 500);
  }
  div.appendChild(viz);
}
```

`{ojs} downloadButton(futureProjections_plotData, "futureProjections")`

# `{ojs} heading5` {#extremeEvents}

```{ojs}
admin01Form();
climateForm();

bars_extremeEvents();

extremeEvents_plotData;
```

`{ojs} downloadButton(extremeEvents_plotData, "extremeEvents")`

# `{ojs} heading6` {#hazardExposure}

`{ojs} _lang(nbText.sections.hazardExposure.introText)`

```{ojs}
loaderDiv("plotHazardExposure");
```

# `{ojs} summary` {#summary}

{{< lipsum 1 >}}

# `{ojs} appendix` {#appendix}

```{ojs}
toc_bottom = atlasTOC({
  skip: ["notebook-title", "appendix", "source-code"], // These should be the section headings in the {# headings}
  heading: `<b>${Lang.toSentenceCase(_lang(general_translations.toc))}</b>`,
});

htl.html`
  <div class='floating-toc'>
    ${toc_bottom}
  </div>
`;
```

## `{ojs} methodsData` {#methodsData}

### Data Sources

```{ojs}
data_obj;
```

<div id="datasets"></div>

```{=html}
<script type="module">
  import { buildDatasetDescriptor } from '/components/dataDescriptor.js';
  
  const datasets = await fetch("/data/climateRationale/nbData.json").then(response => {
    if (!response.ok) throw new Error(`Unable to load JSON. Status: ${response.status}`);
    return response.json();
  })

  console.log("data", datasets.data);
  document.getElementById("datasets").innerHTML =
    buildDatasetDescriptor(datasets.data);
</script>
```

### Methods

# Source code {#source-code}

<!-- Add .hidden back in to hide -->

## Text and Language Translations

{{< include /components/_lang.qmd >}}

```{ojs}
// This cell is to contain all the headings and the notebook title
nbTitle = _lang({
  en: "Formulate A Climate Rational",
  fr: "Formuler une justification climatique",
});

nbText = await FileAttachment("/data/climateRationale/nbText.json").json();

heading1 = _lang(general_translations.overview);
heading2 = _lang(nbText.sections.keyFacts.title);
heading3 = _lang(nbText.sections.recentChanges.title);
heading4 = _lang(nbText.sections.futureProjections.title);
heading5 = _lang({ en: "Extreme Events", fr: "Evenements extremes" }); //nbText.sections.extremeEvents.title
heading6 = _lang(nbText.sections.hazardExposure.title);
summary = _lang(general_translations.summary);
appendix = _lang(general_translations.appendix);
methodsData = _lang(general_translations.methodsData);
```

## General

### formatters

```{ojs}
//TODO: Move to shared helpers
// format number, short notation
formatNumCompactShort = ({ locale = "en-US" } = {}) =>
  new Intl.NumberFormat(locale, {
    notation: "compact",
    compactDisplay: "short",
  }).format;

// format number, to significant figures
formatNumCompactSigFigs = ({ locale = "en-US", sigFigs = 3 } = {}) => {
  // Return a formatting function
  return (number) => {
    // Adjust number to specified significant figures
    const formattedNumber = Number(number).toLocaleString(locale, {
      maximumSignificantDigits: sigFigs,
      notation: "compact",
      compactDisplay: "short",
    });

    return formattedNumber;
  };
};

function formatUSD({ locale = "en-US" } = {}) {
  const formatter = formatNumCompactShort({ locale });

  return (number) => {
    const formattedNum = formatter(number);
    return "$" + formattedNum;
  };
}
```

```{ojs}
// template for observable input forms
inputTemplate = ({ gap = "2em" } = {}) => {
  // template for input display
  return (inputs) =>
    html`<div style="display: flex; gap: ${gap};">${inputs}</div>`;
};

// create where clause that handles null cases
sqlWhereNull = ({ value, field } = {}) => {
  return value === null ? `and ${field} is null` : `and ${field} = '${value}'`;
};

// alphabetic sort, nulls first
sortByField = (a, b, { field } = {}) => {
  const av = a[field];
  const bv = b[field];

  // nulls first
  if (av === null || bv === null) {
    if (av === bv) return 0;
    return av === null ? -1 : 1;
  }

  // alphabetical compare
  return av.localeCompare(bv);
};
```

## Styling

```{ojs}
function NavbarLangSelector(language_obj, masterLanguage) {
  let navEnd = document.querySelector(".navbar-nav.ms-auto .nav-item.compact");
  if (navEnd) {
    let existingLangSelector = document.getElementById("nav-lang-selector");
    if (!existingLangSelector) {
      let lang_sel = Inputs.bind(
        Inputs.radio(language_obj, {
          label: "",
          format: (d) => d.label
        }),
        viewof masterLanguage
      );
      lang_sel.id = "nav-lang-selector";
      
      // Hack the css together for the observable inputs
      lang_sel.style.display = "flex";
      lang_sel.style.alignItems = "center";
      lang_sel.style.marginLeft = "10px";
      let lang_div = lang_sel.querySelector("div");
      lang_div.style.display = "flex";
      lang_div.style.flexDirection = "column";

      // Insert the new item after the GitHub icon and other elements
      navEnd.parentNode.appendChild(lang_sel);
    }
  }
}

NavbarLangSelector(languages, masterLanguage)
```

## Data

```{ojs}
import { cleanAdminInput_SQL } from "/helpers/data.js";
```

### Database

```{ojs}
generateDB = async (data_obj) => {
  let data = data_obj;
  const _db = await DuckDBClient.of();

  // loop through datasets
  for (const d of data) {
    if (!d.key || d.key.trim() === "") continue;
    let path = d.s3_path || d.local_path;
    let view = d.sql.table ? "TABLE" : "VIEW";
    let query = d.sql.query;
    if (!query) {
      // use default query
      query = `CREATE ${view} "${d.key}" AS SELECT * FROM read_parquet("${path}");`;
    } else {
      query = `
        CREATE ${view} "${d.key}" AS
          SELECT ${query.select} 
          FROM read_parquet("${path}")
          WHERE ${query.where.join(" AND ")};`;
    }
    await _db.query(query);
  }

  return await _db;
};
```

```{ojs}
data_obj = {
  const obj = await FileAttachment("/data/climateRationale/nbData.json").json();
  return obj.data
}
db = await generateDB(
  // Future projection data is big, so split into different database
  data_obj.filter((d) => !d.sections.includes("futureProjections")),
);
```

```{ojs}
dbFutureHive = {
    const fut = data_obj.filter((d) => d.sections.includes("futureProjections"));
    const _db = await DuckDBClient.of();
    _db.query(`
      CREATE VIEW futureProjections as
        SELECT *, period as timeperiod
        FROM parquet_scan([
          ${fut.map((d) => `'${d.s3_path}'`).join(", ")}
        ],filename=true, hive_partitioning = 1)
    `)
  return _db
}
```

### Sections

#### data - keyFacts

```{ojs}
gdp_plotData = {
  const resp = await db.query(`
    SELECT iso3,
      sector,
      year,
      gdp_usd2015,
      ROUND(
          gdp_usd2015
            / SUM(CASE WHEN sector = 'total' THEN gdp_usd2015 END)
              OVER (PARTITION BY iso3, year),
          1
        ) * 100 AS pct_of_total
    FROM a0_gdp
    WHERE iso3 = '${admin0Select.iso3c}'
    AND year = 2022
  `)
  return resp
}

landuse_plotData = {
  const resp = await db.query(`
    SELECT iso3,
      sub_group,
      "group",
      year,
      ha,
      ha_pct
    FROM a0_landuse
    WHERE iso3 = '${admin0Select.iso3c}'
    AND year = 2021
  `)
  return resp
}

gdp_plotData

landuse_plotData
```

```{ojs}
exposure_plotData = {
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;

  const resp = await db.query(`
  SELECT *
  FROM exposure
    WHERE 1=1
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
  `);

  const data = resp.map(row => ({
    ...row,
    adminName: row.admin1_name
      ? `${row.admin1_name} (${row.iso3})`
      : row.iso3
  }));
  return data
}

exposureMap = new Map(
  exposure_plotData.map(d => [
    `${d.iso3}|${d.admin1_name}|${d.crop}`,
    d.value
  ])
);
```

```{ojs}
exposure_groups = new Object({
  livestock: [
    "sheep-tropical",
    "sheep-highland",
    "goats-tropical",
    "goats-highland",
    "pigs-tropical",
    "pigs-highland",
    "poultry-tropical",
    "poultry-highland",
    "cattle-tropical",
    "cattle-highland",
  ],
  rootsTuber: ["potato", "sweet-potato", "yams", "cassava"],
  cereals: [
    "wheat",
    "rice",
    "maize",
    "barley",
    "pearl-millet",
    "small-millet",
    "sorghum",
  ],
  legumes: [
    "bean",
    "chickpea",
    "cowpea",
    "pigeonpea",
    "lentil",
    "groundnut",
    "soybean",
  ],
  fruitVeg: ["plantain", "coconut", "banana"],
  nonEdible: [
    "cocoa",
    "rapeseed",
    "sesameseed",
    "oilpalm",
    "cotton",
    "tea",
    "tobacco",
    "arabica-coffee",
    "sunflower",
    "sugarcane",
    "sugarbeet",
    "robusta-coffee",
  ],
});
```

#### data - recentChanges

```{ojs}
recentChanges_plotData = {
  document.body.style.cursor = "wait";
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;
  const _variable = climateVarSelect.id;

  const resp = await db.query(`
  SELECT
    iso3,
    admin0_name,
    admin1_name,
    season,
    year,
    hazard,
    mean,
    mean_anomaly
  FROM historic_climate_timeseries
    where 1=1
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
    ${sqlWhereNull({ field: "season", value: _season })}
    ${sqlWhereNull({ field: "hazard", value: _variable })}
  `);

  const data = resp.map(row => ({
  ...row,
  adminName: row.admin1_name
    ? `${row.admin1_name} (${row.iso3})`
    : row.iso3
  }));

  document.body.style.cursor = "";
  return data;
}

recentChanges_plotData
```

#### data - futureProjections

```{ojs}
futureProjections_plotData = {
  document.body.style.cursor = "wait";
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;
  const _variable = climateVarSelect.id;
  //WARN: Temp return no to avoid constant loading/re-query
  // Make sure this is removed for prod.
  // return null
  const resp = await dbFutureHive.query(`
  SELECT
    iso3,
    admin0_name,
    admin1_name,
    season,
    scenario,
    year,
    timeperiod,
    hazard,
    mean,
    mean_anomaly,
    max,
    max_anomaly,
    min,
    min_anomaly
  FROM futureProjections
    where 1=1
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
    ${sqlWhereNull({ field: "season", value: _season })}
    ${sqlWhereNull({ field: "hazard", value: _variable })}
    AND timeperiod in (${["2021-2040"].map((t) => `'${t}'`).join(", ")})
    AND scenario in (${["ssp245", "ssp585"].map((t) => `'${t}'`).join(", ")})
  `);

  const data = resp.map(row => ({
    ...row,
    adminName: row.admin1_name
      ? `${row.admin1_name} (${row.iso3})`
      : row.iso3
  }));

  document.body.style.cursor = "";
  return data;
}
```

#### data - extremeEvents

```{ojs}
function addZScores(data, groupKeys, field = "mean") {
  const groups = d3.group(data, (d) => groupKeys.map((k) => d[k]).join("|"));

  const result = [];

  for (const [_, records] of groups) {
    const mean = d3.mean(records, (d) => d[field]);
    const std = d3.deviation(records, (d) => d[field]);

    for (const d of records) {
      result.push({
        ...d,
        z: std === 0 ? 0 : (d[field] - mean) / std,
      });
    }
  }

  return result;
}

zThresholds = new Object({
  extreme_low: (z) => z <= -2,
  unusual_low: (z) => z > -2 && z <= -1,
  unusual_high: (z) => z >= 1 && z < 2,
  extreme_high: (z) => z >= 2,
});

function classifyZ(z) {
  return Object.keys(zThresholds).find((k) => zThresholds[k](z)) || null;
}

function aggregateEvents(data, scenario_name) {
  const groups = new Map();

  for (const d of data) {
    const key = `${d.iso3}|${d.admin0_name}|${d.admin1_name}|${d.hazard}|${d.season}|${d.scenario}`;

    if (!groups.has(key)) {
      groups.set(key, {
        iso3: d.iso3,
        admin0: d.admin0_name,
        admin1: d.admin1_name,
        adminName: d.adminName,
        hazard: d.hazard,
        scenario: d.scenario || scenario_name,
        // count number in each class from thresholds
        ...Object.fromEntries(Object.keys(zThresholds).map((k) => [k, 0])),
      });
    }

    const group = groups.get(key);
    const category = classifyZ(d.z);

    if (category) group[category] += 1;
  }

  return Array.from(groups.values());
}

extremeEvents_plotData = {
  const historicZ = addZScores(recentChanges_plotData, [
    "iso3",
    "admin1_name",
    "season",
    "hazard",
  ])
  const historicData = aggregateEvents(historicZ, "historical")
  
  const futureZ = addZScores(futureProjections_plotData, [
    "iso3",
    "admin1_name",
    "season",
    "hazard",
    "scenario",
  ])
  const futureData = aggregateEvents(futureZ)
  
  const data = [...historicData, ...futureData]

  const longData = data.flatMap(d =>
    Object.entries({
      extreme_low: d.extreme_low,
      unusual_low: d.unusual_low,
      unusual_high: d.unusual_high,
      extreme_high: d.extreme_high
    }).map(([category, value]) => ({
      scenario: d.scenario,
      adminName: d.adminName,
      hazard: d.hazard,
      category,
      value
    }))
  );
  return longData
}
```

#### data - hazardExposure

```{ojs}
hazardExposure_plotData = {
  const _iso3 = admin0Select.iso3c;
  const _admin1 = admin1Select.admin1_name;
  const _season = seasonSelect.season;

  const resp = await db.query(`
  SELECT
    iso3,
    admin0_name,
    admin1_name,
    crop,
    hazard,
    timeframe,
    scenario,
    value
  FROM hazard_exposure
    where 1=1
    AND admin2_name IS NULL
    AND hazard_vars in ('NDWS+NTx35+NDWL0', 'NDWS+THI-max+NDWL0')
    AND exposure_unit = 'nominal-usd-2021'
    ${sqlWhereNull({ field: "iso3", value: cleanAdminInput_SQL(_iso3)})}
    ${sqlWhereNull({ field: "admin1_name", value: cleanAdminInput_SQL(_admin1) })}
  `);
  
    const data = resp.map(row => ({
    ...row,
    adminName: row.admin1_name
      ? `${row.admin1_name} (${row.iso3})`
      : row.iso3
  }));
  
  // Add in total production not exposed
  const merged = data.map(d => ({
    ...d,
    total_value: exposureMap.get(`${d.iso3}|${d.admin1_name}|${d.crop}`) ?? null
  }));

  return merged
}

hazardExposure_plotData
```

### Global Selectors

#### Admin Regions

{{< include /components/_adminSelectors.qmd >}}

#### Climate data

```{ojs}
seasons = new Array(
  { season: "annual", season_rank: null, season_string: "Annual Average" },
  { season: "JFM", season_rank: 0, season_string: "Jan-Feb-Mar" },
  { season: "FMA", season_rank: 1, season_string: "Feb-Mar-Apr" },
  { season: "MAM", season_rank: 2, season_string: "Mar-Apr-May" },
  { season: "AMJ", season_rank: 3, season_string: "Apr-May-Jun" },
  { season: "MJJ", season_rank: 4, season_string: "May-Jun-Jul" },
  { season: "JJA", season_rank: 5, season_string: "Jun-Jul-Aug" },
  { season: "JAS", season_rank: 6, season_string: "Jul-Aug-Sep" },
  { season: "ASO", season_rank: 7, season_string: "Aug-Sep-Oct" },
  { season: "SON", season_rank: 8, season_string: "Sep-Oct-Nov" },
  { season: "OND", season_rank: 9, season_string: "Oct-Nov-Dec" },
  { season: "NDJ", season_rank: 10, season_string: "Nov-Dec-Jan" },
  { season: "DJF", season_rank: 11, season_string: "Dec-Jan-Feb" },
);

viewof seasonSelect = Inputs.select(seasons, {
  format: (d) => d.season,
});
```

```{ojs}
hazards_obj = {
  const input = general_translations.hazardVariables;

  const hazard_lookup = new Object({
    "ndwl0": "NDWL0",
    "ndws": "NDWS",
    "ntx35": "NTx35",
    "ntx40": "NTx40",
    "ptot": "PTOT",
    "tavg": "TAVG",
    "thi": "THI-max",
    "tmax": "TMAX",
    "hsh": "HSH-max"
  })
  return Object.entries(input).map(([id, data]) => ({
    id: hazard_lookup[id],
    ...data
  }));
}

viewof climateVarSelect = Inputs.select(hazards_obj, {format: (d) => d.id});
```

```{ojs}
climateForm()

climateForm = () => {
  let season = Inputs.bind(
    Inputs.select(seasons, {
      format: (d) => d.season_string,
      label: _lang(general_translations.season),
    }),
    viewof seasonSelect
  );

  const climateVar = Inputs.bind(
    Inputs.select(hazards_obj, {
      format: (d) => _lang(d.name),
      label: _lang(general_translations.climateVar),
    }),
    viewof climateVarSelect
  )

  return Inputs.form(
    [
      season,
      climateVar
    ],
    {
      template: inputTemplate()
    }
  )
};
```

## Figures

### Key facts

```{ojs}
exposureBars_keyFacts = function () {
  const dataCategories = exposure_plotData.map((row) => {
    const category =
      Object.entries(exposure_groups).find(([group, crops]) =>
        crops.includes(row.crop),
      )?.[0] || "other";
    return { ...row, category };
  });

  let _data;
  // If no prod_type, aggregate by category
  if (!prod_type) {
    _data = Array.from(
      d3.rollup(
        dataCategories,
        (v) => d3.sum(v, (d) => d.value),
        (d) => d.admin0_name,
        (d) => d.category,
      ),
      ([admin0_name, catMap]) =>
        Array.from(catMap, ([category, value]) => ({
          admin0_name,
          crop: category,
          value,
        })),
    ).flat();
  } else {
    _data = dataCategories.filter((d) => d.category === prod_type);
  }

  if (_data.length === 0) {
    return html`
      <div style="
        width: ${width}px;
        height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f5f5f5;
        border-radius: 4px;
        color: #666;
        font-size: 16px;
      ">
        No data available for the plot
      </div>
    `;
  }

  return Plot.plot({
    width,
    height: 400,
    marginLeft: 120,
    marginBottom: 50,
    marginTop: 30,

    x: {
      axis: "bottom",
      grid: true,
      percent: true,
      label: "Value of Production",
      tickFormat: formatUSD(),
    },

    y: { label: "Category" },

    facet: {
      data: _data,
      x: "admin0_name",
    },

    color: {
      type: "linear",
      range: ["#F7D732", "#216729"],
      domain: d3.extent(_data, (d) => d.value),
    },

    marks: [
      Plot.barX(_data, {
        x: "value", // summed value
        y: "crop",
        fill: "value", // color by total
        sort: { y: "x", reverse: true },
        tip: true,
      }),
    ],
  });
};
```

```{ojs}
function createStackedBarChart({
  data,
  // Required field mappings
  xField = "percentage", // Field for bar width
  yField = "admin0_name", // Field for faceting/grouping
  fillField = "sector", // Field for coloring segments

  // Chart dimensions
  width,
  heightPerRow = 110,

  // Color configuration
  fillColors = {},
  // fillDomain, // Array of category names
  // fillRange, // Array of colors matching domain
  fillLabelFormatter = (d) => d,

  // Labels and text
  title = "",
  caption = "",

  // Text formatting
  textFormatter = (d) => `${d[xField].toFixed(1)}%`,

  // Tooltip configuration
  channels = {}, // Custom channels for tooltips
  tooltipFormat = {}, // Which fields to show in tooltip
}) {
  const _data = data.filter((d) => d[xField] != null && d[fillField] != null);

  // Calculate number of unique groups for height
  const uniqueGroups = new Set(_data.map((d) => d[yField]));
  const numGroups = uniqueGroups.size;

  // Setup color scale
  const dataCategories = new Set(_data.map((d) => d[fillField]));
  const fillDomain = Object.keys(fillColors).filter((k) =>
    dataCategories.has(k),
  );
  const fillRange = fillDomain.map((d) => fillColors[d]);
  const colorScale = d3.scaleOrdinal().domain(fillDomain).range(fillRange);

  const marks = [
    Plot.barX(
      _data,
      Plot.stackX({
        x: xField,
        y: yField,
        fill: (d) => d[fillField],
        channels: channels,
        tip: {
          dy: 6,
          format: {
            fill: false,
            x: false,
            y: false,
            ...tooltipFormat,
          },
        },
      }),
    ),
    Plot.textX(
      _data.filter((d) => d[xField] > 1), //Assume labels under 1% are too small to show well
      Plot.stackX({
        x: xField,
        y: yField,
        text: textFormatter,
        fill: "#fff",
        fontWeight: "bold",
      }),
    ),
  ];

  return Plot.plot({
    style: {
      overflow: "visible",
    },
    title,
    caption,
    width,
    height: heightPerRow * numGroups,
    x: {
      axis: null,
    },
    y: {
      axis: null,
    },
    color: {
      domain: fillDomain,
      range: fillRange,
      legend: true,
      label: fillLabelFormatter,
    },
    facet: {
      data: _data,
      y: yField,
      label: null,
    },
    marks,
  });
}
```

```{ojs}
gdpBar_keyFacts = () => {
  return createStackedBarChart({
    data: gdp_plotData.filter((d) => d.sector !== "total"),
    xField: "pct_of_total",
    yField: "iso3",
    fillField: "sector",
    width: width,
    fillColors: {
      agriculture: "#74B95A",
      industry: "#8C3E5F",
      manufacturing: "#B34E65",
      services: "#523D4E",
    },
    fillLabelFormatter: (d) => (d) => d.toUpperCase(),
    title: "Country GDP by Sector",
  });
};

areaBar_keyFacts = () => {
  return createStackedBarChart({
    data: landuse_plotData.filter((d) => d.sector !== "total"),
    xField: "ha_pct",
    yField: "iso3",
    fillField: "sub_group",
    width: width,
    fillColors: {
      "Permanent meadows and pastures": "#E8C654",
      Cropland: "#E0A810",
      "Naturally regenerating forest": "#4C843A",
      "Planted Forest": "#8DB878",
      "Other land": "#955D7C",
      "Land used for aquaculture": "#4FB5B7",
    },
    fillLabelFormatter: (d) => (d) => d.toUpperCase(),
    title: "Country GDP by Sector",
  });
};
```

### Recent changes

```{ojs}
barplot_recentChanges = () => {
  const _data = recentChanges_plotData;
  const _season = seasonSelect.season_string;
  const _variableName = _lang(climateVarSelect.name);
  const _variableAxis = _lang(climateVarSelect.labelAxis);
  const _admin1 = admin1Select.admin1_name;
  const _admin0 = _lang(admin0Select.translation);

  const _mainTitle = `${_variableName} (${_lang(general_translations.anomaly)})`;

  const _reverse = ["PTOT"].includes(climateVarSelect.id);

  // 1. Determine the min and max for consistent axis scaling
  const maxAnomaly = Math.max(..._data.map((d) => d.mean_anomaly));
  const minAnomaly = Math.min(..._data.map((d) => d.mean_anomaly));
  const absMax = Math.max(Math.abs(minAnomaly), Math.abs(maxAnomaly));

  const chart = Plot.plot({
    // --- General Configuration ---
    width,
    height: 400,
    marginTop: 30,
    title: _mainTitle,
    subtitle: `Season: ${_season}`,

    // --- Axis Scales ---
    x: {
      label: "Year",
      tickFormat: "d",
    },
    y: {
      // Ensure the Y-axis is also symmetric around 0 for visual balance
      domain: [-absMax, absMax],
      grid: true,
      label: _variableAxis,
    },
    facet: { data: _data, y: "adminName", label: null },

    // --- Color Scale ---
    color: {
      scheme: "BuRd",
      type: "diverging",
      reverse: _reverse,
      legend: true,
      label: `${_variableAxis} (${_lang(general_translations.anomaly)})`,
    },
    // --- Marks ---
    marks: [
      // A single bar mark is used, with 'fill' set to the anomaly value
      Plot.barY(_data, {
        x: "year",
        y: "mean_anomaly",
        // The color scale defined above will automatically color and grade the bars
        fill: "mean_anomaly",
        tip: true,
        channels: {
          Admin: "adminName",
        },
        tip: {
          format: {
            y: false,
            fy: false,
            Admin: true,
            x: (d) => d,
            color: true,
          },
        },
      }),

      // Add a black line at y=0 for a clear baseline
      Plot.ruleY([0], { stroke: "black", strokeWidth: 1.5 }),
    ],
  });
  return chart;
};
```

```{ojs}
warmingStripes_recentChanges = () => {
  const _data = recentChanges_plotData;
  const _season = seasonSelect.season_string;
  const _variableName = _lang(climateVarSelect.name);
  const _variableAxis = _lang(climateVarSelect.labelAxis);
  const _admin1 = admin1Select.admin1_name;
  const _admin0 = _lang(admin0Select.translation);
  const _showAnomaly = true;
  const _anomalyText = _showAnomaly
    ? `(${_lang(general_translations.anomaly)})`
    : "";

  const _mainTitle = `${_variableName}${_anomalyText}`;
  const plotValue = _showAnomaly ? "mean_anomaly" : "mean";
  const lineColor = "#000";

  const yMax = d3.max(_data, (d) => d[plotValue]);
  const yMin = d3.min(_data, (d) => d[plotValue]);
  const yExtent = Math.abs(yMax - yMin);
  const yBufferPerc = 0.05;
  const yBuffer = yExtent * yBufferPerc;
  const yDomain = [yMin - yBuffer, yMax + yBuffer];
  const _reverse = ["PTOT"].includes(climateVarSelect.id);

  const warmingStripes = Plot.plot({
    width,
    height: 350,
    title: _mainTitle,
    subtitle: `Season: ${_season}`,
    // caption: caption,
    x: {
      label: "Year",
      tickFormat: "d",
      padding: 0,
    },
    y: {
      // axis: ws_iToggleLine ? "left" : null,
      label: `${_variableAxis} ${_anomalyText}`,
      domain: yDomain,
    },
    facet: { data: _data, y: "adminName", label: null },
    color: {
      scheme: _showAnomaly ? "BuRd" : "Reds",
      legend: true,
      label: _variableAxis,
      reverse: _reverse,
    },
    marks: [
      // stripes
      Plot.barY(_data, {
        x: "year",
        y1: yDomain[0],
        y2: yDomain[1],
        fill: (d) => d[plotValue],
      }),
      // zero line
      Plot.ruleY(_showAnomaly ? [0] : [], {
        strokeDasharray: [5],
        stroke: lineColor,
      }),
      // line
      Plot.line(_data, {
        x: "year",
        y: (d) => d[plotValue],
        stroke: lineColor,
      }),
      // dots
      Plot.dot(_data, {
        x: "year",
        y: (d) => d[plotValue],
        fill: lineColor,
      }),
      // tooltip
      Plot.tip(
        _data,
        Plot.pointerX({
          x: "year",
          y: (d) => yMin,
          tip: true,
          channels: {
            Admin: "adminName",
            varMean: {
              label: _variableAxis,
              value: (d) => d.mean,
            },
            varMeanAnomaly: {
              label: _lang(general_translations.anomaly),
              value: (d) => d.mean_anomaly,
            },
          },
          format: {
            y: false,
            fy: false,
            Admin: true,
            x: (d) => d,
            varMean: true,
            varMeanAnomaly: true,
          },
          lineWidth: Infinity,
        }),
      ),
    ],
  });

  return warmingStripes;
};
```

### futureProjections

```{ojs}
scenarioColors = new Object({
  SSP126: "#4FB5B7",
  SSP245: "#F4BB21",
  SSP370: "#EE624F",
  SSP585: "#B34E65",
});

timeseries_futureProjections = () => {
  const _data = futureProjections_plotData;
  const _season = seasonSelect.season_string;
  const _variableName = _lang(climateVarSelect.name);
  const _variableAxis = _lang(climateVarSelect.labelAxis);
  const _admin1 = admin1Select.admin1_name;
  const _admin0 = _lang(admin0Select.translation);
  const _showAnomaly = true;
  const _anomalyText = _showAnomaly
    ? ` (${_lang(general_translations.anomaly)})`
    : "";

  const _mainTitle = `${_variableName}${_anomalyText}`;
  const plotValue_mean = _showAnomaly ? "mean_anomaly" : "mean";
  const plotValue_max = _showAnomaly ? "max_anomaly" : "max";
  const plotValue_min = _showAnomaly ? "min_anomaly" : "min";

  const formatScenario = (d) => d?.toUpperCase();
  const scenariosInData = [
    ...new Set(_data.map((d) => formatScenario(d.scenario))),
  ];

  return Plot.plot({
    width,
    title: _mainTitle,
    // caption: caption,
    x: {
      tickFormat: "d",
      label: null,
    },
    y: {
      axis: "right",
      grid: true,
      label: _variableAxis,
      tickSize: 0,
    },
    facet: { data: _data, y: "adminName", label: null },
    color: {
      domain: scenariosInData,
      range: scenariosInData.map((s) => scenarioColors[s]),
      legend: true,
    },
    marks: [
      Plot.ruleY(_showAnomaly ? [0] : [], {
        strokeDasharray: [5],
      }),
      Plot.line(_data, {
        x: "year",
        y: plotValue_mean,
        stroke: (d) => formatScenario(d.scenario),
      }),
      Plot.areaY(_data, {
        x: "year",
        y1: plotValue_max,
        y2: plotValue_min,
        fill: (d) => formatScenario(d.scenario),
        fillOpacity: 0.2,
      }),
      Plot.dot(_data, {
        x: "year",
        y: plotValue_mean,
        fill: (d) => formatScenario(d.scenario),
        // tip: true
        tip: {
          channels: {
            scenario: {
              label: _lang(general_translations.scenario),
              value: (d) => formatScenario(d.scenario),
            },
            year: {
              label: _lang(general_translations.year),
              value: (d) => d3.format("d")(d.year),
            },
            Admin: "adminName",
            varMean: {
              label: _variableAxis,
              value: (d) => d.mean,
            },
            varMeanAnomaly: {
              label: _lang(general_translations.anomaly),
              value: (d) => d.mean_anomaly,
            },
          },
          format: {
            Admin: true,
            scenario: true,
            year: true,
            varMean: true,
            varMeanAnomaly: true,
            // value: d => `${d} ${plotField.unit}`,
            x: false,
            y: false,
            fy: false,
            fill: false,
          },
        },
      }),
      Plot.linearRegressionY(false ? _data : [], {
        x: "year",
        y: plotValue_mean,
        stroke: (d) => formatScenario(d.scenario),
        strokeDasharray: [5],
        fill: null,
      }),
    ],
  });
};
```

### extremeEvents

```{ojs}
bars_extremeEvents = () => {
  const categories = [
    "extreme_low",
    "unusual_low",
    "unusual_high",
    "extreme_high",
  ];
  const interp = (t) => d3.interpolateRdBu(1 - t);
  const colors = categories.map((_, i) => interp(i / (categories.length - 1)));
  const colorScale = d3.scaleOrdinal(categories, colors);
  const _data = extremeEvents_plotData;

  return Plot.plot({
    width: 750,
    height: 420,
    marginLeft: 60,
    marginBottom: 50,
    facet: {
      data: _data,
      x: "adminName",
    },
    x: {
      domain: ["historical", "ssp245", "ssp585"],
    },
    color: {
      legend: true,
      domain: categories,
      range: colors,
    },
    marks: [
      Plot.barY(_data, {
        x: "scenario",
        y: "value",
        fill: (d) => colorScale(d.category),
        tip: true,
      }),
    ],
  });
};
```

### hazardExposure

```{ojs}
{
  const _data = hazardExposure_plotData.filter(
    (d) =>
      d.hazard !== "any" &&
      ["1995-2014", "2021-2040"].includes(d.timeframe) &&
      ["historic", "ssp245", "ssp585"].includes(d.scenario) &&
      d.crop !== "generic-crop"
  );

  const _hazards = [
    "wet",
    "dry",
    "heat",
    "dry+heat",
    "dry+wet",
    "heat+wet",
    "heat+wet+dry"
  ];
  return Plot.plot({
    width,
    marginLeft: 100,
    color: {
      legend: true,
      range: [
        "#4FB5B7",
        "#FCC42C",
        "#FC8A34",
        "#EE624F",
        "#B34E65",
        "#8C3E5F",
        "#523D4E",
        "#EFEFEF"
      ],
      domain: _hazards
    },
    x: {
      ticks: 1,
      axis: "top",
      // domain: [0, 100],
      grid: true
    },
    facet: {
      data: _data,
      x: "scenario",
    },
    marks: [
      // main y-axis
      Plot.axisY({
        tickSize: 0
      }),
      // pointer white-out
      Plot.axisY(
        Plot.pointerY({
          fill: "white",
          textStroke: "white",
          textStrokeWidth: 2,
          tickSize: 0
        })
      ),
      // bold pointer
      Plot.axisY(
        Plot.pointerY({
          fontWeight: "bold",
          tickSize: 0
        })
      ),
      Plot.barX(
        _data,
        Plot.stackX(
          { order: _hazards },
          {
            x: (d) => d.value,
            // x: (d) => (d.value / d.total_value) * 100,
            y: "crop",
            fill: "hazard",
            stroke: "#fff",
            strokeWidth: 0.25,
            tip: true
          }
        )
      )
    ]
  });
}
```

## Tooling

```{ojs}
function loaderDiv(id) {
  return html`
  <div id="${id}">
    <div style="
        min-height: 500px;
        display: flex;
        justify-content: center;
        align-items: center;"
    >
      <div style="
        width: 40px;
        height: 40px;
        border: 4px solid #ccc;
        border-top-color: var(--atlasGreen);
        border-radius: 50%;
        animation: spin 0.9s linear infinite;
      "></div>

      <style>
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
      </style>
    </div>
  </div>
  `;
}
```

<style>
  .dataset-card {
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 1rem 1.25rem;
    margin-bottom: 1rem;
    background: #fff;
  }

  .dataset-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 0.25rem;
  }

  .dataset-title {
    margin: 0;
    font-size: 1.1rem;
  }

  .dataset-description {
    margin: 0.25rem 0 0.75rem;
    color: #444;
  }

  .dataset-meta {
    margin: 0 0 0.75rem;
  }

  .dataset-meta dt {
    font-weight: 600;
    font-size: 0.85rem;
    margin-bottom: 0.1rem;
  }

  .dataset-meta dd {
    margin: 0 0 0.5rem;
    font-size: 0.85rem;
  }

  .dataset-s3-path {
    font-family: monospace;
    font-size: 0.8rem;
    padding: 0.1rem 0.25rem;
    background: #f5f5f5;
    border-radius: 4px;
  }

  .dataset-section-link {
    text-decoration: none;
    color: #0366d6;
  }

  .dataset-section-link:hover {
    text-decoration: underline;
  }

  .dataset-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }

  .dataset-download-btn,
  .dataset-copy-btn {
    font-size: 0.8rem;
    padding: 0.35rem 0.7rem;
    border-radius: 4px;
    border: 1px solid #ccc;
    background: #f8f8f8;
    cursor: pointer;
  }

  .dataset-download-btn:hover,
  .dataset-copy-btn:hover {
    background: #eee;
  }

  .dataset-download-btn[disabled] {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>
