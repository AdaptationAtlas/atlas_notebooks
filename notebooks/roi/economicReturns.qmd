---
pagetitle: "Atlas Notebook Template"
nb-authors:
  - Brayden Youngberg
  - Pete Stewart
date-created: "2025-10-15"
date-edited: today
execute:
  echo: true
format:
  html:
    code-fold: true
    code-summary: "Show the code" ## Add this to global template to make debugging easier.
    css: roi_styles.css # Custom CSS for this notebook so the multi select works.
---

```{ojs}
import {
  atlasTOC,
  atlasHero,
  dropdown_section,
} from "/helpers/uiComponents.ojs";

hero_url = "./../../images/default_crop.webp";

atlasHero(nbTitle, hero_url);
```

# `{ojs} nbOverview` {#overview}

```{ojs}
//| echo: false
// Text for overview section
md`${_lang(nbText.overview.blocks.block1)}`;

md`${_lang(nbText.overview.blocks.block2)}`;

md`${_lang(nbText.indicators.irr.overview)}`;

md`${_lang(nbText.indicators.mirr.overview)}`;

md`${_lang(nbText.indicators.npv.overview)}`;

md`${_lang(nbText.indicators.bcr.overview)}`;

md`${_lang(nbText.overview.blocks.block3)}`;

md`${_lang(nbText.overview.blocks.block4)}`;
```

# `{ojs} heading1` {#project-setup}

`{ojs} _lang(nbText.projectSetup.blocks.opener1)`

`{ojs} _lang(nbText.projectSetup.blocks.opener2)`

```{ojs}
htl.html`
  <div style="display: flex; gap: 3em; flex-wrap: wrap;">
    <div>${viewof select_country}</div>
    <div>${viewof select_region}</div>
    <div>${viewof select_crop}</div>
  </div>
`
```

## `{ojs} _lang(nbText.projectSetup.blocks.costs.h2)`

`{ojs} _lang(nbText.projectSetup.blocks.costs.text)`

```{ojs}
viewof inputProjectOptions = {
  const inputProjectCost = Inputs.text({
    label: makeTooltipLabel({
      labelText: inputOptions_projectCost.label,
      tooltipText: inputOptions_projectCost.tooltip
    }),
    pattern: inputOptions_projectCost.pattern,
    placeholder: inputOptions_projectCost.placeholder,
    value: inputOptions_projectCost.valueString
  });
  const inputProjectYears = Inputs.select(inputOptions_projectYears.data, {
    format: (x) => x.label,
    label: makeTooltipLabel({
      labelText: inputOptions_projectYears.label,
      tooltipText: inputOptions_projectYears.tooltip
    })
  });

  return Inputs.form(
    {
      cost: inputProjectCost,
      years:inputProjectYears
    },
    {
      template: (inputs) =>
        htl.html`<div style="display: flex; gap: 3em">${Object.values(
          inputs
        )}</div>`
    }
  );
}
```

```{ojs}
{
  const template = _lang(nbText.projectSetup.blocks.costs.calloutTemplate)
  const templateItems = [
    {name: "money", value: formatUSD({locale: language.locale})(rangeProjectCost)},
    {name: "time", value: inputProjectOptions.years.label},
  ]
  const formatted = Lang.reduceReplaceTemplateItems(template, templateItems)
  return md`${formatted}`
}
```

## `{ojs} _lang(nbText.projectSetup.blocks.impacts.h2)`

`{ojs} _lang(nbText.projectSetup.blocks.impacts.text)`

## Select Parameters

<!-- This is not correct in the notebook as this section
is on production impact, adapotion rate, etc. -->

Choose your model parameters for the analysis.

```{ojs}
viewof options_econPerfWalkthrough = {
  const terms = {
    none: _lang(nbText.projectSetup.blocks.impacts.terms.none, {
      key: language.key
    }),
    low: _lang(nbText.projectSetup.blocks.impacts.terms.low, {
      key: language.key
    }),
    moderate: _lang(nbText.projectSetup.blocks.impacts.terms.moderate, {
      key: language.key
    }),
    high: _lang(nbText.projectSetup.blocks.impacts.terms.high, {
      key: language.key
    }),
    incremental: _lang(
      nbText.projectSetup.blocks.impacts.terms.incremental,
      
    ),
    transformative: _lang(
      nbText.projectSetup.blocks.impacts.terms.transformative,
      
    )
  };
  const dataProdImpact = [
    { label: `10% (${terms.incremental})`, value: 0.1 },
    { label: `20%`, value: 0.2 },
    { label: `30% (${terms.moderate})`, value: 0.3 },
    { label: `40%`, value: 0.4 },
    { label: `50% (${terms.transformative})`, value: 0.5 }
  ];
  const inputProdImpact = Inputs.select(dataProdImpact, {
    label: makeTooltipLabel({
      labelText: _lang(
      nbText.projectSetup.blocks.impacts.inputs.prodImpactDropdown.label,
      
    ),
      tooltipText:
        _lang(
      nbText.projectSetup.blocks.impacts.inputs.prodImpactDropdown.tooltip,
      
    )
    }),
    format: (x) => x.label,
    value: dataProdImpact.find((d) => d.value == 0.3)
  });
  const dataAdoption = [
    { label: `0.5% (${terms.low})`, value: 0.005 },
    { label: `1% (${terms.moderate})`, value: 0.01 },
    { label: `2% (${terms.high})`, value: 0.02 }
  ];
  const inputAdoption = Inputs.select(dataAdoption, {
    label: makeTooltipLabel({
      labelText: _lang(
      nbText.projectSetup.blocks.impacts.inputs.adoptionRateDropdown.label,
      
    ),
      tooltipText:
        _lang(
      nbText.projectSetup.blocks.impacts.inputs.adoptionRateDropdown.tooltip,
      
    )
    }),
    format: (x) => x.label,
    value: dataAdoption.find((d) => d.value == 0.01)
  });
  const dataCisImpact = [
    { label: `0% (${terms.none})`, value: 0 },
    { label: `10% (${terms.low})`, value: 0.1 },
    { label: `25% (${terms.moderate})`, value: 0.25 },
    { label: `50% (${terms.high})`, value: 0.5 }
  ];
  const inputCisImpact = Inputs.select(dataCisImpact, {
    label: makeTooltipLabel({
      labelText: _lang(
      nbText.projectSetup.blocks.impacts.inputs.cisImpactDropdown.label,
      
    ),
      tooltipText:
        _lang(
      nbText.projectSetup.blocks.impacts.inputs.cisImpactDropdown.tooltip,
      
    )
    }),
    format: (x) => x.label,
    value: dataCisImpact.find((d) => d.value == 0.25)
  });
  return Inputs.form(
    {
      inputProdImpact,
      inputAdoption,
      inputCisImpact
    },
    {
      template: (inputs) =>
        htl.html`<div style="display: flex; gap: 3em">${Object.values(
          inputs
        )}</div>`
    }
  );
}
```

`{ojs} dropdown_section("Advanced Controls", false, "Stuff for experts")`

# `{ojs} heading2` {#investment-returns}

# `{ojs} nbSummary` {#summary}

{{< lipsum 1 >}}

# `{ojs} nbMethods` {#methods}

{{< lipsum 1 >}}

# `{ojs} appendix` {#appendix}

```{ojs}
toc_bottom = atlasTOC({
  skip: ["notebook-title", "appendix", "source-code"], // These should be the section headings in the {# headings}
  heading: `<b>${Lang.toSentenceCase(_lang(general_translations.toc))}</b>`,
});

htl.html`
      <div class='floating-toc'>
      ${toc_bottom}
      </div>
      `;
```

# Source code {#source-code}

<!--TODO: Add .hidden in bracket to hide for production -->

## Data import and cleaning

```{ojs}
// Data loader cell
//TODO: Move this to s3 paths
db = {
  let db = await DuckDBClient.of({
    exposure_raw: FileAttachment("/data/economicReturns/exposure_adm_sum_spam20-21_glw420-21.parquet"),
    cv_raw: FileAttachment("/data/economicReturns/faostat_prod_cv.parquet")
  })
  await db.query(`
    CREATE VIEW exposure AS
      SELECT
        iso3,
        admin0_name,
        admin1_name,
        REGEXP_REPLACE(crop, '-tropical|-highland', '') AS crop,
        CONCAT(exposure, '_', unit) AS exposure,
        SUM(value) AS value
      FROM exposure_raw
      WHERE
        admin2_name IS NULL
        AND (tech = 'all' OR tech IS NULL)
        AND isfinite(value)
        AND CONCAT(exposure, '_', unit) = 'vop_usd'
        AND crop !~ '(^other-|rest-of|temperate-fruit|tropical-fruit|vegetables)'
      GROUP BY
        iso3,
        admin0_name,
        admin1_name,
        crop,
        CONCAT(exposure, '_', unit)
  `)
  await db.query(`
    CREATE VIEW cv AS
      SELECT
        admin0_name,
        -- clean and standardize crop names
        REGEXP_REPLACE(
          REGEXP_REPLACE(
            REPLACE(REPLACE(crop, '_meat', ''), ' ', '-'),
            'goat$', 'goats'
          ),
          'pig$', 'pigs'
        ) AS crop,
        value_filled AS cv
      FROM cv_raw
      WHERE NOT (crop ILIKE '%milk%' OR crop ILIKE '%eggs%' OR LOWER(crop) = 'total')

      UNION ALL
      -- add robusta-coffee and small-millet substitutes
      SELECT admin0_name, 'robusta-coffee', value_filled AS cv
      FROM cv_raw
      WHERE crop = 'arabica-coffee'

      UNION ALL
      SELECT admin0_name, 'small-millet', value_filled AS cv
      FROM cv_raw
      WHERE crop = 'pearl-millet';
`)
  return db;
};

countries = {
  const country_list = await FileAttachment("/data/shared/atlas_countries.json").json();
  const filteredCountries = country_list
    .filter((c) => c.include && c.iso3c !== "SDN")
    .map(({ include, ...rest }) => rest);
  return filteredCountries;
};
```

<!-- Crops and admin regions based on dataset -->

```{ojs}
dataAdminRegions = {
  const regions = await db.query(`
    SELECT DISTINCT admin0_name, admin1_name, iso3
    FROM exposure
    WHERE admin1_name IS NOT null
    AND iso3 in ('${select_country.join("', '")}')
  `)

  return regions.map(row => ({
    ...row,
    id: `${row.iso3}_${row.admin1_name}`
  }));
}

//TODO: Need to add translations and label cleaning to items
dataCrops = await db.query(`
  SELECT DISTINCT crop AS item
  FROM exposure
  ORDER BY item
`)
```

## Inputs

```{ojs}
// Defaults and gaurd rails for the inputs
inputOptions_projectCost = {
  return {
    range: [1e6, 5e8],
    label: _lang(nbText.projectSetup.blocks.costs.inputs.costInput.label),
    tooltip: _lang(nbText.projectSetup.blocks.costs.inputs.costInput.tooltip),
    step: 1e5,
    value: 50_000_000,
    format: d3.format('$.3s'),
    outputWidth: 90,
    placeholder: "Ex. $5,000,000",
    pattern: "^[$]?[1-9]+[0-9,$]*$",
    valueString: "$50,000,000"
  }
}

inputOptions_projectYears = {
  const years = _lang(
      nbText.projectSetup.blocks.costs.inputs.projectYearDropdown.terms.year.plural,
  );
  return {
    range: [2, 16],
    data: d3
      .range(2, 16 + 1, 1)
      .map((d) => ({ label: `${d} ${years}`, value: d })),
    label: _lang(nbText.projectSetup.blocks.costs.inputs.projectYearDropdown.label),
    tooltip: _lang(nbText.projectSetup.blocks.costs.inputs.projectYearDropdown.tooltip),
    step: 1,
    value: 8,
    outputWidth: 90
  };
}
```

### Scope Selectors - country, region, crop

```{ojs}
viewof select_country = {
  //TODO: Possibly add a debounce to this.
  const data = countries
    .map((d) => ({
      value: d.iso3c, //Migrating to iso codes for future flexability
      label: _lang(d.translation)
    }))
  return dropdownInput({
    inputLabel: makeTooltipLabel({
      labelText: _lang(nbText.supportNbText.words.country.plural),
      tooltipText: _lang(
        nbText.projectSetup.blocks.locations.inputs.countryDropdown.tooltip
      )    
    }),
    inputId: "positionsTest",
    placeholderText: "Select Countries...",
    options: data,
    selected: ["KEN", "TZA"],
  });
}

select_country
```

```{ojs}
// admin multi-select: regions
viewof select_region = {
  // filter regions based on country id's
  const filteredRegions = dataAdminRegions
  // const translateCountry = (d) => _lang(td.admin0_name.values?.[d]);
  const translateCountry = (iso) => _lang(countries.find((c) => c.iso3c === iso).translation);
  const data = filteredRegions.map((d) => ({
    value: d.id,
    label: `${translateCountry(d.iso3)}: ${d.admin1_name}`
  }));
  const selectedIds = filteredRegions.map((d) => d.id);
  const text = {
    label: _lang(nbText.supportNbText.words.region.plural),
    tooltip: _lang(nbText.projectSetup.blocks.locations.inputs.regionDropdown.tooltip),
  }
  const input = dropdownInput({
    inputLabel: makeTooltipLabel({labelText: text.label, tooltipText: text.tooltip}),
    inputId: "positionsTest",
    placeholderText: "Select regions...",
    options: data,
    selected: selectedIds
  });

  // return debounce(debounceDelay, input);
  return input
}
```

```{ojs}
// admin multi-select: countries
viewof select_crop = {
  const data = dataCrops
    .map((d) => ({
      value: d.item,
      label: Lang.toSentenceCase(d.item) //TODO: Add translations
    }))
    .sort((a,b) => a.label > b.label);
  const selectedId = dataCrops
    .filter((d) => ["bean", "goats", "maize"].includes(d.item))
    .map((d) => d.item);
  const text = {
    label: _lang(nbText.supportNbText.words.commodity.plural),
    tooltip: _lang(
      nbText.projectSetup.blocks.locations.inputs.commodityDropdown.tooltip
    )
  };
  const input = dropdownInput({
    inputLabel: makeTooltipLabel({
      labelText: text.label,
      tooltipText: text.tooltip
    }),
    inputId: "positionsTest",
    placeholderText: "Select crops...",
    options: data,
    selected: selectedId
  });

  // return debounce(debounceDelay, input);
  return input
}
```

## Economic Input Variables

### Main Control Variables

```{ojs}
rangeProjectCost = {
  const unpack = Number(inputProjectOptions.cost.replace(/[,|$]/g, ""))
  const number = Number(unpack)
  return number
}

projectYears = inputProjectOptions.years.value
```

### Advanced Control Variables

```{ojs}
//TODO:
// -[ ] years, cost, Prod Impact,Adoption, Reduction of impacts, CIS Impact
// -[ ] BCR
// -[ ] CIS impact

bcr = 1.62;
```

### Derived Variables

```{ojs}
recipe_paymentSchedule = Array.from({ length: projectYears }).map((_, i) => {
  return {
    year: i,
    cost: (1 / projectYears) * rangeProjectCost,
    cost_cum: ((i + 1) / projectYears) * rangeProjectCost,
  };
});
```

## Elements

```{ojs}
function makeTooltipLabel({
  labelText = "Dropdown label",
  tooltipText = "Tooltip text",
} = {}) {
  return htl.html`
    <span
      data-title="${tooltipText}"
      style="
        position:relative;
        cursor:pointer;
      "
    >${labelText}</span>
    <style>
      [data-title]:hover::after {
        content: attr(data-title);
        position: absolute;
        left: 0;
        top: 100%;
        background: #efefef;
        color: #333;
        font-size: 14px;
        padding: 6px 10px;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        white-space: nowrap;
        z-index: 9999;
      }
    </style>
  `;
}
```

```{ojs}
import {
  dropdownInput,
  dropdownCSS,
} from "@adaptationatlas/data-spotlight-multi-select";

dropdownCSS;
```

## Helper Functions

```{ojs}
// Formatting
function formatUSD({ locale = "en-US" } = {}) {
  const formatter = formatNumCompactShort({ locale });

  return (number) => {
    const formattedNum = formatter(number);
    return "$" + formattedNum;
  };
}

// format number, short notation
formatNumCompactShort = ({ locale = "en-US" } = {}) =>
  new Intl.NumberFormat(locale, {
    notation: "compact",
    compactDisplay: "short",
  }).format;

function formatCurrencyAuto(value, precision = 1) {
  const absVal = Math.abs(value);

  if (absVal >= 1e9) {
    return `$${(value / 1e9).toFixed(precision)}B`;
  } else if (absVal >= 1e6) {
    return `$${(value / 1e6).toFixed(precision)}M`;
  } else if (absVal >= 1e3) {
    return `$${(value / 1e3).toFixed(precision)}K`;
  } else {
    return `$${value.toFixed(1)}`;
  }
}
```

## Language

<!-- Text and Language Translations -->

```{ojs}
// This cell is to contain all the headings and the notebook title
nbTitle = _lang({
  en: "Estimate Economic Returns on Adaptation",
  fr: "Estimer les retours sur économiques l'adaptation",
});
// key_insights = _lang({en: "Key Insights", fr: "Résumé"})
nbOverview = _lang({ en: "Overview", fr: "Vue d’Ensemble" });
heading1 = _lang({ en: "Project Set-Up", fr: "Configuration de Project" });
heading2 = _lang({ en: "Investment Returns", fr: "Retours d'Investissements" });
nbSummary = _lang({ en: "Summary", fr: "Résumé" });
nbMethods = _lang({ en: "Methods & Sources", fr: "Méthodes & Sources" });
appendix = _lang(general_translations.appendix);
```

```{ojs}
import { lang as Lang } from "/helpers/lang.js"

general_translations = await FileAttachment("/data/shared/generalTranslations.json").json()

nbText = await FileAttachment("/data/economicReturns/translations.json").json()

languages = [
  { key: "en", label: "English", locale: 'en-US' },
  { key: "fr", label: "Français", locale: 'fr-FR' }
]

defaultLangKey = {
  const name = "lang";
  const list = languages.map((d) => d.key);
  const defaultKey = "en";
  const queryParam = await Lang.getParamFromList({ name, list });
  return queryParam ?? defaultKey;
}

_lang = Lang.lg(masterLanguage.key)

viewof masterLanguage = Inputs.radio(languages, {
  label: "Main language toggle",
  format: (d) => d.key,
  value: languages.find((x) => x.key === defaultLangKey),
})
```

```{ojs}
function NavbarLangSelector(language_obj, masterLanguage) {
  let navEnd = document.querySelector(".navbar-nav.ms-auto .nav-item.compact");
  if (navEnd) {
    let existingLangSelector = document.getElementById("nav-lang-selector");
    if (!existingLangSelector) {
      let lang_sel = Inputs.bind(
        Inputs.radio(language_obj, {
          label: "",
          format: (d) => d.label
        }),
        viewof masterLanguage
      );
      lang_sel.id = "nav-lang-selector";
      
      // Hack the css together for the observable inputs
      lang_sel.style.display = "flex";
      lang_sel.style.alignItems = "center";
      lang_sel.style.marginLeft = "10px";
      let lang_div = lang_sel.querySelector("div");
      lang_div.style.display = "flex";
      lang_div.style.flexDirection = "column";

      // Insert the new item after the GitHub icon and other elements
      navEnd.parentNode.appendChild(lang_sel);
    }
  }
}

NavbarLangSelector(languages, masterLanguage)
```

```{ojs}
prettyLanguageView = {
  return Inputs.bind(
    Inputs.radio(languages, {
      label: _lang(general_translations.language),
      format: (d) => d.label
    }),
    viewof masterLanguage
  );
}
```

```{ojs}
dataPickMetric = {
  return [
    {
      key: "irr",
      columnName: "irr",
      label: _lang(nbText.indicators.irr.label),
      tooltip: _lang(nbText.indicators.irr.tooltip),
      labelLong: _lang(nbText.indicators.irr.labelLong),
      labelFull: _lang(nbText.indicators.irr.labelFull),
      info: {
        what: _lang(nbText.indicators.irr.info.what),
        interpret: _lang(nbText.indicators.irr.info.interpret),
        tell: _lang(nbText.indicators.irr.info.tell)
      },
      yFormat: (d) => `${d.toFixed(1)}%`
    },
    {
      key: "mirr",
      columnName: "mirr",
      label: _lang(nbText.indicators.mirr.label),
      tooltip: _lang(nbText.indicators.mirr.tooltip),
      labelLong: _lang(nbText.indicators.mirr.labelLong),
      labelFull: _lang(nbText.indicators.mirr.labelFull),
      info: {
        what: _lang(nbText.indicators.mirr.info.what),
        interpret: _lang(nbText.indicators.mirr.info.interpret),
        tell: _lang(nbText.indicators.mirr.info.tell)
      },
      yFormat: (d) => `${d.toFixed(1)}%`
    },
    {
      key: "npv",
      columnName: "npv",
      label: _lang(nbText.indicators.npv.label),
      tooltip: _lang(nbText.indicators.npv.tooltip),
      labelLong: _lang(nbText.indicators.npv.labelLong),
      labelFull: _lang(nbText.indicators.npv.labelFull),
      info: {
        what: _lang(nbText.indicators.npv.info.what),
        interpret: _lang(nbText.indicators.npv.info.interpret),
        tell: _lang(nbText.indicators.npv.info.tell)
      },
       yFormat: (d) => formatCurrencyAuto(d, 1)
    },
    {
      key: "bcr",
      columnName: "discounted_bcr",
      label: _lang(nbText.indicators.bcr.label),
      tooltip: _lang(nbText.indicators.bcr.tooltip),
      labelLong: _lang(nbText.indicators.bcr.labelLong),
      labelFull: _lang(nbText.indicators.bcr.labelFull),
      info: {
        what: _lang(nbText.indicators.bcr.info.what),
        interpret: _lang(nbText.indicators.bcr.info.interpret),
        tell: _lang(nbText.indicators.bcr.info.tell)
      },
      yFormat: d3.format(".2f")
    }
  ];
}
```

## Data Filtering and Processing

```{ojs}
admin0_names = {
  const isoSet = new Set(select_country);
  return countries
  .filter((d) => isoSet.has(d.iso3c))
  .map((d) => d.admin0_name);
}
admin0_names;
```

### CV Data

```{ojs}
import { avlossCalc } from "/notebooks/roi/roi_tools.js";
```

```{ojs}
mutable cv_results = []; // To allow rest of the cells to render and say, "run code"

//TODO: this gets wrapped in a function
cv_data = db.query(`
  SELECT * 
  FROM cv 
  WHERE crop in ('${select_crop.join("', '")}')
  AND admin0_name in ('${admin0_names.join("', '")}') -- This needs to find admin0_name from iso3
`);

cis_impact = options_econPerfWalkthrough.inputCisImpact.value;

results = await Promise.all(
  // Reduced to only run for each country/crop selection 1. I think it yields same result.
  cv_data.map(async ({ crop, admin0_name, cv }) => {
    const av = await avlossCalc(cv, cis_impact);
    const avloss = Math.abs(Number(av.toFixed?.(4) ?? av));
    return { admin0_name, crop, cv, cis_impact, avloss };
  }),
);

results;
```
