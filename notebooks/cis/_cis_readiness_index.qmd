```{ojs}
// ============================================================================
// SECTION 1: CIS READINESS INDEX ANALYSIS
// ============================================================================
// This file contains the core analysis of Climate Information Services (CIS)
// readiness across Sub-Saharan Africa. It loads CIS indicator data, calculates
// Africa-wide tercile classifications, and provides interactive visualizations
// for weather station density, cloud coverage, satellite agreement, and
// forecast skill at multiple administrative levels (Admin 0/1/2).
//
// Key Features:
// - DuckDB-powered Parquet data loading for performance
// - Reactive admin-level filtering with synced selectors across sections
// - Multiple visualization types (maps, charts, tables, heatmaps)
// - Dynamic insights that update based on user selections
// ============================================================================

section1Title = _lang(cis.section1Title)
```

# `{ojs} section1Title` {#section1}

```{ojs}
// ============================================================================
// DATA LOADING: CIS Indicator Data
// ============================================================================
// Uses DuckDB + Parquet for efficient data loading. This approach:
// 1. Loads data directly from columnar Parquet format (faster than CSV)
// 2. Enables SQL queries if needed for server-side filtering
// 3. Provides better memory efficiency for large datasets
//
// Data Source: CIS_nb_data.parquet contains Climate Information Services
// indicators at Admin 0/1/2 levels across Sub-Saharan Africa.
// ============================================================================

cisDB = await DuckDBClient.of({
  cis_data: FileAttachment("/data/cis/CIS_nb_data.parquet")
});

// Query all data - processing is done in JavaScript for type safety
// and Observable reactivity compatibility
cisDataRaw = await cisDB.query(`SELECT * FROM cis_data`);

// Transform raw data with proper type parsing
// Note: Parquet files from some sources encode NULL as "\\N" string
cisData = cisDataRaw.map(row => ({
  ...row,
  // Clean null values represented as "\N" (common in database exports)
  // These must be converted to JavaScript null for proper filtering
  admin1_name: row.admin1_name === "\\N" || row.admin1_name === "" ? null : row.admin1_name,
  admin2_name: row.admin2_name === "\\N" || row.admin2_name === "" ? null : row.admin2_name,
  
  // Parse all numeric indicator fields from strings to numbers
  // Each indicator is normalized to 0-1 scale in the source data
  "weather-station_density": parseFloat(row["weather-station_density"]),
  "cloud-coverage_meanannual": parseFloat(row["cloud-coverage_meanannual"]),
  "cv-precipitation_agreement": parseFloat(row["cv-precipitation_agreement"]),
  "short-term_frcst_skill": parseFloat(row["short-term_frcst_skill"]),
  "seasonal_frcst_skill": parseFloat(row["seasonal_frcst_skill"]),
  "cis_readiness_index": parseFloat(row["cis_readiness_index"]),
  
  // GAUL (Global Administrative Unit Layers) codes for geo-matching
  gaul0_code: parseInt(row.gaul0_code),
  gaul1_code: parseInt(row.gaul1_code),
  gaul2_code: parseInt(row.gaul2_code)
}));
```

```{ojs}
// Import boundary helper functions
import { geojsonFromWKB_wk, read_topojson } from "/helpers/boundaries.js"
import { boundary_paths } from "/helpers/data.js"
```

```{ojs}
// Load boundary data
admin0Boundaries = await read_topojson(boundary_paths.admin0_path, "atlas_gaul24_a0_africa")
admin1Boundaries = await read_topojson(boundary_paths.admin1_path, "atlas_gaul24_a1_africa")
admin2Boundaries = await read_topojson(boundary_paths.admin2_path, "atlas_gaul_a2_africa_simple-lowres")
```

```{ojs}
// ============================================================================
// TERCILE CALCULATION: Africa-Wide Classification Thresholds  
// ============================================================================
// Terciles divide the data into three equal groups (33.3%, 66.7% cutoffs).
// This provides a relative classification system where:
//   - "Weaker" = Bottom third of African values
//   - "Moderate" = Middle third
//   - "Stronger" = Top third
//
// Why terciles? They provide context-appropriate classifications that
// account for the distribution of values across Sub-Saharan Africa,
// rather than using arbitrary absolute thresholds.
//
// Note: These cutoffs are computed once from ALL data (not filtered),
// ensuring consistent classifications regardless of user selections.
// ============================================================================

africaTerciles = {
  // Extract each indicator's values, filtering out nulls
  const weatherStations = cisData.map(d => d["weather-station_density"]).filter(d => d != null);
  const cloudCover = cisData.map(d => d["cloud-coverage_meanannual"]).filter(d => d != null);
  const precipAgreement = cisData.map(d => parseFloat(d["cv-precipitation_agreement"])).filter(d => !isNaN(d));
  const shortTermSkill = cisData.map(d => d["short-term_frcst_skill"]).filter(d => d != null);
  const seasonalSkill = cisData.map(d => d["seasonal_frcst_skill"]).filter(d => d != null);
  const cisReadiness = cisData.map(d => d["cis_readiness_index"]).filter(d => d != null);
  
  // Custom quantile function using linear interpolation
  // This matches most statistical software implementations (e.g., R's type=7)
  const quantile = (arr, q) => {
    const sorted = arr.slice().sort((a, b) => a - b);
    const pos = (sorted.length - 1) * q;  // Position in sorted array
    const base = Math.floor(pos);          // Lower index
    const rest = pos - base;               // Fractional part for interpolation
    return sorted[base + 1] !== undefined 
      ? sorted[base] + rest * (sorted[base + 1] - sorted[base])  // Interpolate
      : sorted[base];  // Edge case: q=1.0
  };
  
  // Return tercile cutoffs for each indicator
  // p33 = 33rd percentile (Weaker/Moderate boundary)
  // p66 = 66th percentile (Moderate/Stronger boundary)
  return {
    weatherStation: {
      p33: quantile(weatherStations, 0.33),
      p66: quantile(weatherStations, 0.66)
    },
    cloudCover: {
      p33: quantile(cloudCover, 0.33),
      p66: quantile(cloudCover, 0.66)
    },
    precipAgreement: {
      p33: quantile(precipAgreement, 0.33),
      p66: quantile(precipAgreement, 0.66)
    },
    shortTermSkill: {
      p33: quantile(shortTermSkill, 0.33),
      p66: quantile(shortTermSkill, 0.66)
    },
    seasonalSkill: {
      p33: quantile(seasonalSkill, 0.33),
      p66: quantile(seasonalSkill, 0.66)
    },
    cisReadiness: {
      p33: quantile(cisReadiness, 0.33),
      p66: quantile(cisReadiness, 0.66)
    }
  };
}
```

```{ojs}
// ============================================================================
// CLASSIFICATION FUNCTIONS: Transform Raw Values to Interpretable Categories
// ============================================================================
// These functions convert numeric indicator values into human-readable
// classification labels for visualization and insight generation.
// ============================================================================

/**
 * Classify a value into tercile categories (Weaker/Moderate/Stronger)
 * @param {number} value - The indicator value to classify
 * @param {object} terciles - Object with p33 and p66 cutoff values
 * @returns {string} Classification label
 */
classifyTercile = (value, terciles) => {
  if (value == null || isNaN(value)) return "No data";
  if (value <= terciles.p33) return "Weaker";
  if (value <= terciles.p66) return "Moderate";
  return "Stronger";
}

/**
 * Classify precipitation satellite agreement (CV - Coefficient of Variation)
 * Unlike terciles, this uses absolute thresholds based on the number
 * of satellite products that agree on precipitation patterns:
 *   0 = No products agree (Very Low confidence)
 *   1-2 = Partial agreement (Moderate confidence)
 *   3 = Most products agree (High confidence) 
 *   4 = All products agree (Very High confidence)
 * @param {number|string} value - Agreement count (0-4)
 * @returns {string} Classification label with confidence level
 */
classifyPrecipAgreement = (value) => {
  if (value == null || isNaN(value)) return "No data";
  const numVal = parseFloat(value);
  if (numVal === 0) return "No agreement (Very Low)";
  if (numVal <= 2) return "Partial agreement (Moderate)";
  if (numVal === 3) return "High agreement (High)";
  return "Full agreement (Very High)";
}

/**
 * Interpret forecast skill based on both short-term and long-term RPSS scores
 * RPSS (Ranked Probability Skill Score) measures forecast quality:
 *   > 0.6 = Good/reliable forecasts
 *   < 0.4 = Poor/unreliable forecasts
 * 
 * The delta (difference) between short and long term indicates skill decay:
 *   Large positive delta = Rapid skill loss at longer lead times
 * 
 * @param {number} shortTerm - Short-term (1-2 month) forecast RPSS
 * @param {number} longTerm - Long-term (11-12 month) forecast RPSS
 * @returns {object} Interpretation text and CIS implication
 */
classifyForecastSkill = (shortTerm, longTerm) => {
  if (shortTerm == null || longTerm == null) return { interpretation: "No data", implication: "Insufficient data" };
  
  const delta = shortTerm - longTerm;
  
  // Case 1: Both horizons perform well - ideal for CIS deployment
  if (shortTerm > 0.6 && longTerm > 0.6) {
    return {
      interpretation: "Reliable forecasts at both horizons",
      implication: "Scale CIS for advisories + finance"
    };
  } 
  // Case 2: Good short-term but poor long-term - limit to operational use
  else if (shortTerm > 0.6 && longTerm < 0.4 && delta > 0.2) {
    return {
      interpretation: "Rapid loss of skill",
      implication: "Limit use to short-term planning"
    };
  } 
  // Case 3: Both horizons perform poorly - use historical averages instead
  else if (shortTerm < 0.4 && longTerm < 0.4) {
    return {
      interpretation: "Weak predictability",
      implication: "Use climatology / caution"
    };
  } 
  // Case 4: Mixed results - blend forecasts with historical data
  else {
    return {
      interpretation: "Uncertain but usable",
      implication: "Blend with historical averages"
    };
  }
}
```

```{ojs}
// ============================================================================
// ADMIN HIERARCHY: Dynamic Options Based on User Selection
// ============================================================================
// These functions provide cascading options for admin selectors:
// - Admin0 (Country): All unique countries in the dataset
// - Admin1 (Region): Only regions within selected countries
// - Admin2 (District): Only districts within selected regions
//
// This hierarchy enables progressive drill-down through the data
// while keeping each selector's options relevant to prior selections.
// ============================================================================

// All unique Admin0 (country) names, sorted alphabetically
uniqueAdmin0 = Array.from(new Set(cisData.map(d => d.admin0_name))).sort()

/**
 * Get Admin1 options filtered by selected Admin0
 * @param {string[]} admin0Selection - Selected country names
 * @returns {string[]} Available Admin1 names within those countries
 */
uniqueAdmin1 = (admin0Selection) => {
  if (!admin0Selection || admin0Selection.length === 0) return [];
  return Array.from(new Set(
    cisData
      .filter(d => admin0Selection.includes(d.admin0_name) && d.admin1_name != null)
      .map(d => d.admin1_name)
  )).sort();
}

/**
 * Get Admin2 options filtered by selected Admin0 AND Admin1
 * @param {string[]} admin0Selection - Selected country names
 * @param {string[]} admin1Selection - Selected region names
 * @returns {string[]} Available Admin2 names within those regions
 */
uniqueAdmin2 = (admin0Selection, admin1Selection) => {
  if (!admin1Selection || admin1Selection.length === 0) return [];
  return Array.from(new Set(
    cisData
      .filter(d => 
        admin0Selection.includes(d.admin0_name) && 
        admin1Selection.includes(d.admin1_name) &&
        d.admin2_name != null
      )
      .map(d => d.admin2_name)
  )).sort();
}
```

```{ojs}
// Display dropdown CSS (imports are in parent file to avoid duplication)
dropdownCSS
```

```{ojs}
// ============================================================================
// MASTER ADMIN SELECTORS: Source of Truth for Admin Selections
// ============================================================================
// These are the PRIMARY selectors that all other section selectors sync to.
// Using Observable's Inputs.bind() pattern (defined in cis_readiness.qmd),
// changes here automatically propagate to section-specific selectors.
//
// Note: createSyncedAdminSelector() is defined in the parent file and uses
// Inputs.bind() to create two-way binding between master and section selectors.
// ============================================================================

viewof selectedAdmin0 = multiSelect({
  inputLabel: _lang(cis.admin0Label),
  inputId: "admin0Select",
  placeholderText: _lang(cis.admin0Placeholder),
  options: uniqueAdmin0.map(d => ({ value: d, label: d })),
  selected: [],
  maxSelections: 10
})

// Expose the reactive value for other cells to depend on
selectedAdmin0Value = selectedAdmin0
```

```{ojs}
// Admin1 selector - options depend on Admin0 selection
admin1Options = uniqueAdmin1(selectedAdmin0)

viewof selectedAdmin1 = multiSelect({
  inputLabel: _lang(cis.admin1Label),
  inputId: "admin1Select",
  placeholderText: _lang(cis.admin1Placeholder),
  options: admin1Options.map(d => ({ value: d, label: d })),
  selected: [],
  maxSelections: 10
})

selectedAdmin1Value = selectedAdmin1
```

```{ojs}
// Admin2 selector - options depend on both Admin0 AND Admin1 selections
admin2Options = uniqueAdmin2(selectedAdmin0, selectedAdmin1)

viewof selectedAdmin2 = multiSelect({
  inputLabel: _lang(cis.admin2Label),
  inputId: "admin2Select",
  placeholderText: _lang(cis.admin2Placeholder),
  options: admin2Options.map(d => ({ value: d, label: d })),
  selected: [],
  maxSelections: 10
})

selectedAdmin2Value = selectedAdmin2
```

```{ojs}
// ============================================================================
// ADMIN LEVEL DETECTION: Determine Display Level Based on Selections
// ============================================================================
// The currentAdminLevel drives which geographic boundaries to display:
//   Level 0: No selections → Show all countries (Admin0)
//   Level 1: Country selected → Show regions within that country (Admin1)
//   Level 2: Region selected → Show districts within that region (Admin2)
//
// Note: When Admin2 items are selected, we stay at Level 2 but highlight
// those specific districts rather than drilling down further.
// ============================================================================

currentAdminLevel = {
  if (selectedAdmin0.length === 0) return 0;  // No country selected → show all
  if (selectedAdmin1.length === 0) return 1;  // Country selected, no region → admin1
  if (selectedAdmin2.length === 0) return 2;  // Region selected, no district → admin2
  return 2; // Districts selected → still admin2, but with highlighting
}

// ============================================================================
// DATA FILTERING: Filter CIS Data Based on Admin Level
// ============================================================================
// The data structure uses NULL values to indicate admin level:
// - Admin0 row: admin1_name IS NULL, admin2_name IS NULL
// - Admin1 row: admin1_name IS NOT NULL, admin2_name IS NULL  
// - Admin2 row: admin1_name IS NOT NULL, admin2_name IS NOT NULL
//
// This allows storing all admin levels in a single flat table.
// ============================================================================

filteredData = {
  // Default: No admin0 selected - show country-level data (admin1_name is null)
  if (selectedAdmin0.length === 0) {
    return cisData.filter(d => d.admin1_name == null);
  }
  
  // Admin0 selected, no admin1 - show region-level data for selected countries
  if (selectedAdmin1.length === 0) {
    return cisData.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
      d.admin1_name != null && 
      d.admin2_name == null
    );
  }
  
  // Admin1 selected - show district-level data for selected regions
  return cisData.filter(d => 
    selectedAdmin0.includes(d.admin0_name) &&
    selectedAdmin1.includes(d.admin1_name) &&
    d.admin2_name != null
  );
}

// Track which Admin2 regions are selected for highlighting on maps
// When empty, all admin2 regions in the view are shown equally
// When populated, only these districts get visual emphasis
highlightedAdmin2 = selectedAdmin2.length > 0 ? selectedAdmin2 : []
```

```{ojs}
// Breadcrumb navigation
breadcrumb = {
  const parts = [];
  
  // Show SSA if no admin0 selected
  if (selectedAdmin0.length === 0) {
    parts.push('Sub-Saharan Africa');
  } else {
  if (selectedAdmin0.length === 1) parts.push(selectedAdmin0[0]);
    else parts.push(`${selectedAdmin0.length} countries`);
  }
  
  if (selectedAdmin1.length === 1) parts.push(selectedAdmin1[0]);
  else if (selectedAdmin1.length > 1) parts.push(`${selectedAdmin1.length} admin1 regions`);
  
  if (selectedAdmin2.length === 1) parts.push(selectedAdmin2[0]);
  else if (selectedAdmin2.length > 1) parts.push(`${selectedAdmin2.length} admin2 regions (highlighted)`);
  
  return parts.join(' → ');
}
```

---

```{ojs}
section11Title = _lang(cis.section11Title)
```

## `{ojs} section11Title` {#section1-1}

```{ojs}
section11Content = _lang(cis.section11Content)
```

`{ojs} section11Content`

```{ojs}
//| echo: false

// Inline admin level selectors for this section - Region Selection
htl.html`
<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
  <div style="flex: 1; min-width: 200px;">
    ${viewof selectedAdmin0}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof selectedAdmin1}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof selectedAdmin2}
  </div>
</div>
`
```

```{ojs}
// Section 1.1 Controls
viewof s11ViewType = Inputs.radio(["Map", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s11MapMode = Inputs.radio(["Raw values", "Classified"], {
  label: _lang(cis.mapModeLabel),
  value: "Raw values"
})
```

```{ojs}
// Prepare data for Section 1.1 maps
s11MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  // Filter boundaries based on current selection
  // Instead of filtering by property names (which might not exist), filter by matching with filteredData
  let filteredBoundaries = boundaries;
  if (currentAdminLevel === 2) {
    // When showing admin2, only include boundaries that match our filtered data
    // This ensures we only show boundaries for selected admin1 regions
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        // Include if it matches filtered data OR if it's in the selected admin0/admin1
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesData || (matchesAdmin0 && matchesAdmin1);
      })
    };
  } else if (currentAdminLevel === 1) {
    // When showing admin1, filter by admin0 and match with filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesData || matchesAdmin0;
      })
    };
  }
  
  // Join data with boundaries
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    // Try to match by GAUL code first
    let dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: if GAUL code match fails, try matching by admin names
    if (!dataRow && currentAdminLevel === 2) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!dataRow && currentAdminLevel === 1) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    // Pre-compute region name for faster tooltip rendering
    const regionName = currentAdminLevel === 0 
      ? feature.properties.admin0_name 
      : currentAdminLevel === 1
      ? `${feature.properties.admin1_name}, ${feature.properties.admin0_name}`
      : `${feature.properties.admin2_name}, ${feature.properties.admin1_name}, ${feature.properties.admin0_name}`;
    
    // Check if this admin2 region is highlighted
    const isHighlighted = currentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        regionName: regionName,
        weatherStation: dataRow?.["weather-station_density"],
        cloudCover: dataRow?.["cloud-coverage_meanannual"],
        weatherStationClass: dataRow ? classifyTercile(dataRow["weather-station_density"], africaTerciles.weatherStation) : "No data",
        cloudCoverClass: dataRow ? classifyTercile(dataRow["cloud-coverage_meanannual"], africaTerciles.cloudCover) : "No data",
        isHighlighted: isHighlighted
      }
    };
  });
  
  // Only filter out features without data if we have some features with data
  // This prevents removing all features if matching fails
  const featuresWithData = features.filter(f => f.properties.weatherStation != null || f.properties.cloudCover != null);
  
  // If we have features with data, use those; otherwise, show all features (they'll show as "No data")
  return { type: "FeatureCollection", features: featuresWithData.length > 0 ? featuresWithData : features };
}
```

```{ojs}
// Section 1.1 Maps
{
  if (s11ViewType === "Map") {
    const width = 2000;
    const height = 1000;
    
    // Color scale for 0-1 values
    const colorScale = d3.scaleSequential(d3.interpolateYlGnBu).domain([0, 1]);
    
    // Classification color scale
    const classColorScale = (className) => {
      if (className === "Weaker") return "#fee5d9";
      if (className === "Moderate") return "#fcae91";
      if (className === "Stronger") return "#fb6a4a";
      return "#ddd";
    };
    
    const useRaw = s11MapMode === "Raw values";
    
    return htl.html`
    <div style="display: flex; gap: 20px;">
      <div style="flex: 1;">
        <h4>${_lang(cis.weatherStationLabel)}</h4>
        ${Plot.plot({
          width: width / 2,
          height: height,
          projection: {type: "mercator", domain: s11MapData},
          color: useRaw ? {
            type: "linear",
            domain: [0, 1],
            scheme: "YlGnBu",
            legend: true,
            label: "Density (0-1)"
          } : {
            type: "categorical",
            domain: ["Weaker", "Moderate", "Stronger"],
            range: ["#fee5d9", "#fcae91", "#fb6a4a"],
            legend: true,
            label: "Classification"
          },
          marks: [
            Plot.geo(s11MapData.features, {
              fill: useRaw ? d => d.properties.weatherStation : d => d.properties.weatherStationClass,
              stroke: d => d.properties.isHighlighted ? "#000" : "#333",
              strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
            }),
            Plot.tip(
              s11MapData.features,
              Plot.pointer(
                Plot.centroid({
                  fontSize: 14,
                  channels: {
                    region: {
                      label: "Region",
                      value: (d) => d.properties.regionName
                    },
                    weatherStation: {
                      label: "Weather Station",
                      value: (d) => d.properties.weatherStation
                    },
                    class: {
                      label: "Class",
                      value: (d) => d.properties.weatherStationClass
                    }
                  },
                  format: {
                    region: true,
                    weatherStation: (d) => d != null ? d.toFixed(3) : "N/A",
                    class: true
                  }
                })
              )
            )
          ]
        })}
      </div>
      <div style="flex: 1;">
        <h4>${_lang(cis.cloudCoverLabel)}</h4>
        ${Plot.plot({
          width: width / 2,
          height: height,
          projection: {type: "mercator", domain: s11MapData},
          color: useRaw ? {
            type: "linear",
            domain: [0, 1],
            scheme: "YlGnBu",
            legend: true,
            label: "Coverage (0-1)"
          } : {
            type: "categorical",
            domain: ["Weaker", "Moderate", "Stronger"],
            range: ["#fee5d9", "#fcae91", "#fb6a4a"],
            legend: true,
            label: "Classification"
          },
          marks: [
            Plot.geo(s11MapData.features, {
              fill: useRaw ? d => d.properties.cloudCover : d => d.properties.cloudCoverClass,
              stroke: d => d.properties.isHighlighted ? "#000" : "#333",
              strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
            }),
            Plot.tip(
              s11MapData.features,
              Plot.pointer(
                Plot.centroid({
                  fontSize: 14,
                  channels: {
                    region: {
                      label: "Region",
                      value: (d) => d.properties.regionName
                    },
                    cloudCover: {
                      label: "Cloud Cover",
                      value: (d) => d.properties.cloudCover
                    },
                    class: {
                      label: "Class",
                      value: (d) => d.properties.cloudCoverClass
                    }
                  },
                  format: {
                    region: true,
                    cloudCover: (d) => d != null ? d.toFixed(3) : "N/A",
                    class: true
                  }
                })
              )
            )
          ]
        })}
      </div>
    </div>`;
  } else {
    // Table view
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
      "Weather Station (Raw)": d["weather-station_density"]?.toFixed(3) || "N/A",
      "Weather Station (Class)": classifyTercile(d["weather-station_density"], africaTerciles.weatherStation),
      "Cloud Cover (Raw)": d["cloud-coverage_meanannual"]?.toFixed(3) || "N/A",
      "Cloud Cover (Class)": classifyTercile(d["cloud-coverage_meanannual"], africaTerciles.cloudCover)
      };
    });
    
    return Inputs.table(tableData, {
      sort: "Admin Name",
      rows: 20
    });
  }
}
```

```{ojs}
// Section 1.1 Dynamic Insight
s11Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgWeatherStation = d3.mean(insightData, d => d["weather-station_density"]);
  const avgCloudCover = d3.mean(insightData, d => d["cloud-coverage_meanannual"]);
  
  const wsClass = classifyTercile(avgWeatherStation, africaTerciles.weatherStation).toLowerCase();
  const ccClass = classifyTercile(avgCloudCover, africaTerciles.cloudCover).toLowerCase();
  
  const capacity = (wsClass === "stronger" && ccClass === "stronger") ? "high" :
                   (wsClass === "weaker" || ccClass === "weaker") ? "low" : "moderate";
  
  return _lang({
    en: `In ${breadcrumb}, ground-station density is ${avgWeatherStation?.toFixed(3)} and clear-sky fraction ${avgCloudCover?.toFixed(3)}, indicating ${capacity} capacity for both in-situ and optical observation. Classification is relative to Sub-Saharan Africa.`,
    fr: `Dans ${breadcrumb}, la densité des stations au sol est ${avgWeatherStation?.toFixed(3)} et la fraction de ciel clair ${avgCloudCover?.toFixed(3)}, indiquant une capacité ${capacity} pour l'observation in-situ et optique. La classification est relative à l'Afrique subsaharienne.`
  });
}
```

::: {.key-insights}
`{ojs} s11Insight`
:::

---

```{ojs}
section12Title = _lang(cis.section12Title)
```

## `{ojs} section12Title` {#section1-2}

```{ojs}
section12Content = _lang(cis.section12Content)
```

`{ojs} section12Content`

```{ojs}
//| echo: false

// Synchronized admin selectors for Section 1.2 - these sync with the master selectors
viewof s12Admin0 = createSyncedAdminSelector(0, viewof selectedAdmin0, uniqueAdmin0.map(d => ({ value: d, label: d })), "s12", cis?.admin0Label?.en || "Select Country (Fallback)", cis?.admin0Placeholder?.en || "Select countries...")

viewof s12Admin1 = createSyncedAdminSelector(1, viewof selectedAdmin1, admin1Options.map(d => ({ value: d, label: d })), "s12", _lang(cis.admin1Label), _lang(cis.admin1Placeholder))

viewof s12Admin2 = createSyncedAdminSelector(2, viewof selectedAdmin2, admin2Options.map(d => ({ value: d, label: d })), "s12", _lang(cis.admin2Label), _lang(cis.admin2Placeholder))
```

```{ojs}
//| echo: false

// Inline admin level selectors for this section - Region Selection
htl.html`
<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
  <div style="flex: 1; min-width: 200px;">
    ${viewof s12Admin0}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s12Admin1}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s12Admin2}
  </div>
</div>
`
```

```{ojs}
// Section 1.2 Controls
viewof s12ViewType = Inputs.radio(["Map", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s12MapMode = Inputs.radio(["Raw values", "Classified"], {
  label: _lang(cis.mapModeLabel),
  value: "Raw values"
})
```

```{ojs}
// Prepare data for Section 1.2 map
s12MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  // Filter boundaries based on current selection
  // Instead of filtering by property names, filter by matching with filteredData
  let filteredBoundaries = boundaries;
  if (currentAdminLevel === 2) {
    // When showing admin2, only include boundaries that match our filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesData || (matchesAdmin0 && matchesAdmin1);
      })
    };
  } else if (currentAdminLevel === 1) {
    // When showing admin1, filter by admin0 and match with filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesData || matchesAdmin0;
      })
    };
  }
  
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    let dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: try matching by admin names if GAUL code fails
    if (!dataRow && currentAdminLevel === 2) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!dataRow && currentAdminLevel === 1) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    const precipValue = dataRow ? parseFloat(dataRow["cv-precipitation_agreement"]) : null;
    
    // Check if this admin2 region is highlighted
    const isHighlighted = currentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        precipAgreement: precipValue,
        precipAgreementClass: classifyPrecipAgreement(precipValue),
        isHighlighted: isHighlighted
      }
    };
  }).filter(f => f.properties.precipAgreement != null);
  
  return { type: "FeatureCollection", features };
}
```

```{ojs}
// Section 1.2 Map/Table
{
  if (s12ViewType === "Map") {
    const useRaw = s12MapMode === "Raw values";
    
    return Plot.plot({
      width: 2000,
      height: 1000,
      projection: {type: "mercator", domain: s12MapData},
      color: useRaw ? {
        type: "linear",
        domain: [0, 4],
        scheme: "Viridis",
        legend: true,
        label: "Agreement (0-4)"
      } : {
        type: "categorical",
        domain: ["No agreement (Very Low)", "Partial agreement (Moderate)", "High agreement (High)", "Full agreement (Very High)"],
        range: ["#fee5d9", "#fcae91", "#fb6a4a", "#a50f15"],
        legend: true,
        label: "Classification"
      },
      marks: [
        Plot.geo(s12MapData.features, {
          fill: useRaw ? d => d.properties.precipAgreement : d => d.properties.precipAgreementClass,
          stroke: d => d.properties.isHighlighted ? "#000" : "#333",
          strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
        }),
        Plot.tip(
          s12MapData.features,
          Plot.pointer(
            Plot.centroid({
              fontSize: 14,
              channels: {
                region: {
                  label: "Region",
                  value: (d) => {
                    const regionName = d.properties.admin2_name || d.properties.admin1_name || d.properties.admin0_name;
                    const country = d.properties.admin0_name;
                    return regionName === country ? regionName : `${regionName}, ${country}`;
                  }
                },
                satelliteAgreement: {
                  label: "Satellite Agreement",
                  value: (d) => d.properties.precipAgreement
                },
                class: {
                  label: "Class",
                  value: (d) => d.properties.precipAgreementClass
                }
              },
              format: {
                region: true,
                satelliteAgreement: (d) => d != null ? d.toFixed(1) : "N/A",
                class: true
              }
            })
          )
        )
      ]
    });
  } else {
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
      "Satellite Agreement (Raw)": parseFloat(d["cv-precipitation_agreement"])?.toFixed(1) || "N/A",
      "Satellite Agreement (Class)": classifyPrecipAgreement(d["cv-precipitation_agreement"])
      };
    });
    
    return Inputs.table(tableData, {
      sort: "Admin Name",
      rows: 20
    });
  }
}
```

```{ojs}
// Download button for Section 1.2
downloadButton(
  filteredData.map(d => {
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    return {
      "Admin Name": adminName,
    "Satellite Agreement": parseFloat(d["cv-precipitation_agreement"]),
    "Classification": classifyPrecipAgreement(d["cv-precipitation_agreement"])
    };
  }),
  "cis_precipitation_agreement",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.2 Dynamic Insight
s12Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgAgreement = d3.mean(insightData, d => parseFloat(d["cv-precipitation_agreement"]));
  
  let agreementLevel = "no";
  if (avgAgreement >= 3) agreementLevel = "high";
  else if (avgAgreement >= 1) agreementLevel = "partial";
  
  return _lang({
    en: `In ${breadcrumb}, consistency across satellite data sources is ${avgAgreement?.toFixed(2)} indicating ${agreementLevel} agreement.`,
    fr: `Dans ${breadcrumb}, la cohérence entre les sources de données satellites est ${avgAgreement?.toFixed(2)} indiquant un accord ${agreementLevel}.`
  });
}
```

::: {.key-insights}
`{ojs} s12Insight`
:::

---

```{ojs}
section13Title = _lang(cis.section13Title)
```

## `{ojs} section13Title` {#section1-3}

```{ojs}
section13Content = _lang(cis.section13Content)
```

`{ojs} section13Content`

```{ojs}
//| echo: false

// Synchronized admin selectors for Section 1.3 - these sync with the master selectors
viewof s13Admin0 = createSyncedAdminSelector(0, viewof selectedAdmin0, uniqueAdmin0.map(d => ({ value: d, label: d })), "s13", _lang(cis.admin0Label), _lang(cis.admin0Placeholder))

viewof s13Admin1 = createSyncedAdminSelector(1, viewof selectedAdmin1, admin1Options.map(d => ({ value: d, label: d })), "s13", _lang(cis.admin1Label), _lang(cis.admin1Placeholder))

viewof s13Admin2 = createSyncedAdminSelector(2, viewof selectedAdmin2, admin2Options.map(d => ({ value: d, label: d })), "s13", _lang(cis.admin2Label), _lang(cis.admin2Placeholder))
```

```{ojs}
//| echo: false

// Inline admin level selectors for this section - Region Selection
htl.html`
<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
  <div style="flex: 1; min-width: 200px;">
    ${viewof s13Admin0}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s13Admin1}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s13Admin2}
  </div>
</div>
`
```

```{ojs}
// Section 1.3 Controls
viewof s13ViewType = Inputs.radio(["Chart", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Chart"
})

viewof s13SortBy = Inputs.radio(["Short-term skill", "Long-term skill", "Difference (Δ)"], {
  label: _lang(cis.sortByLabel),
  value: "Short-term skill"
})
```

```{ojs}
// Prepare data for Section 1.3
s13Data = {
  const data = filteredData.map(d => {
    const shortTerm = d["short-term_frcst_skill"];
    const longTerm = d["seasonal_frcst_skill"];
    const classification = classifyForecastSkill(shortTerm, longTerm);
    
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    
    return {
      admin: adminName,
      shortTerm: shortTerm,
      longTerm: longTerm,
      delta: shortTerm != null && longTerm != null ? longTerm - shortTerm : null,
      interpretation: classification.interpretation,
      implication: classification.implication
    };
  }).filter(d => d.shortTerm != null || d.longTerm != null);
  
  // Sort data
  if (s13SortBy === "Short-term skill") {
    data.sort((a, b) => (b.shortTerm || 0) - (a.shortTerm || 0));
  } else if (s13SortBy === "Long-term skill") {
    data.sort((a, b) => (b.longTerm || 0) - (a.longTerm || 0));
  } else {
    // Sort by delta - most positive to most negative
    data.sort((a, b) => (b.delta || 0) - (a.delta || 0));
  }
  
  return data;
}
```

```{ojs}
// Section 1.3 Chart/Table
{
  if (s13ViewType === "Chart") {
    // Prepare data in the format expected by the chart
    const data = s13Data.map(d => {
      const short = d.shortTerm != null ? parseFloat(d.shortTerm) : null;
      const long = d.longTerm != null ? parseFloat(d.longTerm) : null;
      const delta = short != null && long != null ? long - short : null;
      
      // Calculate sort value based on selected sort mode
      let sortValue = 0;
      if (s13SortBy === "Short-term skill") {
        sortValue = short || 0;
      } else if (s13SortBy === "Long-term skill") {
        sortValue = long || 0;
      } else {
        // Sort by delta (preserving sign)
        sortValue = delta || 0;
      }
      
      return {
        country: d.admin,
        short: short,
        long: long,
        delta: delta,
        sortValue: sortValue
      };
    }).filter(d => d.short != null || d.long != null);
    
    // Sort data based on selected mode
    const sorted = data.sort((a, b) => {
      if (s13SortBy === "Short-term skill") {
        return (b.short || 0) - (a.short || 0);
      } else if (s13SortBy === "Long-term skill") {
        return (b.long || 0) - (a.long || 0);
      } else {
        // Sort by delta - most positive to most negative
        return (b.delta || 0) - (a.delta || 0);
      }
    });
    
    // Flatten data: each geography gets 3 entries (Short-term, Long-term, Delta)
    const longData = sorted.flatMap((d) => [
      {
        country: d.country,
        metric: "Short-term RPSS (1–2 mo)",
        value: d.short
      },
      {
        country: d.country,
        metric: "Long-term RPSS (11–12 mo)",
        value: d.long
      },
      {
        country: d.country,
        metric: "Δ (Long − Short)",
        value: d.delta
      }
    ]).filter(d => d.value != null);
    
    // Calculate responsive height based on number of geographies
    const geographyCount = sorted.length;
    // Height is dynamic: 20px per region to prevent label overlap, min 400px
    const height = Math.max(400, geographyCount * 20);
    
    // Get the ordered list of countries from sorted data
    const countryOrder = sorted.map(d => d.country);
    
    // Calculate margin based on longest geography name
    const maxNameLength = Math.max(...countryOrder.map(name => name.length), 0);
    const marginLeft = Math.max(200, maxNameLength * 8); // At least 200px, or 8px per character
    
    // Wrap chart in scrollable container to handle many regions
    const chart = Plot.plot({
      marginLeft: marginLeft,
      marginTop: 40,
      marginBottom: 60,
      width: 900,
      height: height,
      y: { axis: null },
      x: { 
        grid: true,
        axis: "top",
        label: "RPSS (0-1) or Δ"
      },
      fy: { 
        padding: 0,  // Set padding to 0 to reduce spacing between bars
        label: null,
        domain: countryOrder // Use pre-sorted order to maintain sort
      },
      color: { 
        domain: [
          "Short-term RPSS (1–2 mo)",
          "Long-term RPSS (11–12 mo)",
          "Δ (Long − Short)"
        ],
        range: ["#4477AA", "#EE6677", "#228833"],
        legend: true
      },
      marks: [
        // X-axis at bottom
        Plot.axisX({ 
          anchor: "bottom", 
          label: "RPSS (0-1) or Δ"
        }),
        Plot.barX(longData, {
          x: "value",
          y: "metric",
          fill: "metric",
          fy: "country",
          sort: {
            y: null,
            color: null
          },
          tip: true
        }),
        Plot.ruleX([0], { stroke: "black" })
      ]
    });
    
    // Return chart in scrollable container with fixed max-height
    return htl.html`<div style="max-height: 600px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; padding: 10px;">
      ${chart}
    </div>`;
  } else {
    const tableData = s13Data.map(d => ({
      "Admin Name": d.admin,
      "Short-term": d.shortTerm?.toFixed(3) || "N/A",
      "Long-term": d.longTerm?.toFixed(3) || "N/A",
      "Δ": d.delta?.toFixed(3) || "N/A",
      "Interpretation": d.interpretation,
      "CIS Implication": d.implication
    }));
    
    return Inputs.table(tableData, {
      rows: 20
    });
  }
}
```

```{ojs}
// Download button for Section 1.3
downloadButton(
  s13Data.map(d => ({
    "Admin Name": d.admin,
    "Short-term Skill": d.shortTerm,
    "Long-term Skill": d.longTerm,
    "Delta": d.delta,
    "Interpretation": d.interpretation,
    "CIS Implication": d.implication
  })),
  "cis_forecast_skill",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.3 Dynamic Insight
s13Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgShortTerm = d3.mean(insightData, d => d["short-term_frcst_skill"]);
  const avgLongTerm = d3.mean(insightData, d => d["seasonal_frcst_skill"]);
  
  const classification = classifyForecastSkill(avgShortTerm, avgLongTerm);
  
  return _lang({
    en: `In ${breadcrumb}, short-term forecast skill averages ${avgShortTerm?.toFixed(3)} while long-term skill drops to ${avgLongTerm?.toFixed(3)}. Predictability is ${classification.interpretation.toLowerCase()}.`,
    fr: `Dans ${breadcrumb}, la compétence de prévision à court terme est en moyenne ${avgShortTerm?.toFixed(3)} tandis que la compétence à long terme chute à ${avgLongTerm?.toFixed(3)}. La prévisibilité est ${classification.interpretation.toLowerCase()}.`
  });
}
```

::: {.key-insights}
`{ojs} s13Insight`
:::

---

```{ojs}
section14Title = _lang(cis.section14Title)
```

## `{ojs} section14Title` {#section1-4}

```{ojs}
section14Content = _lang(cis.section14Content)
```

`{ojs} section14Content`

```{ojs}
//| echo: false

// Synchronized admin selectors for Section 1.4 - these sync with the master selectors
viewof s14Admin0 = createSyncedAdminSelector(0, viewof selectedAdmin0, uniqueAdmin0.map(d => ({ value: d, label: d })), "s14", _lang(cis.admin0Label), _lang(cis.admin0Placeholder))

viewof s14Admin1 = createSyncedAdminSelector(1, viewof selectedAdmin1, admin1Options.map(d => ({ value: d, label: d })), "s14", _lang(cis.admin1Label), _lang(cis.admin1Placeholder))

viewof s14Admin2 = createSyncedAdminSelector(2, viewof selectedAdmin2, admin2Options.map(d => ({ value: d, label: d })), "s14", _lang(cis.admin2Label), _lang(cis.admin2Placeholder))
```

```{ojs}
//| echo: false

// Inline admin level selectors for this section - Region Selection
htl.html`
<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
  <div style="flex: 1; min-width: 200px;">
    ${viewof s14Admin0}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s14Admin1}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s14Admin2}
  </div>
</div>
`
```

```{ojs}
// Section 1.4 Controls
viewof s14ViewType = Inputs.radio(["Map", "Table", "Heatmap"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s14Threshold = Inputs.range([0, 1], {
  label: _lang(cis.thresholdLabel),
  value: 0.5,
  step: 0.05
})
```

```{ojs}
// Prepare data for Section 1.4
s14MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  // Filter boundaries based on current selection
  // Instead of filtering by property names, filter by matching with filteredData
  let filteredBoundaries = boundaries;
  if (currentAdminLevel === 2) {
    // When showing admin2, only include boundaries that match our filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesData || (matchesAdmin0 && matchesAdmin1);
      })
    };
  } else if (currentAdminLevel === 1) {
    // When showing admin1, filter by admin0 and match with filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesData || matchesAdmin0;
      })
    };
  }
  
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    let dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: try matching by admin names if GAUL code fails
    if (!dataRow && currentAdminLevel === 2) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!dataRow && currentAdminLevel === 1) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    // Check if this admin2 region is highlighted
    const isHighlighted = currentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        cisReadiness: dataRow?.["cis_readiness_index"],
        cisReadinessClass: dataRow ? classifyTercile(dataRow["cis_readiness_index"], africaTerciles.cisReadiness) : "No data",
        weatherStation: dataRow?.["weather-station_density"],
        weatherStationClass: dataRow ? classifyTercile(dataRow["weather-station_density"], africaTerciles.weatherStation) : "No data",
        cloudCover: dataRow?.["cloud-coverage_meanannual"],
        cloudCoverClass: dataRow ? classifyTercile(dataRow["cloud-coverage_meanannual"], africaTerciles.cloudCover) : "No data",
        precipAgreement: dataRow ? parseFloat(dataRow["cv-precipitation_agreement"]) : null,
        precipAgreementClass: dataRow ? classifyPrecipAgreement(dataRow["cv-precipitation_agreement"]) : "No data",
        shortTerm: dataRow?.["short-term_frcst_skill"],
        longTerm: dataRow?.["seasonal_frcst_skill"],
        isHighlighted: isHighlighted
      }
    };
  }).filter(f => f.properties.cisReadiness != null);
  
  return { type: "FeatureCollection", features };
}
```

```{ojs}
// Section 1.4 Visualization
{
  if (s14ViewType === "Map") {
    // Apply threshold to highlight regions
    const aboveThreshold = s14MapData.features.filter(f => f.properties.cisReadiness >= s14Threshold);
    const belowThreshold = s14MapData.features.filter(f => f.properties.cisReadiness < s14Threshold);
    
    const allFeatures = [...belowThreshold, ...aboveThreshold];
    
    return Plot.plot({
      width: 2000,
      height: 1000,
      projection: {type: "mercator", domain: s14MapData},
      color: {
        type: "linear",
        domain: [0, 1],
        scheme: "RdYlGn",
        legend: true,
        label: "CIS Readiness Index (0-1)"
      },
      marks: [
        // Regions below threshold - slightly transparent
        Plot.geo(belowThreshold, {
          fill: d => d.properties.cisReadiness,
          fillOpacity: 0.5,
          stroke: d => d.properties.isHighlighted ? "#000" : "#999",
          strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
        }),
        // Regions above threshold - fully opaque with bold border
        Plot.geo(aboveThreshold, {
          fill: d => d.properties.cisReadiness,
          fillOpacity: 1,
          stroke: d => d.properties.isHighlighted ? "#000" : "#333",
          strokeWidth: d => d.properties.isHighlighted ? 2.5 : 1.5
        }),
        Plot.tip(
          allFeatures,
          Plot.pointer(
            Plot.centroid({
              fontSize: 14,
              channels: {
                region: {
                  label: "Region",
                  value: (d) => d.properties.admin0_name || d.properties.admin1_name || d.properties.admin2_name
                },
                cisReadiness: {
                  label: "CIS Readiness",
                  value: (d) => d.properties.cisReadiness
                },
                threshold: {
                  label: "Threshold Status",
                  value: (d) => d.properties.cisReadiness >= s14Threshold ? "Above threshold" : "Below threshold"
                },
                class: {
                  label: "Class",
                  value: (d) => d.properties.cisReadinessClass
                },
                weatherStation: {
                  label: "Weather Station",
                  value: (d) => d.properties.weatherStationClass
                },
                cloudCover: {
                  label: "Cloud Cover",
                  value: (d) => d.properties.cloudCoverClass
                },
                precipAgreement: {
                  label: "Precip Agreement",
                  value: (d) => d.properties.precipAgreementClass
                },
                shortTerm: {
                  label: "Short-term",
                  value: (d) => d.properties.shortTerm
                },
                longTerm: {
                  label: "Long-term",
                  value: (d) => d.properties.longTerm
                }
              },
              format: {
                region: true,
                cisReadiness: (d) => d != null ? d.toFixed(3) : "N/A",
                threshold: true,
                class: true,
                weatherStation: true,
                cloudCover: true,
                precipAgreement: true,
                shortTerm: (d) => d != null ? d.toFixed(3) : "N/A",
                longTerm: (d) => d != null ? d.toFixed(3) : "N/A"
              }
            })
          )
        )
      ]
    });
  } else if (s14ViewType === "Table") {
    // Apply threshold filter
    const thresholdFilteredData = filteredData.filter(d => 
      d["cis_readiness_index"] != null && d["cis_readiness_index"] >= s14Threshold
    );
    
    const tableData = thresholdFilteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
      "CIS Readiness (Raw)": d["cis_readiness_index"]?.toFixed(3) || "N/A",
      "CIS Readiness (Class)": classifyTercile(d["cis_readiness_index"], africaTerciles.cisReadiness),
      "Weather Station (Class)": classifyTercile(d["weather-station_density"], africaTerciles.weatherStation),
      "Cloud Cover (Class)": classifyTercile(d["cloud-coverage_meanannual"], africaTerciles.cloudCover),
      "Precip Agreement (Class)": classifyPrecipAgreement(d["cv-precipitation_agreement"]),
      "Short-term (Raw)": d["short-term_frcst_skill"]?.toFixed(3) || "N/A",
      "Long-term (Raw)": d["seasonal_frcst_skill"]?.toFixed(3) || "N/A"
      };
    });
    
    return Inputs.table(tableData, {
      sort: "CIS Readiness (Raw)",
      reverse: true,
      rows: 20
    });
  } else {
    // Heatmap using Observable Plot (cleaner, no overlap issues)
    // Apply threshold filter
    const thresholdFilteredData = filteredData.filter(d => 
      d["cis_readiness_index"] != null && d["cis_readiness_index"] >= s14Threshold
    );
    
    // Prepare data with admin names
    const heatmapData = thresholdFilteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      
      return {
        country: adminName,
        "Weather Stations": d["weather-station_density"],
        "Cloud Cover": d["cloud-coverage_meanannual"],
        "Precip Agreement": parseFloat(d["cv-precipitation_agreement"]) / 4, // Normalize to 0-1
        "Short-term Forecast": d["short-term_frcst_skill"],
        "Long-term Forecast": d["seasonal_frcst_skill"],
        "CIS Readiness": d["cis_readiness_index"]
      };
    }).filter(d => d["CIS Readiness"] != null);
    
    // Sort by CIS Readiness (descending)
    heatmapData.sort((a, b) => (b["CIS Readiness"] || 0) - (a["CIS Readiness"] || 0));
    
    const sortedCountries = heatmapData.map(d => d.country);
    const indicators = ["Weather Stations", "Cloud Cover", "Precip Agreement", "Short-term Forecast", "Long-term Forecast", "CIS Readiness"];
    
    // Calculate responsive dimensions
    const geographyCount = heatmapData.length;
    const cellHeight = 25;
    const height = Math.max(400, geographyCount * cellHeight + 120); // Extra space for legend at bottom
    const maxNameLength = Math.max(...sortedCountries.map(name => name.length), 0);
    const marginLeft = Math.max(180, maxNameLength * 7);
    
    // Flatten data for heatmap (long format)
    const longData = heatmapData.flatMap(row => 
      indicators.map(indicator => ({
        country: row.country,
        indicator: indicator,
        value: row[indicator]
      }))
    ).filter(d => d.value != null);
    
    // Use Observable Plot.cell for the heatmap
    return htl.html`<div style="max-height: 700px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; padding: 10px;">
      ${Plot.plot({
        width: 900,
        height: height,
        marginLeft: marginLeft,
        marginTop: 80,  // More space for rotated axis labels
        marginBottom: 50,
        marginRight: 20,
        x: {
          label: null,
          tickRotate: -45,
          domain: indicators
        },
        y: {
          label: null,
          domain: sortedCountries
        },
        color: {
          type: "linear",
          scheme: "RdYlBu",
          reverse: true,  // Red = high, Blue = low
          legend: true,
          label: "Value (0-1)"
        },
        marks: [
          Plot.cell(longData, {
            x: "indicator",
            y: "country",
            fill: "value",
            tip: {
              fontSize: 14,
              format: {
                fill: d => d != null ? d.toFixed(3) : "N/A"
              }
            }
          }),
          Plot.text(longData, {
            x: "indicator",
            y: "country",
            text: d => d.value != null ? d.value.toFixed(2) : "",
            fill: d => d.value > 0.5 ? "white" : "black",
            fontSize: 9
          })
        ]
      })}
    </div>`;
  }
}
```

```{ojs}
// Download button for Section 1.4
downloadButton(
  filteredData.map(d => {
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    return {
      "Admin Name": adminName,
    "CIS Readiness Index": d["cis_readiness_index"],
    "Weather Station Density": d["weather-station_density"],
    "Cloud Coverage": d["cloud-coverage_meanannual"],
    "Precipitation Agreement": parseFloat(d["cv-precipitation_agreement"]),
    "Short-term Forecast Skill": d["short-term_frcst_skill"],
    "Long-term Forecast Skill": d["seasonal_frcst_skill"]
    };
  }),
  "cis_readiness_index",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.4 Dynamic Insight
s14Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgReadiness = d3.mean(insightData, d => d["cis_readiness_index"]);
  const readinessClass = classifyTercile(avgReadiness, africaTerciles.cisReadiness).toLowerCase();
  
  const aboveThreshold = insightData.filter(d => d["cis_readiness_index"] >= s14Threshold).length;
  const total = insightData.length;
  const pct = ((aboveThreshold / total) * 100).toFixed(1);
  
  return _lang({
    en: `In ${breadcrumb}, the overall CIS Readiness Index averages ${avgReadiness?.toFixed(3)}, classified as ${readinessClass} relative to Sub-Saharan Africa. ${pct}% of regions exceed the ${s14Threshold} readiness threshold.`,
    fr: `Dans ${breadcrumb}, l'indice global de préparation CIS est en moyenne ${avgReadiness?.toFixed(3)}, classé comme ${readinessClass} par rapport à l'Afrique subsaharienne. ${pct}% des régions dépassent le seuil de préparation ${s14Threshold}.`
  });
}
```

::: {.key-insights}
`{ojs} s14Insight`
:::
