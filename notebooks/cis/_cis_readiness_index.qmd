```{ojs}
section1Title = _lang(cis.section1Title)
```

# `{ojs} section1Title` {#section1}

```{ojs}
// Load CIS data using DuckDB with Parquet for better performance
cisDB = await DuckDBClient.of({
  cis_data: FileAttachment("/data/cis/CIS_nb_data.parquet")
});

// Load all data and process in JavaScript for type safety
cisDataRaw = await cisDB.query(`SELECT * FROM cis_data`);

cisData = cisDataRaw.map(row => ({
    ...row,
    // Clean null values represented as \N
    admin1_name: row.admin1_name === "\\N" || row.admin1_name === "" ? null : row.admin1_name,
    admin2_name: row.admin2_name === "\\N" || row.admin2_name === "" ? null : row.admin2_name,
    // Parse numeric fields
    "weather-station_density": parseFloat(row["weather-station_density"]),
    "cloud-coverage_meanannual": parseFloat(row["cloud-coverage_meanannual"]),
    "cv-precipitation_agreement": parseFloat(row["cv-precipitation_agreement"]),
    "short-term_frcst_skill": parseFloat(row["short-term_frcst_skill"]),
    "seasonal_frcst_skill": parseFloat(row["seasonal_frcst_skill"]),
    "cis_readiness_index": parseFloat(row["cis_readiness_index"]),
    gaul0_code: parseInt(row.gaul0_code),
    gaul1_code: parseInt(row.gaul1_code),
    gaul2_code: parseInt(row.gaul2_code)
}));
```

```{ojs}
// Import boundary helper functions
import { geojsonFromWKB_wk, read_topojson } from "/helpers/boundaries.js"
import { boundary_paths } from "/helpers/data.js"
```

```{ojs}
// Load boundary data
admin0Boundaries = await read_topojson(boundary_paths.admin0_path, "atlas_gaul24_a0_africa")
admin1Boundaries = await read_topojson(boundary_paths.admin1_path, "atlas_gaul24_a1_africa")
admin2Boundaries = await read_topojson(boundary_paths.admin2_path, "atlas_gaul_a2_africa_simple-lowres")
```

```{ojs}
// Calculate Africa-wide tercile cutoffs for classification
africaTerciles = {
  const weatherStations = cisData.map(d => d["weather-station_density"]).filter(d => d != null);
  const cloudCover = cisData.map(d => d["cloud-coverage_meanannual"]).filter(d => d != null);
  const precipAgreement = cisData.map(d => parseFloat(d["cv-precipitation_agreement"])).filter(d => !isNaN(d));
  const shortTermSkill = cisData.map(d => d["short-term_frcst_skill"]).filter(d => d != null);
  const seasonalSkill = cisData.map(d => d["seasonal_frcst_skill"]).filter(d => d != null);
  const cisReadiness = cisData.map(d => d["cis_readiness_index"]).filter(d => d != null);
  
  const quantile = (arr, q) => {
    const sorted = arr.slice().sort((a, b) => a - b);
    const pos = (sorted.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    return sorted[base + 1] !== undefined 
      ? sorted[base] + rest * (sorted[base + 1] - sorted[base])
      : sorted[base];
  };
  
  return {
    weatherStation: {
      p33: quantile(weatherStations, 0.33),
      p66: quantile(weatherStations, 0.66)
    },
    cloudCover: {
      p33: quantile(cloudCover, 0.33),
      p66: quantile(cloudCover, 0.66)
    },
    precipAgreement: {
      p33: quantile(precipAgreement, 0.33),
      p66: quantile(precipAgreement, 0.66)
    },
    shortTermSkill: {
      p33: quantile(shortTermSkill, 0.33),
      p66: quantile(shortTermSkill, 0.66)
    },
    seasonalSkill: {
      p33: quantile(seasonalSkill, 0.33),
      p66: quantile(seasonalSkill, 0.66)
    },
    cisReadiness: {
      p33: quantile(cisReadiness, 0.33),
      p66: quantile(cisReadiness, 0.66)
    }
  };
}
```

```{ojs}
// Classification functions
classifyTercile = (value, terciles) => {
  if (value == null || isNaN(value)) return "No data";
  if (value <= terciles.p33) return "Weaker";
  if (value <= terciles.p66) return "Moderate";
  return "Stronger";
}

classifyPrecipAgreement = (value) => {
  if (value == null || isNaN(value)) return "No data";
  const numVal = parseFloat(value);
  if (numVal === 0) return "No agreement (Very Low)";
  if (numVal <= 2) return "Partial agreement (Moderate)";
  if (numVal === 3) return "High agreement (High)";
  return "Full agreement (Very High)";
}

classifyForecastSkill = (shortTerm, longTerm) => {
  if (shortTerm == null || longTerm == null) return { interpretation: "No data", implication: "Insufficient data" };
  
  const delta = shortTerm - longTerm;
  
  if (shortTerm > 0.6 && longTerm > 0.6) {
    return {
      interpretation: "Reliable forecasts at both horizons",
      implication: "Scale CIS for advisories + finance"
    };
  } else if (shortTerm > 0.6 && longTerm < 0.4 && delta > 0.2) {
    return {
      interpretation: "Rapid loss of skill",
      implication: "Limit use to short-term planning"
    };
  } else if (shortTerm < 0.4 && longTerm < 0.4) {
    return {
      interpretation: "Weak predictability",
      implication: "Use climatology / caution"
    };
  } else {
    return {
      interpretation: "Uncertain but usable",
      implication: "Blend with historical averages"
    };
  }
}
```

```{ojs}
// Get unique admin values for selectors
uniqueAdmin0 = Array.from(new Set(cisData.map(d => d.admin0_name))).sort()
uniqueAdmin1 = (admin0Selection) => {
  if (!admin0Selection || admin0Selection.length === 0) return [];
  return Array.from(new Set(
    cisData
      .filter(d => admin0Selection.includes(d.admin0_name) && d.admin1_name != null)
      .map(d => d.admin1_name)
  )).sort();
}
uniqueAdmin2 = (admin0Selection, admin1Selection) => {
  if (!admin1Selection || admin1Selection.length === 0) return [];
  return Array.from(new Set(
    cisData
      .filter(d => 
        admin0Selection.includes(d.admin0_name) && 
        admin1Selection.includes(d.admin1_name) &&
        d.admin2_name != null
      )
      .map(d => d.admin2_name)
  )).sort();
}
```

```{ojs}
// Display dropdown CSS (imports are in parent file to avoid duplication)
dropdownCSS
```

```{ojs}
// Admin level selectors
viewof selectedAdmin0 = multiSelect({
  inputLabel: _lang(cis.admin0Label),
  inputId: "admin0Select",
  placeholderText: _lang(cis.admin0Placeholder),
  options: uniqueAdmin0.map(d => ({ value: d, label: d })),
  selected: [],
  maxSelections: 5
})
```

```{ojs}
admin1Options = uniqueAdmin1(selectedAdmin0)

viewof selectedAdmin1 = multiSelect({
  inputLabel: _lang(cis.admin1Label),
  inputId: "admin1Select",
  placeholderText: _lang(cis.admin1Placeholder),
  options: admin1Options.map(d => ({ value: d, label: d })),
  selected: [],
  maxSelections: 5
})
```

```{ojs}
admin2Options = uniqueAdmin2(selectedAdmin0, selectedAdmin1)

viewof selectedAdmin2 = multiSelect({
  inputLabel: _lang(cis.admin2Label),
  inputId: "admin2Select",
  placeholderText: _lang(cis.admin2Placeholder),
  options: admin2Options.map(d => ({ value: d, label: d })),
  selected: [],
  maxSelections: 5
})
```

```{ojs}
// Determine current admin level based on selections
// Level 0: No admin0 selected OR "SSA" selected
// Level 1: Admin0 selected but no admin1 selected
// Level 2: Admin1 selected but no admin2 selected
// Level 2 with highlight: Admin2 selected
currentAdminLevel = {
  if (selectedAdmin0.length === 0) return 0;
  if (selectedAdmin1.length === 0) return 1;
  if (selectedAdmin2.length === 0) return 2;
  return 2; // Admin2 selected - still show admin2 level but with highlighting
}

// Filter data based on admin level
filteredData = {
  // Default: No admin0 selected - show all admin0 level data (where admin1_name is null)
  if (selectedAdmin0.length === 0) {
    return cisData.filter(d => d.admin1_name == null);
  }
  
  // Admin0 selected, no admin1 - show all admin1 data for selected countries
  if (selectedAdmin1.length === 0) {
    return cisData.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
      d.admin1_name != null && 
      d.admin2_name == null
    );
  }
  
  // Admin1 selected - show all admin2 data for selected admin1 regions
    return cisData.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
    selectedAdmin1.includes(d.admin1_name) &&
    d.admin2_name != null
    );
  }

// For admin2 highlighting: track which admin2 regions are selected
highlightedAdmin2 = selectedAdmin2.length > 0 ? selectedAdmin2 : []
```

```{ojs}
// Breadcrumb navigation
breadcrumb = {
  const parts = [];
  
  // Show SSA if no admin0 selected
  if (selectedAdmin0.length === 0) {
    parts.push('Sub-Saharan Africa');
  } else {
  if (selectedAdmin0.length === 1) parts.push(selectedAdmin0[0]);
    else parts.push(`${selectedAdmin0.length} countries`);
  }
  
  if (selectedAdmin1.length === 1) parts.push(selectedAdmin1[0]);
  else if (selectedAdmin1.length > 1) parts.push(`${selectedAdmin1.length} admin1 regions`);
  
  if (selectedAdmin2.length === 1) parts.push(selectedAdmin2[0]);
  else if (selectedAdmin2.length > 1) parts.push(`${selectedAdmin2.length} admin2 regions (highlighted)`);
  
  return parts.join(' → ');
}
```

---

```{ojs}
section11Title = _lang(cis.section11Title)
```

## `{ojs} section11Title` {#section1-1}

```{ojs}
section11Content = _lang(cis.section11Content)
```

`{ojs} section11Content`

```{ojs}
// Section 1.1 Controls
viewof s11ViewType = Inputs.radio(["Map", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s11MapMode = Inputs.radio(["Raw values", "Classified"], {
  label: _lang(cis.mapModeLabel),
  value: "Raw values"
})
```

```{ojs}
// Prepare data for Section 1.1 maps
s11MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  // Filter boundaries based on current selection
  // Instead of filtering by property names (which might not exist), filter by matching with filteredData
  let filteredBoundaries = boundaries;
  if (currentAdminLevel === 2) {
    // When showing admin2, only include boundaries that match our filtered data
    // This ensures we only show boundaries for selected admin1 regions
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        // Include if it matches filtered data OR if it's in the selected admin0/admin1
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesData || (matchesAdmin0 && matchesAdmin1);
      })
    };
  } else if (currentAdminLevel === 1) {
    // When showing admin1, filter by admin0 and match with filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesData || matchesAdmin0;
      })
    };
  }
  
  // Join data with boundaries
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    // Try to match by GAUL code first
    let dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: if GAUL code match fails, try matching by admin names
    if (!dataRow && currentAdminLevel === 2) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!dataRow && currentAdminLevel === 1) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    // Pre-compute region name for faster tooltip rendering
    const regionName = currentAdminLevel === 0 
      ? feature.properties.admin0_name 
      : currentAdminLevel === 1
      ? `${feature.properties.admin1_name}, ${feature.properties.admin0_name}`
      : `${feature.properties.admin2_name}, ${feature.properties.admin1_name}, ${feature.properties.admin0_name}`;
    
    // Check if this admin2 region is highlighted
    const isHighlighted = currentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        regionName: regionName,
        weatherStation: dataRow?.["weather-station_density"],
        cloudCover: dataRow?.["cloud-coverage_meanannual"],
        weatherStationClass: dataRow ? classifyTercile(dataRow["weather-station_density"], africaTerciles.weatherStation) : "No data",
        cloudCoverClass: dataRow ? classifyTercile(dataRow["cloud-coverage_meanannual"], africaTerciles.cloudCover) : "No data",
        isHighlighted: isHighlighted
      }
    };
  });
  
  // Only filter out features without data if we have some features with data
  // This prevents removing all features if matching fails
  const featuresWithData = features.filter(f => f.properties.weatherStation != null || f.properties.cloudCover != null);
  
  // If we have features with data, use those; otherwise, show all features (they'll show as "No data")
  return { type: "FeatureCollection", features: featuresWithData.length > 0 ? featuresWithData : features };
}
```

```{ojs}
// Section 1.1 Maps
{
  if (s11ViewType === "Map") {
    const width = 2000;
    const height = 1000;
    
    // Color scale for 0-1 values
    const colorScale = d3.scaleSequential(d3.interpolateYlGnBu).domain([0, 1]);
    
    // Classification color scale
    const classColorScale = (className) => {
      if (className === "Weaker") return "#fee5d9";
      if (className === "Moderate") return "#fcae91";
      if (className === "Stronger") return "#fb6a4a";
      return "#ddd";
    };
    
    const useRaw = s11MapMode === "Raw values";
    
    return htl.html`<style>
      /* Tooltip styling with much larger font sizes */
      .plot-tip,
      [class*="plot-tip"],
      .observablehq .plot-tip,
      .observablehq [class*="plot-tip"],
      div[class*="plot-tip"],
      body .plot-tip,
      body [class*="plot-tip"] {
        font-size: 28px !important;
        padding: 30px 35px !important;
        line-height: 2 !important;
        min-width: 400px !important;
        max-width: 600px !important;
        box-sizing: border-box !important;
        background: white !important;
        border: 3px solid #333 !important;
        border-radius: 8px !important;
        box-shadow: 0 6px 16px rgba(0,0,0,0.4) !important;
      }
      .plot-tip table,
      [class*="plot-tip"] table,
      .observablehq .plot-tip table,
      .observablehq [class*="plot-tip"] table,
      div[class*="plot-tip"] table,
      body .plot-tip table,
      body [class*="plot-tip"] table {
        font-size: 28px !important;
        width: 100% !important;
      }
      .plot-tip th,
      .plot-tip td,
      [class*="plot-tip"] th,
      [class*="plot-tip"] td,
      .observablehq .plot-tip th,
      .observablehq .plot-tip td,
      .observablehq [class*="plot-tip"] th,
      .observablehq [class*="plot-tip"] td,
      div[class*="plot-tip"] th,
      div[class*="plot-tip"] td,
      body .plot-tip th,
      body .plot-tip td,
      body [class*="plot-tip"] th,
      body [class*="plot-tip"] td {
        padding: 15px 18px !important;
        font-size: 28px !important;
        line-height: 1.8 !important;
      }
      .plot-tip th,
      [class*="plot-tip"] th,
      .observablehq .plot-tip th,
      .observablehq [class*="plot-tip"] th,
      div[class*="plot-tip"] th,
      body .plot-tip th,
      body [class*="plot-tip"] th {
        font-weight: 700 !important;
        font-size: 28px !important;
        text-align: left !important;
      }
      .plot-tip *,
      [class*="plot-tip"] *,
      .observablehq .plot-tip *,
      .observablehq [class*="plot-tip"] *,
      div[class*="plot-tip"] *,
      body .plot-tip *,
      body [class*="plot-tip"] * {
        font-size: 28px !important;
      }
    </style>
    <div style="display: flex; gap: 20px;">
      <div style="flex: 1;">
        <h4>${_lang(cis.weatherStationLabel)}</h4>
        ${Plot.plot({
          width: width / 2,
          height: height,
          projection: {type: "mercator", domain: s11MapData},
          color: useRaw ? {
            type: "linear",
            domain: [0, 1],
            scheme: "YlGnBu",
            legend: true,
            label: "Density (0-1)"
          } : {
            type: "categorical",
            domain: ["Weaker", "Moderate", "Stronger"],
            range: ["#fee5d9", "#fcae91", "#fb6a4a"],
            legend: true,
            label: "Classification"
          },
          marks: [
            Plot.geo(s11MapData.features, {
              fill: useRaw ? d => d.properties.weatherStation : d => d.properties.weatherStationClass,
              stroke: d => d.properties.isHighlighted ? "#000" : "#333",
              strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
            }),
            Plot.tip(
              s11MapData.features,
              Plot.pointer(
                Plot.centroid({
                  channels: {
                    region: {
                      label: "Region",
                      value: (d) => d.properties.regionName
                    },
                    weatherStation: {
                      label: "Weather Station",
                      value: (d) => d.properties.weatherStation
                    },
                    class: {
                      label: "Class",
                      value: (d) => d.properties.weatherStationClass
                    }
                  },
                  format: {
                    region: true,
                    weatherStation: (d) => d != null ? d.toFixed(3) : "N/A",
                    class: true
                  }
                })
              )
            )
          ]
        })}
      </div>
      <div style="flex: 1;">
        <h4>${_lang(cis.cloudCoverLabel)}</h4>
        ${Plot.plot({
          width: width / 2,
          height: height,
          projection: {type: "mercator", domain: s11MapData},
          color: useRaw ? {
            type: "linear",
            domain: [0, 1],
            scheme: "YlGnBu",
            legend: true,
            label: "Coverage (0-1)"
          } : {
            type: "categorical",
            domain: ["Weaker", "Moderate", "Stronger"],
            range: ["#fee5d9", "#fcae91", "#fb6a4a"],
            legend: true,
            label: "Classification"
          },
          marks: [
            Plot.geo(s11MapData.features, {
              fill: useRaw ? d => d.properties.cloudCover : d => d.properties.cloudCoverClass,
              stroke: d => d.properties.isHighlighted ? "#000" : "#333",
              strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
            }),
            Plot.tip(
              s11MapData.features,
              Plot.pointer(
                Plot.centroid({
                  channels: {
                    region: {
                      label: "Region",
                      value: (d) => d.properties.regionName
                    },
                    cloudCover: {
                      label: "Cloud Cover",
                      value: (d) => d.properties.cloudCover
                    },
                    class: {
                      label: "Class",
                      value: (d) => d.properties.cloudCoverClass
                    }
                  },
                  format: {
                    region: true,
                    cloudCover: (d) => d != null ? d.toFixed(3) : "N/A",
                    class: true
                  }
                })
              )
            )
          ]
        })}
      </div>
    </div>`;
  } else {
    // Table view
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
      "Weather Station (Raw)": d["weather-station_density"]?.toFixed(3) || "N/A",
      "Weather Station (Class)": classifyTercile(d["weather-station_density"], africaTerciles.weatherStation),
      "Cloud Cover (Raw)": d["cloud-coverage_meanannual"]?.toFixed(3) || "N/A",
      "Cloud Cover (Class)": classifyTercile(d["cloud-coverage_meanannual"], africaTerciles.cloudCover)
      };
    });
    
    return Inputs.table(tableData, {
      sort: "Admin Name",
      rows: 20
    });
  }
}
```

```{ojs}
// Section 1.1 Dynamic Insight
s11Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgWeatherStation = d3.mean(insightData, d => d["weather-station_density"]);
  const avgCloudCover = d3.mean(insightData, d => d["cloud-coverage_meanannual"]);
  
  const wsClass = classifyTercile(avgWeatherStation, africaTerciles.weatherStation).toLowerCase();
  const ccClass = classifyTercile(avgCloudCover, africaTerciles.cloudCover).toLowerCase();
  
  const capacity = (wsClass === "stronger" && ccClass === "stronger") ? "high" :
                   (wsClass === "weaker" || ccClass === "weaker") ? "low" : "moderate";
  
  return _lang({
    en: `In ${breadcrumb}, ground-station density is ${avgWeatherStation?.toFixed(3)} and clear-sky fraction ${avgCloudCover?.toFixed(3)}, indicating ${capacity} capacity for both in-situ and optical observation. Classification is relative to Sub-Saharan Africa.`,
    fr: `Dans ${breadcrumb}, la densité des stations au sol est ${avgWeatherStation?.toFixed(3)} et la fraction de ciel clair ${avgCloudCover?.toFixed(3)}, indiquant une capacité ${capacity} pour l'observation in-situ et optique. La classification est relative à l'Afrique subsaharienne.`
  });
}
```

::: {.key-insights}
`{ojs} s11Insight`
:::

---

```{ojs}
section12Title = _lang(cis.section12Title)
```

## `{ojs} section12Title` {#section1-2}

```{ojs}
section12Content = _lang(cis.section12Content)
```

`{ojs} section12Content`

```{ojs}
// Section 1.2 Controls
viewof s12ViewType = Inputs.radio(["Map", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s12MapMode = Inputs.radio(["Raw values", "Classified"], {
  label: _lang(cis.mapModeLabel),
  value: "Raw values"
})
```

```{ojs}
// Prepare data for Section 1.2 map
s12MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  // Filter boundaries based on current selection
  // Instead of filtering by property names, filter by matching with filteredData
  let filteredBoundaries = boundaries;
  if (currentAdminLevel === 2) {
    // When showing admin2, only include boundaries that match our filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesData || (matchesAdmin0 && matchesAdmin1);
      })
    };
  } else if (currentAdminLevel === 1) {
    // When showing admin1, filter by admin0 and match with filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesData || matchesAdmin0;
      })
    };
  }
  
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    let dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: try matching by admin names if GAUL code fails
    if (!dataRow && currentAdminLevel === 2) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!dataRow && currentAdminLevel === 1) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    const precipValue = dataRow ? parseFloat(dataRow["cv-precipitation_agreement"]) : null;
    
    // Check if this admin2 region is highlighted
    const isHighlighted = currentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        precipAgreement: precipValue,
        precipAgreementClass: classifyPrecipAgreement(precipValue),
        isHighlighted: isHighlighted
      }
    };
  }).filter(f => f.properties.precipAgreement != null);
  
  return { type: "FeatureCollection", features };
}
```

```{ojs}
// Section 1.2 Map/Table
{
  if (s12ViewType === "Map") {
    const useRaw = s12MapMode === "Raw values";
    
    return Plot.plot({
      width: 2000,
      height: 1000,
      projection: {type: "mercator", domain: s12MapData},
      color: useRaw ? {
        type: "linear",
        domain: [0, 4],
        scheme: "Viridis",
        legend: true,
        label: "Agreement (0-4)"
      } : {
        type: "categorical",
        domain: ["No agreement (Very Low)", "Partial agreement (Moderate)", "High agreement (High)", "Full agreement (Very High)"],
        range: ["#fee5d9", "#fcae91", "#fb6a4a", "#a50f15"],
        legend: true,
        label: "Classification"
      },
      marks: [
        Plot.geo(s12MapData.features, {
          fill: useRaw ? d => d.properties.precipAgreement : d => d.properties.precipAgreementClass,
          stroke: d => d.properties.isHighlighted ? "#000" : "#333",
          strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
        }),
        Plot.tip(
          s12MapData.features,
          Plot.pointer(
            Plot.centroid({
              channels: {
                region: {
                  label: "Region",
                  value: (d) => {
                    const regionName = d.properties.admin2_name || d.properties.admin1_name || d.properties.admin0_name;
                    const country = d.properties.admin0_name;
                    return regionName === country ? regionName : `${regionName}, ${country}`;
                  }
                },
                satelliteAgreement: {
                  label: "Satellite Agreement",
                  value: (d) => d.properties.precipAgreement
                },
                class: {
                  label: "Class",
                  value: (d) => d.properties.precipAgreementClass
                }
              },
              format: {
                region: true,
                satelliteAgreement: (d) => d != null ? d.toFixed(1) : "N/A",
                class: true
              }
            })
          )
        )
      ]
    });
  } else {
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
      "Satellite Agreement (Raw)": parseFloat(d["cv-precipitation_agreement"])?.toFixed(1) || "N/A",
      "Satellite Agreement (Class)": classifyPrecipAgreement(d["cv-precipitation_agreement"])
      };
    });
    
    return Inputs.table(tableData, {
      sort: "Admin Name",
      rows: 20
    });
  }
}
```

```{ojs}
// Download button for Section 1.2
downloadButton(
  filteredData.map(d => {
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    return {
      "Admin Name": adminName,
    "Satellite Agreement": parseFloat(d["cv-precipitation_agreement"]),
    "Classification": classifyPrecipAgreement(d["cv-precipitation_agreement"])
    };
  }),
  "cis_precipitation_agreement",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.2 Dynamic Insight
s12Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgAgreement = d3.mean(insightData, d => parseFloat(d["cv-precipitation_agreement"]));
  
  let agreementLevel = "no";
  if (avgAgreement >= 3) agreementLevel = "high";
  else if (avgAgreement >= 1) agreementLevel = "partial";
  
  return _lang({
    en: `In ${breadcrumb}, consistency across satellite data sources is ${avgAgreement?.toFixed(2)} indicating ${agreementLevel} agreement.`,
    fr: `Dans ${breadcrumb}, la cohérence entre les sources de données satellites est ${avgAgreement?.toFixed(2)} indiquant un accord ${agreementLevel}.`
  });
}
```

::: {.key-insights}
`{ojs} s12Insight`
:::

---

```{ojs}
section13Title = _lang(cis.section13Title)
```

## `{ojs} section13Title` {#section1-3}

```{ojs}
section13Content = _lang(cis.section13Content)
```

`{ojs} section13Content`

```{ojs}
// Section 1.3 Controls
viewof s13ViewType = Inputs.radio(["Chart", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Chart"
})

viewof s13SortBy = Inputs.radio(["Short-term skill", "Long-term skill", "Difference (Δ)"], {
  label: _lang(cis.sortByLabel),
  value: "Short-term skill"
})
```

```{ojs}
// Prepare data for Section 1.3
s13Data = {
  const data = filteredData.map(d => {
    const shortTerm = d["short-term_frcst_skill"];
    const longTerm = d["seasonal_frcst_skill"];
    const classification = classifyForecastSkill(shortTerm, longTerm);
    
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    
    return {
      admin: adminName,
      shortTerm: shortTerm,
      longTerm: longTerm,
      delta: shortTerm && longTerm ? shortTerm - longTerm : null,
      interpretation: classification.interpretation,
      implication: classification.implication
    };
  }).filter(d => d.shortTerm != null || d.longTerm != null);
  
  // Sort data
  if (s13SortBy === "Short-term skill") {
    data.sort((a, b) => (b.shortTerm || 0) - (a.shortTerm || 0));
  } else if (s13SortBy === "Long-term skill") {
    data.sort((a, b) => (b.longTerm || 0) - (a.longTerm || 0));
  } else {
    data.sort((a, b) => (b.delta || 0) - (a.delta || 0));
  }
  
  return data;
}
```

```{ojs}
// Section 1.3 Chart/Table
{
  if (s13ViewType === "Chart") {
    // Prepare data with delta for vertically stacked bars
    const dataWithDelta = s13Data.map(d => {
      const short = d.shortTerm != null ? parseFloat(d.shortTerm.toFixed(2)) : null;
      const long = d.longTerm != null ? parseFloat(d.longTerm.toFixed(2)) : null;
      // Delta = long - short (for the delta bar, negative means long < short)
      const delta = (short != null && long != null) ? parseFloat((long - short).toFixed(2)) : null;
      return {
        name: d.admin,
        short: short,
        long: long,
        delta: delta
      };
    });
    
    // Sort data based on selected mode (default = short-term skill descending)
    const sortMode = s13SortBy === "Short-term skill" ? "short" : 
                     s13SortBy === "Long-term skill" ? "long" : "delta";
    
    const sorted = (() => {
      if (sortMode === "short") {
        return dataWithDelta.sort((a, b) => (b.short || 0) - (a.short || 0));
      } else if (sortMode === "long") {
        return dataWithDelta.sort((a, b) => (b.long || 0) - (a.long || 0));
      } else {
        return dataWithDelta.sort((a, b) => {
          const deltaA = (a.long || 0) - (a.short || 0);
          const deltaB = (b.long || 0) - (b.short || 0);
          return Math.abs(deltaB) - Math.abs(deltaA);
        });
      }
    })();
    
    // Flatten data for vertical stacking: each country gets 3 rows in order (Delta on top, Long in middle, Short on bottom)
    const stackedData = sorted.flatMap(d => [
      { 
        country: d.name, 
        metric: "Δ (Long − Short)",
        label: `${d.name} | Δ`,
        value: d.delta,
        order: 0  // Top position
      },
      { 
        country: d.name, 
        metric: "Long-term RPSS (11-12 mo)",
        label: `${d.name} | Long`,
        value: d.long,
        order: 1  // Middle position
      },
      { 
        country: d.name, 
        metric: "Short-term RPSS (1-2 mo)",
        label: `${d.name} | Short`,
        value: d.short,
        order: 2  // Bottom position
      }
    ]);
    
    // Calculate responsive height - 3 bars per country (smaller bars to match wireframe)
    const itemCount = sorted.length * 3;
    const chartHeight = Math.max(500, itemCount * 12);  // Reduced from 18 to 12 for thinner bars
    
    const marginLeft = 150;
    
    // Calculate x-axis domain to accommodate negative delta values
    const maxValue = Math.max(...sorted.map(d => Math.max(d.short || 0, d.long || 0)), 0.7);
    const minDelta = Math.min(...sorted.map(d => d.delta || 0), -0.1);
    const xMin = Math.min(minDelta, -0.1);
    const xMax = Math.max(maxValue, 0.7);
    
    // Generate ticks for x-axis
    const tickStep = 0.1;
    const ticks = [];
    for (let i = Math.ceil(xMin / tickStep) * tickStep; i <= xMax; i += tickStep) {
      if (Math.abs(i) < 0.01) ticks.push(0);
      else ticks.push(Math.round(i * 10) / 10);
    }
    
    // Create y-axis domain maintaining the proper vertical order for each country
    const yDomain = stackedData.map(d => d.label);
    
    const filteredStackedData = stackedData.filter(d => d.value != null);
    
    return Plot.plot({
      marginLeft: marginLeft,
      marginTop: 40,
      marginBottom: 60,
      width: 900,
      height: chartHeight,
      style: {
        fontSize: "14px"  // Increase base font size for all text
      },
      x: {
        label: "RPSS (0-1) or Δ",
        labelAnchor: "center",
        domain: [xMin, xMax],
        ticks: ticks,
        grid: true,
        tickSize: 6,
        fontSize: 14  // Larger tick labels
      },
      y: {
        label: null,
        domain: yDomain,
        padding: 0.3,  // Increased from 0.15 to 0.3 for tighter bars
        tickSize: 6,
        fontSize: 13  // Larger y-axis labels (country names)
      },
      color: {
        legend: true,
        domain: ["Short-term RPSS (1-2 mo)", "Long-term RPSS (11-12 mo)", "Δ (Long − Short)"],
        range: ["#1f77b4", "#ff7f0e", "#808080"]
      },
      marks: [
        // X-axis at top (without label)
        Plot.axisX({ 
          anchor: "top", 
          label: null, 
          ticks: ticks,
          fontSize: 14,
          tickSize: 6
        }),
        
        // X-axis at bottom (with label) - this is the default
        Plot.axisX({ 
          anchor: "bottom", 
          label: "RPSS (0-1) or Δ", 
          ticks: ticks,
          fontSize: 14,
          tickSize: 6,
          labelFontSize: 16  // Larger x-axis title
        }),
        
        // Reference line at 0
        Plot.ruleX([0], { stroke: "#333", strokeWidth: 1 }),
        
        // All bars stacked vertically, maintaining order
        Plot.barX(filteredStackedData, {
          x1: 0,
          x2: "value",
          y: "label",
          fill: "metric"
        }),
        Plot.tip(
          filteredStackedData,
          Plot.pointer({
            x: "value",
            y: "label",
            channels: {
              country: {
                label: "Country",
                value: (d) => d.country
              },
              metric: {
                label: "Metric",
                value: (d) => d.metric
              },
              value: {
                label: "Value",
                value: (d) => d.value
              }
            },
            format: {
              country: true,
              metric: true,
              value: (d) => d != null ? d.toFixed(2) : "N/A"
            }
          })
        )
      ]
    });
  } else {
    const tableData = s13Data.map(d => ({
      "Admin Name": d.admin,
      "Short-term": d.shortTerm?.toFixed(3) || "N/A",
      "Long-term": d.longTerm?.toFixed(3) || "N/A",
      "Δ": d.delta?.toFixed(3) || "N/A",
      "Interpretation": d.interpretation,
      "CIS Implication": d.implication
    }));
    
    return Inputs.table(tableData, {
      rows: 20
    });
  }
}
```

```{ojs}
// Download button for Section 1.3
downloadButton(
  s13Data.map(d => ({
    "Admin Name": d.admin,
    "Short-term Skill": d.shortTerm,
    "Long-term Skill": d.longTerm,
    "Delta": d.delta,
    "Interpretation": d.interpretation,
    "CIS Implication": d.implication
  })),
  "cis_forecast_skill",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.3 Dynamic Insight
s13Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgShortTerm = d3.mean(insightData, d => d["short-term_frcst_skill"]);
  const avgLongTerm = d3.mean(insightData, d => d["seasonal_frcst_skill"]);
  
  const classification = classifyForecastSkill(avgShortTerm, avgLongTerm);
  
  return _lang({
    en: `In ${breadcrumb}, short-term forecast skill averages ${avgShortTerm?.toFixed(3)} while long-term skill drops to ${avgLongTerm?.toFixed(3)}. Predictability is ${classification.interpretation.toLowerCase()}.`,
    fr: `Dans ${breadcrumb}, la compétence de prévision à court terme est en moyenne ${avgShortTerm?.toFixed(3)} tandis que la compétence à long terme chute à ${avgLongTerm?.toFixed(3)}. La prévisibilité est ${classification.interpretation.toLowerCase()}.`
  });
}
```

::: {.key-insights}
`{ojs} s13Insight`
:::

---

```{ojs}
section14Title = _lang(cis.section14Title)
```

## `{ojs} section14Title` {#section1-4}

```{ojs}
section14Content = _lang(cis.section14Content)
```

`{ojs} section14Content`

```{ojs}
// Section 1.4 Controls
viewof s14ViewType = Inputs.radio(["Map", "Table", "Heatmap"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s14Threshold = Inputs.range([0, 1], {
  label: _lang(cis.thresholdLabel),
  value: 0.5,
  step: 0.05
})
```

```{ojs}
// Prepare data for Section 1.4
s14MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  // Filter boundaries based on current selection
  // Instead of filtering by property names, filter by matching with filteredData
  let filteredBoundaries = boundaries;
  if (currentAdminLevel === 2) {
    // When showing admin2, only include boundaries that match our filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesData || (matchesAdmin0 && matchesAdmin1);
      })
    };
  } else if (currentAdminLevel === 1) {
    // When showing admin1, filter by admin0 and match with filtered data
    const filteredGaulCodes = new Set(filteredData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesData || matchesAdmin0;
      })
    };
  }
  
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    let dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: try matching by admin names if GAUL code fails
    if (!dataRow && currentAdminLevel === 2) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!dataRow && currentAdminLevel === 1) {
      dataRow = filteredData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    // Check if this admin2 region is highlighted
    const isHighlighted = currentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        cisReadiness: dataRow?.["cis_readiness_index"],
        cisReadinessClass: dataRow ? classifyTercile(dataRow["cis_readiness_index"], africaTerciles.cisReadiness) : "No data",
        weatherStation: dataRow?.["weather-station_density"],
        weatherStationClass: dataRow ? classifyTercile(dataRow["weather-station_density"], africaTerciles.weatherStation) : "No data",
        cloudCover: dataRow?.["cloud-coverage_meanannual"],
        cloudCoverClass: dataRow ? classifyTercile(dataRow["cloud-coverage_meanannual"], africaTerciles.cloudCover) : "No data",
        precipAgreement: dataRow ? parseFloat(dataRow["cv-precipitation_agreement"]) : null,
        precipAgreementClass: dataRow ? classifyPrecipAgreement(dataRow["cv-precipitation_agreement"]) : "No data",
        shortTerm: dataRow?.["short-term_frcst_skill"],
        longTerm: dataRow?.["seasonal_frcst_skill"],
        isHighlighted: isHighlighted
      }
    };
  }).filter(f => f.properties.cisReadiness != null);
  
  return { type: "FeatureCollection", features };
}
```

```{ojs}
// Section 1.4 Visualization
{
  if (s14ViewType === "Map") {
    // Apply threshold to highlight regions
    const aboveThreshold = s14MapData.features.filter(f => f.properties.cisReadiness >= s14Threshold);
    const belowThreshold = s14MapData.features.filter(f => f.properties.cisReadiness < s14Threshold);
    
    const allFeatures = [...belowThreshold, ...aboveThreshold];
    
    return Plot.plot({
      width: 2000,
      height: 1000,
      projection: {type: "mercator", domain: s14MapData},
      color: {
        type: "linear",
        domain: [0, 1],
        scheme: "RdYlGn",
        legend: true,
        label: "CIS Readiness Index (0-1)"
      },
      marks: [
        // Regions below threshold - slightly transparent
        Plot.geo(belowThreshold, {
          fill: d => d.properties.cisReadiness,
          fillOpacity: 0.5,
          stroke: d => d.properties.isHighlighted ? "#000" : "#999",
          strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
        }),
        // Regions above threshold - fully opaque with bold border
        Plot.geo(aboveThreshold, {
          fill: d => d.properties.cisReadiness,
          fillOpacity: 1,
          stroke: d => d.properties.isHighlighted ? "#000" : "#333",
          strokeWidth: d => d.properties.isHighlighted ? 2.5 : 1.5
        }),
        Plot.tip(
          allFeatures,
          Plot.pointer(
            Plot.centroid({
              channels: {
                region: {
                  label: "Region",
                  value: (d) => d.properties.admin0_name || d.properties.admin1_name || d.properties.admin2_name
                },
                cisReadiness: {
                  label: "CIS Readiness",
                  value: (d) => d.properties.cisReadiness
                },
                threshold: {
                  label: "Threshold Status",
                  value: (d) => d.properties.cisReadiness >= s14Threshold ? "Above threshold" : "Below threshold"
                },
                class: {
                  label: "Class",
                  value: (d) => d.properties.cisReadinessClass
                },
                weatherStation: {
                  label: "Weather Station",
                  value: (d) => d.properties.weatherStationClass
                },
                cloudCover: {
                  label: "Cloud Cover",
                  value: (d) => d.properties.cloudCoverClass
                },
                precipAgreement: {
                  label: "Precip Agreement",
                  value: (d) => d.properties.precipAgreementClass
                },
                shortTerm: {
                  label: "Short-term",
                  value: (d) => d.properties.shortTerm
                },
                longTerm: {
                  label: "Long-term",
                  value: (d) => d.properties.longTerm
                }
              },
              format: {
                region: true,
                cisReadiness: (d) => d != null ? d.toFixed(3) : "N/A",
                threshold: true,
                class: true,
                weatherStation: true,
                cloudCover: true,
                precipAgreement: true,
                shortTerm: (d) => d != null ? d.toFixed(3) : "N/A",
                longTerm: (d) => d != null ? d.toFixed(3) : "N/A"
              }
            })
          )
        )
      ]
    });
  } else if (s14ViewType === "Table") {
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
      "CIS Readiness (Raw)": d["cis_readiness_index"]?.toFixed(3) || "N/A",
      "CIS Readiness (Class)": classifyTercile(d["cis_readiness_index"], africaTerciles.cisReadiness),
      "Weather Station (Class)": classifyTercile(d["weather-station_density"], africaTerciles.weatherStation),
      "Cloud Cover (Class)": classifyTercile(d["cloud-coverage_meanannual"], africaTerciles.cloudCover),
      "Precip Agreement (Class)": classifyPrecipAgreement(d["cv-precipitation_agreement"]),
      "Short-term (Raw)": d["short-term_frcst_skill"]?.toFixed(3) || "N/A",
      "Long-term (Raw)": d["seasonal_frcst_skill"]?.toFixed(3) || "N/A"
      };
    });
    
    return Inputs.table(tableData, {
      sort: "CIS Readiness (Raw)",
      reverse: true,
      rows: 20
    });
  } else {
    // Heatmap
    const heatmapData = filteredData.map(d => ({
      admin: d[`admin${currentAdminLevel}_name`] || d.admin0_name,
      "Weather Stations": d["weather-station_density"],
      "Cloud Cover": d["cloud-coverage_meanannual"],
      "Precip Agreement": parseFloat(d["cv-precipitation_agreement"]) / 4, // Normalize to 0-1
      "Short-term Forecast": d["short-term_frcst_skill"],
      "Long-term Forecast": d["seasonal_frcst_skill"],
      "CIS Readiness": d["cis_readiness_index"]
    })).slice(0, 30); // Limit to 30 rows for readability
    
    const indicators = ["Weather Stations", "Cloud Cover", "Precip Agreement", "Short-term Forecast", "Long-term Forecast", "CIS Readiness"];
    
    const heatData = heatmapData.flatMap(row => 
      indicators.map(indicator => ({
        admin: row.admin,
        indicator: indicator,
        value: row[indicator]
      }))
    );
    
    return Plot.plot({
      width: 2000,
      height: Math.max(800, heatmapData.length * 30),
      marginLeft: 250,
      marginBottom: 120,
      style: {
        fontSize: "16px"  // Increase base font size
      },
      x: { 
        label: null,
        tickRotate: -45,
        fontSize: 16,  // Larger x-axis labels
        tickSize: 8
      },
      y: { 
        label: null,
        fontSize: 15,  // Larger y-axis labels
        tickSize: 8
      },
      color: {
        type: "linear",
        domain: [0, 1],
        scheme: "RdYlGn",
        legend: true,
        label: "Value (0-1)",
        fontSize: 16  // Larger legend text
      },
      marks: [
        Plot.cell(heatData, {
          x: "indicator",
          y: "admin",
          fill: "value"
        }),
        Plot.tip(
          heatData,
          Plot.pointer({
            x: "indicator",
            y: "admin",
            channels: {
              admin: {
                label: "Admin",
                value: (d) => d.admin
              },
              indicator: {
                label: "Indicator",
                value: (d) => d.indicator
              },
              value: {
                label: "Value",
                value: (d) => d.value
              }
            },
            format: {
              admin: true,
              indicator: true,
              value: (d) => d != null ? d.toFixed(3) : "N/A"
            }
          })
        )
      ]
    });
  }
}
```

```{ojs}
// Download button for Section 1.4
downloadButton(
  filteredData.map(d => {
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    return {
      "Admin Name": adminName,
    "CIS Readiness Index": d["cis_readiness_index"],
    "Weather Station Density": d["weather-station_density"],
    "Cloud Coverage": d["cloud-coverage_meanannual"],
    "Precipitation Agreement": parseFloat(d["cv-precipitation_agreement"]),
    "Short-term Forecast Skill": d["short-term_frcst_skill"],
    "Long-term Forecast Skill": d["seasonal_frcst_skill"]
    };
  }),
  "cis_readiness_index",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.4 Dynamic Insight
s14Insight = {
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? filteredData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : filteredData;
  
  const avgReadiness = d3.mean(insightData, d => d["cis_readiness_index"]);
  const readinessClass = classifyTercile(avgReadiness, africaTerciles.cisReadiness).toLowerCase();
  
  const aboveThreshold = insightData.filter(d => d["cis_readiness_index"] >= s14Threshold).length;
  const total = insightData.length;
  const pct = ((aboveThreshold / total) * 100).toFixed(1);
  
  return _lang({
    en: `In ${breadcrumb}, the overall CIS Readiness Index averages ${avgReadiness?.toFixed(3)}, classified as ${readinessClass} relative to Sub-Saharan Africa. ${pct}% of regions exceed the ${s14Threshold} readiness threshold.`,
    fr: `Dans ${breadcrumb}, l'indice global de préparation CIS est en moyenne ${avgReadiness?.toFixed(3)}, classé comme ${readinessClass} par rapport à l'Afrique subsaharienne. ${pct}% des régions dépassent le seuil de préparation ${s14Threshold}.`
  });
}
```

::: {.key-insights}
`{ojs} s14Insight`
:::
