```{ojs}
section1Title = _lang(cis.section1Title)
```

# `{ojs} section1Title` {#section1}

```{ojs}
// Load CIS data using DuckDB with Parquet for better performance
cisDB = await DuckDBClient.of({
  cis_data: FileAttachment("/data/cis/CIS_nb_data.parquet")
});

// Load all data and process in JavaScript for type safety
cisDataRaw = await cisDB.query(`SELECT * FROM cis_data`);

cisData = cisDataRaw.map(row => ({
  ...row,
  "weather-station_density": parseFloat(row["weather-station_density"]),
  "cloud-coverage_meanannual": parseFloat(row["cloud-coverage_meanannual"]),
  "cv-precipitation_agreement": parseFloat(row["cv-precipitation_agreement"]),
  "short-term_frcst_skill": parseFloat(row["short-term_frcst_skill"]),
  "seasonal_frcst_skill": parseFloat(row["seasonal_frcst_skill"]),
  "cis_readiness_index": parseFloat(row["cis_readiness_index"]),
  gaul0_code: parseInt(row.gaul0_code),
  gaul1_code: parseInt(row.gaul1_code),
  gaul2_code: parseInt(row.gaul2_code)
}));
```

```{ojs}
// Import boundary helper functions
import { geojsonFromWKB_wk, read_topojson } from "/helpers/boundaries.js"
import { boundary_paths } from "/helpers/data.js"
```

```{ojs}
// Load boundary data
admin0Boundaries = await read_topojson(boundary_paths.admin0_path, "atlas_gaul24_a0_africa")
admin1Boundaries = await read_topojson(boundary_paths.admin1_path, "atlas_gaul24_a1_africa")
admin2Boundaries = await read_topojson(boundary_paths.admin2_path, "atlas_gaul_a2_africa_simple-lowres")
```

```{ojs}
// Calculate Africa-wide tercile cutoffs for classification
africaTerciles = {
  const weatherStations = cisData.map(d => d["weather-station_density"]).filter(d => d != null);
  const cloudCover = cisData.map(d => d["cloud-coverage_meanannual"]).filter(d => d != null);
  const precipAgreement = cisData.map(d => parseFloat(d["cv-precipitation_agreement"])).filter(d => !isNaN(d));
  const shortTermSkill = cisData.map(d => d["short-term_frcst_skill"]).filter(d => d != null);
  const seasonalSkill = cisData.map(d => d["seasonal_frcst_skill"]).filter(d => d != null);
  const cisReadiness = cisData.map(d => d["cis_readiness_index"]).filter(d => d != null);
  
  const quantile = (arr, q) => {
    const sorted = arr.slice().sort((a, b) => a - b);
    const pos = (sorted.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    return sorted[base + 1] !== undefined 
      ? sorted[base] + rest * (sorted[base + 1] - sorted[base])
      : sorted[base];
  };
  
  return {
    weatherStation: {
      p33: quantile(weatherStations, 0.33),
      p66: quantile(weatherStations, 0.66)
    },
    cloudCover: {
      p33: quantile(cloudCover, 0.33),
      p66: quantile(cloudCover, 0.66)
    },
    precipAgreement: {
      p33: quantile(precipAgreement, 0.33),
      p66: quantile(precipAgreement, 0.66)
    },
    shortTermSkill: {
      p33: quantile(shortTermSkill, 0.33),
      p66: quantile(shortTermSkill, 0.66)
    },
    seasonalSkill: {
      p33: quantile(seasonalSkill, 0.33),
      p66: quantile(seasonalSkill, 0.66)
    },
    cisReadiness: {
      p33: quantile(cisReadiness, 0.33),
      p66: quantile(cisReadiness, 0.66)
    }
  };
}
```

```{ojs}
// Classification functions
classifyTercile = (value, terciles) => {
  if (value == null || isNaN(value)) return "No data";
  if (value <= terciles.p33) return "Weaker";
  if (value <= terciles.p66) return "Moderate";
  return "Stronger";
}

classifyPrecipAgreement = (value) => {
  if (value == null || isNaN(value)) return "No data";
  const numVal = parseFloat(value);
  if (numVal === 0) return "No agreement (Very Low)";
  if (numVal <= 2) return "Partial agreement (Moderate)";
  if (numVal === 3) return "High agreement (High)";
  return "Full agreement (Very High)";
}

classifyForecastSkill = (shortTerm, longTerm) => {
  if (shortTerm == null || longTerm == null) return { interpretation: "No data", implication: "Insufficient data" };
  
  const delta = shortTerm - longTerm;
  
  if (shortTerm > 0.6 && longTerm > 0.6) {
    return {
      interpretation: "Reliable forecasts at both horizons",
      implication: "Scale CIS for advisories + finance"
    };
  } else if (shortTerm > 0.6 && longTerm < 0.4 && delta > 0.2) {
    return {
      interpretation: "Rapid loss of skill",
      implication: "Limit use to short-term planning"
    };
  } else if (shortTerm < 0.4 && longTerm < 0.4) {
    return {
      interpretation: "Weak predictability",
      implication: "Use climatology / caution"
    };
  } else {
    return {
      interpretation: "Uncertain but usable",
      implication: "Blend with historical averages"
    };
  }
}
```

```{ojs}
// Get unique admin values for selectors
uniqueAdmin0 = Array.from(new Set(cisData.map(d => d.admin0_name))).sort()
uniqueAdmin1 = (admin0Selection) => {
  if (!admin0Selection || admin0Selection.length === 0) return [];
  return Array.from(new Set(
    cisData
      .filter(d => admin0Selection.includes(d.admin0_name))
      .map(d => d.admin1_name)
      .filter(d => d != null)
  )).sort();
}
uniqueAdmin2 = (admin0Selection, admin1Selection) => {
  if (!admin1Selection || admin1Selection.length === 0) return [];
  return Array.from(new Set(
    cisData
      .filter(d => 
        admin0Selection.includes(d.admin0_name) && 
        admin1Selection.includes(d.admin1_name)
      )
      .map(d => d.admin2_name)
      .filter(d => d != null)
  )).sort();
}
```

```{ojs}
// Display dropdown CSS (imports are in parent file to avoid duplication)
dropdownCSS
```

```{ojs}
// Admin level selectors
viewof selectedAdmin0 = multiSelect({
  inputLabel: _lang(cis.admin0Label),
  inputId: "admin0Select",
  placeholderText: _lang(cis.admin0Placeholder),
  options: uniqueAdmin0.map(d => ({ value: d, label: d })),
  selected: ['Kenya'],
  maxSelections: 10
})
```

```{ojs}
admin1Options = uniqueAdmin1(selectedAdmin0)

viewof selectedAdmin1 = multiSelect({
  inputLabel: _lang(cis.admin1Label),
  inputId: "admin1Select",
  placeholderText: _lang(cis.admin1Placeholder),
  options: admin1Options.map(d => ({ value: d, label: d })),
  selected: admin1Options.length > 0 ? admin1Options.slice(0, 10) : [],
  maxSelections: 10
})
```

```{ojs}
admin2Options = uniqueAdmin2(selectedAdmin0, selectedAdmin1)

viewof selectedAdmin2 = multiSelect({
  inputLabel: _lang(cis.admin2Label),
  inputId: "admin2Select",
  placeholderText: _lang(cis.admin2Placeholder),
  options: admin2Options.map(d => ({ value: d, label: d })),
  selected: [],
  maxSelections: 10
})
```

```{ojs}
// Determine current admin level and filter data
currentAdminLevel = selectedAdmin2.length > 0 ? 2 : (selectedAdmin1.length > 0 ? 1 : 0)

filteredData = {
  if (currentAdminLevel === 2) {
    return cisData.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
      selectedAdmin1.includes(d.admin1_name) &&
      selectedAdmin2.includes(d.admin2_name)
    );
  } else if (currentAdminLevel === 1) {
    return cisData.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
      selectedAdmin1.includes(d.admin1_name)
    );
  } else {
    return cisData.filter(d => selectedAdmin0.includes(d.admin0_name));
  }
}
```

```{ojs}
// Breadcrumb navigation
breadcrumb = {
  const parts = [];
  if (selectedAdmin0.length === 1) parts.push(selectedAdmin0[0]);
  else if (selectedAdmin0.length > 1) parts.push(`${selectedAdmin0.length} countries`);
  
  if (selectedAdmin1.length === 1) parts.push(selectedAdmin1[0]);
  else if (selectedAdmin1.length > 1) parts.push(`${selectedAdmin1.length} admin1 regions`);
  
  if (selectedAdmin2.length === 1) parts.push(selectedAdmin2[0]);
  else if (selectedAdmin2.length > 1) parts.push(`${selectedAdmin2.length} admin2 regions`);
  
  return parts.join(' → ');
}
```

---

```{ojs}
section11Title = _lang(cis.section11Title)
```

## `{ojs} section11Title` {#section1-1}

```{ojs}
section11Content = _lang(cis.section11Content)
```

`{ojs} section11Content`

```{ojs}
// Section 1.1 Controls
viewof s11ViewType = Inputs.radio(["Map", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s11MapMode = Inputs.radio(["Raw values", "Classified"], {
  label: _lang(cis.mapModeLabel),
  value: "Classified"
})
```

```{ojs}
// Prepare data for Section 1.1 maps
s11MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  // Join data with boundaries
  const features = boundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    const dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    // Pre-compute region name for faster tooltip rendering
    const regionName = currentAdminLevel === 0 
      ? feature.properties.admin0_name 
      : currentAdminLevel === 1
      ? `${feature.properties.admin1_name}, ${feature.properties.admin0_name}`
      : `${feature.properties.admin2_name}, ${feature.properties.admin1_name}, ${feature.properties.admin0_name}`;
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        regionName: regionName,
        weatherStation: dataRow?.["weather-station_density"],
        cloudCover: dataRow?.["cloud-coverage_meanannual"],
        weatherStationClass: dataRow ? classifyTercile(dataRow["weather-station_density"], africaTerciles.weatherStation) : "No data",
        cloudCoverClass: dataRow ? classifyTercile(dataRow["cloud-coverage_meanannual"], africaTerciles.cloudCover) : "No data"
      }
    };
  }).filter(f => f.properties.weatherStation != null || f.properties.cloudCover != null);
  
  return { type: "FeatureCollection", features };
}
```

```{ojs}
// Section 1.1 Maps
{
  if (s11ViewType === "Map") {
    const width = 2000;
    const height = 1000;
    
    // Color scale for 0-1 values
    const colorScale = d3.scaleSequential(d3.interpolateYlGnBu).domain([0, 1]);
    
    // Classification color scale
    const classColorScale = (className) => {
      if (className === "Weaker") return "#fee5d9";
      if (className === "Moderate") return "#fcae91";
      if (className === "Stronger") return "#fb6a4a";
      return "#ddd";
    };
    
    const useRaw = s11MapMode === "Raw values";
    
    return htl.html`<style>
      .plot-tip,
      [class*="plot-tip"],
      .observablehq .plot-tip,
      .observablehq [class*="plot-tip"] {
        font-size: 24px !important;
        padding: 30px 40px !important;
        line-height: 2.2 !important;
        min-width: 500px !important;
        max-width: 700px !important;
        min-height: 200px !important;
        box-sizing: border-box !important;
      }
      .plot-tip table,
      [class*="plot-tip"] table,
      .observablehq .plot-tip table,
      .observablehq [class*="plot-tip"] table {
        font-size: 24px !important;
        width: 100% !important;
      }
      .plot-tip th,
      .plot-tip td,
      [class*="plot-tip"] th,
      [class*="plot-tip"] td,
      .observablehq .plot-tip th,
      .observablehq .plot-tip td,
      .observablehq [class*="plot-tip"] th,
      .observablehq [class*="plot-tip"] td {
        padding: 16px 20px !important;
        font-size: 24px !important;
      }
      .plot-tip th,
      [class*="plot-tip"] th,
      .observablehq .plot-tip th,
      .observablehq [class*="plot-tip"] th {
        font-weight: 700 !important;
        font-size: 24px !important;
      }
      .plot-tip *,
      [class*="plot-tip"] *,
      .observablehq .plot-tip *,
      .observablehq [class*="plot-tip"] * {
        font-size: 24px !important;
      }
    </style>
    <div style="display: flex; gap: 20px;">
      <div style="flex: 1;">
        <h4>${_lang(cis.weatherStationLabel)}</h4>
        ${Plot.plot({
          width: width / 2,
          height: height,
          projection: {type: "mercator", domain: s11MapData},
          color: useRaw ? {
            type: "linear",
            domain: [0, 1],
            scheme: "YlGnBu",
            legend: true,
            label: "Density (0-1)"
          } : {
            type: "categorical",
            domain: ["Weaker", "Moderate", "Stronger"],
            range: ["#fee5d9", "#fcae91", "#fb6a4a"],
            legend: true,
            label: "Classification"
          },
          marks: [
            Plot.geo(s11MapData, {
              fill: useRaw ? d => d.properties.weatherStation : d => d.properties.weatherStationClass,
              stroke: "#333",
              strokeWidth: 0.5
            }),
            Plot.tip(s11MapData.features, Plot.pointer(Plot.centroid({
              channels: {
                Region: {
                  value: d => d.properties.regionName
                },
                "Weather Station": {
                  value: d => d.properties.weatherStation != null ? d.properties.weatherStation.toFixed(3) : 'N/A'
                },
                Class: {
                  value: d => d.properties.weatherStationClass
                },
               
              },
             
           
            })))
          ]
        })}
      </div>
      <div style="flex: 1;">
        <h4>${_lang(cis.cloudCoverLabel)}</h4>
        ${Plot.plot({
          width: width / 2,
          height: height,
          projection: {type: "mercator", domain: s11MapData},
          color: useRaw ? {
            type: "linear",
            domain: [0, 1],
            scheme: "YlGnBu",
            legend: true,
            label: "Coverage (0-1)"
          } : {
            type: "categorical",
            domain: ["Weaker", "Moderate", "Stronger"],
            range: ["#fee5d9", "#fcae91", "#fb6a4a"],
            legend: true,
            label: "Classification"
          },
          marks: [
            Plot.geo(s11MapData, {
              fill: useRaw ? d => d.properties.cloudCover : d => d.properties.cloudCoverClass,
              stroke: "#333",
              strokeWidth: 0.5
            }),
            Plot.tip(s11MapData.features, Plot.pointer(Plot.centroid({
              channels: {
                Region: {
                  value: d => d.properties.regionName
                },
                "Cloud Cover": {
                  value: d => d.properties.cloudCover != null ? d.properties.cloudCover.toFixed(3) : 'N/A'
                },
                Class: {
                  value: d => d.properties.cloudCoverClass
                }
              }
            })))
          ]
        })}
      </div>
    </div>`;
  } else {
    // Table view
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
        "Weather Station (Raw)": d["weather-station_density"]?.toFixed(3) || "N/A",
        "Weather Station (Class)": classifyTercile(d["weather-station_density"], africaTerciles.weatherStation),
        "Cloud Cover (Raw)": d["cloud-coverage_meanannual"]?.toFixed(3) || "N/A",
        "Cloud Cover (Class)": classifyTercile(d["cloud-coverage_meanannual"], africaTerciles.cloudCover)
      };
    });
    
    return Inputs.table(tableData, {
      sort: "Admin Name",
      rows: 20
    });
  }
}
```

```{ojs}
// Section 1.1 Dynamic Insight
s11Insight = {
  const avgWeatherStation = d3.mean(filteredData, d => d["weather-station_density"]);
  const avgCloudCover = d3.mean(filteredData, d => d["cloud-coverage_meanannual"]);
  
  const wsClass = classifyTercile(avgWeatherStation, africaTerciles.weatherStation).toLowerCase();
  const ccClass = classifyTercile(avgCloudCover, africaTerciles.cloudCover).toLowerCase();
  
  const capacity = (wsClass === "stronger" && ccClass === "stronger") ? "high" :
                   (wsClass === "weaker" || ccClass === "weaker") ? "low" : "moderate";
  
  return _lang({
    en: `In ${breadcrumb}, ground-station density is ${avgWeatherStation?.toFixed(3)} and clear-sky fraction ${avgCloudCover?.toFixed(3)}, indicating ${capacity} capacity for both in-situ and optical observation. Classification is relative to Sub-Saharan Africa.`,
    fr: `Dans ${breadcrumb}, la densité des stations au sol est ${avgWeatherStation?.toFixed(3)} et la fraction de ciel clair ${avgCloudCover?.toFixed(3)}, indiquant une capacité ${capacity} pour l'observation in-situ et optique. La classification est relative à l'Afrique subsaharienne.`
  });
}
```

::: {.key-insights}
`{ojs} s11Insight`
:::

---

```{ojs}
section12Title = _lang(cis.section12Title)
```

## `{ojs} section12Title` {#section1-2}

```{ojs}
section12Content = _lang(cis.section12Content)
```

`{ojs} section12Content`

```{ojs}
// Section 1.2 Controls
viewof s12ViewType = Inputs.radio(["Map", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s12MapMode = Inputs.radio(["Raw values", "Classified"], {
  label: _lang(cis.mapModeLabel),
  value: "Classified"
})
```

```{ojs}
// Prepare data for Section 1.2 map
s12MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  const features = boundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    const dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    const precipValue = dataRow ? parseFloat(dataRow["cv-precipitation_agreement"]) : null;
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        precipAgreement: precipValue,
        precipAgreementClass: classifyPrecipAgreement(precipValue)
      }
    };
  }).filter(f => f.properties.precipAgreement != null);
  
  return { type: "FeatureCollection", features };
}
```

```{ojs}
// Section 1.2 Map/Table
{
  if (s12ViewType === "Map") {
    const useRaw = s12MapMode === "Raw values";
    
    return Plot.plot({
      width: 2000,
      height: 1000,
      projection: {type: "mercator", domain: s12MapData},
      color: useRaw ? {
        type: "linear",
        domain: [0, 4],
        scheme: "Viridis",
        legend: true,
        label: "Agreement (0-4)"
      } : {
        type: "categorical",
        domain: ["No agreement (Very Low)", "Partial agreement (Moderate)", "High agreement (High)", "Full agreement (Very High)"],
        range: ["#fee5d9", "#fcae91", "#fb6a4a", "#a50f15"],
        legend: true,
        label: "Classification"
      },
      marks: [
        Plot.geo(s12MapData, {
          fill: useRaw ? d => d.properties.precipAgreement : d => d.properties.precipAgreementClass,
          stroke: "#333",
          strokeWidth: 0.5,
          title: d => `${d.properties.admin0_name || d.properties.admin1_name || d.properties.admin2_name}\n` +
                      `Satellite Agreement: ${d.properties.precipAgreement?.toFixed(1) || 'N/A'}\n` +
                      `Class: ${d.properties.precipAgreementClass}`
        })
      ]
    });
  } else {
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
        "Satellite Agreement (Raw)": parseFloat(d["cv-precipitation_agreement"])?.toFixed(1) || "N/A",
        "Satellite Agreement (Class)": classifyPrecipAgreement(d["cv-precipitation_agreement"])
      };
    });
    
    return Inputs.table(tableData, {
      sort: "Admin Name",
      rows: 20
    });
  }
}
```

```{ojs}
// Download button for Section 1.2
downloadButton(
  filteredData.map(d => {
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    return {
      "Admin Name": adminName,
      "Satellite Agreement": parseFloat(d["cv-precipitation_agreement"]),
      "Classification": classifyPrecipAgreement(d["cv-precipitation_agreement"])
    };
  }),
  "cis_precipitation_agreement",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.2 Dynamic Insight
s12Insight = {
  const avgAgreement = d3.mean(filteredData, d => parseFloat(d["cv-precipitation_agreement"]));
  
  let agreementLevel = "no";
  if (avgAgreement >= 3) agreementLevel = "high";
  else if (avgAgreement >= 1) agreementLevel = "partial";
  
  return _lang({
    en: `In ${breadcrumb}, consistency across satellite data sources is ${avgAgreement?.toFixed(2)} indicating ${agreementLevel} agreement.`,
    fr: `Dans ${breadcrumb}, la cohérence entre les sources de données satellites est ${avgAgreement?.toFixed(2)} indiquant un accord ${agreementLevel}.`
  });
}
```

::: {.key-insights}
`{ojs} s12Insight`
:::

---

```{ojs}
section13Title = _lang(cis.section13Title)
```

## `{ojs} section13Title` {#section1-3}

```{ojs}
section13Content = _lang(cis.section13Content)
```

`{ojs} section13Content`

```{ojs}
// Section 1.3 Controls
viewof s13ViewType = Inputs.radio(["Chart", "Table"], {
  label: _lang(cis.viewTypeLabel),
  value: "Chart"
})

viewof s13SortBy = Inputs.radio(["Short-term skill", "Long-term skill", "Difference (Δ)"], {
  label: _lang(cis.sortByLabel),
  value: "Short-term skill"
})
```

```{ojs}
// Prepare data for Section 1.3
s13Data = {
  const data = filteredData.map(d => {
    const shortTerm = d["short-term_frcst_skill"];
    const longTerm = d["seasonal_frcst_skill"];
    const classification = classifyForecastSkill(shortTerm, longTerm);
    
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    
    return {
      admin: adminName,
      shortTerm: shortTerm,
      longTerm: longTerm,
      delta: shortTerm && longTerm ? shortTerm - longTerm : null,
      interpretation: classification.interpretation,
      implication: classification.implication
    };
  }).filter(d => d.shortTerm != null || d.longTerm != null);
  
  // Sort data
  if (s13SortBy === "Short-term skill") {
    data.sort((a, b) => (b.shortTerm || 0) - (a.shortTerm || 0));
  } else if (s13SortBy === "Long-term skill") {
    data.sort((a, b) => (b.longTerm || 0) - (a.longTerm || 0));
  } else {
    data.sort((a, b) => (b.delta || 0) - (a.delta || 0));
  }
  
  return data;
}
```

```{ojs}
// Section 1.3 Chart/Table
{
  if (s13ViewType === "Chart") {
    // Prepare data with delta for vertically stacked bars
    const dataWithDelta = s13Data.map(d => {
      const short = d.shortTerm != null ? parseFloat(d.shortTerm.toFixed(2)) : null;
      const long = d.longTerm != null ? parseFloat(d.longTerm.toFixed(2)) : null;
      // Delta = long - short (for the delta bar, negative means long < short)
      const delta = (short != null && long != null) ? parseFloat((long - short).toFixed(2)) : null;
      return {
        name: d.admin,
        short: short,
        long: long,
        delta: delta
      };
    });
    
    // Sort data based on selected mode (default = short-term skill descending)
    const sortMode = s13SortBy === "Short-term skill" ? "short" : 
                     s13SortBy === "Long-term skill" ? "long" : "delta";
    
    const sorted = (() => {
      if (sortMode === "short") {
        return dataWithDelta.sort((a, b) => (b.short || 0) - (a.short || 0));
      } else if (sortMode === "long") {
        return dataWithDelta.sort((a, b) => (b.long || 0) - (a.long || 0));
      } else {
        return dataWithDelta.sort((a, b) => {
          const deltaA = (a.long || 0) - (a.short || 0);
          const deltaB = (b.long || 0) - (b.short || 0);
          return Math.abs(deltaB) - Math.abs(deltaA);
        });
      }
    })();
    
    // Flatten data for vertical stacking: each country gets 3 rows in order (Delta on top, Long in middle, Short on bottom)
    const stackedData = sorted.flatMap(d => [
      { 
        country: d.name, 
        metric: "Δ (Long − Short)",
        label: `${d.name} | Δ`,
        value: d.delta,
        order: 0  // Top position
      },
      { 
        country: d.name, 
        metric: "Long-term RPSS (11-12 mo)",
        label: `${d.name} | Long`,
        value: d.long,
        order: 1  // Middle position
      },
      { 
        country: d.name, 
        metric: "Short-term RPSS (1-2 mo)",
        label: `${d.name} | Short`,
        value: d.short,
        order: 2  // Bottom position
      }
    ]);
    
    // Calculate responsive height - 3 bars per country (smaller bars to match wireframe)
    const itemCount = sorted.length * 3;
    const chartHeight = Math.max(500, itemCount * 12);  // Reduced from 18 to 12 for thinner bars
    
    const marginLeft = 150;
    
    // Calculate x-axis domain to accommodate negative delta values
    const maxValue = Math.max(...sorted.map(d => Math.max(d.short || 0, d.long || 0)), 0.7);
    const minDelta = Math.min(...sorted.map(d => d.delta || 0), -0.1);
    const xMin = Math.min(minDelta, -0.1);
    const xMax = Math.max(maxValue, 0.7);
    
    // Generate ticks for x-axis
    const tickStep = 0.1;
    const ticks = [];
    for (let i = Math.ceil(xMin / tickStep) * tickStep; i <= xMax; i += tickStep) {
      if (Math.abs(i) < 0.01) ticks.push(0);
      else ticks.push(Math.round(i * 10) / 10);
    }
    
    // Create y-axis domain maintaining the proper vertical order for each country
    const yDomain = stackedData.map(d => d.label);
    
    return Plot.plot({
      marginLeft: marginLeft,
      width: 900,
      height: chartHeight,
      x: {
        label: "RPSS (0-1) or Δ",
        domain: [xMin, xMax],
        ticks: ticks,
        grid: true
      },
      y: {
        label: null,
        domain: yDomain,
        padding: 0.3  // Increased from 0.15 to 0.3 for tighter bars
      },
      color: {
        legend: true,
        domain: ["Short-term RPSS (1-2 mo)", "Long-term RPSS (11-12 mo)", "Δ (Long − Short)"],
        range: ["#1f77b4", "#ff7f0e", "#808080"]
      },
      marks: [
        // Reference line at 0
        Plot.ruleX([0], { stroke: "#333", strokeWidth: 1 }),
        
        // All bars stacked vertically, maintaining order
        Plot.barX(stackedData.filter(d => d.value != null), {
          x1: 0,
          x2: "value",
          y: "label",
          fill: "metric",
          title: d => `${d.country}\n${d.metric}: ${d.value?.toFixed(2) || 'N/A'}`
        })
      ]
    });
  } else {
    const tableData = s13Data.map(d => ({
      "Admin Name": d.admin,
      "Short-term": d.shortTerm?.toFixed(3) || "N/A",
      "Long-term": d.longTerm?.toFixed(3) || "N/A",
      "Δ": d.delta?.toFixed(3) || "N/A",
      "Interpretation": d.interpretation,
      "CIS Implication": d.implication
    }));
    
    return Inputs.table(tableData, {
      rows: 20
    });
  }
}
```

```{ojs}
// Download button for Section 1.3
downloadButton(
  s13Data.map(d => ({
    "Admin Name": d.admin,
    "Short-term Skill": d.shortTerm,
    "Long-term Skill": d.longTerm,
    "Delta": d.delta,
    "Interpretation": d.interpretation,
    "CIS Implication": d.implication
  })),
  "cis_forecast_skill",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.3 Dynamic Insight
s13Insight = {
  const avgShortTerm = d3.mean(filteredData, d => d["short-term_frcst_skill"]);
  const avgLongTerm = d3.mean(filteredData, d => d["seasonal_frcst_skill"]);
  
  const classification = classifyForecastSkill(avgShortTerm, avgLongTerm);
  
  return _lang({
    en: `In ${breadcrumb}, short-term forecast skill averages ${avgShortTerm?.toFixed(3)} while long-term skill drops to ${avgLongTerm?.toFixed(3)}. Predictability is ${classification.interpretation.toLowerCase()}.`,
    fr: `Dans ${breadcrumb}, la compétence de prévision à court terme est en moyenne ${avgShortTerm?.toFixed(3)} tandis que la compétence à long terme chute à ${avgLongTerm?.toFixed(3)}. La prévisibilité est ${classification.interpretation.toLowerCase()}.`
  });
}
```

::: {.key-insights}
`{ojs} s13Insight`
:::

---

```{ojs}
section14Title = _lang(cis.section14Title)
```

## `{ojs} section14Title` {#section1-4}

```{ojs}
section14Content = _lang(cis.section14Content)
```

`{ojs} section14Content`

```{ojs}
// Section 1.4 Controls
viewof s14ViewType = Inputs.radio(["Map", "Table", "Heatmap"], {
  label: _lang(cis.viewTypeLabel),
  value: "Map"
})

viewof s14Threshold = Inputs.range([0, 1], {
  label: _lang(cis.thresholdLabel),
  value: 0.5,
  step: 0.05
})
```

```{ojs}
// Prepare data for Section 1.4
s14MapData = {
  const boundaries = currentAdminLevel === 2 ? admin2Boundaries :
                     currentAdminLevel === 1 ? admin1Boundaries :
                     admin0Boundaries;
  
  const gaulCodeField = currentAdminLevel === 2 ? 'gaul2_code' :
                        currentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul0_code';
  
  const features = boundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    const dataRow = filteredData.find(d => d[gaulCodeField] === gaulCode);
    
    return {
      ...feature,
      properties: {
        ...feature.properties,
        cisReadiness: dataRow?.["cis_readiness_index"],
        cisReadinessClass: dataRow ? classifyTercile(dataRow["cis_readiness_index"], africaTerciles.cisReadiness) : "No data",
        weatherStation: dataRow?.["weather-station_density"],
        weatherStationClass: dataRow ? classifyTercile(dataRow["weather-station_density"], africaTerciles.weatherStation) : "No data",
        cloudCover: dataRow?.["cloud-coverage_meanannual"],
        cloudCoverClass: dataRow ? classifyTercile(dataRow["cloud-coverage_meanannual"], africaTerciles.cloudCover) : "No data",
        precipAgreement: dataRow ? parseFloat(dataRow["cv-precipitation_agreement"]) : null,
        precipAgreementClass: dataRow ? classifyPrecipAgreement(dataRow["cv-precipitation_agreement"]) : "No data",
        shortTerm: dataRow?.["short-term_frcst_skill"],
        longTerm: dataRow?.["seasonal_frcst_skill"]
      }
    };
  }).filter(f => f.properties.cisReadiness != null);
  
  return { type: "FeatureCollection", features };
}
```

```{ojs}
// Section 1.4 Visualization
{
  if (s14ViewType === "Map") {
    return Plot.plot({
      width: 2000,
      height: 1000,
      projection: {type: "mercator", domain: s14MapData},
      color: {
        type: "linear",
        domain: [0, 1],
        scheme: "RdYlGn",
        legend: true,
        label: "CIS Readiness Index (0-1)"
      },
      marks: [
        Plot.geo(s14MapData, {
          fill: d => d.properties.cisReadiness,
          stroke: "#333",
          strokeWidth: 0.5,
          title: d => `${d.properties.admin0_name || d.properties.admin1_name || d.properties.admin2_name}\n` +
                      `CIS Readiness: ${d.properties.cisReadiness?.toFixed(3) || 'N/A'}\n` +
                      `Class: ${d.properties.cisReadinessClass}\n` +
                      `Weather Station: ${d.properties.weatherStationClass}\n` +
                      `Cloud Cover: ${d.properties.cloudCoverClass}\n` +
                      `Precip Agreement: ${d.properties.precipAgreementClass}\n` +
                      `Short-term: ${d.properties.shortTerm?.toFixed(3) || 'N/A'}\n` +
                      `Long-term: ${d.properties.longTerm?.toFixed(3) || 'N/A'}`
        }),
        Plot.ruleX([s14Threshold])
      ]
    });
  } else if (s14ViewType === "Table") {
    const tableData = filteredData.map(d => {
      const adminName = currentAdminLevel === 0 
        ? d.admin0_name 
        : currentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      return {
        "Admin Name": adminName,
        "CIS Readiness (Raw)": d["cis_readiness_index"]?.toFixed(3) || "N/A",
        "CIS Readiness (Class)": classifyTercile(d["cis_readiness_index"], africaTerciles.cisReadiness),
        "Weather Station (Class)": classifyTercile(d["weather-station_density"], africaTerciles.weatherStation),
        "Cloud Cover (Class)": classifyTercile(d["cloud-coverage_meanannual"], africaTerciles.cloudCover),
        "Precip Agreement (Class)": classifyPrecipAgreement(d["cv-precipitation_agreement"]),
        "Short-term (Raw)": d["short-term_frcst_skill"]?.toFixed(3) || "N/A",
        "Long-term (Raw)": d["seasonal_frcst_skill"]?.toFixed(3) || "N/A"
      };
    });
    
    return Inputs.table(tableData, {
      sort: "CIS Readiness (Raw)",
      reverse: true,
      rows: 20
    });
  } else {
    // Heatmap
    const heatmapData = filteredData.map(d => ({
      admin: d[`admin${currentAdminLevel}_name`] || d.admin0_name,
      "Weather Stations": d["weather-station_density"],
      "Cloud Cover": d["cloud-coverage_meanannual"],
      "Precip Agreement": parseFloat(d["cv-precipitation_agreement"]) / 4, // Normalize to 0-1
      "Short-term Forecast": d["short-term_frcst_skill"],
      "Long-term Forecast": d["seasonal_frcst_skill"],
      "CIS Readiness": d["cis_readiness_index"]
    })).slice(0, 30); // Limit to 30 rows for readability
    
    const indicators = ["Weather Stations", "Cloud Cover", "Precip Agreement", "Short-term Forecast", "Long-term Forecast", "CIS Readiness"];
    
    const heatData = heatmapData.flatMap(row => 
      indicators.map(indicator => ({
        admin: row.admin,
        indicator: indicator,
        value: row[indicator]
      }))
    );
    
    return Plot.plot({
      width: 2000,
      height: Math.max(800, heatmapData.length * 30),
      marginLeft: 250,
      marginBottom: 120,
      x: { 
        label: null,
        tickRotate: -45
      },
      y: { label: null },
      color: {
        type: "linear",
        domain: [0, 1],
        scheme: "RdYlGn",
        legend: true,
        label: "Value (0-1)"
      },
      marks: [
        Plot.cell(heatData, {
          x: "indicator",
          y: "admin",
          fill: "value",
          title: d => `${d.admin}\n${d.indicator}: ${d.value?.toFixed(3) || 'N/A'}`
        })
      ]
    });
  }
}
```

```{ojs}
// Download button for Section 1.4
downloadButton(
  filteredData.map(d => {
    const adminName = currentAdminLevel === 0 
      ? d.admin0_name 
      : currentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    return {
      "Admin Name": adminName,
      "CIS Readiness Index": d["cis_readiness_index"],
      "Weather Station Density": d["weather-station_density"],
      "Cloud Coverage": d["cloud-coverage_meanannual"],
      "Precipitation Agreement": parseFloat(d["cv-precipitation_agreement"]),
      "Short-term Forecast Skill": d["short-term_frcst_skill"],
      "Long-term Forecast Skill": d["seasonal_frcst_skill"]
    };
  }),
  "cis_readiness_index",
  _lang(cis.downloadLabel)
)
```

```{ojs}
// Section 1.4 Dynamic Insight
s14Insight = {
  const avgReadiness = d3.mean(filteredData, d => d["cis_readiness_index"]);
  const readinessClass = classifyTercile(avgReadiness, africaTerciles.cisReadiness).toLowerCase();
  
  const aboveThreshold = filteredData.filter(d => d["cis_readiness_index"] >= s14Threshold).length;
  const total = filteredData.length;
  const pct = ((aboveThreshold / total) * 100).toFixed(1);
  
  return _lang({
    en: `In ${breadcrumb}, the overall CIS Readiness Index averages ${avgReadiness?.toFixed(3)}, classified as ${readinessClass} relative to Sub-Saharan Africa. ${pct}% of regions exceed the ${s14Threshold} readiness threshold.`,
    fr: `Dans ${breadcrumb}, l'indice global de préparation CIS est en moyenne ${avgReadiness?.toFixed(3)}, classé comme ${readinessClass} par rapport à l'Afrique subsaharienne. ${pct}% des régions dépassent le seuil de préparation ${s14Threshold}.`
  });
}
```

::: {.key-insights}
`{ojs} s14Insight`
:::
