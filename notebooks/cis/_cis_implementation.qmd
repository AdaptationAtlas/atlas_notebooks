```{ojs}
// ============================================================================
// SECTION 3: CIS READINESS × ACCESS/IMPLEMENTATION INTERSECTION
// ============================================================================
// This file analyzes the intersection between CIS readiness and digital/media
// access (TV, internet, cellphone). It identifies regions where CIS capacity
// exists but communication channels may limit uptake, and vice versa.
//
// Key Concepts:
// - Access Types: TV, Internet, Cellphone, and Combined average
// - Gap Analysis: Difference between readiness and access levels
// - Multiple Visualizations: Map, Dumbbell chart, Scatter plot, Table
//
// The bivariate approach mirrors Section 2, but uses access instead of hazard
// on the second dimension. "High × High" = optimal CIS deployment zones.
//
// Data Sources:
// - CIS_access.parquet: Digital access percentages at admin levels
// - Section 1 cisData: CIS readiness indicators (reused)
// ============================================================================

section3Title = _lang(cis.section3Title)
section31Title = _lang(cis.section31Title)
section31Intro = _lang(cis.section31Intro)
```

# `{ojs} section3Title` {#section3}

## `{ojs} section31Title` {#section3-1}

`{ojs} section31Intro`

```{ojs}
//| echo: false

// Synchronized admin selectors for Section 3 - these sync with the master selectors
// Note: createSyncedAdminSelector is defined in _cis_readiness_index.qmd
viewof s3Admin0 = createSyncedAdminSelector(0, viewof selectedAdmin0, uniqueAdmin0.map(d => ({ value: d, label: d })), "s3", _lang(cis.admin0Label), _lang(cis.admin0Placeholder))

viewof s3Admin1 = createSyncedAdminSelector(1, viewof selectedAdmin1, admin1Options.map(d => ({ value: d, label: d })), "s3", _lang(cis.admin1Label), _lang(cis.admin1Placeholder))

viewof s3Admin2 = createSyncedAdminSelector(2, viewof selectedAdmin2, admin2Options.map(d => ({ value: d, label: d })), "s3", _lang(cis.admin2Label), _lang(cis.admin2Placeholder))
```

```{ojs}
//| echo: false

// Check if loaded data has admin1 info
s3HasAdmin1Data = {
  if (!s3AccessData || s3AccessData.length === 0) return false;
  // Check first few rows for non-null admin1
  return s3AccessData.slice(0, 50).some(d => d.admin1_name !== null);
}

// Inline admin level selectors for this section - Region Selection
// Only show Admin 1/2 selectors if data supports it
htl.html`
<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
  <div style="flex: 1; min-width: 200px;">
    ${viewof s3Admin0}
  </div>
  <div style="flex: 1; min-width: 200px; display: ${s3HasAdmin1Data ? 'block' : 'none'};">
    ${viewof s3Admin1}
  </div>
  <div style="flex: 1; min-width: 200px; display: ${s3HasAdmin1Data ? 'block' : 'none'};">
    ${viewof s3Admin2}
  </div>
</div>
`
```

```{ojs}
//| echo: false

// ============================================================================
// ACCESS DATA LOADING AND CLEANING
// ============================================================================
// Load digital access data (TV, internet, cellphone percentages) and clean
// null values. Access data is stored as percentages (0-100) and normalized
// to 0-1 scale for comparison with CIS readiness.
// ============================================================================

s3AccessDB = await DuckDBClient.of({
  access_data: FileAttachment("/data/cis/CIS_access.parquet")
});

s3AccessDataRaw = await s3AccessDB.query(`SELECT * FROM access_data`);

// Transform access data with proper null handling and type parsing
// Note: "\\N" is a common null representation in database exports
s3AccessData = s3AccessDataRaw.map(row => ({
  admin0_name: row.admin0_name,
  admin1_name: row.admin1_name === "\\N" || row.admin1_name === "" ? null : row.admin1_name,
  admin2_name: row.admin2_name === "\\N" || row.admin2_name === "" ? null : row.admin2_name,
  iso3: row.iso3,
  // GAUL codes for geographic matching
  gaul0_code: row.gaul0_code !== "\\N" && row.gaul0_code !== "" && row.gaul0_code !== null ? parseInt(row.gaul0_code) : null,
  gaul1_code: row.gaul1_code !== "\\N" && row.gaul1_code !== "" && row.gaul1_code !== null ? parseInt(row.gaul1_code) : null,
  gaul2_code: row.gaul2_code !== "\\N" && row.gaul2_code !== "" && row.gaul2_code !== null ? parseInt(row.gaul2_code) : null,
  // Access percentages (0-100 scale)
  tv: row.tv !== "\\N" && row.tv !== null && row.tv !== "" ? parseFloat(row.tv) : null,
  internet: row.internet !== "\\N" && row.internet !== null && row.internet !== "" ? parseFloat(row.internet) : null,
  cellphone: row.cellphone !== "\\N" && row.cellphone !== null && row.cellphone !== "" ? parseFloat(row.cellphone) : null
}));

// ============================================================================
// AGGREGATION TO ADMIN0 LEVEL
// ============================================================================
// For Section 3, we aggregate both CIS readiness and access data to the
// country (Admin0) level by taking the mean across all sub-regions.
// This provides a country-level comparison of capacity vs. access.
// ============================================================================

// Aggregate CIS readiness to Admin0 (country) level
s3CisReadinessAdmin0 = {
  // Verify cisData is available from Section 1
  if (typeof cisData === 'undefined' || !cisData) {
    console.error("cisData is not available - Section 1 must load first");
    return [];
  }
  
  // Group by country and calculate mean CIS readiness
  const grouped = d3.rollup(
    cisData,
    v => ({
      cis_readiness_avg: d3.mean(v, d => d.cis_readiness_index),
      iso3: v[0].iso3,
      gaul0_code: v[0].gaul0_code
    }),
    d => d.admin0_name
  );
  
  // Convert Map to array of objects
  return Array.from(grouped, ([admin0_name, data]) => {
    return {
      admin0_name: admin0_name,
      ...data
    };
  });
}

// Aggregate access data to Admin0 (country) level
s3AccessAdmin0 = {
  // Group by country and calculate mean for each access type
  const grouped = d3.rollup(
    s3AccessData.filter(d => d.gaul0_code !== null),
    v => ({
      tv_avg: d3.mean(v, d => d.tv),
      internet_avg: d3.mean(v, d => d.internet),
      cellphone_avg: d3.mean(v, d => d.cellphone),
      iso3: v[0].iso3,
      gaul0_code: v[0].gaul0_code
    }),
    d => d.admin0_name
  );
  
  return Array.from(grouped, ([admin0_name, data]) => {
    return {
      admin0_name: admin0_name,
      ...data
    };
  });
}

// ============================================================================
// DATA JOINING: Combine CIS Readiness with Access Data
// ============================================================================
// Join the aggregated CIS readiness with aggregated access data.
// Use Admin 1/2 levels if data available and selected, otherwise default to Admin 0
// ============================================================================

section3Data = {
  // Determine which data level to use
  // If s3HasAdmin1Data is true, we should use the same logic as Section 1/2
  // For now, sticking to Admin 0 aggregation as per original design safe default,
  // but logic can be expanded here if Admin 1 data is confirmed available.
  
  return s3CisReadinessAdmin0.map(cis => {
    // Find matching access data by country name or ISO3 code
    const access = s3AccessAdmin0.find(a => 
      a.admin0_name === cis.admin0_name || a.iso3 === cis.iso3
    );
    
    if (!access) return null;
    
    // Calculate combined access: average of available indicators
    // This provides a single "overall access" metric
    const combined_access = (() => {
      const values = [access.tv_avg, access.internet_avg, access.cellphone_avg]
        .filter(v => v !== null && !isNaN(v));
      return values.length > 0 
        ? values.reduce((a, b) => a + b, 0) / values.length 
        : null;
    })();
    
    return {
      admin0_name: cis.admin0_name,
      iso3: cis.iso3 || access.iso3,
      gaul0_code: cis.gaul0_code || access.gaul0_code,
      cis_readiness_avg: cis.cis_readiness_avg,
      // Raw access percentages (0-100 scale)
      tv_pct: access.tv_avg,
      internet_pct: access.internet_avg,
      cellphone_pct: access.cellphone_avg,
      combined_pct: combined_access,
      // Normalized access values (0-1 scale, for comparison with CIS readiness)
      tv_norm: access.tv_avg !== null ? access.tv_avg / 100 : null,
      internet_norm: access.internet_avg !== null ? access.internet_avg / 100 : null,
      cellphone_norm: access.cellphone_avg !== null ? access.cellphone_avg / 100 : null,
      combined_norm: combined_access !== null ? combined_access / 100 : null
    };
  }).filter(d => d !== null);
}

// Note: cisReadinessCutoffs is defined in Section 2 (_cis_hazard_intersection.qmd)
// and reused here to ensure consistent readiness classification across sections
```

```{ojs}
//| echo: false

// Access Type Selector
viewof s3AccessType = Inputs.radio(
  ["combined", "internet", "tv", "cellphone"],
  {
    label: _lang(cis.s3AccessSelector),
    value: "combined",
    format: x => x === "combined" ? _lang(cis.s3AccessCombined) :
                 x === "internet" ? _lang(cis.s3AccessInternet) :
                 x === "tv" ? _lang(cis.s3AccessTV) :
                 _lang(cis.s3AccessCellphone)
  }
)
```

```{ojs}
//| echo: false

// View Toggle
viewof s3ViewType = Inputs.radio(
  ["map", "dumbbell", "scatter", "table"],
  {
    label: _lang(cis.s3ViewToggle),
    value: "map",
    format: x => x === "map" ? _lang(cis.s3ViewMap) :
                 x === "dumbbell" ? _lang(cis.s3ViewDumbbell) :
                 x === "scatter" ? _lang(cis.s3ViewScatter) :
                 _lang(cis.s3ViewTable)
  }
)

// Map Type Toggle (Only shown when view type is map)
viewof s3MapType = {
  if (s3ViewType !== "map") {
     const input = Inputs.radio(["bivariate"], {label: "Map Type", value: "bivariate"});
     input.style.display = "none";
     return input;
  }
  return Inputs.radio(["bivariate", "univariate"], {
    label: "Map Type",
    value: "bivariate", 
    format: x => x === "bivariate" ? "Bivariate (Readiness × Access)" : "Access Distribution"
  });
}
```

```{ojs}
//| echo: false

// Sort By Selector - only shown when view type is not "map"
viewof s3SortBy = {
  if (s3ViewType === "map") {
    // Return a hidden selector that maintains state but isn't displayed
    const input = Inputs.select(
      ["readiness", "combined", "internet", "tv", "cellphone"],
      {
        label: _lang(cis.s3SortBy),
        value: "readiness"
      }
    );
    input.style.display = "none";
    return input;
  }
  
  return Inputs.select(
    ["readiness", "combined", "internet", "tv", "cellphone"],
    {
      label: _lang(cis.s3SortBy),
      value: "readiness",
      format: x => x === "readiness" ? _lang(cis.s3SortReadiness) :
                   x === "combined" ? _lang(cis.s3AccessCombined) :
                   x === "internet" ? _lang(cis.s3AccessInternet) :
                   x === "tv" ? _lang(cis.s3AccessTV) :
                   _lang(cis.s3AccessCellphone)
    }
  );
}
```

```{ojs}
//| echo: false

// Filter Countries Multi-select
s3UniqueCountries = {
  const countries = Array.from(new Set((section3Data || []).map(d => d.admin0_name))).sort();
  return countries;
}

viewof s3FilteredCountries = {
  if (!s3UniqueCountries || s3UniqueCountries.length === 0) {
    return Inputs.select([], {label: _lang(cis.s3FilterCountries), disabled: true});
  }
  return multiSelect({
    inputLabel: _lang(cis.s3FilterCountries),
    inputId: "s3FilterCountries",
    placeholderText: _lang(cis.admin0Placeholder),
    options: s3UniqueCountries.map(d => ({ value: d, label: d })),
    selected: s3UniqueCountries // Select all by default
  });
}
```

```{ojs}
//| echo: false

// Highlight Countries Multi-select (for scatter plot only)
viewof s3HighlightedCountries = {
  // Only show when view type is scatter
  if (s3ViewType !== "scatter") {
    const input = Inputs.select([], {label: _lang(cis.s3HighlightCountries)});
    input.style.display = "none";
    input.value = [];
    return input;
  }
  
  if (!s3UniqueCountries || s3UniqueCountries.length === 0) {
    return Inputs.select([], {label: _lang(cis.s3HighlightCountries), disabled: true});
  }
  return multiSelect({
    inputLabel: _lang(cis.s3HighlightCountries),
    inputId: "s3HighlightCountries",
    placeholderText: _lang(cis.admin0Placeholder),
    options: s3UniqueCountries.map(d => ({ value: d, label: d })),
    selected: [] // None selected by default
  });
}
```

```{ojs}
//| echo: false

// View Toggle

// Helper to get current access field name
s3CurrentAccessField = s3AccessType === "combined" ? "combined_norm" :
                       s3AccessType === "internet" ? "internet_norm" :
                       s3AccessType === "tv" ? "tv_norm" :
                       "cellphone_norm"

// Helper to get current access label
s3CurrentAccessLabel = s3AccessType === "combined" ? _lang(cis.s3AccessCombined) :
                       s3AccessType === "internet" ? _lang(cis.s3AccessInternet) :
                       s3AccessType === "tv" ? _lang(cis.s3AccessTV) :
                       _lang(cis.s3AccessCellphone)

// Helper to get current access raw field
s3CurrentAccessRawField = s3AccessType === "combined" ? "combined_pct" :
                          s3AccessType === "internet" ? "internet_pct" :
                          s3AccessType === "tv" ? "tv_pct" :
                          "cellphone_pct"
```

```{ojs}
//| echo: false

// ============================================================================
// FILTERED & SORTED DATA PREPARATION
// ============================================================================

// Filter data based on country selection in multi-select
s3FilteredData = {
  if (!section3Data || section3Data.length === 0) {
    return [];
  }
  
  // If no countries selected in filter, show all; otherwise filter to selection
  return section3Data.filter(d => 
    !s3FilteredCountries || s3FilteredCountries.length === 0 || s3FilteredCountries.includes(d.admin0_name)
  );
}
```

```{ojs}
//| echo: false

// ============================================================================
// ACCESS TERCILE CUTOFFS (Dynamic)
// ============================================================================
// Unlike CIS readiness (which uses pre-computed cutoffs), access cutoffs
// are computed dynamically from the filtered data. This allows the
// bivariate classification to adapt to the current selection.
// ============================================================================

s3AccessCutoffs = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return { low: 0.33, moderate: 0.67 };  // Default fallback
  }
  
  // Extract values for the currently selected access type
  const values = s3FilteredData
    .map(d => d[s3CurrentAccessField])
    .filter(v => v !== null && !isNaN(v))
    .sort((a, b) => a - b);
  
  if (values.length === 0) {
    return { low: 0.33, moderate: 0.67 };
  }
  
  // Calculate tercile cutoffs (33.3% and 66.7% quantiles)
  return {
    low: d3.quantile(values, 0.333),
    moderate: d3.quantile(values, 0.667)
  };
}
```

```{ojs}
//| echo: false

// ============================================================================
// BIVARIATE CLASSIFICATION FOR ACCESS
// ============================================================================
// Similar to Section 2's bivariateClassify, but uses access level instead
// of hazard severity. The "High × High" zone indicates optimal regions
// for CIS deployment (high capacity AND high communication reach).
// ============================================================================

function bivariateClassifyAccess(readiness, access, readinessCutoffs, accessCutoffs) {
  // Classify CIS readiness
  let readinessClass;
  if (readiness < readinessCutoffs.low) readinessClass = "Low";
  else if (readiness < readinessCutoffs.moderate) readinessClass = "Moderate";
  else readinessClass = "High";
  
  // Classify access level (using dynamic tercile cutoffs)
  let accessClass;
  if (access === null || isNaN(access)) accessClass = "N/A";
  else if (access < accessCutoffs.low) accessClass = "Low";
  else if (access < accessCutoffs.moderate) accessClass = "Moderate";
  else accessClass = "High";
  
  return {
    readinessClass,
    accessClass,
    bivariateClass: accessClass === "N/A" ? "N/A" : `${readinessClass} × ${accessClass}`
  };
}

// Bivariate color palette (reused from Section 2 for consistency)
s3BivariateColors = {
  return {
    "Low × Low": "#e8e8e8",        // Low priority
    "Low × Moderate": "#b8d6be",
    "Low × High": "#6c9a8b",        // High access but low readiness
    "Moderate × Low": "#c8b2d6",
    "Moderate × Moderate": "#9c9eba",
    "Moderate × High": "#627a8e",
    "High × Low": "#b8a0c2",        // High readiness but low access (capacity gap)
    "High × Moderate": "#8b7fa8",
    "High × High": "#5a5f8f",       // OPTIMAL - scale CIS here
    "N/A": "#cccccc"                // No access data available
  };
}
```

```{ojs}
//| echo: false

// Process data with bivariate classification
s3ProcessedData = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return [];
  }
  
  return s3FilteredData.map(d => {
    const accessValue = d[s3CurrentAccessField];
    const classification = bivariateClassifyAccess(
      d.cis_readiness_avg,
      accessValue,
      cisReadinessCutoffs,
      s3AccessCutoffs
    );
    
    return {
      ...d,
      accessValue,
      ...classification,
      gap: accessValue !== null && !isNaN(accessValue) ? accessValue - d.cis_readiness_avg : null
    };
  });
}
```

```{ojs}
//| echo: false

// Sort data based on selected metric
s3SortedData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
    return [];
  }
  
  const data = [...s3ProcessedData];
  
  if (s3SortBy === "readiness") {
    return data.sort((a, b) => (b.cis_readiness_avg || 0) - (a.cis_readiness_avg || 0));
  } else if (s3SortBy === "combined") {
    return data.sort((a, b) => (b.combined_norm || 0) - (a.combined_norm || 0));
  } else if (s3SortBy === "internet") {
    return data.sort((a, b) => (b.internet_norm || 0) - (a.internet_norm || 0));
  } else if (s3SortBy === "tv") {
    return data.sort((a, b) => (b.tv_norm || 0) - (a.tv_norm || 0));
  } else if (s3SortBy === "cellphone") {
    return data.sort((a, b) => (b.cellphone_norm || 0) - (a.cellphone_norm || 0));
  }
  
  return data;
}
```

```{ojs}
//| echo: false

// Prepare geographic data for map - dynamically show admin levels based on selection
// Use the master admin selectors (selectedAdmin0, etc.) for consistency with other sections
s3GeoData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
    return { type: "FeatureCollection", features: [] };
  }
  
  // Use master admin selections (same as Section 1 and 2)
  const selectedCountries = selectedAdmin0 || [];
  const selectedAdmin1s = selectedAdmin1 || [];
  const selectedAdmin2s = selectedAdmin2 || [];
  
  let boundaries = null;
  let levelKey = "admin0_name";
  let gaul_key = "gaul0_code";
  
  // Determine which admin level to show based on currentAdminLevel from Section 1
  // Level 0: No admin0 selected - show all admin0
  // Level 1: Admin0 selected but no admin1 - show admin1 within selected countries
  // Level 2: Admin1 selected - show admin2 within selected admin1s
  if (currentAdminLevel === 2 && admin2Boundaries) {
    boundaries = admin2Boundaries;
    levelKey = "admin2_name";
    gaul_key = "gaul2_code";
  } else if (currentAdminLevel === 1 && admin1Boundaries) {
    boundaries = admin1Boundaries;
    levelKey = "admin1_name";
    gaul_key = "gaul1_code";
  } else if (admin0Boundaries) {
    boundaries = admin0Boundaries;
    levelKey = "admin0_name";
    gaul_key = "gaul0_code";
  }
  
  if (!boundaries) {
    return { type: "FeatureCollection", features: [] };
  }
  
  // Filter boundaries based on current selection
  let filteredBoundaries = boundaries;
  if (currentAdminLevel === 2) {
    // Show only admin2 within selected admin1s
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => 
        selectedCountries.includes(f.properties.admin0_name) &&
        selectedAdmin1s.includes(f.properties.admin1_name)
      )
    };
  } else if (currentAdminLevel === 1) {
    // Show only admin1 within selected countries
    filteredBoundaries = {
      ...boundaries,
      features: boundaries.features.filter(f => 
        selectedCountries.includes(f.properties.admin0_name)
      )
    };
  }
  // Level 0: show all countries (no filtering needed)
  
  // Map data to boundaries
  const features = filteredBoundaries.features.map(feature => {
    // Find the parent admin0 for this feature (data is at country level)
    const parentCountry = feature.properties.admin0_name;
    const countryData = s3ProcessedData.find(d => d.admin0_name === parentCountry);
    
    if (!countryData) return null;
    
    // Check if this region is highlighted (for admin2 level)
    const isHighlighted = currentAdminLevel === 2 && 
                          selectedAdmin2s.length > 0 && 
                          selectedAdmin2s.includes(feature.properties.admin2_name);
    
    return {
      type: "Feature",
      geometry: feature.geometry,
      properties: {
        ...feature.properties,
        ...countryData,
        displayName: feature.properties[levelKey] || feature.properties.admin0_name,
        isHighlighted: isHighlighted
      }
    };
  }).filter(f => f !== null);
  
  return {
    type: "FeatureCollection",
    features
  };
}
```

### Visualization

```{ojs}
//| echo: false

// Section 3 Map Display (Handles both Bivariate and Univariate)
s3MapDisplay = {
  if (s3ViewType !== "map") return null;
  
  if (s3MapType === "univariate") {
    return createS3AccessMap();
  } else {
    return createS3BivariateMap();
  }
}

// Access Map (Univariate)
function createS3AccessMap() {
  const height = 610;
  const width = 775;
  const padding = 20;

  // Cleanup tooltips
  d3.select(".s3AccessMapTip").remove();
  
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plot-tip s3AccessMapTip") // reusing css from shared styles
    .style("position", "absolute")
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("z-index", "1000")
    .style("background", "rgba(255, 255, 255, 0.95)")
    .style("padding", "10px")
    .style("border", "1px solid #ccc")
    .style("border-radius", "4px");

  const projection = d3.geoMercator();
  const geo_path = d3.geoPath().projection(projection);
  
  // Linear color scale for access (0-1)
  const color = d3.scaleSequential(d3.interpolateBlues).domain([0, 1]);

  projection.fitExtent(
    [
      [padding, padding],
      [width - padding, height - padding]
    ],
    s3GeoData
  );

  const svg = d3.create("svg")
    .attr("viewBox", [0, 0, width, height])
    .attr("style", "overflow: visible;");

  svg.append("g")
    .selectAll("path")
    .data(s3GeoData.features)
    .join("path")
    .attr("fill", d => {
        const val = d.properties.accessValue;
        return (val !== null && !isNaN(val)) ? color(val) : "#ccc";
    })
    .attr("stroke", "white")
    .attr("stroke-width", 0.5)
    .attr("d", geo_path)
    .on("mousemove", (event, d) => {
        const val = d.properties.accessValue;
        const valPct = (val * 100).toFixed(1) + "%";
        tooltip.style("opacity", 1)
               .style("left", (event.pageX + 10) + "px")
               .style("top", (event.pageY - 10) + "px")
               .html(`<strong>${d.properties.admin0_name}</strong><br>${s3CurrentAccessLabel}: ${valPct}`);
    })
    .on("mouseout", () => tooltip.style("opacity", 0));
    
  // Simple Legend for Univariate Map
  // ... (Can use Plot.legend or d3 equivalent if needed, for brevity using simple gradient bar logic could be complex here so skipping complex legend for now, relies on tooltip)
  
  return svg.node();
}


// Section 3 bivariate map with diamond legend (matching Section 2 style)
function createS3BivariateMap() {
  if (s3ViewType !== "map") return null;
  
  const height = 610;
  const width = 775;
  const padding = 20;
  
  // Remove existing tooltip
  d3.select(".s3BivariateTip").remove();
  
  // Add CSS for consistent tooltip styling
  if (!d3.select("style#s3BivariateTipStyles").node()) {
    d3.select("head").append("style")
      .attr("id", "s3BivariateTipStyles")
      .text(`
        .s3BivariateTip,
        .s3BivariateLegendTip {
          font-size: 14px !important;
          padding: 10px 12px !important;
          line-height: 1.5 !important;
          background: rgba(255, 255, 255, 0.95) !important;
          border: 1px solid #ccc !important;
          border-radius: 4px !important;
          box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
        }
        .s3BivariateTip table,
        .s3BivariateLegendTip table {
          font-size: 14px !important;
        }
        .s3BivariateTip th,
        .s3BivariateTip td,
        .s3BivariateLegendTip th,
        .s3BivariateLegendTip td {
          padding: 4px 8px !important;
          font-size: 14px !important;
          line-height: 1.4 !important;
        }
        .s3BivariateTip th,
        .s3BivariateLegendTip th {
          font-weight: 600 !important;
          font-size: 14px !important;
        }
        .s3BivariateTip *,
        .s3BivariateLegendTip * {
          font-size: 14px !important;
        }
      `);
  }
  
  // Create tooltip matching Plot.tip style
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plot-tip s3BivariateTip")
    .style("position", "absolute")
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("z-index", "1000");
  
  const projection = d3.geoMercator();
  const geo_path = d3.geoPath().projection(projection);
  const color = d3.scaleOrdinal()
    .domain(["Low × Low", "Low × Moderate", "Low × High", "Moderate × Low", "Moderate × Moderate", "Moderate × High", "High × Low", "High × Moderate", "High × High"])
    .range(Object.values(s3BivariateColors));
  
  // Fit projection to features - leave space at bottom for legend
  const bottomPadding = 100; // Reduced for tighter integration
  const leftPadding = 80; // Reduced left padding
  projection.fitExtent(
    [
      [padding + leftPadding, padding],
      [width - padding, height - padding]
    ],
    s3GeoData
  );
  
  // Compact viewBox for tighter legend integration
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 900, 700])
    .attr("style", "overflow: visible;")
    .attr("title", "Bivariate Map");
  
  // Render paths
  const paths = svg
    .append("g")
    .selectAll("path")
    .data(s3GeoData.features)
    .join("path")
    .attr("stroke", d => d.properties.isHighlighted ? "#000" : "white")
    .attr("stroke-width", d => d.properties.isHighlighted ? "2.5px" : "1px")
    .attr("fill", (d) => {
      return color(d.properties.bivariateClass) || "#cccccc";
    })
    .attr("d", geo_path);
  
  // Tooltip on mousemove with hover effect
  paths
    .on("mouseover", function(event, d) {
      // Change stroke to black on hover
      d3.select(this).attr("stroke", "black").attr("stroke-width", "2px");
    })
    .on("mousemove", (event, d) => {
      const regionName = d.properties.displayName || d.properties.admin0_name;
      const readiness = d.properties.cis_readiness_avg;
      const readinessClass = d.properties.readinessClass;
      const access = d.properties.accessValue;
      const accessClass = d.properties.accessClass;
      const category = d.properties.bivariateClass;
      const optimal = d.properties.bivariateClass === "High × High";
      
      // Determine label based on which boundaries are shown
      let regionLabel = "Country";
      if (d.properties.gaul2_code) {
        regionLabel = "District";
      } else if (d.properties.gaul1_code && !d.properties.gaul2_code) {
        regionLabel = "Region";
      }
      
      // Format tooltip as table matching Plot.tip pattern
      const tooltipHtml = `
        <table>
          <tr><th>${regionLabel}</th><td>${regionName || "N/A"}</td></tr>
          <tr><th>${_lang(cis.s3ReadinessLabel)}</th><td>${readiness != null ? readiness.toFixed(2) : "N/A"}</td></tr>
          <tr><th>Readiness Class</th><td>${readinessClass || "N/A"}</td></tr>
          <tr><th>${s3CurrentAccessLabel}</th><td>${access != null ? (access * 100).toFixed(1) + '%' : "N/A"}</td></tr>
          <tr><th>Access Class</th><td>${accessClass || "N/A"}</td></tr>
          <tr><th>Category</th><td>${category || "N/A"}</td></tr>
          ${optimal ? `<tr><th>Optimal Zone</th><td>✓ ${_lang(cis.s3OptimalZone)}</td></tr>` : ""}
        </table>
      `;
      
      tooltip
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1)
        .html(tooltipHtml);
    })
    .on("mouseout", function(event, d) {
      // Revert stroke to white (or keep highlighted if selected)
      const isHighlighted = d.properties.isHighlighted;
      d3.select(this)
        .attr("stroke", isHighlighted ? "black" : "white")
        .attr("stroke-width", isHighlighted ? "2.5px" : "1px");
      
      tooltip.style("opacity", 0);
    });
  
  // Add mesh/boundaries
  const mesh = svg
    .append("path")
    .datum(s3GeoData)
    .attr("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-linejoin", "round")
    .attr("d", geo_path);
  
  // Create legend tooltip (separate from map tooltip) - matching Plot.tip style
  d3.select(".s3BivariateLegendTip").remove();
  const legendTooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plot-tip s3BivariateLegendTip")
    .style("position", "absolute")
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("z-index", "1000");
  
  // Create bi_legend function (diamond shape - matching Section 2)
  function bi_legend(selection) {
    const size = 40;
    const gap = 2;
    // Order classes High -> Low to place High-High at Top (0,0) and Low-Low at Bottom (2,2)
    const classes = ["High", "Moderate", "Low"];
    const totalWidth = size * 3 + gap * 2;
    const totalHeight = size * 3 + gap * 2;
    const centerX = totalWidth / 2;
    const centerY = totalHeight / 2;
    
    // Create inner group for the legend content (will be rotated)
    const legendContent = selection.append("g");
    
    // Legend squares with hover tooltips
    // i = rows (Access), j = cols (Readiness)
    classes.forEach((accessClass, i) => {
      classes.forEach((readinessClass, j) => {
        const key = `${readinessClass} × ${accessClass}`;
        const isPriority = readinessClass === "High" && accessClass === "High";
        
        const rect = legendContent
          .append("rect")
          .attr("x", j * (size + gap))
          .attr("y", i * (size + gap))
          .attr("width", size)
          .attr("height", size)
          //.attr("fill", s3BivariateColors[key] || "#cccccc") // Use helper or global
          .attr("fill", (d) => {
             return s3BivariateColors[key] || "#cccccc";
          })
          .attr("stroke", isPriority ? "#000" : "#999")
          .attr("stroke-width", isPriority ? "2.5" : "0.5")
          .style("cursor", "pointer");
        
        // Add hover tooltip
        rect
          .on("mousemove", (event) => {
            const tooltipHtml = `
              <table>
                <tr><th>CIS Readiness</th><td>${readinessClass}</td></tr>
                <tr><th>${s3CurrentAccessLabel}</th><td>${accessClass}</td></tr>
                <tr><th>Category</th><td>${key}</td></tr>
              </table>
            `;
            legendTooltip
              .style("top", event.pageY - 10 + "px")
              .style("left", event.pageX + 10 + "px")
              .style("opacity", 1)
              .html(tooltipHtml);
          })
          .on("mouseout", () => {
            legendTooltip.style("opacity", 0);
          });
      });
    });
    
    // Axes and Labels
    
    // Readiness Arrow (Along Bottom Edge: Right -> Left)
    legendContent.append("line")
      .attr("x1", totalWidth)
      .attr("y1", totalHeight + 8)
      .attr("x2", 0)
      .attr("y2", totalHeight + 8)
      .attr("stroke", "#333")
      .attr("stroke-width", 1.5)
      .attr("marker-end", "url(#arrowhead)");

    // Readiness Label
    legendContent.append("text")
      .attr("x", totalWidth / 2)
      .attr("y", totalHeight + 22)
      .attr("text-anchor", "middle")
      .attr("font-size", "11px")
      .attr("font-weight", "bold")
      .attr("fill", "#333")
      .text("CIS Readiness");

    // Access Arrow (Along Right Edge: Bottom -> Top)
    legendContent.append("line")
      .attr("x1", totalWidth + 8)
      .attr("y1", totalHeight)
      .attr("x2", totalWidth + 8)
      .attr("y2", 0)
      .attr("stroke", "#333")
      .attr("stroke-width", 1.5)
      .attr("marker-end", "url(#arrowhead)");

    // Access Label (using s3CurrentAccessLabel for dynamic type)
    legendContent.append("text")
      .attr("x", totalWidth + 22)
      .attr("y", totalHeight / 2)
      .attr("text-anchor", "middle")
      .attr("font-size", "11px")
      .attr("font-weight", "bold")
      .attr("fill", "#333")
      .attr("transform", `rotate(-90, ${totalWidth + 22}, ${totalHeight / 2})`)
      .text(s3AccessType === "combined" ? "Combined Access" : s3CurrentAccessLabel);

    // Reuse arrow marker (assumed defined in main SVG or duplicated here if scope issues)
    // To be safe, adding defs here too
    const defs = selection.append("defs");
    defs.append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 8)
      .attr("refY", 5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", "#333");

    // Rotate the entire legend 45 degrees
    legendContent.attr("transform", `rotate(45, ${centerX}, ${centerY})`);
    
    return selection;
  }
        
  
  // Add legend to SVG - positioned at bottom-left to match Section 2
  const legendX = 80;
  const legendY = height - 180;
  const legendGroup = svg
    .append("g")
    .attr("transform", `translate(${legendX}, ${legendY})`);
  
  // Apply the legend function to the group using .call()
  legendGroup.call(bi_legend);
  
  return svg.node();
}
```

```{ojs}
//| echo: false

// Render based on view type
{
  if (s3ViewType === "map") {
    yield html`<div style="width: 100%; overflow-x: auto;">
      ${s3MapDisplay}
    </div>`;
  } else if (s3ViewType === "dumbbell") {
    // Clean up any leftover tooltips from map view
    d3.select(".s3BivariateTip").remove();
    d3.select(".s3BivariateLegendTip").remove();
    d3.select(".s3AccessMapTip").remove();
    
    // Dumbbell Chart - inline to prevent auto-display
  if (!s3SortedData || s3SortedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Dumbbell chart will appear once data is loaded...</em>
    </div>`;
    } else {
  const chartHeight = Math.max(600, s3SortedData.length * 25);
  const linkData = s3SortedData.filter(d => d.accessValue !== null && !isNaN(d.accessValue));
  const accessData = s3SortedData.filter(d => d.accessValue !== null && !isNaN(d.accessValue));
  
      yield html`<div style="width: 100%; overflow-x: auto;">
    <div style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="display: flex; gap: 20px; align-items: center; font-size: 12px;">
        <div><span style="color: #377eb8;">●</span> ${_lang(cis.s3ReadinessLabel)}</div>
            <div><span style="color: #ff7f00;">●</span> ${s3CurrentAccessLabel}</div>
        <div><span style="color: #4daf4a;">━</span> ${_lang(cis.s3PositiveGap)}</div>
        <div><span style="color: #e41a1c;">━</span> ${_lang(cis.s3NegativeGap)}</div>
        <div><span style="color: #999999;">━</span> Similar values</div>
      </div>
    </div>
    ${Plot.plot({
      width: 1200,
      height: chartHeight,
      marginLeft: 150,
      marginRight: 50,
      marginTop: 80,
      marginBottom: 80,
      x: {
        domain: d3.extent([...s3SortedData.map(d => d.cis_readiness_avg || 0), ...s3SortedData.map(d => d.accessValue || 0)]),
        label: "Value",
        grid: true,
        axis: "top"
      },
      y: {
        label: null,
        domain: s3SortedData.map(d => d.admin0_name)
      },
      marks: [
        Plot.axisX({anchor: "bottom", label: "Value"}),
        // Connecting lines
        Plot.link(linkData, {
          x1: "cis_readiness_avg",
          x2: "accessValue",
          y1: "admin0_name",
          y2: "admin0_name",
              stroke: d => {
                if (d.gap === null || isNaN(d.gap)) return "#999999";
                return d.gap > 0.05 ? "#4daf4a" : d.gap < -0.05 ? "#e41a1c" : "#999999";
              },
          strokeWidth: 2
        }),
        // Readiness dots (left) - with tooltip
        Plot.dot(s3SortedData, {
          x: "cis_readiness_avg",
          y: "admin0_name",
          fill: "#377eb8",
          r: 5,
          tip: {
            fontSize: 14,
            format: {
              x: d => `Readiness: ${d != null ? d.toFixed(3) : "N/A"}`
            },
            channels: {
              country: { label: "Country", value: d => d.admin0_name },
              readiness: { label: _lang(cis.s3ReadinessLabel), value: d => d.cis_readiness_avg },
              access: { label: s3CurrentAccessLabel, value: d => d.accessValue },
              gap: { label: _lang(cis.s3GapLabel), value: d => d.gap }
            },
            format: {
              country: true,
              x: false,
              y: false,
              readiness: d => d != null ? d.toFixed(3) : "N/A",
              access: d => d != null ? (d * 100).toFixed(1) + '%' : "N/A",
              gap: d => {
                if (d == null || isNaN(d)) return "N/A";
                const label = d > 0 ? _lang(cis.s3PositiveGap) : _lang(cis.s3NegativeGap);
                return `${d.toFixed(3)} (${label})`;
              }
            }
          }
        }),
        // Access dots (right) - with tooltip (using circle for consistency)
        Plot.dot(accessData, {
          x: "accessValue",
          y: "admin0_name",
          fill: "#ff7f00",
          r: 5,
          stroke: "#ff7f00",
          strokeWidth: 2,
          tip: {
            fontSize: 14,
            channels: {
              country: { label: "Country", value: d => d.admin0_name },
              readiness: { label: _lang(cis.s3ReadinessLabel), value: d => d.cis_readiness_avg },
              access: { label: s3CurrentAccessLabel, value: d => d.accessValue },
              gap: { label: _lang(cis.s3GapLabel), value: d => d.gap }
            },
            format: {
              country: true,
              x: false,
              y: false,
              readiness: d => d != null ? d.toFixed(3) : "N/A",
              access: d => d != null ? (d * 100).toFixed(1) + '%' : "N/A",
              gap: d => {
                if (d == null || isNaN(d)) return "N/A";
                const label = d > 0 ? _lang(cis.s3PositiveGap) : _lang(cis.s3NegativeGap);
                return `${d.toFixed(3)} (${label})`;
              }
            }
          }
        })
      ]
    })}
    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="display: flex; gap: 20px; align-items: center; font-size: 12px;">
        <div><span style="color: #377eb8;">●</span> ${_lang(cis.s3ReadinessLabel)}</div>
            <div><span style="color: #ff7f00;">●</span> ${s3CurrentAccessLabel}</div>
        <div><span style="color: #4daf4a;">━</span> ${_lang(cis.s3PositiveGap)}</div>
        <div><span style="color: #e41a1c;">━</span> ${_lang(cis.s3NegativeGap)}</div>
        <div><span style="color: #999999;">━</span> Similar values</div>
      </div>
    </div>
    <div style="margin-top: 10px;">
       ${s3DownloadButton} 
    </div>
  </div>`;
}
  } else if (s3ViewType === "scatter") {
    // Clean up any leftover tooltips from map view
    d3.select(".s3BivariateTip").remove();
    d3.select(".s3BivariateLegendTip").remove();
    
    // Faceted Scatter Plot - showing all access types
    if (!s3ProcessedData || s3ProcessedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
        <em>Scatter plot will appear once data is loaded...</em>
      </div>`;
    } else {
      // Prepare data for faceting - create separate data points for each access type
      const facetData = [];
      s3ProcessedData.forEach(d => {
        if (d.combined_norm != null && !isNaN(d.combined_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessCombined),
            accessValue: d.combined_norm,
            accessKey: "combined"
          });
        }
        if (d.internet_norm != null && !isNaN(d.internet_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessInternet),
            accessValue: d.internet_norm,
            accessKey: "internet"
          });
        }
        if (d.tv_norm != null && !isNaN(d.tv_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessTV),
            accessValue: d.tv_norm,
            accessKey: "tv"
          });
        }
        if (d.cellphone_norm != null && !isNaN(d.cellphone_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessCellphone),
            accessValue: d.cellphone_norm,
            accessKey: "cellphone"
          });
        }
      });
      
      // Setup 2x2 facet grid using index-based mapping
      const n = 2; // Number of columns for 2x2 grid
      const accessTypes = [
        _lang(cis.s3AccessCombined), 
        _lang(cis.s3AccessInternet), 
        _lang(cis.s3AccessTV), 
        _lang(cis.s3AccessCellphone)
      ];
      const accessIndex = new Map(accessTypes.map((key, i) => [key, i]));
      const getFx = (key) => accessIndex.get(key) % n;
      const getFy = (key) => Math.floor(accessIndex.get(key) / n);
      
      yield html`<div style="width: 100%; overflow-x: auto;">
        <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
          <div style="font-size: 12px;">
            <strong>${_lang(cis.s3ParityLine)}:</strong> Points above the line indicate access exceeds readiness; points below indicate readiness exceeds access.
          </div>
        </div>
        ${Plot.plot((() => {
          return {
          width: 900,
          height: 700,
          marginTop: 40,
          marginRight: 40,
          marginBottom: 60,
          marginLeft: 60,
          grid: true,
          x: {
            domain: d3.extent(facetData, d => d.cis_readiness_avg),
            label: _lang(cis.s3ReadinessLabel) + " →"
          },
          y: {
            // Dynamic domain based on data range
            // domain: d3.extent(facetData, d => d.accessValue),
            label: "Access →"
          },
          color: {
            legend: true
          },
          fx: {
            label: null,
            padding: 0.08,
            tickFormat: null  // Hide fx tick labels, we use text marks for labels
          },
          fy: {
            label: null,
            padding: 0.08,
            tickFormat: null  // Hide fy tick labels
          },
          marks: [
            // Parity lines per facet
            ...accessTypes.map(accessType => 
              Plot.line([[0, 0], [1, 1]], {
                stroke: "#999",
                strokeWidth: 1.5,
                strokeDasharray: "4,4",
                fx: getFx(accessType),
                fy: getFy(accessType)
              })
            ),
            // Facet labels at top-left of each panel
            Plot.text(accessTypes, {
              fx: d => getFx(d),
              fy: d => getFy(d),
              text: d => d,
              frameAnchor: "top-left",
              dx: 6,
              dy: 6,
              fontWeight: "bold",
              fontSize: 11
            }),
            Plot.frame(),
            // All countries (not highlighted)
            Plot.dot(
              facetData.filter(d => !s3HighlightedCountries.includes(d.admin0_name)),
              {
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: d => getFx(d.accessType),
                fy: d => getFy(d.accessType),
                fill: d => {
                  // Calculate bivariate class for this specific access type using dynamic cutoffs
                  const readinessClass = d.cis_readiness_avg >= cisReadinessCutoffs.moderate ? "High" : d.cis_readiness_avg >= cisReadinessCutoffs.low ? "Moderate" : "Low";
                  const accessClass = d.accessValue >= s3AccessCutoffs.moderate ? "High" : d.accessValue >= s3AccessCutoffs.low ? "Moderate" : "Low";
                  return s3BivariateColors[`${readinessClass} × ${accessClass}`] || "#cccccc";
                },
                stroke: "#333",
                strokeWidth: 0.5,
                r: 4
              }
            ),
            // Highlighted countries
            Plot.dot(
              facetData.filter(d => s3HighlightedCountries.includes(d.admin0_name)),
              {
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: d => getFx(d.accessType),
                fy: d => getFy(d.accessType),
                fill: "#0066cc",
                stroke: "#000",
                strokeWidth: 1.5,
                r: 6
              }
            ),
            // Tooltips
            Plot.tip(
              facetData,
              Plot.pointer({
                fontSize: 14,
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: d => getFx(d.accessType),
                fy: d => getFy(d.accessType),
                channels: {
                  country: {
                    label: "Country",
                    value: (d) => d.admin0_name
                  },
                  readiness: {
                    label: _lang(cis.s3ReadinessLabel),
                    value: (d) => d.cis_readiness_avg
                  },
                  access: {
                    label: "Access",
                    value: (d) => d.accessValue
                  }
                },
                format: {
                  country: true,
                  readiness: (d) => d != null ? d.toFixed(3) : "N/A",
                  access: (d) => d != null ? (d * 100).toFixed(1) + '%' : "N/A",
                  fx: false, // Ensure facet keys don't show in tooltip
                  fy: false 
                }
              })
            ),
            // Labels for highlighted countries
            Plot.text(
              facetData.filter(d => s3HighlightedCountries.includes(d.admin0_name)),
              {
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: d => getFx(d.accessType),
                fy: d => getFy(d.accessType),
                text: "admin0_name",
                dy: -12,
                fontSize: 9,
                fontWeight: "bold"
              }
            )
          ]
        };
        })())}
      </div>`;
    // Place download button after chart
    yield html`<div style="margin-top: 10px;">${s3DownloadButton}</div>`;
}
  } else {
    // Clean up any leftover tooltips from map view
    d3.select(".s3BivariateTip").remove();
    d3.select(".s3BivariateLegendTip").remove();
    
    // Table View - inline to prevent auto-display
  if (!s3SortedData || s3SortedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Table will appear once data is loaded...</em>
    </div>`;
    } else {
      yield Inputs.table(s3SortedData, {
    columns: [
      "admin0_name",
      "iso3",
      "cis_readiness_avg",
      "readinessClass",
      "tv_pct",
          "tv_norm",
      "internet_pct",
          "internet_norm",
      "cellphone_pct",
          "cellphone_norm",
          "combined_pct",
          "combined_norm",
      "gap"
    ],
    header: {
      admin0_name: "Country",
      iso3: "ISO3",
      cis_readiness_avg: "CIS Readiness (Raw)",
      readinessClass: "CIS Class",
      tv_pct: "TV Access (%)",
          tv_norm: "TV",
      internet_pct: "Internet (%)",
          internet_norm: "Internet",
      cellphone_pct: "Cellphone (%)",
          cellphone_norm: "Cellphone",
          combined_pct: "Combined (%)",
          combined_norm: "Combined",
      gap: "Gap"
    },
    format: {
          cis_readiness_avg: d => d?.toFixed(3) || "N/A",
      tv_pct: d => d !== null ? d.toFixed(1) : "N/A",
          tv_norm: d => d !== null ? d.toFixed(3) : "N/A",
      internet_pct: d => d !== null ? d.toFixed(1) : "N/A",
          internet_norm: d => d !== null ? d.toFixed(3) : "N/A",
      cellphone_pct: d => d !== null ? d.toFixed(1) : "N/A",
          cellphone_norm: d => d !== null ? d.toFixed(3) : "N/A",
          combined_pct: d => d !== null ? d.toFixed(1) : "N/A",
          combined_norm: d => d !== null ? d.toFixed(3) : "N/A",
          gap: d => d !== null ? d.toFixed(3) : "N/A"
    },
    width: {
      admin0_name: 150,
      iso3: 60
    }
  });
    }
  }
}
```

```{ojs}
//| echo: false

// Define Download button separately to be used in multiple places
s3DownloadButton = {
  if (typeof downloadButton === 'undefined' || !s3SortedData || s3SortedData.length === 0) {
    return html`<div style="padding: 10px; background: #f0f0f0; border-radius: 5px;">
      <em>Download will be available once data is loaded</em>
    </div>`;
  } else {
    // Helper function to safely format numbers
    const safeFormat = (value, decimals) => {
      if (value == null || isNaN(value)) return "N/A";
      return value.toFixed(decimals);
    };
    
    return downloadButton(
      s3SortedData.map(d => ({
        "Country": d.admin0_name || "N/A",
        "ISO3": d.iso3 || "N/A",
        "CIS Readiness Raw": safeFormat(d.cis_readiness_avg, 3),
        "CIS Readiness Class": d.readinessClass || "N/A",
        "TV Access %": safeFormat(d.tv_pct, 1),
        "TV Access": safeFormat(d.tv_norm, 3),
        "Internet Access %": safeFormat(d.internet_pct, 1),
        "Internet Access": safeFormat(d.internet_norm, 3),
        "Cellphone Access %": safeFormat(d.cellphone_pct, 1),
        "Cellphone Access": safeFormat(d.cellphone_norm, 3),
        "Combined Access %": safeFormat(d.combined_pct, 1),
        "Combined Access": safeFormat(d.combined_norm, 3),
        "Gap (Access - Readiness)": safeFormat(d.gap, 3),
        "Bivariate Category": d.bivariateClass || "N/A"
      })),
      `cis_implementation_${s3AccessType}_access`,
      _lang(cis.downloadLabel)
    );
  }
}
```

### Dynamic Insights

```{ojs}
//| echo: false

s3Insights = {
  if (!s3FilteredData || s3FilteredData.length === 0 || !s3ProcessedData || s3ProcessedData.length === 0) {
    yield html`
      <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
        <h4 style="margin-top: 0;">Key Insights</h4>
        <p style="margin: 10px 0;"><em>Insights will appear once data is loaded...</em></p>
      </div>
    `;
    return;
  }
  
  const avgReadiness = d3.mean(s3FilteredData, d => d.cis_readiness_avg);
  const avgAccess = d3.mean(
    s3FilteredData.filter(d => d[s3CurrentAccessField] !== null && !isNaN(d[s3CurrentAccessField])),
    d => d[s3CurrentAccessField]
  );
  
  // Find countries with high readiness but low access (capacity-access gap)
  const capacityGaps = s3ProcessedData.filter(d => 
    d.cis_readiness_avg > 0.6 && d.accessValue !== null && !isNaN(d.accessValue) && d.accessValue < 0.4
  );
  
  // Find optimal zones (high readiness + high access)
  const optimalZones = s3ProcessedData.filter(d => 
    d.bivariateClass === "High × High"
  );
  
  // Use breadcrumb from master admin selectors for consistent region naming
  // breadcrumb is defined in _cis_readiness_index.qmd and reflects the current admin selection
  const selectedRegion = breadcrumb || "Sub-Saharan Africa";
  
  const insight1 = `In ${selectedRegion}, average CIS Readiness is **${avgReadiness.toFixed(2)}** while ${s3CurrentAccessLabel} averages **${(avgAccess * 100).toFixed(1)}%**.`;
  
  const insight2 = capacityGaps.length > 0 
    ? `Countries such as **${capacityGaps.slice(0, 2).map(d => d.admin0_name).join(' and ')}** show strong technical capacity but limited digital reach, highlighting the need for investment in ICT and communication channels to deliver CIS to users.`
    : 'Most countries show balanced capacity and access.';
  
  const insight3 = optimalZones.length > 0
    ? `**${optimalZones.length} countries** (${(optimalZones.length / s3ProcessedData.length * 100).toFixed(1)}%) fall in the optimal zone with both high CIS readiness and high ${s3CurrentAccessLabel.toLowerCase()}, representing prime opportunities for scaling climate services.`
    : `No countries currently fall in the optimal zone for ${s3CurrentAccessLabel.toLowerCase()}.`;
  
  yield html`
    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
      <h4 style="margin-top: 0;">Key Insights</h4>
      <p style="margin: 10px 0;">${md([insight1])}</p>
      <p style="margin: 10px 0;"><strong>${_lang(cis.s3CapacityGap)}:</strong> ${md([insight2])}</p>
      <p style="margin: 10px 0;"><strong>Optimal Zones:</strong> ${md([insight3])}</p>
    </div>
  `;
}
```

---

<!--
```{ojs}
section32Title = _lang(cis.section32Title)
section32Placeholder = _lang(cis.section32Placeholder)
```

### `{ojs} section32Title` {#section3-2}

**Status:** `{ojs} section32Placeholder`

This section will examine non-technical barriers to CIS uptake across three pillars:

1. **Social, Cultural, and Demographic Factors**
   - Gender dynamics (sex ratio)
   - Language barriers (linguistic diversity)
   - Education levels (years of schooling)

2. **Programming Mechanisms**
   - Communication channels
   - Forecast scale and relevance
   - Trust and credibility

3. **Institutional Support and Resource Allocation**
   - Funding (WMO Climate Services Dashboard)
   - Boundary organizations
   - Livelihood assets

*Data compilation in progress. This section will feature a heatmap comparing countries across barrier indicators, bivariate maps showing barriers × readiness, and dynamic insights identifying priority areas for capacity building.*
-->

