---
title: "Section 3: CIS Implementation"
---

## {section3Title}

### {section31Title}

{section31Intro}

```{ojs}
//| echo: false

// Section titles and intro
section3Title = _lang(cis.section3Title)
section31Title = _lang(cis.section31Title)
section31Intro = _lang(cis.section31Intro)
```

```{ojs}
//| echo: false

// Load access data - use CSV instead of Parquet to avoid path issues
s3AccessData = await d3.csv("/data/cis/CIS_access.csv", row => {
  return {
    iso3: row.iso3,
    admin0_name: row.admin0_name,
    admin1_name: row.admin1_name,
    admin2_name: row.admin2_name,
    tv: row.tv !== "\\N" && row.tv !== null ? parseFloat(row.tv) : null,
    internet: row.internet !== "\\N" && row.internet !== null ? parseFloat(row.internet) : null,
    cellphone: row.cellphone !== "\\N" && row.cellphone !== null ? parseFloat(row.cellphone) : null,
    gaul0_code: parseInt(row.gaul0_code),
    gaul1_code: parseInt(row.gaul1_code),
    gaul2_code: row.gaul2_code !== "\\N" && row.gaul2_code !== null ? parseInt(row.gaul2_code) : null
  };
})
```

```{ojs}
//| echo: false

// Normalize access data to 0-1 scale and calculate combined access
s3NormalizedAccessData = s3AccessData.map(d => ({
  ...d,
  tv_norm: d.tv !== null ? d.tv / 100 : null,
  internet_norm: d.internet !== null ? d.internet / 100 : null,
  cellphone_norm: d.cellphone !== null ? d.cellphone / 100 : null,
  // Combined access: average of all three indicators (handling nulls)
  combined_access: (() => {
    const values = [d.tv, d.internet, d.cellphone].filter(v => v !== null);
    return values.length > 0 ? values.reduce((a, b) => a + b, 0) / (values.length * 100) : null;
  })()
}))
```

```{ojs}
//| echo: false

// Aggregate CIS readiness to Admin 0 level
s3CisReadinessAdmin0 = {
  // Check if cisData is available (from Section 1)
  if (typeof cisData === 'undefined' || !cisData) {
    console.error("cisData is not available - Section 1 must load first");
    return [];
  }
  
  // Group by admin0 and calculate mean CIS readiness
  const grouped = d3.rollup(
    cisData,
    v => ({
      cis_readiness_avg: d3.mean(v, d => d.cis_readiness_index),
      iso3: v[0].iso3,
      gaul0_code: v[0].gaul0_code
    }),
    d => d.admin0_name
  );
  
  return Array.from(grouped, ([admin0_name, data]) => ({
    admin0_name,
    ...data
  }));
}
```

```{ojs}
//| echo: false

// Join CIS readiness with access data at Admin 0 level
section3Data = {
  return s3CisReadinessAdmin0.map(cis => {
    // Find matching access data by admin0_name or iso3
    const access = s3NormalizedAccessData.find(a => 
      (a.admin0_name === cis.admin0_name || a.iso3 === cis.iso3) &&
      (a.admin2_name === null || a.admin2_name === '\\N' || a.admin2_name === '')
    );
    
    if (!access) return null;
    
    return {
      admin0_name: cis.admin0_name,
      iso3: cis.iso3,
      gaul0_code: cis.gaul0_code,
      cis_readiness_avg: cis.cis_readiness_avg,
      tv_access: access.tv_norm,
      internet_access: access.internet_norm,
      cellphone_access: access.cellphone_norm,
      combined_access: access.combined_access,
      // Raw percentages for display
      tv_pct: access.tv,
      internet_pct: access.internet,
      cellphone_pct: access.cellphone
    };
  }).filter(d => d !== null && d.combined_access !== null);
}
```

### Controls

```{ojs}
//| echo: false

// Access Type Selector
viewof s3AccessType = Inputs.radio(
  ["combined", "tv", "internet", "cellphone"],
  {
    label: _lang(cis.s3AccessSelector),
    value: "combined",
    format: x => x === "combined" ? _lang(cis.s3AccessCombined) :
                 x === "tv" ? _lang(cis.s3AccessTV) :
                 x === "internet" ? _lang(cis.s3AccessInternet) :
                 _lang(cis.s3AccessCellphone)
  }
)
```

```{ojs}
//| echo: false

// Sort By Selector
viewof s3SortBy = Inputs.select(
  ["readiness", "tv", "internet", "cellphone", "combined"],
  {
    label: _lang(cis.s3SortBy),
    value: "readiness",
    format: x => x === "readiness" ? _lang(cis.s3SortReadiness) :
                 x === "tv" ? _lang(cis.s3AccessTV) :
                 x === "internet" ? _lang(cis.s3AccessInternet) :
                 x === "cellphone" ? _lang(cis.s3AccessCellphone) :
                 _lang(cis.s3AccessCombined)
  }
)
```

```{ojs}
//| echo: false

// Filter Countries Multi-select
viewof s3FilteredCountries = {
  if (typeof multiSelect === 'undefined' || !section3Data || section3Data.length === 0) {
    return Inputs.select([], {label: "Loading...", disabled: true});
  }
  
  return multiSelect(
    section3Data.map(d => d.admin0_name).sort(),
    {
      label: _lang(cis.s3FilterCountries),
      placeholder: _lang(cis.admin0Placeholder),
      selectAll: true
    }
  );
}
```

```{ojs}
//| echo: false

// Highlight Countries Multi-select (for scatter plot)
viewof s3HighlightedCountries = {
  if (typeof multiSelect === 'undefined' || !section3Data || section3Data.length === 0) {
    return Inputs.select([], {label: "Loading...", disabled: true});
  }
  
  return multiSelect(
    section3Data.map(d => d.admin0_name).sort(),
    {
      label: _lang(cis.s3HighlightCountries),
      placeholder: _lang(cis.admin0Placeholder),
      selectAll: false
    }
  );
}
```

```{ojs}
//| echo: false

// View Toggle
viewof s3ViewType = Inputs.radio(
  ["map", "dumbbell", "scatter", "table"],
  {
    label: _lang(cis.s3ViewToggle),
    value: "map",
    format: x => x === "map" ? _lang(cis.s3ViewMap) :
                 x === "dumbbell" ? _lang(cis.s3ViewDumbbell) :
                 x === "scatter" ? _lang(cis.s3ViewScatter) :
                 _lang(cis.s3ViewTable)
  }
)
```

```{ojs}
//| echo: false

// Helper to get current access field name
s3CurrentAccessField = s3AccessType === "combined" ? "combined_access" :
                       s3AccessType === "tv" ? "tv_access" :
                       s3AccessType === "internet" ? "internet_access" :
                       "cellphone_access"

// Helper to get current access label
s3CurrentAccessLabel = s3AccessType === "combined" ? _lang(cis.s3AccessCombined) :
                       s3AccessType === "tv" ? _lang(cis.s3AccessTV) :
                       s3AccessType === "internet" ? _lang(cis.s3AccessInternet) :
                       _lang(cis.s3AccessCellphone)
```

```{ojs}
//| echo: false

// Filter data based on selected countries
s3FilteredData = {
  if (!section3Data || section3Data.length === 0) {
    return [];
  }
  
  return section3Data.filter(d => 
    !s3FilteredCountries || s3FilteredCountries.length === 0 || s3FilteredCountries.includes(d.admin0_name)
  );
}
```

```{ojs}
//| echo: false

// Calculate access cutoffs (terciles) for current access type
s3AccessCutoffs = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return { low: 0.33, moderate: 0.67 };
  }
  
  const values = s3FilteredData
    .map(d => d[s3CurrentAccessField])
    .filter(v => v !== null)
    .sort((a, b) => a - b);
  
  if (values.length === 0) {
    return { low: 0.33, moderate: 0.67 };
  }
  
  return {
    low: d3.quantile(values, 0.333),
    moderate: d3.quantile(values, 0.667)
  };
}
```

```{ojs}
//| echo: false

// Bivariate classification function
function bivariateClassifyAccess(readiness, access, readinessCutoffs, accessCutoffs) {
  let readinessClass;
  if (readiness < readinessCutoffs.low) readinessClass = "Low";
  else if (readiness < readinessCutoffs.moderate) readinessClass = "Moderate";
  else readinessClass = "High";
  
  let accessClass;
  if (access === null) accessClass = "N/A";
  else if (access < accessCutoffs.low) accessClass = "Low";
  else if (access < accessCutoffs.moderate) accessClass = "Moderate";
  else accessClass = "High";
  
  return {
    readinessClass,
    accessClass,
    bivariateClass: accessClass === "N/A" ? "N/A" : `${readinessClass} × ${accessClass}`
  };
}
```

```{ojs}
//| echo: false

// Note: bivariateColors is already defined in Section 2, reusing it here
// Adding N/A color if not present
s3BivariateColors = {
  return {
    ...bivariateColors,
    "N/A": "#cccccc"
  };
}
```

```{ojs}
//| echo: false

// Process data with bivariate classification
s3ProcessedData = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return [];
  }
  
  return s3FilteredData.map(d => {
    const accessValue = d[s3CurrentAccessField];
    const classification = bivariateClassifyAccess(
      d.cis_readiness_avg,
      accessValue,
      cisReadinessCutoffs,
      s3AccessCutoffs
    );
    
    return {
      ...d,
      accessValue,
      ...classification,
      gap: accessValue !== null ? accessValue - d.cis_readiness_avg : null
    };
  });
}
```

```{ojs}
//| echo: false

// Sort data based on selected metric
s3SortedData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
    return [];
  }
  
  const data = [...s3ProcessedData];
  
  if (s3SortBy === "readiness") {
    return data.sort((a, b) => b.cis_readiness_avg - a.cis_readiness_avg);
  } else if (s3SortBy === "combined") {
    return data.sort((a, b) => (b.combined_access || 0) - (a.combined_access || 0));
  } else if (s3SortBy === "tv") {
    return data.sort((a, b) => (b.tv_access || 0) - (a.tv_access || 0));
  } else if (s3SortBy === "internet") {
    return data.sort((a, b) => (b.internet_access || 0) - (a.internet_access || 0));
  } else if (s3SortBy === "cellphone") {
    return data.sort((a, b) => (b.cellphone_access || 0) - (a.cellphone_access || 0));
  }
  
  return data;
}
```

```{ojs}
//| echo: false

// Prepare geographic data for map
s3GeoData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0 || !admin0Boundaries) {
    return { type: "FeatureCollection", features: [] };
  }
  
  const features = admin0Boundaries.features.map(feature => {
    const countryData = s3ProcessedData.find(d => 
      d.gaul0_code === feature.properties.gaul0_code ||
      d.admin0_name === feature.properties.admin0_name
    );
    
    if (!countryData) return null;
    
    return {
      type: "Feature",
      geometry: feature.geometry,
      properties: {
        ...feature.properties,
        ...countryData
      }
    };
  }).filter(f => f !== null);
  
  return {
    type: "FeatureCollection",
    features
  };
}
```

### Visualization

```{ojs}
//| echo: false

// Render based on view type
{
  if (s3ViewType === "map") {
    yield html`<div style="width: 100%; overflow-x: auto;">
      ${Plot.plot({
        width: 2000,
        height: 1000,
        projection: {
          type: "mercator",
          domain: s3GeoData
        },
        color: {
          legend: false
        },
        marks: [
          Plot.geo(s3GeoData, {
            fill: d => s3BivariateColors[d.properties.bivariateClass],
            stroke: "#333",
            strokeWidth: 0.5,
            title: d => {
              const isOptimal = d.properties.bivariateClass === "High × High";
              const optimalLabel = isOptimal ? `\n✓ ${_lang(cis.s3OptimalZone)}` : "";
              
              return `${d.properties.admin0_name}\n` +
                     `${_lang(cis.s3ReadinessLabel)}: ${d.properties.cis_readiness_avg?.toFixed(2)} (${d.properties.readinessClass})\n` +
                     `${s3CurrentAccessLabel}: ${d.properties.accessValue !== null ? (d.properties.accessValue * 100).toFixed(1) + '%' : 'N/A'} (${d.properties.accessClass})\n` +
                     `Category: ${d.properties.bivariateClass}${optimalLabel}`;
            }
          })
        ]
      })}
      ${s3Legend}
    </div>`;
  } else if (s3ViewType === "dumbbell") {
    yield s3DumbbellChart;
  } else if (s3ViewType === "scatter") {
    yield s3ScatterPlot;
  } else {
    yield s3TableView;
  }
}
```

```{ojs}
//| echo: false

// Bivariate legend (3x3 grid)
s3Legend = {
  const size = 40;
  const gap = 2;
  const classes = ["Low", "Moderate", "High"];
  
  return html`
    <div style="margin: 20px 0; padding: 20px; background: white; border-radius: 8px; display: inline-block;">
      <div style="font-weight: bold; margin-bottom: 10px;">
        ${_lang(cis.s3ReadinessLabel)} → (horizontal) | ${s3CurrentAccessLabel} → (vertical)
      </div>
      <svg width="${size * 3 + gap * 2 + 100}" height="${size * 3 + gap * 2 + 50}">
        ${classes.flatMap((accessClass, i) => 
          classes.map((readinessClass, j) => {
            const bivClass = `${readinessClass} × ${accessClass}`;
            return svg`
              <rect 
                x="${j * (size + gap)}" 
                y="${(2 - i) * (size + gap)}"
                width="${size}" 
                height="${size}"
                fill="${s3BivariateColors[bivClass]}"
                stroke="#333"
                stroke-width="1"
              />
            `;
          })
        )}
        <text x="${size * 3 + gap * 2 + 5}" y="${size * 1.5}" font-size="12">High</text>
        <text x="${size * 3 + gap * 2 + 5}" y="${size * 2.5 + gap}" font-size="12">Moderate</text>
        <text x="${size * 3 + gap * 2 + 5}" y="${size * 3.5 + gap * 2}" font-size="12">Low</text>
        
        <text x="${size * 0.5}" y="${size * 3 + gap * 2 + 20}" font-size="12" text-anchor="middle">Low</text>
        <text x="${size * 1.5 + gap}" y="${size * 3 + gap * 2 + 20}" font-size="12" text-anchor="middle">Moderate</text>
        <text x="${size * 2.5 + gap * 2}" y="${size * 3 + gap * 2 + 20}" font-size="12" text-anchor="middle">High</text>
      </svg>
    </div>
  `;
}
```

```{ojs}
//| echo: false

// Dumbbell Chart
s3DumbbellChart = {
  if (!s3SortedData || s3SortedData.length === 0) {
    return html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Dumbbell chart will appear once data is loaded...</em>
    </div>`;
  }
  
  const chartHeight = Math.max(600, s3SortedData.length * 25);
  
  return html`<div style="width: 100%; overflow-x: auto;">
    ${Plot.plot({
      width: 1200,
      height: chartHeight,
      marginLeft: 150,
      marginRight: 50,
      x: {
        domain: [0, 1],
        label: "Value (0-1 scale)",
        grid: true
      },
      y: {
        label: null,
        domain: s3SortedData.map(d => d.admin0_name)
      },
      marks: [
        // Connecting lines
        Plot.link(s3SortedData.filter(d => d.accessValue !== null), {
          x1: "cis_readiness_avg",
          x2: "accessValue",
          y1: "admin0_name",
          y2: "admin0_name",
          stroke: d => d.gap > 0.05 ? "#4daf4a" : d.gap < -0.05 ? "#e41a1c" : "#999999",
          strokeWidth: 2,
          title: d => `${d.admin0_name}\n${_lang(cis.s3GapLabel)}: ${d.gap?.toFixed(3)} (${d.gap > 0 ? _lang(cis.s3PositiveGap) : _lang(cis.s3NegativeGap)})`
        }),
        // Readiness dots (left)
        Plot.dot(s3SortedData, {
          x: "cis_readiness_avg",
          y: "admin0_name",
          fill: "#377eb8",
          r: 5,
          title: d => `${d.admin0_name}\n${_lang(cis.s3ReadinessLabel)}: ${d.cis_readiness_avg?.toFixed(3)}`
        }),
        // Access dots (right)
        Plot.dot(s3SortedData.filter(d => d.accessValue !== null), {
          x: "accessValue",
          y: "admin0_name",
          fill: "#ff7f00",
          r: 5,
          title: d => `${d.admin0_name}\n${s3CurrentAccessLabel}: ${(d.accessValue * 100)?.toFixed(1)}%`
        }),
        // Text labels
        Plot.text(s3SortedData, {
          x: 0,
          y: "admin0_name",
          text: "admin0_name",
          textAnchor: "end",
          dx: -10,
          fontSize: 11
        })
      ]
    })}
    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="display: flex; gap: 20px; align-items: center; font-size: 12px;">
        <div><span style="color: #377eb8;">●</span> ${_lang(cis.s3ReadinessLabel)}</div>
        <div><span style="color: #ff7f00;">●</span> ${s3CurrentAccessLabel}</div>
        <div><span style="color: #4daf4a;">━</span> ${_lang(cis.s3PositiveGap)}</div>
        <div><span style="color: #e41a1c;">━</span> ${_lang(cis.s3NegativeGap)}</div>
        <div><span style="color: #999999;">━</span> Similar values</div>
      </div>
    </div>
  </div>`;
}
```

```{ojs}
//| echo: false

// Scatter Plot
s3ScatterPlot = {
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
    return html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Scatter plot will appear once data is loaded...</em>
    </div>`;
  }
  
  return html`<div style="width: 100%; overflow-x: auto;">
    ${Plot.plot({
      width: 1000,
      height: 1000,
      x: {
        domain: [0, 1],
        label: _lang(cis.s3ReadinessLabel) + " →",
        grid: true
      },
      y: {
        domain: [0, 1],
        label: s3CurrentAccessLabel + " →",
        grid: true
      },
      marks: [
        // Diagonal reference line (parity)
        Plot.line([[0, 0], [1, 1]], {
          stroke: "#999",
          strokeWidth: 2,
          strokeDasharray: "5,5"
        }),
        // All countries (not highlighted)
        Plot.dot(
          s3ProcessedData.filter(d => 
            d.accessValue !== null && 
            !s3HighlightedCountries.includes(d.admin0_name)
          ),
          {
            x: "cis_readiness_avg",
            y: "accessValue",
            fill: d => s3BivariateColors[d.bivariateClass],
            stroke: "#333",
            strokeWidth: 1,
            r: 6,
            title: d => `${d.admin0_name}\n${_lang(cis.s3ReadinessLabel)}: ${d.cis_readiness_avg?.toFixed(3)}\n${s3CurrentAccessLabel}: ${(d.accessValue * 100)?.toFixed(1)}%\n${_lang(cis.s3GapLabel)}: ${d.gap?.toFixed(3)}`
          }
        ),
        // Highlighted countries
        Plot.dot(
          s3ProcessedData.filter(d => 
            d.accessValue !== null && 
            s3HighlightedCountries.includes(d.admin0_name)
          ),
          {
            x: "cis_readiness_avg",
            y: "accessValue",
            fill: "#ff0000",
            stroke: "#000",
            strokeWidth: 2,
            r: 10,
            title: d => `${d.admin0_name}\n${_lang(cis.s3ReadinessLabel)}: ${d.cis_readiness_avg?.toFixed(3)}\n${s3CurrentAccessLabel}: ${(d.accessValue * 100)?.toFixed(1)}%\n${_lang(cis.s3GapLabel)}: ${d.gap?.toFixed(3)}`
          }
        ),
        // Labels for highlighted countries
        Plot.text(
          s3ProcessedData.filter(d => 
            d.accessValue !== null && 
            s3HighlightedCountries.includes(d.admin0_name)
          ),
          {
            x: "cis_readiness_avg",
            y: "accessValue",
            text: "admin0_name",
            dy: -15,
            fontSize: 11,
            fontWeight: "bold"
          }
        )
      ]
    })}
    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="font-size: 12px;">
        <strong>${_lang(cis.s3ParityLine)}:</strong> Points above the line indicate access exceeds readiness; points below indicate readiness exceeds access.
      </div>
    </div>
  </div>`;
}
```

```{ojs}
//| echo: false

// Table View
s3TableView = {
  if (!s3SortedData || s3SortedData.length === 0) {
    return html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Table will appear once data is loaded...</em>
    </div>`;
  }
  
  return Inputs.table(s3SortedData, {
    columns: [
      "admin0_name",
      "iso3",
      "cis_readiness_avg",
      "readinessClass",
      "tv_pct",
      "tv_access",
      "internet_pct",
      "internet_access",
      "cellphone_pct",
      "cellphone_access",
      "combined_access",
      "gap"
    ],
    header: {
      admin0_name: "Country",
      iso3: "ISO3",
      cis_readiness_avg: "CIS Readiness (Raw)",
      readinessClass: "CIS Class",
      tv_pct: "TV Access (%)",
      tv_access: "TV (0-1)",
      internet_pct: "Internet (%)",
      internet_access: "Internet (0-1)",
      cellphone_pct: "Cellphone (%)",
      cellphone_access: "Cellphone (0-1)",
      combined_access: "Combined (0-1)",
      gap: "Gap"
    },
    format: {
      cis_readiness_avg: d => d?.toFixed(2) || "N/A",
      tv_pct: d => d !== null ? d.toFixed(1) : "N/A",
      tv_access: d => d !== null ? d.toFixed(2) : "N/A",
      internet_pct: d => d !== null ? d.toFixed(1) : "N/A",
      internet_access: d => d !== null ? d.toFixed(2) : "N/A",
      cellphone_pct: d => d !== null ? d.toFixed(1) : "N/A",
      cellphone_access: d => d !== null ? d.toFixed(2) : "N/A",
      combined_access: d => d !== null ? d.toFixed(2) : "N/A",
      gap: d => d !== null ? d.toFixed(2) : "N/A"
    },
    width: {
      admin0_name: 150,
      iso3: 60
    }
  });
}
```

### Dynamic Insights

```{ojs}
//| echo: false

s3Insights = {
  if (!s3FilteredData || s3FilteredData.length === 0 || !s3ProcessedData || s3ProcessedData.length === 0) {
    yield html`
      <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
        <h4 style="margin-top: 0;">Key Insights</h4>
        <p style="margin: 10px 0;"><em>Insights will appear once data is loaded...</em></p>
      </div>
    `;
    return;
  }
  
  const avgReadiness = d3.mean(s3FilteredData, d => d.cis_readiness_avg);
  const avgAccess = d3.mean(
    s3FilteredData.filter(d => d[s3CurrentAccessField] !== null),
    d => d[s3CurrentAccessField]
  );
  
  // Find countries with high readiness but low access (capacity-access gap)
  const capacityGaps = s3ProcessedData.filter(d => 
    d.cis_readiness_avg > 0.6 && d.accessValue !== null && d.accessValue < 0.4
  );
  
  // Find optimal zones (high readiness + high access)
  const optimalZones = s3ProcessedData.filter(d => 
    d.bivariateClass === "High × High"
  );
  
  const selectedRegion = (s3FilteredCountries && s3FilteredCountries.length === section3Data.length)
    ? "Africa" 
    : (s3FilteredCountries && s3FilteredCountries.length === 1)
    ? s3FilteredCountries[0]
    : s3FilteredCountries ? `${s3FilteredCountries.length} selected countries` : "Africa";
  
  const insight1 = `In ${selectedRegion}, average CIS Readiness is **${avgReadiness.toFixed(2)}** while ${s3CurrentAccessLabel} averages **${(avgAccess * 100).toFixed(1)}%**.`;
  
  const insight2 = capacityGaps.length > 0 
    ? `Countries such as **${capacityGaps.slice(0, 2).map(d => d.admin0_name).join(' and ')}** show strong technical capacity but limited digital reach, highlighting the need for investment in ICT and communication channels to deliver CIS to users.`
    : 'Most countries show balanced capacity and access.';
  
  const insight3 = optimalZones.length > 0
    ? `**${optimalZones.length} countries** (${(optimalZones.length / s3ProcessedData.length * 100).toFixed(1)}%) fall in the optimal zone with both high CIS readiness and high ${s3CurrentAccessLabel.toLowerCase()}, representing prime opportunities for scaling climate services.`
    : `No countries currently fall in the optimal zone for ${s3CurrentAccessLabel.toLowerCase()}.`;
  
  yield html`
    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
      <h4 style="margin-top: 0;">Key Insights</h4>
      <p style="margin: 10px 0;">${md([insight1])}</p>
      <p style="margin: 10px 0;"><strong>${_lang(cis.s3CapacityGap)}:</strong> ${md([insight2])}</p>
      <p style="margin: 10px 0;"><strong>Optimal Zones:</strong> ${md([insight3])}</p>
    </div>
  `;
}
```

```{ojs}
//| echo: false

// Download button for Section 3
{
  if (typeof downloadButton === 'undefined' || !s3SortedData || s3SortedData.length === 0) {
    yield html`<div style="padding: 10px; background: #f0f0f0; border-radius: 5px;">
      <em>Download will be available once data is loaded</em>
    </div>`;
  } else {
    yield downloadButton(
      s3SortedData.map(d => ({
        "Country": d.admin0_name,
        "ISO3": d.iso3,
        "CIS Readiness Raw": d.cis_readiness_avg?.toFixed(3) || "N/A",
        "CIS Readiness Class": d.readinessClass,
        "TV Access %": d.tv_pct !== null ? d.tv_pct.toFixed(1) : "N/A",
        "TV Access 0-1": d.tv_access !== null ? d.tv_access.toFixed(3) : "N/A",
        "Internet Access %": d.internet_pct !== null ? d.internet_pct.toFixed(1) : "N/A",
        "Internet Access 0-1": d.internet_access !== null ? d.internet_access.toFixed(3) : "N/A",
        "Cellphone Access %": d.cellphone_pct !== null ? d.cellphone_pct.toFixed(1) : "N/A",
        "Cellphone Access 0-1": d.cellphone_access !== null ? d.cellphone_access.toFixed(3) : "N/A",
        "Combined Access 0-1": d.combined_access !== null ? d.combined_access.toFixed(3) : "N/A",
        "Gap (Access - Readiness)": d.gap !== null ? d.gap.toFixed(3) : "N/A",
        "Bivariate Category": d.bivariateClass
      })),
      `cis_implementation_${s3AccessType}_access`,
      _lang(cis.downloadLabel)
    );
  }
}
```

---

### {section32Title}

**Status:** {section32Placeholder}

This section will examine non-technical barriers to CIS uptake across three pillars:

1. **Social, Cultural, and Demographic Factors**
   - Gender dynamics (sex ratio)
   - Language barriers (linguistic diversity)
   - Education levels (years of schooling)

2. **Programming Mechanisms**
   - Communication channels
   - Forecast scale and relevance
   - Trust and credibility

3. **Institutional Support and Resource Allocation**
   - Funding (WMO Climate Services Dashboard)
   - Boundary organizations
   - Livelihood assets

*Data compilation in progress. This section will feature a heatmap comparing countries across barrier indicators, bivariate maps showing barriers × readiness, and dynamic insights identifying priority areas for capacity building.*

