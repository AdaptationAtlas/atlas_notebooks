```{ojs}
section3Title = _lang(cis.section3Title)
section31Title = _lang(cis.section31Title)
section31Intro = _lang(cis.section31Intro)
```

# `{ojs} section3Title` {#section3}

## `{ojs} section31Title` {#section3-1}

`{ojs} section31Intro`

```{ojs}
//| echo: false

// Synchronized admin selectors for Section 3 - these sync with the master selectors
// Note: createSyncedAdminSelector is defined in _cis_readiness_index.qmd
viewof s3Admin0 = createSyncedAdminSelector(0, viewof selectedAdmin0, uniqueAdmin0.map(d => ({ value: d, label: d })), "s3", _lang(cis.admin0Label), _lang(cis.admin0Placeholder))

viewof s3Admin1 = createSyncedAdminSelector(1, viewof selectedAdmin1, admin1Options.map(d => ({ value: d, label: d })), "s3", _lang(cis.admin1Label), _lang(cis.admin1Placeholder))

viewof s3Admin2 = createSyncedAdminSelector(2, viewof selectedAdmin2, admin2Options.map(d => ({ value: d, label: d })), "s3", _lang(cis.admin2Label), _lang(cis.admin2Placeholder))
```

```{ojs}
//| echo: false

// Inline admin level selectors for this section - Region Selection
htl.html`
<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
  <div style="flex: 1; min-width: 200px;">
    ${viewof s3Admin0}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s3Admin1}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s3Admin2}
  </div>
</div>
`
```

```{ojs}
//| echo: false

// ============================================================================
// SECTION 3.1: CIS READINESS × ACCESS INTERSECTION
// ============================================================================

// Load access data using DuckDB with Parquet for better performance
s3AccessDB = await DuckDBClient.of({
  access_data: FileAttachment("/data/cis/CIS_access.parquet")
});

// Load and clean the access data
s3AccessDataRaw = await s3AccessDB.query(`SELECT * FROM access_data`);

s3AccessData = s3AccessDataRaw.map(row => ({
  admin0_name: row.admin0_name,
  admin1_name: row.admin1_name === "\\N" || row.admin1_name === "" ? null : row.admin1_name,
  admin2_name: row.admin2_name === "\\N" || row.admin2_name === "" ? null : row.admin2_name,
  iso3: row.iso3,
  gaul0_code: row.gaul0_code !== "\\N" && row.gaul0_code !== "" && row.gaul0_code !== null ? parseInt(row.gaul0_code) : null,
  gaul1_code: row.gaul1_code !== "\\N" && row.gaul1_code !== "" && row.gaul1_code !== null ? parseInt(row.gaul1_code) : null,
  gaul2_code: row.gaul2_code !== "\\N" && row.gaul2_code !== "" && row.gaul2_code !== null ? parseInt(row.gaul2_code) : null,
  tv: row.tv !== "\\N" && row.tv !== null && row.tv !== "" ? parseFloat(row.tv) : null,
  internet: row.internet !== "\\N" && row.internet !== null && row.internet !== "" ? parseFloat(row.internet) : null,
  cellphone: row.cellphone !== "\\N" && row.cellphone !== null && row.cellphone !== "" ? parseFloat(row.cellphone) : null
}));

// Aggregate CIS readiness to Admin 0 level (average)
s3CisReadinessAdmin0 = {
  if (typeof cisData === 'undefined' || !cisData) {
    console.error("cisData is not available - Section 1 must load first");
    return [];
  }
  
  // Group by admin0 and calculate mean CIS readiness
  const grouped = d3.rollup(
    cisData,
    v => ({
      cis_readiness_avg: d3.mean(v, d => d.cis_readiness_index),
      iso3: v[0].iso3,
      gaul0_code: v[0].gaul0_code
    }),
    d => d.admin0_name
  );
  
  return Array.from(grouped, ([admin0_name, data]) => {
    return {
      admin0_name: admin0_name,
    ...data
    };
  });
}

// Aggregate access data to Admin 0 level (average)
s3AccessAdmin0 = {
  // Group by admin0 and calculate mean access
  const grouped = d3.rollup(
    s3AccessData.filter(d => d.gaul0_code !== null),
    v => ({
      tv_avg: d3.mean(v, d => d.tv),
      internet_avg: d3.mean(v, d => d.internet),
      cellphone_avg: d3.mean(v, d => d.cellphone),
      iso3: v[0].iso3,
      gaul0_code: v[0].gaul0_code
    }),
    d => d.admin0_name
  );
  
  return Array.from(grouped, ([admin0_name, data]) => {
    return {
      admin0_name: admin0_name,
    ...data
    };
  });
}

// Join CIS readiness with access data at Admin 0 level
section3Data = {
  return s3CisReadinessAdmin0.map(cis => {
    // Find matching access data by admin0_name
    const access = s3AccessAdmin0.find(a => 
      a.admin0_name === cis.admin0_name || a.iso3 === cis.iso3
    );
    
    if (!access) return null;
    
    // Calculate combined access (average of all three indicators)
    const combined_access = (() => {
      const values = [access.tv_avg, access.internet_avg, access.cellphone_avg].filter(v => v !== null && !isNaN(v));
      return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : null;
    })();
    
    // Normalize to 0-1 scale (values are already percentages 0-100)
    return {
      admin0_name: cis.admin0_name,
      iso3: cis.iso3 || access.iso3,
      gaul0_code: cis.gaul0_code || access.gaul0_code,
      cis_readiness_avg: cis.cis_readiness_avg,
      // Raw percentages
      tv_pct: access.tv_avg,
      internet_pct: access.internet_avg,
      cellphone_pct: access.cellphone_avg,
      combined_pct: combined_access,
      // Normalized 0-1
      tv_norm: access.tv_avg !== null ? access.tv_avg / 100 : null,
      internet_norm: access.internet_avg !== null ? access.internet_avg / 100 : null,
      cellphone_norm: access.cellphone_avg !== null ? access.cellphone_avg / 100 : null,
      combined_norm: combined_access !== null ? combined_access / 100 : null
    };
  }).filter(d => d !== null);
}

// Note: cisReadinessCutoffs is defined in Section 2 (_cis_hazard_intersection.qmd)
// and reused here to avoid duplicate definitions
```

```{ojs}
//| echo: false

// Access Type Selector
viewof s3AccessType = Inputs.radio(
  ["combined", "internet", "tv", "cellphone"],
  {
    label: _lang(cis.s3AccessSelector),
    value: "combined",
    format: x => x === "combined" ? _lang(cis.s3AccessCombined) :
                 x === "internet" ? _lang(cis.s3AccessInternet) :
                 x === "tv" ? _lang(cis.s3AccessTV) :
                 _lang(cis.s3AccessCellphone)
  }
)
```

```{ojs}
//| echo: false

// Sort By Selector - only shown when view type is not "map"
viewof s3SortBy = {
  if (s3ViewType === "map") {
    // Return a hidden selector that maintains state but isn't displayed
    const input = Inputs.select(
      ["readiness", "combined", "internet", "tv", "cellphone"],
      {
        label: _lang(cis.s3SortBy),
        value: "readiness"
      }
    );
    input.style.display = "none";
    return input;
  }
  
  return Inputs.select(
    ["readiness", "combined", "internet", "tv", "cellphone"],
    {
      label: _lang(cis.s3SortBy),
      value: "readiness",
      format: x => x === "readiness" ? _lang(cis.s3SortReadiness) :
                   x === "combined" ? _lang(cis.s3AccessCombined) :
                   x === "internet" ? _lang(cis.s3AccessInternet) :
                   x === "tv" ? _lang(cis.s3AccessTV) :
                   _lang(cis.s3AccessCellphone)
    }
  );
}
```

```{ojs}
//| echo: false

// Filter Countries Multi-select
s3UniqueCountries = {
  const countries = Array.from(new Set((section3Data || []).map(d => d.admin0_name))).sort();
  return countries;
}

viewof s3FilteredCountries = {
  if (!s3UniqueCountries || s3UniqueCountries.length === 0) {
    return Inputs.select([], {label: _lang(cis.s3FilterCountries), disabled: true});
  }
  return multiSelect({
    inputLabel: _lang(cis.s3FilterCountries),
    inputId: "s3FilterCountries",
    placeholderText: _lang(cis.admin0Placeholder),
    options: s3UniqueCountries.map(d => ({ value: d, label: d })),
    selected: s3UniqueCountries // Select all by default
  });
}
```

```{ojs}
//| echo: false

// Highlight Countries Multi-select (for scatter plot only)
viewof s3HighlightedCountries = {
  // Only show when view type is scatter
  if (s3ViewType !== "scatter") {
    const input = Inputs.select([], {label: _lang(cis.s3HighlightCountries)});
    input.style.display = "none";
    input.value = [];
    return input;
  }
  
  if (!s3UniqueCountries || s3UniqueCountries.length === 0) {
    return Inputs.select([], {label: _lang(cis.s3HighlightCountries), disabled: true});
  }
  return multiSelect({
    inputLabel: _lang(cis.s3HighlightCountries),
    inputId: "s3HighlightCountries",
    placeholderText: _lang(cis.admin0Placeholder),
    options: s3UniqueCountries.map(d => ({ value: d, label: d })),
    selected: [] // None selected by default
  });
}
```

```{ojs}
//| echo: false

// View Toggle
viewof s3ViewType = Inputs.radio(
  ["map", "dumbbell", "scatter", "table"],
  {
    label: _lang(cis.s3ViewToggle),
    value: "map",
    format: x => x === "map" ? _lang(cis.s3ViewMap) :
                 x === "dumbbell" ? _lang(cis.s3ViewDumbbell) :
                 x === "scatter" ? _lang(cis.s3ViewScatter) :
                 _lang(cis.s3ViewTable)
  }
)
```

```{ojs}
//| echo: false

// Helper to get current access field name
s3CurrentAccessField = s3AccessType === "combined" ? "combined_norm" :
                       s3AccessType === "internet" ? "internet_norm" :
                       s3AccessType === "tv" ? "tv_norm" :
                       "cellphone_norm"

// Helper to get current access label
s3CurrentAccessLabel = s3AccessType === "combined" ? _lang(cis.s3AccessCombined) :
                       s3AccessType === "internet" ? _lang(cis.s3AccessInternet) :
                       s3AccessType === "tv" ? _lang(cis.s3AccessTV) :
                       _lang(cis.s3AccessCellphone)

// Helper to get current access raw field
s3CurrentAccessRawField = s3AccessType === "combined" ? "combined_pct" :
                          s3AccessType === "internet" ? "internet_pct" :
                          s3AccessType === "tv" ? "tv_pct" :
                          "cellphone_pct"
```

```{ojs}
//| echo: false

// Filter data based on selected countries
s3FilteredData = {
  if (!section3Data || section3Data.length === 0) {
    return [];
  }
  
  return section3Data.filter(d => 
    !s3FilteredCountries || s3FilteredCountries.length === 0 || s3FilteredCountries.includes(d.admin0_name)
  );
}
```

```{ojs}
//| echo: false

// Calculate access cutoffs (terciles) for current access type
s3AccessCutoffs = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return { low: 0.33, moderate: 0.67 };
  }
  
  const values = s3FilteredData
    .map(d => d[s3CurrentAccessField])
    .filter(v => v !== null && !isNaN(v))
    .sort((a, b) => a - b);
  
  if (values.length === 0) {
    return { low: 0.33, moderate: 0.67 };
  }
  
  return {
    low: d3.quantile(values, 0.333),
    moderate: d3.quantile(values, 0.667)
  };
}
```

```{ojs}
//| echo: false

// Bivariate classification function (reuse from Section 2)
function bivariateClassifyAccess(readiness, access, readinessCutoffs, accessCutoffs) {
  let readinessClass;
  if (readiness < readinessCutoffs.low) readinessClass = "Low";
  else if (readiness < readinessCutoffs.moderate) readinessClass = "Moderate";
  else readinessClass = "High";
  
  let accessClass;
  if (access === null || isNaN(access)) accessClass = "N/A";
  else if (access < accessCutoffs.low) accessClass = "Low";
  else if (access < accessCutoffs.moderate) accessClass = "Moderate";
  else accessClass = "High";
  
  return {
    readinessClass,
    accessClass,
    bivariateClass: accessClass === "N/A" ? "N/A" : `${readinessClass} × ${accessClass}`
  };
}

// Bivariate color palette (3x3 grid) - reuse from Section 2
s3BivariateColors = {
  return {
    "Low × Low": "#e8e8e8",
    "Low × Moderate": "#b8d6be",
    "Low × High": "#6c9a8b",
    "Moderate × Low": "#c8b2d6",
    "Moderate × Moderate": "#9c9eba",
    "Moderate × High": "#627a8e",
    "High × Low": "#b8a0c2",
    "High × Moderate": "#8b7fa8",
    "High × High": "#5a5f8f",
    "N/A": "#cccccc"
  };
}
```

```{ojs}
//| echo: false

// Process data with bivariate classification
s3ProcessedData = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return [];
  }
  
  return s3FilteredData.map(d => {
    const accessValue = d[s3CurrentAccessField];
    const classification = bivariateClassifyAccess(
      d.cis_readiness_avg,
      accessValue,
      cisReadinessCutoffs,
      s3AccessCutoffs
    );
    
    return {
      ...d,
      accessValue,
      ...classification,
      gap: accessValue !== null && !isNaN(accessValue) ? accessValue - d.cis_readiness_avg : null
    };
  });
}
```

```{ojs}
//| echo: false

// Sort data based on selected metric
s3SortedData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
    return [];
  }
  
  const data = [...s3ProcessedData];
  
  if (s3SortBy === "readiness") {
    return data.sort((a, b) => (b.cis_readiness_avg || 0) - (a.cis_readiness_avg || 0));
  } else if (s3SortBy === "combined") {
    return data.sort((a, b) => (b.combined_norm || 0) - (a.combined_norm || 0));
  } else if (s3SortBy === "internet") {
    return data.sort((a, b) => (b.internet_norm || 0) - (a.internet_norm || 0));
  } else if (s3SortBy === "tv") {
    return data.sort((a, b) => (b.tv_norm || 0) - (a.tv_norm || 0));
  } else if (s3SortBy === "cellphone") {
    return data.sort((a, b) => (b.cellphone_norm || 0) - (a.cellphone_norm || 0));
  }
  
  return data;
}
```

```{ojs}
//| echo: false

// Prepare geographic data for map - dynamically show admin levels based on selection
s3GeoData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
    return { type: "FeatureCollection", features: [] };
  }
  
  // Determine which admin level to show based on selections
  const allCountries = Array.from(new Set(cisData.map(d => d.admin0_name))).sort();
  const selectedCountries = s3Admin0 || [];
  const selectedAdmin1s = s3Admin1 || [];
  const selectedAdmin2s = s3Admin2 || [];
  
  let boundaries = null;
  let levelKey = "admin0_name";
  let gaul_key = "gaul0_code";
  
  // If specific admin2 regions are selected, show admin2 boundaries
  if (selectedAdmin2s.length > 0 && selectedAdmin2s.length < admin2Options.length && admin2Boundaries) {
    boundaries = admin2Boundaries;
    levelKey = "admin2_name";
    gaul_key = "gaul2_code";
  }
  // If specific admin1 regions are selected, show admin2 boundaries within those admin1s
  else if (selectedAdmin1s.length > 0 && selectedAdmin1s.length < admin1Options.length && admin2Boundaries) {
    boundaries = admin2Boundaries;
    levelKey = "admin2_name";
    gaul_key = "gaul2_code";
  }
  // If specific countries are selected (not all), show admin1 boundaries
  else if (selectedCountries.length > 0 && selectedCountries.length < allCountries.length && admin1Boundaries) {
    boundaries = admin1Boundaries;
    levelKey = "admin1_name";
    gaul_key = "gaul1_code";
  }
  // Default: show admin0 boundaries
  else if (admin0Boundaries) {
    boundaries = admin0Boundaries;
    levelKey = "admin0_name";
    gaul_key = "gaul0_code";
  }
  
  if (!boundaries) {
    return { type: "FeatureCollection", features: [] };
  }
  
  // Map data to boundaries
  const features = boundaries.features.map(feature => {
    // For admin0 level, match on admin0
    if (gaul_key === "gaul0_code") {
      const countryData = s3ProcessedData.find(d => 
        d.gaul0_code === feature.properties.gaul0_code ||
        d.admin0_name === feature.properties.admin0_name
      );
      
      if (!countryData) return null;
      
      return {
        type: "Feature",
        geometry: feature.geometry,
        properties: {
          ...feature.properties,
          ...countryData,
          displayName: feature.properties.admin0_name
        }
      };
    }
    // For admin1/admin2 levels, aggregate data from admin0
    else {
      // Find the parent admin0 for this feature
      const parentCountry = feature.properties.admin0_name;
      const countryData = s3ProcessedData.find(d => d.admin0_name === parentCountry);
      
      if (!countryData) return null;
      
      return {
        type: "Feature",
        geometry: feature.geometry,
        properties: {
          ...feature.properties,
          ...countryData,
          displayName: feature.properties[levelKey] || feature.properties.admin0_name
        }
      };
    }
  }).filter(f => f !== null);
  
  return {
    type: "FeatureCollection",
    features
  };
}
```

### Visualization

```{ojs}
//| echo: false

// Section 3 bivariate map with diamond legend (matching Section 2 style)
s3BivariateMap = {
  if (s3ViewType !== "map") return null;
  
  const height = 610;
  const width = 775;
  const padding = 20;
  
  // Remove existing tooltip
  d3.select(".s3BivariateTip").remove();
  
  // Add CSS for consistent tooltip styling
  if (!d3.select("style#s3BivariateTipStyles").node()) {
    d3.select("head").append("style")
      .attr("id", "s3BivariateTipStyles")
      .text(`
        .s3BivariateTip,
        .s3BivariateLegendTip {
          font-size: 14px !important;
          padding: 10px 12px !important;
          line-height: 1.5 !important;
          background: rgba(255, 255, 255, 0.95) !important;
          border: 1px solid #ccc !important;
          border-radius: 4px !important;
          box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
        }
        .s3BivariateTip table,
        .s3BivariateLegendTip table {
          font-size: 14px !important;
        }
        .s3BivariateTip th,
        .s3BivariateTip td,
        .s3BivariateLegendTip th,
        .s3BivariateLegendTip td {
          padding: 4px 8px !important;
          font-size: 14px !important;
          line-height: 1.4 !important;
        }
        .s3BivariateTip th,
        .s3BivariateLegendTip th {
          font-weight: 600 !important;
          font-size: 14px !important;
        }
        .s3BivariateTip *,
        .s3BivariateLegendTip * {
          font-size: 14px !important;
        }
      `);
  }
  
  // Create tooltip matching Plot.tip style
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plot-tip s3BivariateTip")
    .style("position", "absolute")
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("z-index", "1000");
  
  const projection = d3.geoMercator();
  const geo_path = d3.geoPath().projection(projection);
  const color = d3.scaleOrdinal()
    .domain(["Low × Low", "Low × Moderate", "Low × High", "Moderate × Low", "Moderate × Moderate", "Moderate × High", "High × Low", "High × Moderate", "High × High"])
    .range(Object.values(s3BivariateColors));
  
  // Fit projection to features - leave space at bottom and left for legend
  const bottomPadding = 140; // Space for rotated diamond legend (reduced for better integration)
  const leftPadding = 150; // Extra space for rotated diamond legend and labels
  projection.fitExtent(
    [
      [padding + leftPadding, padding],
      [width - padding, height - bottomPadding]
    ],
    s3GeoData
  );
  
  // Expand viewBox to accommodate rotated legend (negative X for labels, reduced height for tighter integration)
  const svg = d3
    .create("svg")
    .attr("viewBox", [-50, 0, 950, 720])
    .attr("style", "overflow: visible;")
    .attr("title", "Bivariate Map");
  
  // Render paths
  const paths = svg
    .append("g")
    .selectAll("path")
    .data(s3GeoData.features)
    .join("path")
    .attr("stroke", "white")
    .attr("stroke-width", "1px")
    .attr("fill", (d) => {
      return color(d.properties.bivariateClass) || "#cccccc";
    })
    .attr("d", geo_path);
  
  // Tooltip on mousemove
  paths
    .on("mousemove", (event, d) => {
      const regionName = d.properties.displayName || d.properties.admin0_name;
      const readiness = d.properties.cis_readiness_avg;
      const readinessClass = d.properties.readinessClass;
      const access = d.properties.accessValue;
      const accessClass = d.properties.accessClass;
      const category = d.properties.bivariateClass;
      const optimal = d.properties.bivariateClass === "High × High";
      
      // Determine label based on which boundaries are shown
      let regionLabel = "Country";
      if (d.properties.gaul2_code) {
        regionLabel = "District";
      } else if (d.properties.gaul1_code && !d.properties.gaul2_code) {
        regionLabel = "Region";
      }
      
      // Format tooltip as table matching Plot.tip pattern
      const tooltipHtml = `
        <table>
          <tr><th>${regionLabel}</th><td>${regionName || "N/A"}</td></tr>
          <tr><th>${_lang(cis.s3ReadinessLabel)}</th><td>${readiness != null ? readiness.toFixed(2) : "N/A"}</td></tr>
          <tr><th>Readiness Class</th><td>${readinessClass || "N/A"}</td></tr>
          <tr><th>${s3CurrentAccessLabel}</th><td>${access != null ? (access * 100).toFixed(1) + '%' : "N/A"}</td></tr>
          <tr><th>Access Class</th><td>${accessClass || "N/A"}</td></tr>
          <tr><th>Category</th><td>${category || "N/A"}</td></tr>
          ${optimal ? `<tr><th>Optimal Zone</th><td>✓ ${_lang(cis.s3OptimalZone)}</td></tr>` : ""}
        </table>
      `;
      
      tooltip
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1)
        .html(tooltipHtml);
    })
    .on("mouseout", () => {
      tooltip.style("opacity", 0);
    });
  
  // Add mesh/boundaries
  const mesh = svg
    .append("path")
    .datum(s3GeoData)
    .attr("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-linejoin", "round")
    .attr("d", geo_path);
  
  // Create legend tooltip (separate from map tooltip) - matching Plot.tip style
  d3.select(".s3BivariateLegendTip").remove();
  const legendTooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plot-tip s3BivariateLegendTip")
    .style("position", "absolute")
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("z-index", "1000");
  
  // Create bi_legend function (diamond shape - matching Section 2)
  function bi_legend(selection) {
  const size = 40;
  const gap = 2;
  const classes = ["Low", "Moderate", "High"];
    const totalWidth = size * 3 + gap * 2;
    const totalHeight = size * 3 + gap * 2;
    const centerX = totalWidth / 2;
    const centerY = totalHeight / 2;
    
    // Create inner group for the legend content (will be rotated)
    const legendContent = selection.append("g");
    
    // Legend squares with hover tooltips
    classes.forEach((accessClass, i) => {
      classes.forEach((readinessClass, j) => {
        const key = `${readinessClass} × ${accessClass}`;
        const isPriority = readinessClass === "High" && accessClass === "High";
        
        const rect = legendContent
          .append("rect")
          .attr("x", j * (size + gap))
          .attr("y", i * (size + gap))
          .attr("width", size)
          .attr("height", size)
          .attr("fill", s3BivariateColors[key] || "#cccccc")
          .attr("stroke", isPriority ? "#000" : "#999")
          .attr("stroke-width", isPriority ? "2.5" : "0.5")
          .style("cursor", "pointer");
        
        // Add hover tooltip - matching Plot.tip pattern
        rect
          .on("mousemove", (event) => {
            const tooltipHtml = `
              <table>
                <tr><th>${_lang(cis.s3ReadinessLabel)}</th><td>${readinessClass}</td></tr>
                <tr><th>${s3CurrentAccessLabel}</th><td>${accessClass}</td></tr>
                <tr><th>Category</th><td>${key}</td></tr>
              </table>
            `;
            legendTooltip
              .style("top", event.pageY - 10 + "px")
              .style("left", event.pageX + 10 + "px")
              .style("opacity", 1)
              .html(tooltipHtml);
          })
          .on("mouseout", () => {
            legendTooltip.style("opacity", 0);
          });
      });
    });
    
    // Rotate the entire legend 45 degrees to make it a diamond
    legendContent.attr("transform", `rotate(45, ${centerX}, ${centerY})`);
    
    // Axis labels parallel to the diamond edges
    // CIS Readiness label (horizontal, below the legend)
    selection
      .append("text")
      .attr("x", centerX)
      .attr("y", totalHeight + 40)
      .attr("font-size", "11")
      .attr("fill", "#333")
      .attr("font-weight", "600")
      .attr("text-anchor", "middle")
      .text(_lang(cis.s3ReadinessLabel));
    
    // Access label (vertical, to the right of the legend)
    selection
      .append("text")
      .attr("x", totalWidth + 40)
      .attr("y", centerY)
      .attr("font-size", "11")
      .attr("fill", "#333")
      .attr("font-weight", "600")
      .attr("text-anchor", "middle")
      .attr("transform", `rotate(-90, ${totalWidth + 40}, ${centerY})`)
      .text(s3CurrentAccessLabel);
    
    return selection;
  }
  
  // Add legend to SVG - integrated with map
  // Position legend at bottom-left with enough space for rotated diamond and labels
  // Account for rotation: when rotated 45°, the diagonal extends sqrt(2)/2 * size in each direction
  const legendX = 50; // More space from left edge to accommodate labels
  const legendY = 590; // Position integrated with map area (reduced from 630)
  const legendGroup = svg
    .append("g")
    .attr("transform", `translate(${legendX}, ${legendY})`);
  
  // Apply the legend function to the group using .call()
  legendGroup.call(bi_legend);
  
  return svg.node();
}
```

```{ojs}
//| echo: false

// Render based on view type
{
  if (s3ViewType === "map") {
    yield html`<div style="width: 100%; overflow-x: auto;">
      ${s3BivariateMap}
    </div>`;
  } else if (s3ViewType === "dumbbell") {
    // Dumbbell Chart - inline to prevent auto-display
  if (!s3SortedData || s3SortedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Dumbbell chart will appear once data is loaded...</em>
    </div>`;
    } else {
  const chartHeight = Math.max(600, s3SortedData.length * 25);
  const linkData = s3SortedData.filter(d => d.accessValue !== null && !isNaN(d.accessValue));
  const accessData = s3SortedData.filter(d => d.accessValue !== null && !isNaN(d.accessValue));
  const allTipData = [...s3SortedData, ...accessData];
  
      yield html`<div style="width: 100%; overflow-x: auto;">
    <div style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="display: flex; gap: 20px; align-items: center; font-size: 12px;">
        <div><span style="color: #377eb8;">●</span> ${_lang(cis.s3ReadinessLabel)}</div>
            <div><span style="color: #ff7f00;">▲</span> ${s3CurrentAccessLabel}</div>
        <div><span style="color: #4daf4a;">━</span> ${_lang(cis.s3PositiveGap)}</div>
        <div><span style="color: #e41a1c;">━</span> ${_lang(cis.s3NegativeGap)}</div>
        <div><span style="color: #999999;">━</span> Similar values</div>
      </div>
    </div>
    ${Plot.plot({
      width: 1200,
      height: chartHeight,
      marginLeft: 150,
      marginRight: 50,
      marginTop: 80,
      marginBottom: 80,
      x: {
        domain: [0, 1],
        label: "Value (0-1 scale)",
        grid: true,
        axis: "top"
      },
      y: {
        label: null,
        domain: s3SortedData.map(d => d.admin0_name)
      },
      marks: [
        Plot.axisX({anchor: "bottom", label: "Value (0-1 scale)"}),
        // Connecting lines
        Plot.link(linkData, {
          x1: "cis_readiness_avg",
          x2: "accessValue",
          y1: "admin0_name",
          y2: "admin0_name",
              stroke: d => {
                if (d.gap === null || isNaN(d.gap)) return "#999999";
                return d.gap > 0.05 ? "#4daf4a" : d.gap < -0.05 ? "#e41a1c" : "#999999";
              },
          strokeWidth: 2
        }),
        // Readiness dots (left)
        Plot.dot(s3SortedData, {
          x: "cis_readiness_avg",
          y: "admin0_name",
          fill: "#377eb8",
          r: 5
        }),
        // Access dots (right)
        Plot.dot(accessData, {
          x: "accessValue",
          y: "admin0_name",
          fill: "#ff7f00",
          r: 5,
          shape: "triangle"
        }),
        Plot.tip(
          allTipData,
          Plot.pointer({
            x: (d) => d.cis_readiness_avg != null ? d.cis_readiness_avg : d.accessValue,
            y: "admin0_name",
            channels: {
              country: {
                label: "Country",
                value: (d) => d.admin0_name
              },
              readiness: {
                label: _lang(cis.s3ReadinessLabel),
                value: (d) => d.cis_readiness_avg
              },
              access: {
                label: s3CurrentAccessLabel,
                value: (d) => d.accessValue
              },
              gap: {
                label: _lang(cis.s3GapLabel),
                value: (d) => d.gap
              }
            },
            format: {
              country: true,
              readiness: (d) => d != null ? d.toFixed(3) : "N/A",
              access: (d) => d != null ? (d * 100).toFixed(1) + '%' : "N/A",
              gap: (d) => {
                if (d == null || isNaN(d)) return "N/A";
                const label = d > 0 ? _lang(cis.s3PositiveGap) : _lang(cis.s3NegativeGap);
                return `${d.toFixed(3)} (${label})`;
              }
            }
          })
        )
      ]
    })}
    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="display: flex; gap: 20px; align-items: center; font-size: 12px;">
        <div><span style="color: #377eb8;">●</span> ${_lang(cis.s3ReadinessLabel)}</div>
            <div><span style="color: #ff7f00;">▲</span> ${s3CurrentAccessLabel}</div>
        <div><span style="color: #4daf4a;">━</span> ${_lang(cis.s3PositiveGap)}</div>
        <div><span style="color: #e41a1c;">━</span> ${_lang(cis.s3NegativeGap)}</div>
        <div><span style="color: #999999;">━</span> Similar values</div>
      </div>
    </div>
  </div>`;
}
  } else if (s3ViewType === "scatter") {
    // Faceted Scatter Plot - showing all access types
    if (!s3ProcessedData || s3ProcessedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
        <em>Scatter plot will appear once data is loaded...</em>
      </div>`;
    } else {
      // Prepare data for faceting - create separate data points for each access type
      const facetData = [];
      s3ProcessedData.forEach(d => {
        if (d.combined_norm != null && !isNaN(d.combined_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessCombined),
            accessValue: d.combined_norm,
            accessKey: "combined"
          });
        }
        if (d.internet_norm != null && !isNaN(d.internet_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessInternet),
            accessValue: d.internet_norm,
            accessKey: "internet"
          });
        }
        if (d.tv_norm != null && !isNaN(d.tv_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessTV),
            accessValue: d.tv_norm,
            accessKey: "tv"
          });
        }
        if (d.cellphone_norm != null && !isNaN(d.cellphone_norm)) {
          facetData.push({
            ...d,
            accessType: _lang(cis.s3AccessCellphone),
            accessValue: d.cellphone_norm,
            accessKey: "cellphone"
          });
        }
      });
      
      yield html`<div style="width: 100%; overflow-x: auto;">
        <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
          <div style="font-size: 12px;">
            <strong>${_lang(cis.s3ParityLine)}:</strong> Points above the line indicate access exceeds readiness; points below indicate readiness exceeds access.
          </div>
        </div>
        ${Plot.plot({
          width: 1200,
          height: 800,
          marginTop: 40,
          marginRight: 40,
          marginBottom: 60,
          marginLeft: 60,
          grid: true,
          x: {
            domain: [0, 1],
            label: _lang(cis.s3ReadinessLabel) + " →"
          },
          y: {
            domain: [0, 1],
            label: "Access →"
          },
          fx: {
            label: null,
            padding: 0.05
          },
          facet: {
            data: facetData,
            x: "accessType"
          },
          marks: [
            // Diagonal reference line (parity) - one per facet
            Plot.line([[0, 0], [1, 1]], {
              stroke: "#999",
              strokeWidth: 1.5,
              strokeDasharray: "4,4",
              fx: _lang(cis.s3AccessCombined)
            }),
            Plot.line([[0, 0], [1, 1]], {
              stroke: "#999",
              strokeWidth: 1.5,
              strokeDasharray: "4,4",
              fx: _lang(cis.s3AccessInternet)
            }),
            Plot.line([[0, 0], [1, 1]], {
              stroke: "#999",
              strokeWidth: 1.5,
              strokeDasharray: "4,4",
              fx: _lang(cis.s3AccessTV)
            }),
            Plot.line([[0, 0], [1, 1]], {
              stroke: "#999",
              strokeWidth: 1.5,
              strokeDasharray: "4,4",
              fx: _lang(cis.s3AccessCellphone)
            }),
            // All countries (not highlighted)
            Plot.dot(
              facetData.filter(d => !s3HighlightedCountries.includes(d.admin0_name)),
              {
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: "accessType",
                fill: d => {
                  // Calculate bivariate class for this specific access type
                  const readinessClass = d.cis_readiness_avg > 0.67 ? "High" : d.cis_readiness_avg > 0.33 ? "Moderate" : "Low";
                  const accessClass = d.accessValue > 0.67 ? "High" : d.accessValue > 0.33 ? "Moderate" : "Low";
                  return s3BivariateColors[`${readinessClass} × ${accessClass}`] || "#cccccc";
                },
                stroke: "#333",
                strokeWidth: 0.5,
                r: 4
              }
            ),
            // Highlighted countries
            Plot.dot(
              facetData.filter(d => s3HighlightedCountries.includes(d.admin0_name)),
              {
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: "accessType",
                fill: "#0066cc",
                stroke: "#000",
                strokeWidth: 1.5,
                r: 6
              }
            ),
            // Tooltips
            Plot.tip(
              facetData,
              Plot.pointer({
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: "accessType",
                channels: {
                  country: {
                    label: "Country",
                    value: (d) => d.admin0_name
                  },
                  readiness: {
                    label: _lang(cis.s3ReadinessLabel),
                    value: (d) => d.cis_readiness_avg
                  },
                  access: {
                    label: "Access",
                    value: (d) => d.accessValue
                  }
                },
                format: {
                  country: true,
                  readiness: (d) => d != null ? d.toFixed(3) : "N/A",
                  access: (d) => d != null ? (d * 100).toFixed(1) + '%' : "N/A"
                }
              })
            ),
            // Labels for highlighted countries
            Plot.text(
              facetData.filter(d => s3HighlightedCountries.includes(d.admin0_name)),
              {
                x: "cis_readiness_avg",
                y: "accessValue",
                fx: "accessType",
                text: "admin0_name",
                dy: -12,
                fontSize: 9,
                fontWeight: "bold"
              }
            )
          ]
        })}
      </div>`;
}
  } else {
    // Table View - inline to prevent auto-display
  if (!s3SortedData || s3SortedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Table will appear once data is loaded...</em>
    </div>`;
    } else {
      yield Inputs.table(s3SortedData, {
    columns: [
      "admin0_name",
      "iso3",
      "cis_readiness_avg",
      "readinessClass",
      "tv_pct",
          "tv_norm",
      "internet_pct",
          "internet_norm",
      "cellphone_pct",
          "cellphone_norm",
          "combined_pct",
          "combined_norm",
      "gap"
    ],
    header: {
      admin0_name: "Country",
      iso3: "ISO3",
      cis_readiness_avg: "CIS Readiness (Raw)",
      readinessClass: "CIS Class",
      tv_pct: "TV Access (%)",
          tv_norm: "TV (0-1)",
      internet_pct: "Internet (%)",
          internet_norm: "Internet (0-1)",
      cellphone_pct: "Cellphone (%)",
          cellphone_norm: "Cellphone (0-1)",
          combined_pct: "Combined (%)",
          combined_norm: "Combined (0-1)",
      gap: "Gap"
    },
    format: {
          cis_readiness_avg: d => d?.toFixed(3) || "N/A",
      tv_pct: d => d !== null ? d.toFixed(1) : "N/A",
          tv_norm: d => d !== null ? d.toFixed(3) : "N/A",
      internet_pct: d => d !== null ? d.toFixed(1) : "N/A",
          internet_norm: d => d !== null ? d.toFixed(3) : "N/A",
      cellphone_pct: d => d !== null ? d.toFixed(1) : "N/A",
          cellphone_norm: d => d !== null ? d.toFixed(3) : "N/A",
          combined_pct: d => d !== null ? d.toFixed(1) : "N/A",
          combined_norm: d => d !== null ? d.toFixed(3) : "N/A",
          gap: d => d !== null ? d.toFixed(3) : "N/A"
    },
    width: {
      admin0_name: 150,
      iso3: 60
    }
  });
    }
  }
}
```

### Dynamic Insights

```{ojs}
//| echo: false

s3Insights = {
  if (!s3FilteredData || s3FilteredData.length === 0 || !s3ProcessedData || s3ProcessedData.length === 0) {
    yield html`
      <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
        <h4 style="margin-top: 0;">Key Insights</h4>
        <p style="margin: 10px 0;"><em>Insights will appear once data is loaded...</em></p>
      </div>
    `;
    return;
  }
  
  const avgReadiness = d3.mean(s3FilteredData, d => d.cis_readiness_avg);
  const avgAccess = d3.mean(
    s3FilteredData.filter(d => d[s3CurrentAccessField] !== null && !isNaN(d[s3CurrentAccessField])),
    d => d[s3CurrentAccessField]
  );
  
  // Find countries with high readiness but low access (capacity-access gap)
  const capacityGaps = s3ProcessedData.filter(d => 
    d.cis_readiness_avg > 0.6 && d.accessValue !== null && !isNaN(d.accessValue) && d.accessValue < 0.4
  );
  
  // Find optimal zones (high readiness + high access)
  const optimalZones = s3ProcessedData.filter(d => 
    d.bivariateClass === "High × High"
  );
  
  const selectedRegion = (s3FilteredCountries && s3FilteredCountries.length === section3Data.length)
    ? "Africa" 
    : (s3FilteredCountries && s3FilteredCountries.length === 1)
    ? s3FilteredCountries[0]
    : s3FilteredCountries ? `${s3FilteredCountries.length} selected countries` : "Africa";
  
  const insight1 = `In ${selectedRegion}, average CIS Readiness is **${avgReadiness.toFixed(2)}** while ${s3CurrentAccessLabel} averages **${(avgAccess * 100).toFixed(1)}%**.`;
  
  const insight2 = capacityGaps.length > 0 
    ? `Countries such as **${capacityGaps.slice(0, 2).map(d => d.admin0_name).join(' and ')}** show strong technical capacity but limited digital reach, highlighting the need for investment in ICT and communication channels to deliver CIS to users.`
    : 'Most countries show balanced capacity and access.';
  
  const insight3 = optimalZones.length > 0
    ? `**${optimalZones.length} countries** (${(optimalZones.length / s3ProcessedData.length * 100).toFixed(1)}%) fall in the optimal zone with both high CIS readiness and high ${s3CurrentAccessLabel.toLowerCase()}, representing prime opportunities for scaling climate services.`
    : `No countries currently fall in the optimal zone for ${s3CurrentAccessLabel.toLowerCase()}.`;
  
  yield html`
    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
      <h4 style="margin-top: 0;">Key Insights</h4>
      <p style="margin: 10px 0;">${md([insight1])}</p>
      <p style="margin: 10px 0;"><strong>${_lang(cis.s3CapacityGap)}:</strong> ${md([insight2])}</p>
      <p style="margin: 10px 0;"><strong>Optimal Zones:</strong> ${md([insight3])}</p>
    </div>
  `;
}
```

```{ojs}
//| echo: false

// Download button for Section 3
{
  if (typeof downloadButton === 'undefined' || !s3SortedData || s3SortedData.length === 0) {
    yield html`<div style="padding: 10px; background: #f0f0f0; border-radius: 5px;">
      <em>Download will be available once data is loaded</em>
    </div>`;
  } else {
    // Helper function to safely format numbers
    const safeFormat = (value, decimals) => {
      if (value == null || isNaN(value)) return "N/A";
      return value.toFixed(decimals);
    };
    
    yield downloadButton(
      s3SortedData.map(d => ({
        "Country": d.admin0_name || "N/A",
        "ISO3": d.iso3 || "N/A",
        "CIS Readiness Raw": safeFormat(d.cis_readiness_avg, 3),
        "CIS Readiness Class": d.readinessClass || "N/A",
        "TV Access %": safeFormat(d.tv_pct, 1),
        "TV Access 0-1": safeFormat(d.tv_norm, 3),
        "Internet Access %": safeFormat(d.internet_pct, 1),
        "Internet Access 0-1": safeFormat(d.internet_norm, 3),
        "Cellphone Access %": safeFormat(d.cellphone_pct, 1),
        "Cellphone Access 0-1": safeFormat(d.cellphone_norm, 3),
        "Combined Access %": safeFormat(d.combined_pct, 1),
        "Combined Access 0-1": safeFormat(d.combined_norm, 3),
        "Gap (Access - Readiness)": safeFormat(d.gap, 3),
        "Bivariate Category": d.bivariateClass || "N/A"
      })),
      `cis_implementation_${s3AccessType}_access`,
      _lang(cis.downloadLabel)
    );
  }
}
```

---

<!--
```{ojs}
section32Title = _lang(cis.section32Title)
section32Placeholder = _lang(cis.section32Placeholder)
```

### `{ojs} section32Title` {#section3-2}

**Status:** `{ojs} section32Placeholder`

This section will examine non-technical barriers to CIS uptake across three pillars:

1. **Social, Cultural, and Demographic Factors**
   - Gender dynamics (sex ratio)
   - Language barriers (linguistic diversity)
   - Education levels (years of schooling)

2. **Programming Mechanisms**
   - Communication channels
   - Forecast scale and relevance
   - Trust and credibility

3. **Institutional Support and Resource Allocation**
   - Funding (WMO Climate Services Dashboard)
   - Boundary organizations
   - Livelihood assets

*Data compilation in progress. This section will feature a heatmap comparing countries across barrier indicators, bivariate maps showing barriers × readiness, and dynamic insights identifying priority areas for capacity building.*
-->

