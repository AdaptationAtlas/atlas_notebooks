```{ojs}
section3Title = _lang(cis.section3Title)
section31Title = _lang(cis.section31Title)
section31Intro = _lang(cis.section31Intro)
```

# `{ojs} section3Title` {#section3}

## `{ojs} section31Title` {#section3-1}

`{ojs} section31Intro`

```{ojs}
//| echo: false

// ============================================================================
// SECTION 3.1: CIS READINESS × ACCESS INTERSECTION
// ============================================================================

// Load access data using DuckDB with Parquet for better performance
s3AccessDB = await DuckDBClient.of({
  access_data: FileAttachment("/data/cis/CIS_access.parquet")
});

// Load and clean the access data
s3AccessDataRaw = await s3AccessDB.query(`SELECT * FROM access_data`);

s3AccessData = s3AccessDataRaw.map(row => ({
  admin0_name: row.admin0_name,
  admin1_name: row.admin1_name === "\\N" || row.admin1_name === "" ? null : row.admin1_name,
  admin2_name: row.admin2_name === "\\N" || row.admin2_name === "" ? null : row.admin2_name,
  iso3: row.iso3,
  gaul0_code: row.gaul0_code !== "\\N" && row.gaul0_code !== "" && row.gaul0_code !== null ? parseInt(row.gaul0_code) : null,
  gaul1_code: row.gaul1_code !== "\\N" && row.gaul1_code !== "" && row.gaul1_code !== null ? parseInt(row.gaul1_code) : null,
  gaul2_code: row.gaul2_code !== "\\N" && row.gaul2_code !== "" && row.gaul2_code !== null ? parseInt(row.gaul2_code) : null,
  tv: row.tv !== "\\N" && row.tv !== null && row.tv !== "" ? parseFloat(row.tv) : null,
  internet: row.internet !== "\\N" && row.internet !== null && row.internet !== "" ? parseFloat(row.internet) : null,
  cellphone: row.cellphone !== "\\N" && row.cellphone !== null && row.cellphone !== "" ? parseFloat(row.cellphone) : null
}));

// Aggregate CIS readiness to Admin 0 level (average)
s3CisReadinessAdmin0 = {
  if (typeof cisData === 'undefined' || !cisData) {
    console.error("cisData is not available - Section 1 must load first");
    return [];
  }
  
  // Group by admin0 and calculate mean CIS readiness
  const grouped = d3.rollup(
    cisData,
    v => ({
      cis_readiness_avg: d3.mean(v, d => d.cis_readiness_index),
      iso3: v[0].iso3,
      gaul0_code: v[0].gaul0_code
    }),
    d => d.admin0_name
  );
  
  return Array.from(grouped, ([admin0_name, data]) => {
    return {
      admin0_name: admin0_name,
      ...data
    };
  });
}

// Aggregate access data to Admin 0 level (average)
s3AccessAdmin0 = {
  // Group by admin0 and calculate mean access
  const grouped = d3.rollup(
    s3AccessData.filter(d => d.gaul0_code !== null),
    v => ({
      tv_avg: d3.mean(v, d => d.tv),
      internet_avg: d3.mean(v, d => d.internet),
      cellphone_avg: d3.mean(v, d => d.cellphone),
      iso3: v[0].iso3,
      gaul0_code: v[0].gaul0_code
    }),
    d => d.admin0_name
  );
  
  return Array.from(grouped, ([admin0_name, data]) => {
    return {
      admin0_name: admin0_name,
      ...data
    };
  });
}

// Join CIS readiness with access data at Admin 0 level
section3Data = {
  return s3CisReadinessAdmin0.map(cis => {
    // Find matching access data by admin0_name
    const access = s3AccessAdmin0.find(a => 
      a.admin0_name === cis.admin0_name || a.iso3 === cis.iso3
    );
    
    if (!access) return null;
    
    // Calculate combined access (average of all three indicators)
    const combined_access = (() => {
      const values = [access.tv_avg, access.internet_avg, access.cellphone_avg].filter(v => v !== null && !isNaN(v));
      return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : null;
    })();
    
    // Normalize to 0-1 scale (values are already percentages 0-100)
    return {
      admin0_name: cis.admin0_name,
      iso3: cis.iso3 || access.iso3,
      gaul0_code: cis.gaul0_code || access.gaul0_code,
      cis_readiness_avg: cis.cis_readiness_avg,
      // Raw percentages
      tv_pct: access.tv_avg,
      internet_pct: access.internet_avg,
      cellphone_pct: access.cellphone_avg,
      combined_pct: combined_access,
      // Normalized 0-1
      tv_norm: access.tv_avg !== null ? access.tv_avg / 100 : null,
      internet_norm: access.internet_avg !== null ? access.internet_avg / 100 : null,
      cellphone_norm: access.cellphone_avg !== null ? access.cellphone_avg / 100 : null,
      combined_norm: combined_access !== null ? combined_access / 100 : null
    };
  }).filter(d => d !== null);
}

// Note: cisReadinessCutoffs is defined in Section 2 (_cis_hazard_intersection.qmd)
// and reused here to avoid duplicate definitions
```

```{ojs}
//| echo: false

// Access Type Selector
viewof s3AccessType = Inputs.radio(
  ["combined", "internet", "tv", "cellphone"],
  {
    label: _lang(cis.s3AccessSelector),
    value: "combined",
    format: x => x === "combined" ? _lang(cis.s3AccessCombined) :
                 x === "internet" ? _lang(cis.s3AccessInternet) :
                 x === "tv" ? _lang(cis.s3AccessTV) :
                 _lang(cis.s3AccessCellphone)
  }
)
```

```{ojs}
//| echo: false

// Sort By Selector
viewof s3SortBy = Inputs.select(
  ["readiness", "combined", "internet", "tv", "cellphone"],
  {
    label: _lang(cis.s3SortBy),
    value: "readiness",
    format: x => x === "readiness" ? _lang(cis.s3SortReadiness) :
                 x === "combined" ? _lang(cis.s3AccessCombined) :
                 x === "internet" ? _lang(cis.s3AccessInternet) :
                 x === "tv" ? _lang(cis.s3AccessTV) :
                 _lang(cis.s3AccessCellphone)
  }
)
```

```{ojs}
//| echo: false

// Filter Countries Multi-select
s3UniqueCountries = {
  const countries = Array.from(new Set((section3Data || []).map(d => d.admin0_name))).sort();
  return countries;
}

viewof s3FilteredCountries = {
  if (!s3UniqueCountries || s3UniqueCountries.length === 0) {
    return Inputs.select([], {label: _lang(cis.s3FilterCountries), disabled: true});
  }
  return multiSelect({
    inputLabel: _lang(cis.s3FilterCountries),
    inputId: "s3FilterCountries",
    placeholderText: _lang(cis.admin0Placeholder),
    options: s3UniqueCountries.map(d => ({ value: d, label: d })),
    selected: s3UniqueCountries // Select all by default
  });
}
```

```{ojs}
//| echo: false

// Highlight Countries Multi-select (for scatter plot)
viewof s3HighlightedCountries = {
  if (!s3UniqueCountries || s3UniqueCountries.length === 0) {
    return Inputs.select([], {label: _lang(cis.s3HighlightCountries), disabled: true});
  }
  return multiSelect({
    inputLabel: _lang(cis.s3HighlightCountries),
    inputId: "s3HighlightCountries",
    placeholderText: _lang(cis.admin0Placeholder),
    options: s3UniqueCountries.map(d => ({ value: d, label: d })),
    selected: [] // None selected by default
  });
}
```

```{ojs}
//| echo: false

// View Toggle
viewof s3ViewType = Inputs.radio(
  ["map", "dumbbell", "scatter", "table"],
  {
    label: _lang(cis.s3ViewToggle),
    value: "map",
    format: x => x === "map" ? _lang(cis.s3ViewMap) :
                 x === "dumbbell" ? _lang(cis.s3ViewDumbbell) :
                 x === "scatter" ? _lang(cis.s3ViewScatter) :
                 _lang(cis.s3ViewTable)
  }
)
```

```{ojs}
//| echo: false

// Helper to get current access field name
s3CurrentAccessField = s3AccessType === "combined" ? "combined_norm" :
                       s3AccessType === "internet" ? "internet_norm" :
                       s3AccessType === "tv" ? "tv_norm" :
                       "cellphone_norm"

// Helper to get current access label
s3CurrentAccessLabel = s3AccessType === "combined" ? _lang(cis.s3AccessCombined) :
                       s3AccessType === "internet" ? _lang(cis.s3AccessInternet) :
                       s3AccessType === "tv" ? _lang(cis.s3AccessTV) :
                       _lang(cis.s3AccessCellphone)

// Helper to get current access raw field
s3CurrentAccessRawField = s3AccessType === "combined" ? "combined_pct" :
                          s3AccessType === "internet" ? "internet_pct" :
                          s3AccessType === "tv" ? "tv_pct" :
                          "cellphone_pct"
```

```{ojs}
//| echo: false

// Filter data based on selected countries
s3FilteredData = {
  if (!section3Data || section3Data.length === 0) {
    return [];
  }
  
  return section3Data.filter(d => 
    !s3FilteredCountries || s3FilteredCountries.length === 0 || s3FilteredCountries.includes(d.admin0_name)
  );
}
```

```{ojs}
//| echo: false

// Calculate access cutoffs (terciles) for current access type
s3AccessCutoffs = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return { low: 0.33, moderate: 0.67 };
  }
  
  const values = s3FilteredData
    .map(d => d[s3CurrentAccessField])
    .filter(v => v !== null && !isNaN(v))
    .sort((a, b) => a - b);
  
  if (values.length === 0) {
    return { low: 0.33, moderate: 0.67 };
  }
  
  return {
    low: d3.quantile(values, 0.333),
    moderate: d3.quantile(values, 0.667)
  };
}
```

```{ojs}
//| echo: false

// Bivariate classification function (reuse from Section 2)
function bivariateClassifyAccess(readiness, access, readinessCutoffs, accessCutoffs) {
  let readinessClass;
  if (readiness < readinessCutoffs.low) readinessClass = "Low";
  else if (readiness < readinessCutoffs.moderate) readinessClass = "Moderate";
  else readinessClass = "High";
  
  let accessClass;
  if (access === null || isNaN(access)) accessClass = "N/A";
  else if (access < accessCutoffs.low) accessClass = "Low";
  else if (access < accessCutoffs.moderate) accessClass = "Moderate";
  else accessClass = "High";
  
  return {
    readinessClass,
    accessClass,
    bivariateClass: accessClass === "N/A" ? "N/A" : `${readinessClass} × ${accessClass}`
  };
}

// Bivariate color palette (3x3 grid) - reuse from Section 2
s3BivariateColors = {
  return {
    "Low × Low": "#e8e8e8",
    "Low × Moderate": "#b8d6be",
    "Low × High": "#6c9a8b",
    "Moderate × Low": "#c8b2d6",
    "Moderate × Moderate": "#9c9eba",
    "Moderate × High": "#627a8e",
    "High × Low": "#b8a0c2",
    "High × Moderate": "#8b7fa8",
    "High × High": "#5a5f8f",
    "N/A": "#cccccc"
  };
}
```

```{ojs}
//| echo: false

// Process data with bivariate classification
s3ProcessedData = {
  if (!s3FilteredData || s3FilteredData.length === 0) {
    return [];
  }
  
  return s3FilteredData.map(d => {
    const accessValue = d[s3CurrentAccessField];
    const classification = bivariateClassifyAccess(
      d.cis_readiness_avg,
      accessValue,
      cisReadinessCutoffs,
      s3AccessCutoffs
    );
    
    return {
      ...d,
      accessValue,
      ...classification,
      gap: accessValue !== null && !isNaN(accessValue) ? accessValue - d.cis_readiness_avg : null
    };
  });
}
```

```{ojs}
//| echo: false

// Sort data based on selected metric
s3SortedData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
    return [];
  }
  
  const data = [...s3ProcessedData];
  
  if (s3SortBy === "readiness") {
    return data.sort((a, b) => (b.cis_readiness_avg || 0) - (a.cis_readiness_avg || 0));
  } else if (s3SortBy === "combined") {
    return data.sort((a, b) => (b.combined_norm || 0) - (a.combined_norm || 0));
  } else if (s3SortBy === "internet") {
    return data.sort((a, b) => (b.internet_norm || 0) - (a.internet_norm || 0));
  } else if (s3SortBy === "tv") {
    return data.sort((a, b) => (b.tv_norm || 0) - (a.tv_norm || 0));
  } else if (s3SortBy === "cellphone") {
    return data.sort((a, b) => (b.cellphone_norm || 0) - (a.cellphone_norm || 0));
  }
  
  return data;
}
```

```{ojs}
//| echo: false

// Prepare geographic data for map
s3GeoData = {
  if (!s3ProcessedData || s3ProcessedData.length === 0 || !admin0Boundaries) {
    return { type: "FeatureCollection", features: [] };
  }
  
  const features = admin0Boundaries.features.map(feature => {
    const countryData = s3ProcessedData.find(d => 
      d.gaul0_code === feature.properties.gaul0_code ||
      d.admin0_name === feature.properties.admin0_name
    );
    
    if (!countryData) return null;
    
    return {
      type: "Feature",
      geometry: feature.geometry,
      properties: {
        ...feature.properties,
        ...countryData
      }
    };
  }).filter(f => f !== null);
  
  return {
    type: "FeatureCollection",
    features
  };
}
```

### Visualization

```{ojs}
//| echo: false

// Bivariate legend (3x3 grid)
s3Legend = {
  const size = 40;
  const gap = 2;
  const classes = ["Low", "Moderate", "High"];
  
  return html`
    <div style="margin: 20px 0; padding: 20px; background: white; border-radius: 8px; display: inline-block;">
      <div style="font-weight: bold; margin-bottom: 10px; font-size: 12px;">
        ${_lang(cis.s3ReadinessLabel)} → (horizontal) | ${s3CurrentAccessLabel} → (vertical)
      </div>
      <svg width="${size * 3 + gap * 2 + 100}" height="${size * 3 + gap * 2 + 50}">
        ${classes.flatMap((accessClass, i) => 
          classes.map((readinessClass, j) => {
            const bivClass = `${readinessClass} × ${accessClass}`;
            return svg`
              <rect 
                x="${j * (size + gap)}" 
                y="${(2 - i) * (size + gap)}"
                width="${size}" 
                height="${size}"
                fill="${s3BivariateColors[bivClass]}"
                stroke="#333"
                stroke-width="1"
              />
            `;
          })
        )}
        <text x="${size * 3 + gap * 2 + 5}" y="${size * 1.5}" font-size="12">High</text>
        <text x="${size * 3 + gap * 2 + 5}" y="${size * 2.5 + gap}" font-size="12">Moderate</text>
        <text x="${size * 3 + gap * 2 + 5}" y="${size * 3.5 + gap * 2}" font-size="12">Low</text>
        
        <text x="${size * 0.5}" y="${size * 3 + gap * 2 + 20}" font-size="12" text-anchor="middle">Low</text>
        <text x="${size * 1.5 + gap}" y="${size * 3 + gap * 2 + 20}" font-size="12" text-anchor="middle">Moderate</text>
        <text x="${size * 2.5 + gap * 2}" y="${size * 3 + gap * 2 + 20}" font-size="12" text-anchor="middle">High</text>
      </svg>
    </div>
  `;
}
```

```{ojs}
//| echo: false

// Render based on view type
{
  if (s3ViewType === "map") {
    yield html`<div style="width: 100%; overflow-x: auto;">
      ${Plot.plot({
        width: 2000,
        height: 1000,
        projection: {
          type: "mercator",
          domain: s3GeoData
        },
        color: {
          legend: false
        },
        marks: [
          Plot.geo(s3GeoData.features, {
            fill: d => s3BivariateColors[d.properties.bivariateClass] || "#cccccc",
            stroke: "#333",
            strokeWidth: 0.5
          }),
          Plot.tip(
            s3GeoData.features,
            Plot.pointer(
              Plot.centroid({
                channels: {
                  country: {
                    label: "Country",
                    value: (d) => d.properties.admin0_name
                  },
                  readiness: {
                    label: _lang(cis.s3ReadinessLabel),
                    value: (d) => d.properties.cis_readiness_avg
                  },
                  readinessClass: {
                    label: "Readiness Class",
                    value: (d) => d.properties.readinessClass
                  },
                  access: {
                    label: s3CurrentAccessLabel,
                    value: (d) => d.properties.accessValue
                  },
                  accessClass: {
                    label: "Access Class",
                    value: (d) => d.properties.accessClass
                  },
                  category: {
                    label: "Category",
                    value: (d) => d.properties.bivariateClass
                  },
                  optimal: {
                    label: "Optimal Zone",
                    value: (d) => d.properties.bivariateClass === "High × High" ? `✓ ${_lang(cis.s3OptimalZone)}` : ""
                  }
                },
                format: {
                  country: true,
                  readiness: (d) => d != null ? d.toFixed(2) : "N/A",
                  readinessClass: true,
                  access: (d) => d != null ? (d * 100).toFixed(1) + '%' : "N/A",
                  accessClass: true,
                  category: true,
                  optimal: true
                }
              })
            )
          )
        ]
      })}
      ${s3Legend}
    </div>`;
  } else if (s3ViewType === "dumbbell") {
    // Dumbbell Chart - inline to prevent auto-display
  if (!s3SortedData || s3SortedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Dumbbell chart will appear once data is loaded...</em>
    </div>`;
    } else {
  const chartHeight = Math.max(600, s3SortedData.length * 25);
  const linkData = s3SortedData.filter(d => d.accessValue !== null && !isNaN(d.accessValue));
  const accessData = s3SortedData.filter(d => d.accessValue !== null && !isNaN(d.accessValue));
  const allTipData = [...s3SortedData, ...accessData];
  
      yield html`<div style="width: 100%; overflow-x: auto;">
    <div style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="display: flex; gap: 20px; align-items: center; font-size: 12px;">
        <div><span style="color: #377eb8;">●</span> ${_lang(cis.s3ReadinessLabel)}</div>
            <div><span style="color: #ff7f00;">▲</span> ${s3CurrentAccessLabel}</div>
        <div><span style="color: #4daf4a;">━</span> ${_lang(cis.s3PositiveGap)}</div>
        <div><span style="color: #e41a1c;">━</span> ${_lang(cis.s3NegativeGap)}</div>
        <div><span style="color: #999999;">━</span> Similar values</div>
      </div>
    </div>
    ${Plot.plot({
      width: 1200,
      height: chartHeight,
      marginLeft: 150,
      marginRight: 50,
      marginTop: 80,
      marginBottom: 80,
      x: {
        domain: [0, 1],
        label: "Value (0-1 scale)",
        grid: true,
        axis: "top"
      },
      y: {
        label: null,
        domain: s3SortedData.map(d => d.admin0_name)
      },
      marks: [
        Plot.axisX({anchor: "bottom", label: "Value (0-1 scale)"}),
        // Connecting lines
        Plot.link(linkData, {
          x1: "cis_readiness_avg",
          x2: "accessValue",
          y1: "admin0_name",
          y2: "admin0_name",
          stroke: d => {
            if (d.gap === null || isNaN(d.gap)) return "#999999";
            return d.gap > 0.05 ? "#4daf4a" : d.gap < -0.05 ? "#e41a1c" : "#999999";
          },
          strokeWidth: 2
        }),
        // Readiness dots (left)
        Plot.dot(s3SortedData, {
          x: "cis_readiness_avg",
          y: "admin0_name",
          fill: "#377eb8",
          r: 5
        }),
        // Access dots (right)
        Plot.dot(accessData, {
          x: "accessValue",
          y: "admin0_name",
          fill: "#ff7f00",
          r: 5,
          shape: "triangle"
        }),
        Plot.tip(
          allTipData,
          Plot.pointer({
            x: (d) => d.cis_readiness_avg != null ? d.cis_readiness_avg : d.accessValue,
            y: "admin0_name",
            channels: {
              country: {
                label: "Country",
                value: (d) => d.admin0_name
              },
              readiness: {
                label: _lang(cis.s3ReadinessLabel),
                value: (d) => d.cis_readiness_avg
              },
              access: {
                label: s3CurrentAccessLabel,
                value: (d) => d.accessValue
              },
              gap: {
                label: _lang(cis.s3GapLabel),
                value: (d) => d.gap
              }
            },
            format: {
              country: true,
              readiness: (d) => d != null ? d.toFixed(3) : "N/A",
              access: (d) => d != null ? (d * 100).toFixed(1) + '%' : "N/A",
              gap: (d) => {
                if (d == null || isNaN(d)) return "N/A";
                const label = d > 0 ? _lang(cis.s3PositiveGap) : _lang(cis.s3NegativeGap);
                return `${d.toFixed(3)} (${label})`;
              }
            }
          })
        )
      ]
    })}
    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="display: flex; gap: 20px; align-items: center; font-size: 12px;">
        <div><span style="color: #377eb8;">●</span> ${_lang(cis.s3ReadinessLabel)}</div>
            <div><span style="color: #ff7f00;">▲</span> ${s3CurrentAccessLabel}</div>
        <div><span style="color: #4daf4a;">━</span> ${_lang(cis.s3PositiveGap)}</div>
        <div><span style="color: #e41a1c;">━</span> ${_lang(cis.s3NegativeGap)}</div>
        <div><span style="color: #999999;">━</span> Similar values</div>
      </div>
    </div>
  </div>`;
}
  } else if (s3ViewType === "scatter") {
    // Scatter Plot - inline to prevent auto-display
  if (!s3ProcessedData || s3ProcessedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Scatter plot will appear once data is loaded...</em>
    </div>`;
    } else {
      const scatterData = s3ProcessedData.filter(d => 
        d.accessValue !== null && 
        !isNaN(d.accessValue)
      );
      
      yield html`<div style="width: 100%; overflow-x: auto;">
    <div style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="font-size: 12px;">
        <strong>${_lang(cis.s3ParityLine)}:</strong> Points above the line indicate access exceeds readiness; points below indicate readiness exceeds access.
      </div>
    </div>
    ${Plot.plot({
        width: 1000,
        height: 1000,
        marginTop: 80,
        marginBottom: 80,
        x: {
          domain: [0, 1],
          label: _lang(cis.s3ReadinessLabel) + " →",
          grid: true,
          axis: "top"
        },
        y: {
          domain: [0, 1],
          label: s3CurrentAccessLabel + " →",
          grid: true
        },
        marks: [
          Plot.axisX({anchor: "bottom", label: _lang(cis.s3ReadinessLabel) + " →"}),
          // Diagonal reference line (parity)
          Plot.line([[0, 0], [1, 1]], {
            stroke: "#999",
            strokeWidth: 2,
            strokeDasharray: "5,5"
          }),
          // All countries (not highlighted)
          Plot.dot(
            scatterData.filter(d => !s3HighlightedCountries.includes(d.admin0_name)),
            {
              x: "cis_readiness_avg",
              y: "accessValue",
              fill: d => s3BivariateColors[d.bivariateClass] || "#cccccc",
              stroke: "#333",
              strokeWidth: 1,
              r: 6
            }
          ),
          // Highlighted countries
          Plot.dot(
            scatterData.filter(d => s3HighlightedCountries.includes(d.admin0_name)),
            {
              x: "cis_readiness_avg",
              y: "accessValue",
              fill: "#0066cc",
              stroke: "#000",
              strokeWidth: 2,
              r: 10
            }
          ),
          Plot.tip(
            scatterData,
            Plot.pointer({
              x: "cis_readiness_avg",
              y: "accessValue",
              channels: {
                country: {
                  label: "Country",
                  value: (d) => d.admin0_name
                },
                readiness: {
                  label: _lang(cis.s3ReadinessLabel),
                  value: (d) => d.cis_readiness_avg
                },
                access: {
                  label: s3CurrentAccessLabel,
                  value: (d) => d.accessValue
                },
                gap: {
                  label: _lang(cis.s3GapLabel),
                  value: (d) => d.gap
                }
              },
              format: {
                country: true,
                readiness: (d) => d != null ? d.toFixed(3) : "N/A",
                access: (d) => d != null ? (d * 100).toFixed(1) + '%' : "N/A",
                gap: (d) => d != null ? d.toFixed(3) : "N/A"
              }
            })
          ),
        // Labels for highlighted countries
        Plot.text(
          scatterData.filter(d => s3HighlightedCountries.includes(d.admin0_name)),
          {
            x: "cis_readiness_avg",
            y: "accessValue",
            text: "admin0_name",
            dy: -15,
            fontSize: 11,
            fontWeight: "bold"
          }
        )
      ]
    })}
    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <div style="font-size: 12px;">
        <strong>${_lang(cis.s3ParityLine)}:</strong> Points above the line indicate access exceeds readiness; points below indicate readiness exceeds access.
      </div>
    </div>
  </div>`;
}
  } else {
    // Table View - inline to prevent auto-display
  if (!s3SortedData || s3SortedData.length === 0) {
      yield html`<div style="padding: 20px; background: #f0f0f0; border-radius: 5px;">
      <em>Table will appear once data is loaded...</em>
    </div>`;
    } else {
      yield Inputs.table(s3SortedData, {
    columns: [
      "admin0_name",
      "iso3",
      "cis_readiness_avg",
      "readinessClass",
      "tv_pct",
          "tv_norm",
      "internet_pct",
          "internet_norm",
      "cellphone_pct",
          "cellphone_norm",
          "combined_pct",
          "combined_norm",
      "gap"
    ],
    header: {
      admin0_name: "Country",
      iso3: "ISO3",
      cis_readiness_avg: "CIS Readiness (Raw)",
      readinessClass: "CIS Class",
      tv_pct: "TV Access (%)",
          tv_norm: "TV (0-1)",
      internet_pct: "Internet (%)",
          internet_norm: "Internet (0-1)",
      cellphone_pct: "Cellphone (%)",
          cellphone_norm: "Cellphone (0-1)",
          combined_pct: "Combined (%)",
          combined_norm: "Combined (0-1)",
      gap: "Gap"
    },
    format: {
          cis_readiness_avg: d => d?.toFixed(3) || "N/A",
      tv_pct: d => d !== null ? d.toFixed(1) : "N/A",
          tv_norm: d => d !== null ? d.toFixed(3) : "N/A",
      internet_pct: d => d !== null ? d.toFixed(1) : "N/A",
          internet_norm: d => d !== null ? d.toFixed(3) : "N/A",
      cellphone_pct: d => d !== null ? d.toFixed(1) : "N/A",
          cellphone_norm: d => d !== null ? d.toFixed(3) : "N/A",
          combined_pct: d => d !== null ? d.toFixed(1) : "N/A",
          combined_norm: d => d !== null ? d.toFixed(3) : "N/A",
          gap: d => d !== null ? d.toFixed(3) : "N/A"
    },
    width: {
      admin0_name: 150,
      iso3: 60
    }
  });
    }
  }
}
```

### Dynamic Insights

```{ojs}
//| echo: false

s3Insights = {
  if (!s3FilteredData || s3FilteredData.length === 0 || !s3ProcessedData || s3ProcessedData.length === 0) {
    yield html`
      <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
        <h4 style="margin-top: 0;">Key Insights</h4>
        <p style="margin: 10px 0;"><em>Insights will appear once data is loaded...</em></p>
      </div>
    `;
    return;
  }
  
  const avgReadiness = d3.mean(s3FilteredData, d => d.cis_readiness_avg);
  const avgAccess = d3.mean(
    s3FilteredData.filter(d => d[s3CurrentAccessField] !== null && !isNaN(d[s3CurrentAccessField])),
    d => d[s3CurrentAccessField]
  );
  
  // Find countries with high readiness but low access (capacity-access gap)
  const capacityGaps = s3ProcessedData.filter(d => 
    d.cis_readiness_avg > 0.6 && d.accessValue !== null && !isNaN(d.accessValue) && d.accessValue < 0.4
  );
  
  // Find optimal zones (high readiness + high access)
  const optimalZones = s3ProcessedData.filter(d => 
    d.bivariateClass === "High × High"
  );
  
  const selectedRegion = (s3FilteredCountries && s3FilteredCountries.length === section3Data.length)
    ? "Africa" 
    : (s3FilteredCountries && s3FilteredCountries.length === 1)
    ? s3FilteredCountries[0]
    : s3FilteredCountries ? `${s3FilteredCountries.length} selected countries` : "Africa";
  
  const insight1 = `In ${selectedRegion}, average CIS Readiness is **${avgReadiness.toFixed(2)}** while ${s3CurrentAccessLabel} averages **${(avgAccess * 100).toFixed(1)}%**.`;
  
  const insight2 = capacityGaps.length > 0 
    ? `Countries such as **${capacityGaps.slice(0, 2).map(d => d.admin0_name).join(' and ')}** show strong technical capacity but limited digital reach, highlighting the need for investment in ICT and communication channels to deliver CIS to users.`
    : 'Most countries show balanced capacity and access.';
  
  const insight3 = optimalZones.length > 0
    ? `**${optimalZones.length} countries** (${(optimalZones.length / s3ProcessedData.length * 100).toFixed(1)}%) fall in the optimal zone with both high CIS readiness and high ${s3CurrentAccessLabel.toLowerCase()}, representing prime opportunities for scaling climate services.`
    : `No countries currently fall in the optimal zone for ${s3CurrentAccessLabel.toLowerCase()}.`;
  
  yield html`
    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
      <h4 style="margin-top: 0;">Key Insights</h4>
      <p style="margin: 10px 0;">${md([insight1])}</p>
      <p style="margin: 10px 0;"><strong>${_lang(cis.s3CapacityGap)}:</strong> ${md([insight2])}</p>
      <p style="margin: 10px 0;"><strong>Optimal Zones:</strong> ${md([insight3])}</p>
    </div>
  `;
}
```

```{ojs}
//| echo: false

// Download button for Section 3
{
  if (typeof downloadButton === 'undefined' || !s3SortedData || s3SortedData.length === 0) {
    yield html`<div style="padding: 10px; background: #f0f0f0; border-radius: 5px;">
      <em>Download will be available once data is loaded</em>
    </div>`;
  } else {
    // Helper function to safely format numbers
    const safeFormat = (value, decimals) => {
      if (value == null || isNaN(value)) return "N/A";
      return value.toFixed(decimals);
    };
    
    yield downloadButton(
      s3SortedData.map(d => ({
        "Country": d.admin0_name || "N/A",
        "ISO3": d.iso3 || "N/A",
        "CIS Readiness Raw": safeFormat(d.cis_readiness_avg, 3),
        "CIS Readiness Class": d.readinessClass || "N/A",
        "TV Access %": safeFormat(d.tv_pct, 1),
        "TV Access 0-1": safeFormat(d.tv_norm, 3),
        "Internet Access %": safeFormat(d.internet_pct, 1),
        "Internet Access 0-1": safeFormat(d.internet_norm, 3),
        "Cellphone Access %": safeFormat(d.cellphone_pct, 1),
        "Cellphone Access 0-1": safeFormat(d.cellphone_norm, 3),
        "Combined Access %": safeFormat(d.combined_pct, 1),
        "Combined Access 0-1": safeFormat(d.combined_norm, 3),
        "Gap (Access - Readiness)": safeFormat(d.gap, 3),
        "Bivariate Category": d.bivariateClass || "N/A"
      })),
      `cis_implementation_${s3AccessType}_access`,
      _lang(cis.downloadLabel)
    );
  }
}
```

---

```{ojs}
section32Title = _lang(cis.section32Title)
section32Placeholder = _lang(cis.section32Placeholder)
```

### `{ojs} section32Title` {#section3-2}

**Status:** `{ojs} section32Placeholder`

This section will examine non-technical barriers to CIS uptake across three pillars:

1. **Social, Cultural, and Demographic Factors**
   - Gender dynamics (sex ratio)
   - Language barriers (linguistic diversity)
   - Education levels (years of schooling)

2. **Programming Mechanisms**
   - Communication channels
   - Forecast scale and relevance
   - Trust and credibility

3. **Institutional Support and Resource Allocation**
   - Funding (WMO Climate Services Dashboard)
   - Boundary organizations
   - Livelihood assets

*Data compilation in progress. This section will feature a heatmap comparing countries across barrier indicators, bivariate maps showing barriers × readiness, and dynamic insights identifying priority areas for capacity building.*

