```{ojs}
// ============================================================================
// SECTION 2: CIS READINESS × CLIMATE HAZARD INTERSECTION
// ============================================================================
// This file analyzes the intersection between CIS readiness and climate hazard
// exposure (drought and waterlogging). It uses a bivariate mapping approach
// to identify regions that are both high-exposure AND high-readiness (optimal
// zones for CIS deployment) or high-exposure but low-readiness (priority gaps).
//
// Key Concepts:
// - Bivariate Classification: 3×3 grid combining hazard severity and CIS readiness
// - NDWS (Normalized Difference Water Stress): Drought indicator (days)
// - NDWL0 (Normalized Difference Water Level): Waterlogging indicator (days)
// - Diamond Legend: Rotated 45° to intuitively show the two dimensions
//
// Data Sources:
// - haz-means_adm_historic.parquet: Historical hazard means at admin levels
// - three_cut_offs.csv: Pre-computed tercile cutoffs for CIS readiness
// ============================================================================

section2Title = _lang(cis.section2Title)
section2Intro = _lang(cis.section2Intro)
```

# `{ojs} section2Title` {#section2}

`{ojs} section2Intro`

```{ojs}
//| echo: false

// Synchronized admin selectors for Section 2 - these sync with the master selectors
// Note: createSyncedAdminSelector is defined in _cis_readiness_index.qmd
viewof s2Admin0 = createSyncedAdminSelector(0, viewof selectedAdmin0, uniqueAdmin0.map(d => ({ value: d, label: d })), "s2", _lang(cis.admin0Label), _lang(cis.admin0Placeholder))

viewof s2Admin1 = createSyncedAdminSelector(1, viewof selectedAdmin1, admin1Options.map(d => ({ value: d, label: d })), "s2", _lang(cis.admin1Label), _lang(cis.admin1Placeholder))

viewof s2Admin2 = createSyncedAdminSelector(2, viewof selectedAdmin2, admin2Options.map(d => ({ value: d, label: d })), "s2", _lang(cis.admin2Label), _lang(cis.admin2Placeholder))
```

```{ojs}
//| echo: false

// Inline admin level selectors for this section - Region Selection
htl.html`
<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
  <div style="flex: 1; min-width: 200px;">
    ${viewof s2Admin0}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s2Admin1}
  </div>
  <div style="flex: 1; min-width: 200px;">
    ${viewof s2Admin2}
  </div>
</div>
`
```

```{ojs}
//| echo: false

// ============================================================================
// HAZARD DATA LOADING AND PROCESSING
// ============================================================================
// Load climate hazard data and pivot from long to wide format.
// The source data has one row per (region, hazard_type) combination.
// We need to pivot so each region has separate columns for drought/waterlogging.
// ============================================================================

hazardDB = await DuckDBClient.of({
  hazard_data: FileAttachment("/data/cis/haz-means_adm_historic.parquet")
});

// Load all hazard data - filtering done in JS to avoid DuckDB key issues
hazardDataRaw = await hazardDB.query(`SELECT * FROM hazard_data`);

// Filter for the two hazards we need:
// - NDWS-mean: Normalized Difference Water Stress (drought - days of stress)
// - NDWL0-mean: Normalized Difference Water Level at surface (waterlogging - days)
hazardData = hazardDataRaw.filter(d => 
  d.hazard === "NDWS-mean" || d.hazard === "NDWL0-mean"
);

// ============================================================================
// TERCILE CUTOFFS: Load Pre-Computed Classification Thresholds
// ============================================================================
// Rather than computing cutoffs dynamically (which could vary with selections),
// we load pre-computed Africa-wide cutoffs from a CSV file. This ensures
// consistent classifications across all views and user interactions.
// ============================================================================

cisReadinessCutoffs = await d3.csv("/data/cis/three_cut_offs.csv").then(data => {
  // Find the row for CIS readiness index
  const cisRow = data.find(d => d[''] === 'cis_readiness_index');
  return {
    low: parseFloat(cisRow['X33.33333.']),      // 33rd percentile
    moderate: parseFloat(cisRow['X66.66667.'])  // 66th percentile
  };
});

// ============================================================================
// DATA PIVOTING: Transform Long Format to Wide Format
// ============================================================================
// Input format (long):  | region | hazard     | value |
//                       | Kenya  | NDWS-mean  | 18.5  |
//                       | Kenya  | NDWL0-mean | 3.2   |
//
// Output format (wide): | region | drought_ndws | waterlogging_ndwl0 |
//                       | Kenya  | 18.5         | 3.2                |
//
// This uses D3.group to aggregate by region, then extracts values by hazard type.
// ============================================================================

hazardPivoted = {
  // Create a composite key for each unique region (all admin levels)
  const grouped = d3.group(hazardData, d => `${d.iso3}_${d.admin0_name}_${d.admin1_name}_${d.admin2_name}`);
  
  return Array.from(grouped.values()).map(group => {
    const base = group[0];  // Get region identifiers from first row
    const drought = group.find(d => d.hazard === "NDWS-mean");
    const waterlogging = group.find(d => d.hazard === "NDWL0-mean");
    
    return {
      iso3: base.iso3,
      admin0_name: base.admin0_name,
      admin1_name: base.admin1_name,
      admin2_name: base.admin2_name,
      drought_ndws: drought ? parseFloat(drought.value) : null,
      waterlogging_ndwl0: waterlogging ? parseFloat(waterlogging.value) : null
    };
  });
}

// ============================================================================
// DATA JOINING: Combine CIS Readiness with Hazard Exposure
// ============================================================================
// Join the hazard data with CIS readiness data (from Section 1) to create
// a unified dataset for bivariate analysis. Match on all admin fields.
// ============================================================================

combinedData = cisData.map(cis => {
  // Find matching hazard row by exact admin name match
  const hazard = hazardPivoted.find(h => 
    h.iso3 === cis.iso3 &&
    h.admin0_name === cis.admin0_name &&
    h.admin1_name === cis.admin1_name &&
    h.admin2_name === cis.admin2_name
  );
  
  return {
    ...cis,
    drought_ndws: hazard?.drought_ndws || null,
    waterlogging_ndwl0: hazard?.waterlogging_ndwl0 || null
  };
}).filter(d => d.drought_ndws !== null || d.waterlogging_ndwl0 !== null);

// ============================================================================
// BIVARIATE CLASSIFICATION FUNCTION
// ============================================================================
// Classifies regions into a 3×3 bivariate grid based on:
// - CIS Readiness: Low/Moderate/High (using pre-computed tercile cutoffs)
// - Hazard Severity: Low/Moderate/High (using hazard-specific thresholds)
//
// Hazard thresholds are based on climate science conventions:
// - Drought (NDWS): <15 days = Low, 15-20 = Moderate, >20 = High
// - Waterlogging (NDWL0): <2 days = Low, 2-5 = Moderate, >5 = High
//
// The resulting bivariateClass (e.g., "High × High") drives map coloring.
// ============================================================================

function bivariateClassify(readiness, hazard, readinessCutoffs, hazardType) {
  // Classify CIS readiness using tercile cutoffs from CSV
  let readinessClass;
  if (readiness < readinessCutoffs.low) readinessClass = "Low";
  else if (readiness < readinessCutoffs.moderate) readinessClass = "Moderate";
  else readinessClass = "High";
  
  // Classify hazard using hazard-type-specific thresholds
  let hazardClass;
  if (hazardType === "NDWS-mean") {
    // Drought: measured in stress days per year
    if (hazard < 15) hazardClass = "Low";
    else if (hazard < 20) hazardClass = "Moderate";
    else hazardClass = "High";
  } else if (hazardType === "NDWL0-mean") {
    // Waterlogging: measured in waterlogged days per year
    if (hazard < 2) hazardClass = "Low";
    else if (hazard < 5) hazardClass = "Moderate";
    else hazardClass = "High";
  }
  
  return {
    readinessClass,
    hazardClass,
    bivariateClass: `${readinessClass} × ${hazardClass}`
  };
}

// ============================================================================
// BIVARIATE COLOR PALETTE: 3×3 Grid Colors
// ============================================================================
// Color scheme designed to highlight the "High × High" optimal zone
// (dark purple) while showing the full spectrum of readiness×hazard combos.
//
// Color logic:
// - Rows (vertical): CIS Readiness increases → more purple/blue
// - Columns (horizontal): Hazard Severity increases → more saturated
// - "High × High" = Priority zone for CIS deployment (darkest, most distinct)
// - "Low × High" = Investment gap (high hazard but low readiness)
// ============================================================================

bivariateColors = {
  return {
    "Low × Low": "#e8e8e8",       // Light gray - lowest priority
    "Low × Moderate": "#b8d6be",  
    "Low × High": "#6c9a8b",       // Teal-green - high need, low capacity (GAP)
    "Moderate × Low": "#c8b2d6",
    "Moderate × Moderate": "#9c9eba",
    "Moderate × High": "#627a8e",
    "High × Low": "#b8a0c2",      
    "High × Moderate": "#8b7fa8",
    "High × High": "#5a5f8f"       // Dark purple - OPTIMAL (priority for CIS)
  };
}
```

```{ojs}
//| echo: false

viewof s2HazardType = Inputs.radio(
  ["drought", "waterlogging"],
  {
    label: _lang(cis.s2HazardSelector),
    value: "drought",
    format: d => d === "drought" ? _lang(cis.s2HazardDrought) : _lang(cis.s2HazardWaterlogging)
  }
);

viewof s2ReadinessThreshold = {
  const extent = d3.extent(combinedData, d => d.cis_readiness_index);
  return Inputs.range([extent[0] || 0, extent[1] || 1], {
  label: _lang(cis.s2ReadinessThreshold),
  step: 0.01,
  value: extent[0] || 0
});
}

viewof s2ViewToggle = Inputs.radio(
  ["map", "table"],
  {
    label: _lang(cis.s2ViewToggle),
    value: "map",
    format: d => d === "map" ? _lang(cis.s2ViewMap) : _lang(cis.s2ViewTable)
  }
);
```

```{ojs}
//| echo: false

// Reuse admin level from Section 1
s2CurrentAdminLevel = currentAdminLevel;

// Process and classify data - filter by Section 1's selections
s2ProcessedData = {
  const hazardColumn = s2HazardType === "drought" ? "drought_ndws" : "waterlogging_ndwl0";
  const hazardTypeCode = s2HazardType === "drought" ? "NDWS-mean" : "NDWL0-mean";
  
  // Filter by Section 1's admin selections using the same logic
  let filtered = combinedData;
  
  // Default: No admin0 selected - show all admin0 level data
  if (selectedAdmin0.length === 0) {
    filtered = filtered.filter(d => d.admin1_name == null);
  }
  // Admin0 selected, no admin1 - show all admin1 data for selected countries
  else if (selectedAdmin1.length === 0) {
    filtered = filtered.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
      d.admin1_name != null && 
      d.admin2_name == null
    );
  }
  // Admin1 selected - show all admin2 data for selected admin1 regions
  else {
    filtered = filtered.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
      selectedAdmin1.includes(d.admin1_name) &&
      d.admin2_name != null
    );
  }
  
  // Filter by readiness threshold and remove nulls
  filtered = filtered.filter(d => 
    d.cis_readiness_index >= s2ReadinessThreshold &&
    d[hazardColumn] !== null
  );
  
  // Add classifications
  return filtered.map(d => {
    const classified = bivariateClassify(
      d.cis_readiness_index,
      d[hazardColumn],
      cisReadinessCutoffs,
      hazardTypeCode
    );
    
    return {
      ...d,
      hazardValue: d[hazardColumn],
      ...classified
    };
  });
}

// Prepare map data at the appropriate admin level
s2MapData = {
  const level = s2CurrentAdminLevel;
  
  if (level === 0) {
    // Group by admin0
    const grouped = d3.group(s2ProcessedData, d => d.gaul0_code);
    return Array.from(grouped.values()).map(group => {
      const first = group[0];
      const avgReadiness = d3.mean(group, d => d.cis_readiness_index);
      const avgHazard = d3.mean(group, d => d.hazardValue);
      const hazardTypeCode = s2HazardType === "drought" ? "NDWS-mean" : "NDWL0-mean";
      const classified = bivariateClassify(avgReadiness, avgHazard, cisReadinessCutoffs, hazardTypeCode);
      
      return {
        admin0_name: first.admin0_name,
        iso3: first.iso3,
        gaul0_code: first.gaul0_code,
        cis_readiness_index: avgReadiness,
        hazardValue: avgHazard,
        ...classified
      };
    });
  } else if (level === 1) {
    // Group by admin1
    const grouped = d3.group(s2ProcessedData, d => d.gaul1_code);
    return Array.from(grouped.values()).map(group => {
      const first = group[0];
      const avgReadiness = d3.mean(group, d => d.cis_readiness_index);
      const avgHazard = d3.mean(group, d => d.hazardValue);
      const hazardTypeCode = s2HazardType === "drought" ? "NDWS-mean" : "NDWL0-mean";
      const classified = bivariateClassify(avgReadiness, avgHazard, cisReadinessCutoffs, hazardTypeCode);
      
      return {
        admin0_name: first.admin0_name,
        admin1_name: first.admin1_name,
        iso3: first.iso3,
        gaul0_code: first.gaul0_code,
        gaul1_code: first.gaul1_code,
        cis_readiness_index: avgReadiness,
        hazardValue: avgHazard,
        ...classified
      };
    });
  } else {
    // admin2 - use as is
    return s2ProcessedData;
  }
}

// Load appropriate boundaries based on Section 1's admin level
s2Boundaries = {
  if (s2CurrentAdminLevel === 0) {
    return admin0Boundaries;
  } else if (s2CurrentAdminLevel === 1) {
    return admin1Boundaries;
  } else {
    return admin2Boundaries;
  }
}

// Join boundaries with data
s2GeoData = {
  const gaulCodeField = s2CurrentAdminLevel === 0 ? 'gaul0_code' :
                        s2CurrentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul2_code';
  
  // Filter boundaries based on current selection - show all regions, not just those with data
  let filteredBoundaries = s2Boundaries;
  if (s2CurrentAdminLevel === 2) {
    // When showing admin2, filter by admin selection (but keep all regions, not just those with data)
    filteredBoundaries = {
      ...s2Boundaries,
      features: s2Boundaries.features.filter(f => {
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesAdmin0 && matchesAdmin1;
      })
    };
  } else if (s2CurrentAdminLevel === 1) {
    // When showing admin1, filter by admin0 selection
    filteredBoundaries = {
      ...s2Boundaries,
      features: s2Boundaries.features.filter(f => {
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesAdmin0;
      })
    };
  }
  
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    let match = s2MapData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: try matching by admin names if GAUL code fails
    if (!match && s2CurrentAdminLevel === 2) {
      match = s2MapData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!match && s2CurrentAdminLevel === 1) {
      match = s2MapData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    // Check if this admin2 region is highlighted
    const isHighlighted = s2CurrentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      type: "Feature",
      geometry: feature.geometry,
      properties: {
        ...feature.properties,
        ...(match || {}),
        isHighlighted: isHighlighted,
        hasData: !!match
      }
    };
  }); // Show all features, fade those without data
  
  return { type: "FeatureCollection", features };
}
```

## `{ojs} s2HazardType === "drought" ? _lang(cis.s2MapTitleDrought) : _lang(cis.s2MapTitleWaterlogging)`

```{ojs}
//| echo: false

// Create data index for quick lookup
s2DataIndex = {
  const index = new Map();
  
  // Index current level data
  s2MapData.forEach(d => {
    const admin0 = d.admin0_name;
    const admin1 = d.admin1_name || null;
    
    if (!index.has(admin0)) {
      index.set(admin0, new Map());
    }
    index.get(admin0).set(admin1, d);
  });
  
  return index;
}

// Render map or table based on toggle
s2BivariateMap = {
  if (s2ViewToggle !== "map") return null;
  
    const hazardName = s2HazardType === "drought" ? "Drought (Dry Spell Days)" : "Waterlogging (Days)";
  const height = 610;
  const width = 775;
  const padding = 20;
  
  // Remove existing tooltip
  d3.select(".bivariateTip").remove();
  
  // Add CSS to override large tooltip styles from Section 1.1
  // Local styles removed - now using global tooltipStyle from uiComponents.ojs imported in parent

  
  // Create tooltip matching Plot.tip style
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plot-tip bivariateTip")
    .style("position", "absolute")
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("z-index", "1000");
  
  const projection = d3.geoMercator();
  const geo_path = d3.geoPath().projection(projection);
  const color = d3.scaleOrdinal()
    .domain(["Low × Low", "Low × Moderate", "Low × High", "Moderate × Low", "Moderate × Moderate", "Moderate × High", "High × Low", "High × Moderate", "High × High"])
    .range(Object.values(bivariateColors));
  
  // Use s2GeoData which already has proper boundary filtering and data joining
  const featuresToShow = s2GeoData;
  const dataToUse = s2MapData;
  
  // Create lookup map for current data
  const dataLookup = new Map();
  dataToUse.forEach(d => {
    // Primary key: GAUL code based on current admin level
    const gaulKey = s2CurrentAdminLevel === 0
      ? d.gaul0_code
      : s2CurrentAdminLevel === 1
      ? d.gaul1_code
      : d.gaul2_code;
    dataLookup.set(gaulKey, d);
  });
  
  // Fit projection to features
  projection.fitExtent(
    [
      [padding, padding],
      [width - padding, height - padding]
    ],
    featuresToShow
  );
  
  // Adjust viewBox to accommodate rotated legend
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 900, 680])
    .attr("style", "overflow: visible;")
    .attr("title", "Bivariate Map");
  
  // Track frozen tooltip state
  let frozenRegion = null;
  
  // Render paths
  const paths = svg
    .append("g")
    .selectAll("path")
    .data(featuresToShow.features)
    .join("path")
    .attr("stroke", "white")
    .attr("stroke-width", d => d.properties.isHighlighted ? "2.5px" : "1px")
    .attr("class", `admin${s2CurrentAdminLevel}-boundary`)
    .attr("fill", (d) => {
      const gaulCodeField = s2CurrentAdminLevel === 0
        ? 'gaul0_code'
        : s2CurrentAdminLevel === 1
        ? 'gaul1_code'
        : 'gaul2_code';
      
      const dataEntry = dataLookup.get(d.properties[gaulCodeField]);
      return dataEntry ? color(dataEntry.bivariateClass) : "#e8e8e8";
    })
    .attr("fill-opacity", (d) => {
      // Fade regions without data instead of hiding them
      const gaulCodeField = s2CurrentAdminLevel === 0
        ? 'gaul0_code'
        : s2CurrentAdminLevel === 1
        ? 'gaul1_code'
        : 'gaul2_code';
      
      const dataEntry = dataLookup.get(d.properties[gaulCodeField]);
      return dataEntry ? 1.0 : 0.3; // Faded regions have 30% opacity
    })
    .attr("d", geo_path)
    .on("click", (event, d) => {
      const gaulCodeField = s2CurrentAdminLevel === 0
        ? 'gaul0_code'
        : s2CurrentAdminLevel === 1
        ? 'gaul1_code'
        : 'gaul2_code';
      
      const dataEntry = dataLookup.get(d.properties[gaulCodeField]);
      if (!dataEntry) return;
      
      // Toggle frozen tooltip: if clicking the same region, unfreeze; otherwise, freeze on new region
      const regionId = d.properties[gaulCodeField];
      if (frozenRegion === regionId) {
        // Unfreeze
        frozenRegion = null;
        tooltip.style("opacity", 0);
      } else {
        // Freeze on this region
        frozenRegion = regionId;
        
        const regionName = s2CurrentAdminLevel === 0
          ? d.properties.admin0_name 
          : s2CurrentAdminLevel === 1
          ? `${d.properties.admin1_name}, ${d.properties.admin0_name}`
          : `${d.properties.admin2_name}, ${d.properties.admin1_name}`;
        
        const tooltipHtml = `
          <table>
            <tr><th>Region</th><td>${regionName}</td></tr>
            <tr><th>Readiness (0–1)</th><td>${dataEntry.cis_readiness_index != null ? dataEntry.cis_readiness_index.toFixed(2) : "N/A"}</td></tr>
            <tr><th>${hazardName}</th><td>${dataEntry.hazardValue != null ? dataEntry.hazardValue.toFixed(1) : "N/A"}</td></tr>
            <tr><th>Bivariate class</th><td>${dataEntry.bivariateClass || "N/A"}</td></tr>
          </table>
        `;
        
        tooltip
          .style("top", event.pageY - 10 + "px")
          .style("left", event.pageX + 10 + "px")
          .style("opacity", 1)
          .html(tooltipHtml);
      }
    });
  
  // Tooltip on mousemove (only if not frozen)
  paths
    .on("mouseover", function(event, d) {
      // Change stroke to black on hover
      d3.select(this).attr("stroke", "black").attr("stroke-width", "2px");
    })
    .on("mousemove", (event, d) => {
      if (frozenRegion !== null) return; // Don't show hover tooltip if one is frozen
      
      const gaulCodeField = s2CurrentAdminLevel === 0
        ? 'gaul0_code'
        : s2CurrentAdminLevel === 1
        ? 'gaul1_code'
        : 'gaul2_code';
      
      const dataEntry = dataLookup.get(d.properties[gaulCodeField]);
      if (!dataEntry) return;
      
      const regionName = s2CurrentAdminLevel === 0
        ? d.properties.admin0_name 
        : s2CurrentAdminLevel === 1
        ? `${d.properties.admin1_name}, ${d.properties.admin0_name}`
        : `${d.properties.admin2_name}, ${d.properties.admin1_name}`;
            
      // Format tooltip according to specification
      const tooltipHtml = `
        <table>
          <tr><th>Region</th><td>${regionName}</td></tr>
          <tr><th>Readiness (0–1)</th><td>${dataEntry.cis_readiness_index != null ? dataEntry.cis_readiness_index.toFixed(2) : "N/A"}</td></tr>
          <tr><th>${hazardName}</th><td>${dataEntry.hazardValue != null ? dataEntry.hazardValue.toFixed(1) : "N/A"}</td></tr>
          <tr><th>Bivariate class</th><td>${dataEntry.bivariateClass || "N/A"}</td></tr>
        </table>
      `;
      
      tooltip
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1)
        .html(tooltipHtml);
    })
    .on("mouseout", function (event, d) {
      // Revert stroke to white (or keep highlighted if selected)
      const isHighlighted = d.properties.isHighlighted;
      d3.select(this)
        .attr("stroke", isHighlighted ? "black" : "white")
        .attr("stroke-width", isHighlighted ? "2.5px" : "1px");
      
      if (frozenRegion !== null) return; // Don't hide frozen tooltip
      tooltip.style("opacity", 0);
    });
  
  // Add mesh/boundaries
  const mesh = svg
    .append("path")
    .datum(featuresToShow)
    .attr("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-linejoin", "round")
    .attr("d", geo_path);
  
  // Create legend tooltip (separate from map tooltip) - matching Plot.tip style
  d3.select(".bivariateLegendTip").remove();
  const legendTooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plot-tip bivariateLegendTip")
    .style("position", "absolute")
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("z-index", "1000");
  
  // Create bi_legend function (matching example pattern - diamond shape)
  function bi_legend(selection) {
    const size = 40;
    const gap = 2;
    // Order classes High -> Low to place High-High at Top (0,0) and Low-Low at Bottom (2,2)
    const classes = ["High", "Moderate", "Low"]; 
    const totalWidth = size * 3 + gap * 2;
    const totalHeight = size * 3 + gap * 2;
    const centerX = totalWidth / 2;
    const centerY = totalHeight / 2;
    
    // Create inner group for the legend content (will be rotated)
    const legendContent = selection.append("g");
    
    // Legend squares with hover tooltips
    // i = rows (Hazard), j = cols (Readiness)
    classes.forEach((hazardClass, i) => {
      classes.forEach((readinessClass, j) => {
        // Construct key to match color map format
        const key = `${readinessClass} × ${hazardClass}`;
        const isPriority = readinessClass === "High" && hazardClass === "High";
        
        const rect = legendContent
          .append("rect")
          .attr("x", j * (size + gap))
          .attr("y", i * (size + gap))
          .attr("width", size)
          .attr("height", size)
          //.attr("fill", bivariateColors[key]) // Use helper lookup or direct global
          .attr("fill", (d) => {
             // For Section 2, color scale uses keys like "Low × Low"
             // Ensure we match the global bivariateColors object logic
             return bivariateColors[key] || "#ccc";
          })
          .attr("stroke", isPriority ? "#000" : "#999")
          .attr("stroke-width", isPriority ? "2.5" : "0.5")
          .style("cursor", "pointer");
        
        // Add hover tooltip
        rect
          .on("mousemove", (event) => {
            const tooltipHtml = `
              <table>
                <tr><th>CIS Readiness</th><td>${readinessClass}</td></tr>
                <tr><th>Hazard Severity</th><td>${hazardClass}</td></tr>
                <tr><th>Category</th><td>${key}</td></tr>
              </table>
            `;
            legendTooltip
              .style("top", event.pageY - 10 + "px")
              .style("left", event.pageX + 10 + "px")
              .style("opacity", 1)
              .html(tooltipHtml);
          })
          .on("mouseout", () => {
            legendTooltip.style("opacity", 0);
          });
      });
    });
    
    // Axes and Labels (Attached to unrotated group, then rotated)
    
    // Readiness Arrow (Along Bottom Edge: Right -> Left)
    // Indicates Low(Right) -> High(Left) Readiness
    legendContent.append("line")
      .attr("x1", totalWidth)
      .attr("y1", totalHeight + 8)
      .attr("x2", 0)
      .attr("y2", totalHeight + 8)
      .attr("stroke", "#333")
      .attr("stroke-width", 1.5)
      .attr("marker-end", "url(#arrowhead)");

    // Readiness Label (Below Bottom Edge)
    legendContent.append("text")
      .attr("x", totalWidth / 2)
      .attr("y", totalHeight + 22)
      .attr("text-anchor", "middle")
      .attr("font-size", "11px")
      .attr("font-weight", "bold")
      .attr("fill", "#333")
      .text("CIS Readiness");

    // Hazard Arrow (Along Right Edge: Bottom -> Top)
    // Indicates Low(Bottom) -> High(Top) Hazard
    legendContent.append("line")
      .attr("x1", totalWidth + 8)
      .attr("y1", totalHeight)
      .attr("x2", totalWidth + 8)
      .attr("y2", 0)
      .attr("stroke", "#333")
      .attr("stroke-width", 1.5)
      .attr("marker-end", "url(#arrowhead)");

    // Hazard Label (Right of Right Edge, Rotated -90)
    legendContent.append("text")
      .attr("x", totalWidth + 22)
      .attr("y", totalHeight / 2)
      .attr("text-anchor", "middle")
      .attr("font-size", "11px")
      .attr("font-weight", "bold")
      .attr("fill", "#333")
      .attr("transform", `rotate(-90, ${totalWidth + 22}, ${totalHeight / 2})`)
      .text("Hazard Severity");

    // Define arrow marker
    const defs = selection.append("defs");
    defs.append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 8)
      .attr("refY", 5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", "#333");
    
    // Rotate the entire legend 45 degrees
    legendContent.attr("transform", `rotate(45, ${centerX}, ${centerY})`);
    
    return selection;
  }
  
  // Add legend to SVG - positioned to avoid overflow
  const legendX = 60; // Adjusted for padding
  const legendY = height - 160;
  const legendGroup = svg
    .append("g")
    .attr("transform", `translate(${legendX}, ${legendY})`);
  
  // Apply the legend function
  legendGroup.call(bi_legend);
  
  return svg.node();
}

// Render map or table based on toggle
{
  if (s2ViewToggle === "map") {
    yield html`
      <div>
        ${s2BivariateMap}
      </div>
    `;
  } else {
    // Clean up any leftover tooltips from map view when switching to table
    d3.select(".bivariateTip").remove();
    d3.select(".bivariateLegendTip").remove();
    
    // Table view
    const hazardName = s2HazardType === "drought" ? "Drought (Days)" : "Waterlogging (Days)";
    
    const tableData = s2MapData.map(d => {
      const adminName = s2CurrentAdminLevel === 0 
        ? d.admin0_name 
        : s2CurrentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      
      let priorityLevel;
      if (d.bivariateClass === "High × High") priorityLevel = "Critical";
      else if (d.bivariateClass.includes("High") && d.bivariateClass.includes("Moderate")) priorityLevel = "Moderate";
      else if (d.bivariateClass.includes("High")) priorityLevel = "Moderate";
      else priorityLevel = "Low";
      
      return {
        adminName: adminName,
        readinessRaw: d.cis_readiness_index,
        readinessClass: d.readinessClass,
        hazardRaw: d.hazardValue,
        hazardClass: d.hazardClass,
        bivariateClass: d.bivariateClass,
        priorityLevel: priorityLevel
      };
    });
    
    yield Inputs.table(tableData, {
      columns: [
        "adminName",
        "readinessRaw",
        "readinessClass",
        "hazardRaw",
        "hazardClass",
        "priorityLevel"
      ],
      header: {
        adminName: "Admin Name",
        readinessRaw: "CIS Readiness",
        readinessClass: "Readiness Class",
        hazardRaw: hazardName,
        hazardClass: "Hazard Class",
        priorityLevel: "Priority Level"
      },
      format: {
        readinessRaw: d => d.toFixed(2),
        hazardRaw: d => d.toFixed(1)
      },
      sort: "priorityLevel",
      reverse: true,
      rows: 20
    });
  }
}
```

```{ojs}
//| echo: false

// Download button for Section 2
downloadButton(
  s2MapData.map(d => {
    const adminName = s2CurrentAdminLevel === 0 
      ? d.admin0_name 
      : s2CurrentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    
    const hazardName = s2HazardType === "drought" ? "Drought_Days" : "Waterlogging_Days";
    
    return {
      "Admin Level": s2CurrentAdminLevel === 0 ? "0" : s2CurrentAdminLevel === 1 ? "1" : "2",
      "Admin Name": adminName,
      "CIS Readiness Raw": d.cis_readiness_index?.toFixed(3) || "N/A",
      "CIS Readiness Class": d.readinessClass,
      [hazardName + " Raw"]: d.hazardValue?.toFixed(1) || "N/A",
      [hazardName + " Class"]: d.hazardClass,
      "Bivariate Category": d.bivariateClass
    };
  }),
  `cis_hazard_intersection_${s2HazardType}_admin${s2CurrentAdminLevel}`,
  _lang(cis.downloadLabel)
)
```

## Dynamic Insights

```{ojs}
//| echo: false

s2Insights = {
  const hazardName = s2HazardType === "drought" ? "Drought" : "Waterlogging";
  const selectedRegion = breadcrumb; // Use the breadcrumb from Section 1
  
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? s2MapData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : s2MapData;
  
  // Insight 1: Opportunity (High × High zones)
  const highHazardHighReadiness = insightData.filter(d => d.bivariateClass === "High × High");
  const percentHighHigh = insightData.length > 0 
    ? (highHazardHighReadiness.length / insightData.length * 100).toFixed(1)
    : 0;
  
  const insight1 = `In ${selectedRegion}, **${percentHighHigh}%** of areas fall in High-Readiness & High-${hazardName} zones, indicating strong potential for CIS as an adaptation measure.`;
  
  // Insight 2: Gap (High hazard with Low readiness)
  const highHazardAreas = insightData.filter(d => d.hazardClass === "High");
  const highHazardLowReadiness = highHazardAreas.filter(d => d.readinessClass === "Low");
  const percentGap = highHazardAreas.length > 0 
    ? (highHazardLowReadiness.length / highHazardAreas.length * 100).toFixed(1)
    : 0;
  
  const insight2 = `**${percentGap}%** of High-${hazardName} areas have Low CIS Readiness—priority gaps for station and forecast investment.`;
  
  yield html`
    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
      <h4 style="margin-top: 0;">Key Insights</h4>
      <p style="margin: 10px 0;"><strong>Opportunity:</strong> ${md([insight1])}</p>
      <p style="margin: 10px 0;"><strong>Investment Gap:</strong> ${md([insight2])}</p>
    </div>
  `;
}
```

