```{ojs}
section2Title = _lang(cis.section2Title)
section2Intro = _lang(cis.section2Intro)
```

# `{ojs} section2Title` {#section2}

`{ojs} section2Intro`

```{ojs}
//| echo: false

// ============================================================================
// SECTION 2: CIS READINESS Ã— CLIMATE HAZARD INTERSECTION
// ============================================================================

// Load hazard data using DuckDB with Parquet for better performance
hazardDB = await DuckDBClient.of({
  hazard_data: FileAttachment("/data/cis/haz-means_adm_historic.parquet")
});

// Load all data and filter in JavaScript to avoid DuckDB duplicate key issues
hazardDataRaw = await hazardDB.query(`SELECT * FROM hazard_data`);

// Filter for only the hazards we need
hazardData = hazardDataRaw.filter(d => 
  d.hazard === "NDWS-mean" || d.hazard === "NDWL0-mean"
);

// Load CIS readiness cutoffs from three_cut_offs.csv
cisReadinessCutoffs = await d3.csv("/data/cis/three_cut_offs.csv").then(data => {
  const cisRow = data.find(d => d[''] === 'cis_readiness_index');
  return {
    low: parseFloat(cisRow['X33.33333.']),
    moderate: parseFloat(cisRow['X66.66667.'])
  };
});

// Pivot hazard data to have separate columns for drought and waterlogging
hazardPivoted = {
  const grouped = d3.group(hazardData, d => `${d.iso3}_${d.admin0_name}_${d.admin1_name}_${d.admin2_name}`);
  
  return Array.from(grouped.values()).map(group => {
    const base = group[0];
    const drought = group.find(d => d.hazard === "NDWS-mean");
    const waterlogging = group.find(d => d.hazard === "NDWL0-mean");
    
    return {
      iso3: base.iso3,
      admin0_name: base.admin0_name,
      admin1_name: base.admin1_name,
      admin2_name: base.admin2_name,
      drought_ndws: drought ? parseFloat(drought.value) : null,
      waterlogging_ndwl0: waterlogging ? parseFloat(waterlogging.value) : null
    };
  });
}

// Join hazard data with CIS readiness data
combinedData = cisData.map(cis => {
  const hazard = hazardPivoted.find(h => 
    h.iso3 === cis.iso3 &&
    h.admin0_name === cis.admin0_name &&
    h.admin1_name === cis.admin1_name &&
    h.admin2_name === cis.admin2_name
  );
  
  return {
    ...cis,
    drought_ndws: hazard?.drought_ndws || null,
    waterlogging_ndwl0: hazard?.waterlogging_ndwl0 || null
  };
}).filter(d => d.drought_ndws !== null || d.waterlogging_ndwl0 !== null);

// Bivariate classification function
function bivariateClassify(readiness, hazard, readinessCutoffs, hazardType) {
  // Classify readiness using cutoffs from three_cut_offs.csv
  let readinessClass;
  if (readiness < readinessCutoffs.low) readinessClass = "Low";
  else if (readiness < readinessCutoffs.moderate) readinessClass = "Moderate";
  else readinessClass = "High";
  
  // Classify hazard using thresholds
  let hazardClass;
  if (hazardType === "NDWS-mean") {
    if (hazard < 15) hazardClass = "Low";
    else if (hazard < 20) hazardClass = "Moderate";
    else hazardClass = "High";
  } else if (hazardType === "NDWL0-mean") {
    if (hazard < 2) hazardClass = "Low";
    else if (hazard < 5) hazardClass = "Moderate";
    else hazardClass = "High";
  }
  
  return {
    readinessClass,
    hazardClass,
    bivariateClass: `${readinessClass} Ã— ${hazardClass}`
  };
}

// Bivariate color palette (3x3 grid)
bivariateColors = {
  return {
    "Low Ã— Low": "#e8e8e8",      // Light gray - low priority
    "Low Ã— Moderate": "#b8d6be",  
    "Low Ã— High": "#6c9a8b",      // Dark teal-green - high need, low capacity
    "Moderate Ã— Low": "#c8b2d6",
    "Moderate Ã— Moderate": "#9c9eba",
    "Moderate Ã— High": "#627a8e",
    "High Ã— Low": "#b8a0c2",      
    "High Ã— Moderate": "#8b7fa8",
    "High Ã— High": "#5a5f8f"      // Dark blue-purple - OPTIMAL (priority zone)
  };
}
```

```{ojs}
//| echo: false

viewof s2HazardType = Inputs.radio(
  ["drought", "waterlogging"],
  {
    label: _lang(cis.s2HazardSelector),
    value: "drought",
    format: d => d === "drought" ? _lang(cis.s2HazardDrought) : _lang(cis.s2HazardWaterlogging)
  }
);

viewof s2ReadinessThreshold = Inputs.range([0, 1], {
  label: _lang(cis.s2ReadinessThreshold),
  step: 0.05,
  value: 0
});

viewof s2ViewToggle = Inputs.radio(
  ["map", "table"],
  {
    label: _lang(cis.s2ViewToggle),
    value: "map",
    format: d => d === "map" ? _lang(cis.s2ViewMap) : _lang(cis.s2ViewTable)
  }
);
```

```{ojs}
//| echo: false

// Reuse admin level from Section 1
s2CurrentAdminLevel = currentAdminLevel;

// Process and classify data - filter by Section 1's selections
s2ProcessedData = {
  const hazardColumn = s2HazardType === "drought" ? "drought_ndws" : "waterlogging_ndwl0";
  const hazardTypeCode = s2HazardType === "drought" ? "NDWS-mean" : "NDWL0-mean";
  
  // Filter by Section 1's admin selections using the same logic
  let filtered = combinedData;
  
  // Default: No admin0 selected - show all admin0 level data
  if (selectedAdmin0.length === 0) {
    filtered = filtered.filter(d => d.admin1_name == null);
  }
  // Admin0 selected, no admin1 - show all admin1 data for selected countries
  else if (selectedAdmin1.length === 0) {
    filtered = filtered.filter(d => 
      selectedAdmin0.includes(d.admin0_name) && 
      d.admin1_name != null && 
      d.admin2_name == null
    );
  }
  // Admin1 selected - show all admin2 data for selected admin1 regions
  else {
    filtered = filtered.filter(d => 
      selectedAdmin0.includes(d.admin0_name) &&
      selectedAdmin1.includes(d.admin1_name) &&
      d.admin2_name != null
    );
  }
  
  // Filter by readiness threshold and remove nulls
  filtered = filtered.filter(d => 
    d.cis_readiness_index >= s2ReadinessThreshold &&
    d[hazardColumn] !== null
  );
  
  // Add classifications
  return filtered.map(d => {
    const classified = bivariateClassify(
      d.cis_readiness_index,
      d[hazardColumn],
      cisReadinessCutoffs,
      hazardTypeCode
    );
    
    return {
      ...d,
      hazardValue: d[hazardColumn],
      ...classified
    };
  });
}

// Prepare map data at the appropriate admin level
s2MapData = {
  const level = s2CurrentAdminLevel;
  
  if (level === 0) {
    // Group by admin0
    const grouped = d3.group(s2ProcessedData, d => d.gaul0_code);
    return Array.from(grouped.values()).map(group => {
      const first = group[0];
      const avgReadiness = d3.mean(group, d => d.cis_readiness_index);
      const avgHazard = d3.mean(group, d => d.hazardValue);
      const hazardTypeCode = s2HazardType === "drought" ? "NDWS-mean" : "NDWL0-mean";
      const classified = bivariateClassify(avgReadiness, avgHazard, cisReadinessCutoffs, hazardTypeCode);
      
      return {
        admin0_name: first.admin0_name,
        iso3: first.iso3,
        gaul0_code: first.gaul0_code,
        cis_readiness_index: avgReadiness,
        hazardValue: avgHazard,
        ...classified
      };
    });
  } else if (level === 1) {
    // Group by admin1
    const grouped = d3.group(s2ProcessedData, d => d.gaul1_code);
    return Array.from(grouped.values()).map(group => {
      const first = group[0];
      const avgReadiness = d3.mean(group, d => d.cis_readiness_index);
      const avgHazard = d3.mean(group, d => d.hazardValue);
      const hazardTypeCode = s2HazardType === "drought" ? "NDWS-mean" : "NDWL0-mean";
      const classified = bivariateClassify(avgReadiness, avgHazard, cisReadinessCutoffs, hazardTypeCode);
      
      return {
        admin0_name: first.admin0_name,
        admin1_name: first.admin1_name,
        iso3: first.iso3,
        gaul0_code: first.gaul0_code,
        gaul1_code: first.gaul1_code,
        cis_readiness_index: avgReadiness,
        hazardValue: avgHazard,
        ...classified
      };
    });
  } else {
    // admin2 - use as is
    return s2ProcessedData;
  }
}

// Load appropriate boundaries based on Section 1's admin level
s2Boundaries = {
  if (s2CurrentAdminLevel === 0) {
    return admin0Boundaries;
  } else if (s2CurrentAdminLevel === 1) {
    return admin1Boundaries;
  } else {
    return admin2Boundaries;
  }
}

// Join boundaries with data
s2GeoData = {
  const gaulCodeField = s2CurrentAdminLevel === 0 ? 'gaul0_code' :
                        s2CurrentAdminLevel === 1 ? 'gaul1_code' :
                        'gaul2_code';
  
  // Filter boundaries based on current selection - use same approach as Section 1
  let filteredBoundaries = s2Boundaries;
  if (s2CurrentAdminLevel === 2) {
    // When showing admin2, only include boundaries that match our processed data
    const filteredGaulCodes = new Set(s2MapData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...s2Boundaries,
      features: s2Boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        const matchesAdmin1 = selectedAdmin1.length === 0 || (f.properties.admin1_name && selectedAdmin1.includes(f.properties.admin1_name));
        return matchesData || (matchesAdmin0 && matchesAdmin1);
      })
    };
  } else if (s2CurrentAdminLevel === 1) {
    // When showing admin1, filter by admin0 and match with processed data
    const filteredGaulCodes = new Set(s2MapData.map(d => d[gaulCodeField]).filter(c => c != null));
    filteredBoundaries = {
      ...s2Boundaries,
      features: s2Boundaries.features.filter(f => {
        const gaulCode = f.properties[gaulCodeField];
        const matchesData = filteredGaulCodes.has(gaulCode);
        const matchesAdmin0 = selectedAdmin0.length === 0 || (f.properties.admin0_name && selectedAdmin0.includes(f.properties.admin0_name));
        return matchesData || matchesAdmin0;
      })
    };
  }
  
  const features = filteredBoundaries.features.map(feature => {
    const gaulCode = feature.properties[gaulCodeField];
    let match = s2MapData.find(d => d[gaulCodeField] === gaulCode);
    
    // Fallback: try matching by admin names if GAUL code fails
    if (!match && s2CurrentAdminLevel === 2) {
      match = s2MapData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name &&
        d.admin2_name === feature.properties.admin2_name
      );
    } else if (!match && s2CurrentAdminLevel === 1) {
      match = s2MapData.find(d => 
        d.admin0_name === feature.properties.admin0_name &&
        d.admin1_name === feature.properties.admin1_name
      );
    }
    
    // Check if this admin2 region is highlighted
    const isHighlighted = s2CurrentAdminLevel === 2 && 
                          highlightedAdmin2.length > 0 && 
                          highlightedAdmin2.includes(feature.properties.admin2_name);
    
    return {
      type: "Feature",
      geometry: feature.geometry,
      properties: {
        ...feature.properties,
        ...(match || {}),
        isHighlighted: isHighlighted
      }
    };
  }).filter(f => f.properties.bivariateClass);
  
  return { type: "FeatureCollection", features };
}
```

## `{ojs} s2HazardType === "drought" ? _lang(cis.s2MapTitleDrought) : _lang(cis.s2MapTitleWaterlogging)`

```{ojs}
//| echo: false

// Bivariate legend - simplified and integrated styling
s2Legend = {
  const size = 45;
  const gap = 2;
  const classes = ["Low", "Moderate", "High"];
  const totalWidth = size * 3 + gap * 2;
  const totalHeight = size * 3 + gap * 2 + 50;
  
  return html`
    <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 4px; display: inline-block; font-family: system-ui, -apple-system, sans-serif;">
      <svg width="${totalWidth + 100}" height="${totalHeight}">
        <g transform="translate(0, 15)">
          ${classes.flatMap((hazardClass, i) => 
            classes.map((readinessClass, j) => {
              const key = `${readinessClass} Ã— ${classes[2 - i]}`; // Invert i for Y axis
              const isPriority = readinessClass === "High" && classes[2 - i] === "High";
              return svg`
                <rect 
                  x="${j * (size + gap)}" 
                  y="${i * (size + gap)}"
                  width="${size}" 
                  height="${size}"
                  fill="${bivariateColors[key]}"
                  stroke="${isPriority ? '#000' : '#999'}"
                  stroke-width="${isPriority ? '2.5' : '0.5'}"
                />
              `;
            })
          )}
          <!-- Y-axis labels (Hazard Severity) - right side -->
          <text x="${totalWidth + 8}" y="${size * 0.5 + 3}" font-size="10" fill="#333" font-weight="500">High</text>
          <text x="${totalWidth + 8}" y="${size * 1.5 + gap + 3}" font-size="10" fill="#333" font-weight="500">Moderate</text>
          <text x="${totalWidth + 8}" y="${size * 2.5 + gap * 2 + 3}" font-size="10" fill="#333" font-weight="500">Low</text>
          
          <!-- X-axis labels (CIS Readiness) - bottom -->
          <text x="${size * 0.5}" y="${size * 3 + gap * 2 + 12}" font-size="10" text-anchor="middle" fill="#333" font-weight="500">Low</text>
          <text x="${size * 1.5 + gap}" y="${size * 3 + gap * 2 + 12}" font-size="10" text-anchor="middle" fill="#333" font-weight="500">Moderate</text>
          <text x="${size * 2.5 + gap * 2}" y="${size * 3 + gap * 2 + 12}" font-size="10" text-anchor="middle" fill="#333" font-weight="500">High</text>
          
          <!-- Axis titles -->
          <text x="${totalWidth / 2}" y="${size * 3 + gap * 2 + 28}" font-size="11" text-anchor="middle" fill="#333" font-weight="600">CIS Readiness â†’</text>
          <text x="${totalWidth + 50}" y="${size * 1.5 + gap}" font-size="11" fill="#333" font-weight="600" transform="rotate(90, ${totalWidth + 50}, ${size * 1.5 + gap})">Hazard Severity â†‘</text>
        </g>
      </svg>
    </div>
  `;
}
```

```{ojs}
//| echo: false

// Render map or table based on toggle
{
  if (s2ViewToggle === "map") {
    const hazardName = s2HazardType === "drought" ? "Drought (Dry Spell Days)" : "Waterlogging (Days)";
    
    const map = Plot.plot({
      width: 2000,
      height: 1000,
      projection: {
        type: "mercator",
        domain: s2GeoData
      },
      color: {
        legend: false
      },
      marks: [
        Plot.geo(s2GeoData.features, {
          fill: d => bivariateColors[d.properties.bivariateClass],
          stroke: d => d.properties.isHighlighted ? "#000" : "#333",
          strokeWidth: d => d.properties.isHighlighted ? 2.5 : 0.5
        }),
        Plot.tip(
          s2GeoData.features,
          Plot.pointer(
            Plot.centroid({
              channels: {
                region: {
                  label: "Region",
                  value: (d) => {
                    if (s2CurrentAdminLevel === 0) {
                      return d.properties.admin0_name;
                    } else if (s2CurrentAdminLevel === 1) {
                      return `${d.properties.admin1_name}, ${d.properties.admin0_name}`;
                    } else {
                      return `${d.properties.admin2_name}, ${d.properties.admin1_name}`;
                    }
                  }
                },
                cisReadiness: {
                  label: "CIS Readiness",
                  value: (d) => d.properties.cis_readiness_index
                },
                readinessClass: {
                  label: "Readiness Class",
                  value: (d) => d.properties.readinessClass
                },
                hazardValue: {
                  label: hazardName,
                  value: (d) => d.properties.hazardValue
                },
                hazardClass: {
                  label: "Hazard Class",
                  value: (d) => d.properties.hazardClass
                },
                category: {
                  label: "Category",
                  value: (d) => d.properties.bivariateClass
                },
                priority: {
                  label: "Priority",
                  value: (d) => d.properties.bivariateClass === "High Ã— High" ? "ðŸŽ¯ PRIORITY ZONE" : ""
                }
              },
              format: {
                region: true,
                cisReadiness: (d) => d != null ? d.toFixed(2) : "N/A",
                readinessClass: true,
                hazardValue: (d) => d != null ? d.toFixed(1) : "N/A",
                hazardClass: true,
                category: true,
                priority: true
              }
            })
          )
        )
      ]
    });
    
    yield html`
      <div>
        ${map}
        <div style="display: flex; justify-content: center; margin-top: 15px;">
          ${s2Legend}
        </div>
      </div>
    `;
  } else {
    // Table view
    const hazardName = s2HazardType === "drought" ? "Drought (Days)" : "Waterlogging (Days)";
    
    const tableData = s2MapData.map(d => {
      const adminName = s2CurrentAdminLevel === 0 
        ? d.admin0_name 
        : s2CurrentAdminLevel === 1
        ? `${d.admin1_name}, ${d.admin0_name}`
        : `${d.admin2_name}, ${d.admin1_name}`;
      
      let priorityLevel;
      if (d.bivariateClass === "High Ã— High") priorityLevel = "Critical";
      else if (d.bivariateClass.includes("High") && d.bivariateClass.includes("Moderate")) priorityLevel = "Moderate";
      else if (d.bivariateClass.includes("High")) priorityLevel = "Moderate";
      else priorityLevel = "Low";
      
      return {
        adminName: adminName,
        readinessRaw: d.cis_readiness_index,
        readinessClass: d.readinessClass,
        hazardRaw: d.hazardValue,
        hazardClass: d.hazardClass,
        bivariateClass: d.bivariateClass,
        priorityLevel: priorityLevel
      };
    });
    
    yield Inputs.table(tableData, {
      columns: [
        "adminName",
        "readinessRaw",
        "readinessClass",
        "hazardRaw",
        "hazardClass",
        "bivariateClass",
        "priorityLevel"
      ],
      header: {
        adminName: "Admin Name",
        readinessRaw: "CIS Readiness",
        readinessClass: "Readiness Class",
        hazardRaw: hazardName,
        hazardClass: "Hazard Class",
        bivariateClass: "Bivariate Category",
        priorityLevel: "Priority Level"
      },
      format: {
        readinessRaw: d => d.toFixed(2),
        hazardRaw: d => d.toFixed(1)
      },
      sort: "priorityLevel",
      reverse: true,
      rows: 20
    });
  }
}
```

## Dynamic Insights

```{ojs}
//| echo: false

s2Insights = {
  const hazardName = s2HazardType === "drought" ? "Drought" : "Waterlogging";
  const selectedRegion = breadcrumb; // Use the breadcrumb from Section 1
  
  // If admin2 regions are highlighted, only use those for insights
  const insightData = highlightedAdmin2.length > 0 
    ? s2MapData.filter(d => highlightedAdmin2.includes(d.admin2_name))
    : s2MapData;
  
  // Insight 1: Opportunity (High Ã— High zones)
  const highHazardHighReadiness = insightData.filter(d => d.bivariateClass === "High Ã— High");
  const percentHighHigh = insightData.length > 0 
    ? (highHazardHighReadiness.length / insightData.length * 100).toFixed(1)
    : 0;
  
  const insight1 = `In ${selectedRegion}, **${percentHighHigh}%** of areas fall in High-Readiness & High-${hazardName} zones, indicating strong potential for CIS as an adaptation measure.`;
  
  // Insight 2: Gap (High hazard with Low readiness)
  const highHazardAreas = insightData.filter(d => d.hazardClass === "High");
  const highHazardLowReadiness = highHazardAreas.filter(d => d.readinessClass === "Low");
  const percentGap = highHazardAreas.length > 0 
    ? (highHazardLowReadiness.length / highHazardAreas.length * 100).toFixed(1)
    : 0;
  
  const insight2 = `**${percentGap}%** of High-${hazardName} areas have Low CIS Readinessâ€”priority gaps for station and forecast investment.`;
  
  yield html`
    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
      <h4 style="margin-top: 0;">Key Insights</h4>
      <p style="margin: 10px 0;"><strong>Opportunity:</strong> ${md([insight1])}</p>
      <p style="margin: 10px 0;"><strong>Investment Gap:</strong> ${md([insight2])}</p>
    </div>
  `;
}
```

```{ojs}
//| echo: false

// Download button for Section 2
downloadButton(
  s2MapData.map(d => {
    const adminName = s2CurrentAdminLevel === 0 
      ? d.admin0_name 
      : s2CurrentAdminLevel === 1
      ? `${d.admin1_name}, ${d.admin0_name}`
      : `${d.admin2_name}, ${d.admin1_name}`;
    
    const hazardName = s2HazardType === "drought" ? "Drought_Days" : "Waterlogging_Days";
    
    return {
      "Admin Level": s2CurrentAdminLevel === 0 ? "0" : s2CurrentAdminLevel === 1 ? "1" : "2",
      "Admin Name": adminName,
      "CIS Readiness Raw": d.cis_readiness_index?.toFixed(3) || "N/A",
      "CIS Readiness Class": d.readinessClass,
      [hazardName + " Raw"]: d.hazardValue?.toFixed(1) || "N/A",
      [hazardName + " Class"]: d.hazardClass,
      "Bivariate Category": d.bivariateClass
    };
  }),
  `cis_hazard_intersection_${s2HazardType}_admin${s2CurrentAdminLevel}`,
  _lang(cis.downloadLabel)
)
```

