---
module: "Exposure Section"
nb-authors:
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
exposureQuestion = _lang(vulnerability_translations.exposure_question);
```

# `{ojs} exposureQuestion` {#exposure}

`{ojs} _lang(vulnerability_translations.exposure_description)`

```{ojs}
// Exposure section selectors - follow shared state like other sections
viewof selectAdmin0 = Inputs.select(dataAdmin0, {
  label: adminRegions.labels.admin0, 
  format: x => x.label,
  value: dataAdmin0.find(d => d.value === sharedAdmin0) || (dataAdmin0.length > 0 ? dataAdmin0[0] : null)
})
viewof selectAdmin1 = Inputs.select(dataAdmin1, {
  label: adminRegions.labels.admin1, 
  format: x => x.label,
  value: dataAdmin1.find(d => d.value === sharedAdmin1) || (dataAdmin1.length > 0 ? dataAdmin1[0] : null)
})
viewof selectAdmin2 = Inputs.select(dataAdmin2, {
  label: adminRegions.labels.admin2, 
  format: x => x.label,
  value: dataAdmin2.find(d => d.value === sharedAdmin2) || (dataAdmin2.length > 0 ? dataAdmin2[0] : null)
})
```

```{ojs}
exposureControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof selectAdmin0}</div>
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof selectAdmin1}</div>
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof selectAdmin2}</div>
  </div>
</div>
`
```

```{ojs}
// Data loading and processing with caching
exposureDb = await createExposureDB() // Use cached loading


exposureData = {
  if (!exposureDb) return [];
  
  try {
    const query = `
      SELECT *
      FROM exposure_data
      WHERE hazard = 'any'
    `;
    
    return await exposureDb.query(query);
  } catch (error) {
    return [];
  }
}
```

```{ojs}
// grab tabular data for choropleth
dataGeoImpact = {
  // Check if exposureData exists and is an array before processing
  if (!exposureData || !Array.isArray(exposureData)) {
    return [];
  }
  
  // get data for choropleth map based on choice
  const dataSource = exposureData;

  let filteredData;
  
  // select different data based on admin selections using shared state
  if (sharedAdmin1) {
    filteredData = dataSource.filter((d) => {
      return d.admin0_name == sharedAdmin0
        && d.admin1_name == sharedAdmin1
        && d.admin2_name // always non-null
    });
  } else if (sharedAdmin0) {
    // admin0 is selected, with no admin1
    // get all admin1 data for selected admin0
    filteredData = dataSource.filter((d) => {
      return d.admin0_name == sharedAdmin0
        && d.admin1_name // always non-null 
        && !d.admin2_name // always null
    });
  } else {
    // end case: admin0 is not selected
    // get all admin0 data
    filteredData = dataSource.filter((d) => {
      return !d.admin1_name // always null 
        && !d.admin2_name // always null
    });
  }
  
  // Aggregate data by summing values for each administrative region
  if (filteredData.length === 0) return [];
  
  // Determine grouping key based on admin level
  // Handle null values explicitly to avoid "null" strings in keys
  let groupKey;
  if (sharedAdmin1) {
    // Group by admin2
    groupKey = d => `${d.admin0_name || 'NULL'}|${d.admin1_name || 'NULL'}|${d.admin2_name || 'NULL'}`;
  } else if (sharedAdmin0) {
    // Group by admin1
    groupKey = d => `${d.admin0_name || 'NULL'}|${d.admin1_name || 'NULL'}`;
  } else {
    // Group by admin0
    groupKey = d => d.admin0_name || 'NULL';
  }
  
  const groupedData = d3.group(filteredData, groupKey);
  
  return Array.from(groupedData.entries()).map(([key, values]) => {
    // Parse the key back to get admin names
    let admin0_name, admin1_name, admin2_name;
    
    if (sharedAdmin1) {
      [admin0_name, admin1_name, admin2_name] = key.split("|");
    } else if (sharedAdmin0) {
      [admin0_name, admin1_name] = key.split("|");
    } else {
      admin0_name = key;
    }
    
    // Sum up all exposure values for this region
    const totalValue = d3.sum(values, d => d.value || 0);
    
    return {
      admin0_name,
      admin1_name: admin1_name || null,
      admin2_name: admin2_name || null,
      value: totalValue
    };
  });
}
```

```{ojs}
// Geographic data binding
exposureMapData = {
  if (!dataGeoImpact || dataGeoImpact.length === 0) {
    return { features: [] };
  }

  // Check if boundaries exist before accessing properties
  if (!boundaries) {
    return { features: [] };
  }

  // Determine which admin level to show
  if (!sharedAdmin0) {
    // Show admin0 level
    if (!boundaries.admin0 || !boundaries.admin0.features) {
      return { features: [] };
    }
    return bindTabularToGeo({
      data: dataGeoImpact,
      dataBindColumn: "admin0_name",
      geoData: boundaries.admin0,
      geoDataBindColumn: "admin0_name"
    });
  } else if (!sharedAdmin1) {
    // Show admin1 level within selected admin0
    if (!boundaries.admin1 || !boundaries.admin1.features) {
      return { features: [] };
    }
    const data = dataGeoImpact.map(d => ({
      ...d,
      a1_a0: [d.admin1_name, d.admin0_name].join("_")
    }));
    
    const geoData = {
      ...boundaries.admin1,
      features: boundaries.admin1.features.filter(
        d => d.properties.admin0_name === sharedAdmin0
      )
    };

    return bindTabularToGeo({
      data: data,
      dataBindColumn: "admin1_name",
      geoData: geoData,
      geoDataBindColumn: "admin1_name"
    });
  } else {
    // Show admin2 level within selected admin1
    if (!boundaries.admin2 || !boundaries.admin2.features) {
      return { features: [] };
    }
    const data = dataGeoImpact.map(d => ({
      ...d,
      a2_a1_a0: [d.admin2_name, d.admin1_name, d.admin0_name].join("_")
    }));
    
    const geoData = {
      ...boundaries.admin2,
      features: boundaries.admin2.features.filter(d => 
        d.properties.admin1_name === sharedAdmin1 &&
        d.properties.admin0_name === sharedAdmin0
      )
    };



    return bindTabularToGeo({
      data: data,
      dataBindColumn: "admin2_name",
      geoData: geoData,
      geoDataBindColumn: "admin2_name"
    });
  }
}
```

```{ojs}
// Visualization with proper loading/no-data states
exposureChoroplethMap = {
  // Show loading spinner only if data is still loading (null/undefined)
  if (exposureData === null || exposureData === undefined) {
    return createLoadingState(_lang({en: "Loading exposure data...", fr: "Chargement des données d'exposition..."}));
  }
  
  // If data is loaded but empty, or map data is empty, show no data state
  if (!exposureData || exposureData.length === 0 || !exposureMapData || !exposureMapData.features || exposureMapData.features.length === 0) {
    return createNoDataState(_lang(vulnerability_translations.no_data_available));
  }

  const data = exposureMapData;

  
  const plot = renderGeoMap({
    features: data.features,
    width: mapWidth,
    height: mapHeight,
    caption: vopNote.caption,
    projection: {
      type: "azimuthal-equal-area",
      domain: data
    },
    color: {
      legend: true,
      label: `${_lang({en: "VoP", fr: "VoP"})} (${intDollarUnit})`,
      range: colorScales.range.yellowGreen,
      unknown: colorScales.unknown,
      tickFormat: formatNumCompactShort
    },
    valueAccessor: (d) => {
      const dataColumn = "value";
      const fillValue = d.properties.data ? d.properties.data[dataColumn] : null;
      return fillValue;
    },
    tooltip: {
      channels: {
        country: {
          label: "Country",
          value: (d) => d.properties.admin0_name
        },
        name: {
          label: "Region",
          value: (d) => {
            if (d.properties.admin2_name) {
              return `${d.properties.admin2_name}, ${d.properties.admin1_name}`;
            } else if (d.properties.admin1_name) {
              return d.properties.admin1_name;
            } else {
              return d.properties.admin0_name;
            }
          }
        },
        data: {
          label: "VoP",
          value: (d) => {
            const dataColumn = "value";
            const data = d.properties.data ? d.properties.data[dataColumn] : undefined;
            return data;
          }
        }
      },
      format: {
        country: true,
        name: true,
        data: (d) => d ? formatNumCompactShort(d) : "No data"
      }
    },
    extraMarks: [
      Plot.geo(
        sharedAdmin2
          ? data.features.filter(d => d.properties.admin2_name === sharedAdmin2)
          : [],
        {
          fill: null,
          stroke: "#333",
          strokeWidth: 1.5
        }
      )
    ]
  });

  return htl.html`
  <!--   <div style=" -->
  <!--     border: 1px solid #e5e7eb; -->
  <!--     border-radius: 8px; -->
  <!--   padding: 20px; -->
  <!--   background-color: #fff; -->
  <!--   box-shadow: 0 2px 4px rgba(0,0,0,0.1); -->
  <!--     margin: 16px 0; -->
  <!-- "> -->
    ${plot}
    <!-- </div> -->
  `;
}
```

```{ojs}
// Download functionality
exposureDownloadButton = {
  if (!dataGeoImpact || dataGeoImpact.length === 0) {
    return htl.html``;
  }
  return downloadButton(
    dataGeoImpact, 
    `exposure_data_${getExposureAdminSelection().replace(/\s+/g, '_')}_all_hazard_types`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic insights
exposureInsights = {
  if (!dataGeoImpact || dataGeoImpact.length === 0) {
    return createNoDataState();
  }

  // Calculate total exposure value
  const totalValue = d3.sum(dataGeoImpact, d => d.value || 0);
  const region = getExposureAdminSelection();
  const hazardLabel = "Any";
  
  // Get top 3 most exposed commodities
  let topCommodities = [];
  if (exposureData && exposureData.length > 0) {
    // Filter data based on current admin selection
    let filteredCommodityData = exposureData;
    
    if (sharedAdmin1) {
      filteredCommodityData = exposureData.filter(d => 
        d.admin0_name === sharedAdmin0 && 
        d.admin1_name === sharedAdmin1 &&
        d.admin2_name
      );
    } else if (sharedAdmin0) {
      filteredCommodityData = exposureData.filter(d => 
        d.admin0_name === sharedAdmin0 &&
        d.admin1_name &&
        !d.admin2_name
      );
    } else {
      filteredCommodityData = exposureData.filter(d => 
        !d.admin1_name && !d.admin2_name
      );
    }
    
    // Group by commodity and sum values
    const commodityGroups = d3.group(filteredCommodityData, d => d.crop);
    const commodityTotals = Array.from(commodityGroups.entries()).map(([crop, values]) => ({
      crop: crop,
      totalValue: d3.sum(values, d => d.value || 0)
    }));
    
    // Sort by total value and get top 3
    topCommodities = commodityTotals
      .sort((a, b) => b.totalValue - a.totalValue)
      .slice(0, 3)
      .filter(d => d.totalValue > 0);
  }
  
  // Format currency without the "2015 USD" prefix
  const formatCleanCurrency = (number) => {
    return new Intl.NumberFormat("en-US", {
      notation: "compact",
      compactDisplay: "short",
      style: "currency",
      currency: "USD",
    }).format(number);
  };
  
  const template = _lang(vulnerability_translations.exposure_insight_template);
  const replacements = [
    { name: "region", value: region },
    { name: "amount", value: formatCleanCurrency(totalValue) }
  ];
  
  const insight = generateInsight(template, replacements);
  
  // Add top commodities insight if available
  let commoditiesInsight = "";
  if (topCommodities.length > 0) {
    // Create dynamic text with specific commodity names
    const commodityNames = topCommodities
      .map(d => d.crop.replace(/-/g, ' '))
      .join(", ");
    
    const commoditiesText = _lang({
      en: ` The top 3 most exposed commodities are:`,
      fr: ` Les 3 produits les plus exposés sont:`
    });
    
    // Combine insight text with commodities list as HTML using proper htl.html syntax
    const fullInsight = htl.html`
      ${insight}${commoditiesText}
      <ol>
        ${topCommodities.map(d => htl.html`<li>${d.crop.replace(/-/g, ' ')} (${formatCleanCurrency(d.totalValue)})</li>`)}
      </ol>
    `;
    return createInsightDisplay(fullInsight);
  }
  
  return createInsightDisplay(insight);
}
```
