---
pagetitle: "Exposure Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
  - Pete Stewart
date-created: '2025-02-19'
date-edited: today
css: styles.css
---


```{ojs}
exposureQuestion = _lang(vulnerability_translations.exposure_question)
```
# `{ojs} exposureQuestion ` {#exposure}


`{ojs} _lang(vulnerability_translations.exposure_description)`




```{ojs}



viewof selectAdmin0 = Inputs.select(dataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof selectAdmin1 = Inputs.select(dataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof selectAdmin2 = Inputs.select(dataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})


```

```{ojs}

adminSelections = ({
  selectAdmin0: selectAdmin0.value,
  selectAdmin1: selectAdmin1.value,
  selectAdmin2: selectAdmin2.value,
})


```


```{ojs}

viewof selectGeoDataType = {
  const options = [
    {
      key: "population", // lookup id for data option
      dataColumn: "rural_pop", // data column
      label: "Rural population", // label
      labelTip: "Rural population", // label for tooltip
      labelLegend: "Rural population", // label for legend
      formatFunc: formatNumCompactShort, // formatting function for raw data value
      formatFuncLegend: formatNumCompactShort, // formatting function for legend
      colorRange: colorScales.range.yellowGreen, // color range
      colorUnknown: colorScales.unknown, // unknown fill color 
    },
    {
      key: "vop",
      dataColumn: "vop_total",
      label: "Total Value of Production (VoP)",
      labelTip: "VoP",
      labelLegend: `Value of Production (${intDollarUnit})`,
      formatFunc: formatIntDollar,
      formatFuncLegend: formatUSD,
      colorRange: colorScales.range.yellowGreen,
      colorUnknown: colorScales.unknown,
    },
  ];
  return Inputs.radio(options.sort((a,b) => b.key.localeCompare(a.key)), {
    width: 300,
    label: "Map Layer",
    format: (x) => x.label,
    value: options.find((t) => t.key === "vop")
  });
}



```


```{ojs}

viewof selectedHazard = Inputs.select(
  ["drought", "heat-stress", "any"],
  {label: "Hazard type", value: "any"}
)

```


```{ojs}

db = {
  const parquetUrl = await FileAttachment("/data/vulnerability_notebook/notebook_exposure.parquet").url();


  let db = await DuckDBClient.of();
    await db.query(`
    CREATE VIEW Exposure AS
    SELECT *
    FROM read_parquet('${parquetUrl}')
  `);

 return db


}

console.log(selectedHazard)

exposureData = {
 let query = `
    SELECT *
    FROM Exposure
    WHERE hazard = '${selectedHazard}' 
    LIMIT 50
`;
  let result = await db.query(query);

  
  // Convert proxy objects to human-readable plain objects
  return result.map((row, index) => {
    const readableRow = {};
    
    // Method 1: Try to get column names from the database schema
    try {
      // Extract all properties from the proxy object
      const keys = Object.getOwnPropertyNames(row);
      keys.forEach(key => {
        if (typeof key === 'string' && !key.startsWith('Symbol')) {
          readableRow[key] = row[key];
        }
      });
      
      // If that didn't work, try iterating through the proxy
      if (Object.keys(readableRow).length === 0) {
        for (let key in row) {
          readableRow[key] = row[key];
        }
      }
      
      // If still empty, try alternative approach
      if (Object.keys(readableRow).length === 0) {
        // Get the underlying data using DuckDB's approach
        const columns = Object.keys(result.schema?.fields || {});
        columns.forEach((col, i) => {
          readableRow[col] = row[i] !== undefined ? row[i] : row[col];
        });
      }
      
    } catch (e) {
      // Fallback: just assign what we can
      readableRow.raw_data = `Row ${index + 1} (proxy object)`;
      readableRow.note = "Unable to extract readable data";
    }
    
    // Add row identifier
    readableRow._row_id = index + 1;
    
    return readableRow;
  });
}





```


```{ojs}

// grab tabular data for choropleth

dataGeoImpact = {
  // get data for choropleth map based on choice
  const dataSource = exposureData

  // select different data based on admin selections
  if (adminSelections.selectAdmin1) {
    // admin1 or 2 is selected, show all admin2's for selected admin1
    return T.tidy(
      dataSource,
      T.filter((d) => {
        return d.admin0_name == adminSelections.selectAdmin0
          && d.admin1_name == adminSelections.selectAdmin1
          && d.admin2_name // always non-null
      })
    );
  } else if (adminSelections.selectAdmin0) {
    // admin0 is selected, with no admin1
    // get all admin1 data for selected admin0
    return T.tidy(
      dataSource,
      T.filter((d) => {
        return d.admin0_name == adminSelections.selectAdmin0
        && d.admin1_name // always non-null 
        && !d.admin2_name // always null
      })
    )
  } else {
    // end case: admin0 is not selected
    // get all admin0 data
    return T.tidy(
      dataSource,
      T.filter((d) => {
        return !d.admin1_name // always null 
        && !d.admin2_name // always null
      })
    )
  }
}



```


```{ojs}

// bind geojson to tabular data
mapDataGeoImpact = {
  // no selections
  if (!adminSelections.selectAdmin0) {
    return bindTabularToGeo({
      data: dataGeoImpact,
      dataBindColumn: "admin0_name",
      geoData: boundaries.admin0,
      geoDataBindColumn: "admin0_name"
    });
  }
  // admin0 selected only
  else if (!adminSelections.selectAdmin1) {
    const data = T.tidy(
      dataGeoImpact,
      T.mutate({ a1_a0: (d) => [d.admin1_name, d.admin0_name].join("_") })
    );
    const geoData = {
      ...boundaries.admin1,
      features: boundaries.admin1.features.filter(
        (d) => d.properties.admin0_name == adminSelections.selectAdmin0
      )
    };

    return bindTabularToGeo({
      data: data,
      dataBindColumn: "a1_a0",
      geoData: geoData,
      geoDataBindColumn: "a1_a0"
    });
  }

  // admin1 is selected
  // show all admin2 regions within admin1
  else {
    const data = T.tidy(
      dataGeoImpact,
      T.mutate({
        a2_a1_a0: (d) => [d.admin2_name, d.admin1_name, d.admin0_name].join("_")
      })
    );
    const geoData = {
      ...boundaries.admin2,
      features: boundaries.admin2.features.filter((d) => {
        return d.properties.admin1_name == adminSelections.selectAdmin1
          && d.properties.admin0_name == adminSelections.selectAdmin0
      })
    };

    return bindTabularToGeo({
      data: data,
      dataBindColumn: "a2_a1_a0",
      geoData: geoData,
      geoDataBindColumn: "a2_a1_a0"
    });
  }
}



```




```{ojs}

plotChoroplethGeoImpact = {  
  const data = mapDataGeoImpact
  const selector = selectGeoDataType
  
  const plot = Plot.plot({
    width: mapWidth,
    caption: `Grey regions signal lack of ${selector.label} data. ${vopNote.caption}`,
    projection: {
      type: "azimuthal-equal-area",
      domain: data
    },
    color: {
      legend: true,
      label: selector.labelLegend,
      range: selector.colorRange,
      unknown: selector.colorUnknown,
      tickFormat: selector.formatFuncLegend,
    },
    marks: [
      // geo data
      Plot.geo(data.features, {
        fill: (d) => {
          const dataColumn = selector.dataColumn
          const fillValue = d.properties.data ? d.properties.data[dataColumn] : null; // handle missing data
          return fillValue
        },
        stroke: "#fff",
        strokeWidth: 0.5
      }),
      // admin2 highlight 
      // if Admin selection includes admin2, highlight section
      Plot.geo(adminSelections.selectAdmin2 
               ? data.features.filter(d => d.properties.admin2_name == adminSelections.selectAdmin2)
               : [], {
        fill: null,
        stroke: "#333",
        strokeWidth: 1.5
      }),
      // geo pointer
      Plot.geo(data, Plot.pointer(
        Plot.centroid({
        stroke: "#333",
        strokeWidth: 1.5,
      }))),
      // tooltip
      Plot.tip(
        data.features,
        Plot.pointer(
          Plot.centroid({
            channels: {
              name: {
                // region label, based on selection
                label: getLowerLevelAdminLabel(), // plot-level so inputs don't reload
                value: (d) => d.properties.admin_name
              },
              country: (d) => d.properties.admin0_name,
              data: {
                label: selector.labelTip,
                value: (d) => {
                const dataColumn = selector.dataColumn
                const data = d.properties.data ? d.properties.data[dataColumn] : undefined
                return data
              },
              }
            },
            format: {
              name: true,
              country: false,
              data: (d) => selector.formatFunc(d)
            }
          })
        )
      )
    ]
  });

  return htl.html`${styling}${plot}`
}
```




```{ojs}

styling = {
  return !toggleCustomStyling 
    ? "no custom styling"
    : htl.html`<style>  
      @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');
    
      /* body text */
      body {
        font-family: "IBM Plex Sans", "Source Serif Pro"
      }
    
      form.oi-3a86ea { flex-wrap: wrap; }
    
      form.oi-3a86ea>label { 
         padding: 8px 0;
         font-family: "IBM Plex Sans";
         font-size: 12px;
         text-transform: uppercase;
         border-bottom: 1px solid #333;
         width: 100%;
      }
      
      form.oi-3a86ea select.oi-3a86ea-input {
         border: 0;
         height: 40px;
         font-family: "IBM Plex Sans";
         font-size: 14px; 
      }
      
      form.oi-3a86ea-checkbox { max-width: none; }
      
      form.oi-3a86ea div {
         font-famiy: "IBM Plex Sans";
         font-size: 14px;
         padding: 12px 0;
      }
      
      .oi-3a86ea input { accent-color: #2E7636; }
      
      figure { padding-top: 20px; }
      
      h1 {
         font-size: 32px;
         font-weight: 700;
         padding-top: 80px;
      }
      
      h2 {
         font-weight: 700; 
         padding-top: 40px; 
      }
      
      h3 {
         font-weight: 700; 
         padding-top: 24px; 
      }
      
      body { line-height: 1.6 }

      strong {
        font-weight: 600;
      }
      
      a[href] { color: #2E7636 }
  
    </style>`
}





```