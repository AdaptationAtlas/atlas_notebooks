---
pagetitle: "Exposure Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
  - Pete Stewart
date-created: '2025-02-19'
date-edited: today
css: styles.css
---


{{< include _shared.qmd >}}





```{ojs}
exposureQuestion = _lang(vulnerability_translations.exposure_question)
```
# `{ojs} exposureQuestion ` {#exposure}


`{ojs} _lang(vulnerability_translations.exposure_description)`


```{ojs}

boundaries = {
  const input0 = await FileAttachment("/data/shared/atlas_gaul_a0_africa_simple-vlowres.topojson").json()
  const input1 = await FileAttachment("/data/shared/atlas_gaul_a1_africa_simple-vlowres.topojson").json()
  const input2 = await FileAttachment("/data/shared/atlas_gaul_a2_africa_simple-lowres.topojson").json()



  const geo = {
    admin0: {
      ...topojson.feature(input0, input0.objects["atlas_gaul_a0_africa"]),
      features: topojson.feature(input0, input0.objects["atlas_gaul_a0_africa"]).features.filter(feature => feature.properties.admin0_name !== "Sudan")
    },
    admin1: {
      ...topojson.feature(input1, input1.objects["atlas_gaul_a1_africa"]),
      features: topojson.feature(input1, input1.objects["atlas_gaul_a1_africa"]).features.filter(feature => feature.properties.admin0_name !== "Sudan")
    },
    admin2: {
      ...topojson.feature(input2, input2.objects["atlas_gaul_a2_africa_simple-lowres"]),
      features: topojson.feature(input2, input2.objects["atlas_gaul_a2_africa_simple-lowres"]).features.filter(feature => feature.properties.admin0_name !== "Sudan")
    }
  }
      console.log("geo", geo)
  
  return geo
}



```



```{ojs}

// get admin0 options from geo
dataAdmin0 = {
  const data = boundaries.admin0.features.map(d => d.properties)
  // add a blank value
  return [null, ...data.map(d => d.admin0_name)].map(d => {
    return {label: d == null ? globalSelection.label : d, value: d}
  })
}

// get admin1 options based on admin0 selection
// (the admin1 regions within selected admin0)
dataAdmin1 = {
  // admin 1, filter by 0 
  const data = boundaries.admin1.features.map(d => d.properties)
  .filter(d => d.admin0_name == selectAdmin0.value)
  // add blank value
  return [null, ...data.map(d => d.admin1_name)].map(d => {
    return {label: d, value: d}
  })
}


// get admin2 options based on admin1 selection
// (the admin2 regions within selected admin1)
dataAdmin2 = {
  const data = boundaries.admin2.features.map(d => d.properties)
  .filter(d => d.admin0_name == selectAdmin0.value && d.admin1_name == selectAdmin1.value)
  // add blank value
  return [null, ...data.map(d => d.admin2_name)].map(d => {
    return {label: d, value: d}
  })
}




```

```{ojs}

// info for the admin selectors
adminRegions = {
  return {
    labels: {
      admin0: 'Country',
      admin1: 'Region',
      admin2: 'Subregion'
    }
  };
}


```


```{ojs}
// Simple working form template with flexbox layout
adminFormTemplate = (inputs) => htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    Geographic Region Selection
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: nowrap;
    justify-content: space-between;
  " class="form-inputs-container">
    ${inputs}
  </div>
</div>
`
```

```{ojs}
//| include: false
viewof selectAdmin0 = Inputs.select(dataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof selectAdmin1 = Inputs.select(dataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof selectAdmin2 = Inputs.select(dataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})
```

```{ojs}
// Add CSS styling for the inputs with flex layout
html`<style>
  .observablehq select {
    border: 2px solid #cbd5e0 !important;
    border-radius: 8px !important;
    padding: 8px 12px !important;
    font-size: 14px !important;
    background: white !important;
    transition: all 0.2s ease !important;
    min-width: 180px !important;
    flex: 1 !important;
    color: #000000 !important;
  }
  
  .observablehq select:hover {
    border-color: #216729 !important;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  }
  
  .observablehq select:focus {
    border-color: #216729 !important;
    box-shadow: 0 0 0 3px rgba(66,153,225,0.1) !important;
    outline: none !important;
  }
  
  .observablehq select option {
    color: #000000 !important;
    background: white !important;
  }
  
  .observablehq select::placeholder {
    color: #000000 !important;
    opacity: 1 !important;
  }
  
  .observablehq label {
    font-weight: 600 !important;
    color: #4a5568 !important;
    margin-bottom: 4px !important;
    display: block !important;
  }
  
  /* Ensure input containers take equal space */
  .observablehq form > div > div {
    flex: 1 !important;
    min-width: 180px !important;
  }

    /* Media queries for better responsiveness */
  @media (max-width: 768px) {
    .form-inputs-container {
      flex-direction: column !important;
      align-items: stretch !important;
    }
</style>`
```

```{ojs}
// Styled form with bound inputs
geoImpactAdminSelectors = Inputs.form(
  [
    Inputs.bind(
      Inputs.select(dataAdmin0, { label: adminRegions.labels.admin0, format: x => x.label }),
      viewof selectAdmin0
    ),
    Inputs.bind(
      Inputs.select(dataAdmin1, { label: adminRegions.labels.admin1, format: x => x.label }),
      viewof selectAdmin1
    ),
    Inputs.bind(
      Inputs.select(dataAdmin2, { label: adminRegions.labels.admin2, format: x => x.label }),
      viewof selectAdmin2
    )
  ],
  {
    template: adminFormTemplate
  }
)
```

```{ojs}

adminSelections = ({
  selectAdmin0: selectAdmin0.value,
  selectAdmin1: selectAdmin1.value,
  selectAdmin2: selectAdmin2.value,
})


```




```{ojs}

viewof selectedHazard = Inputs.select(
  ["drought", "heat-stress", "any"],
  {label: "Hazard type", value: "any"}
)

```


```{ojs}

db = {
  const parquetUrl = await FileAttachment("/data/vulnerability_notebook/notebook_exposure.parquet").url();


  let db = await DuckDBClient.of();
    await db.query(`
    CREATE VIEW Exposure AS
    SELECT *
    FROM read_parquet('${parquetUrl}')
  `);

 return db


}


exposureData = {
 let query = `
    SELECT *
    FROM Exposure
    WHERE hazard = '${selectedHazard}' 
  
`;
  let result = await db.query(query);

  
  // Convert proxy objects to human-readable plain objects
  return result.map((row, index) => {
    const readableRow = {};
    
    // Method 1: Try to get column names from the database schema
    try {
      // Extract all properties from the proxy object
      const keys = Object.getOwnPropertyNames(row);
      keys.forEach(key => {
        if (typeof key === 'string' && !key.startsWith('Symbol')) {
          readableRow[key] = row[key];
        }
      });
      
      // If that didn't work, try iterating through the proxy
      if (Object.keys(readableRow).length === 0) {
        for (let key in row) {
          readableRow[key] = row[key];
        }
      }
      
      // If still empty, try alternative approach
      if (Object.keys(readableRow).length === 0) {
        // Get the underlying data using DuckDB's approach
        const columns = Object.keys(result.schema?.fields || {});
        columns.forEach((col, i) => {
          readableRow[col] = row[i] !== undefined ? row[i] : row[col];
        });
      }
      
    } catch (e) {
      // Fallback: just assign what we can
      readableRow.raw_data = `Row ${index + 1} (proxy object)`;
      readableRow.note = "Unable to extract readable data";
    }
    
    // Add row identifier
    readableRow._row_id = index + 1;
    
    return readableRow;
  });
}




```


```{ojs}

// grab tabular data for choropleth

dataGeoImpact = {
  // get data for choropleth map based on choice
  const dataSource = exposureData

  // select different data based on admin selections
  if (adminSelections.selectAdmin1) {
    // admin1 or 2 is selected, show all admin2's for selected admin1
    return T.tidy(
      dataSource,
      T.filter((d) => {
        return d.admin0_name == adminSelections.selectAdmin0
          && d.admin1_name == adminSelections.selectAdmin1
          && d.admin2_name // always non-null
      })
    );
  } else if (adminSelections.selectAdmin0) {
    // admin0 is selected, with no admin1
    // get all admin1 data for selected admin0
    return T.tidy(
      dataSource,
      T.filter((d) => {
        return d.admin0_name == adminSelections.selectAdmin0
        && d.admin1_name // always non-null 
        && !d.admin2_name // always null
      })
    )
  } else {
    // end case: admin0 is not selected
    // get all admin0 data
    return T.tidy(
      dataSource,
      T.filter((d) => {
        return !d.admin1_name // always null 
        && !d.admin2_name // always null
      })
    )
  }
}



```


```{ojs}

// bind geojson to tabular data
mapDataGeoImpact = {
  // no selections
  if (!adminSelections.selectAdmin0) {
    return bindTabularToGeo({
      data: dataGeoImpact,
      dataBindColumn: "admin0_name",
      geoData: boundaries.admin0,
      geoDataBindColumn: "admin0_name"
    });
  }
  // admin0 selected only
  else if (!adminSelections.selectAdmin1) {
    const data = T.tidy(
      dataGeoImpact,
      T.mutate({ a1_a0: (d) => [d.admin1_name, d.admin0_name].join("_") })
    );
    const geoData = {
      ...boundaries.admin1,
      features: boundaries.admin1.features.filter(
        (d) => d.properties.admin0_name == adminSelections.selectAdmin0
      )
    };

    return bindTabularToGeo({
      data: data,
      dataBindColumn: "a1_a0",
      geoData: geoData,
      geoDataBindColumn: "a1_a0"
    });
  }

  // admin1 is selected
  // show all admin2 regions within admin1
  else {
    const data = T.tidy(
      dataGeoImpact,
      T.mutate({
        a2_a1_a0: (d) => [d.admin2_name, d.admin1_name, d.admin0_name].join("_")
      })
    );
    const geoData = {
      ...boundaries.admin2,
      features: boundaries.admin2.features.filter((d) => {
        return d.properties.admin1_name == adminSelections.selectAdmin1
          && d.properties.admin0_name == adminSelections.selectAdmin0
      })
    };

    return bindTabularToGeo({
      data: data,
      dataBindColumn: "a2_a1_a0",
      geoData: geoData,
      geoDataBindColumn: "a2_a1_a0"
    });
  }
}



```




```{ojs}

plotChoroplethGeoImpact = {  
  const data = mapDataGeoImpact
  
  const plot = Plot.plot({
    width: mapWidth,
    caption: `Grey regions signal lack of Total Value of Production(VoP) data. Monetary VoP values are represented in 2005 international dollars`,
    projection: {
      type: "azimuthal-equal-area",
      domain: data
    },
    color: {
      legend: true,
      label: `Value of Production (${intDollarUnit})`,
      range: colorScales.range.yellowGreen,
      unknown: colorScales.unknown,
      tickFormat: formatNumCompactShort,
    },
    marks: [
      // geo data
      Plot.geo(data.features, {
        fill: (d) => {
          const dataColumn = "value"
          const fillValue = d.properties.data ? d.properties.data[dataColumn] : null; // handle missing data
          return fillValue
        },
        stroke: "#fff",
        strokeWidth: 0.5
      }),
      // admin2 highlight 
      // if Admin selection includes admin2, highlight section
      Plot.geo(adminSelections.selectAdmin2 
               ? data.features.filter(d => d.properties.admin2_name == adminSelections.selectAdmin2)
               : [], {
        fill: null,
        stroke: "#333",
        strokeWidth: 1.5
      }),
      // geo pointer
      Plot.geo(data, Plot.pointer(
        Plot.centroid({
        stroke: "#333",
        strokeWidth: 1.5,
      }))),
      // tooltip
      Plot.tip(
        data.features,
        Plot.pointer(
          Plot.centroid({
            channels: {
              name: {
                // region label, based on selection
                label: getLowerLevelAdminLabel(), // plot-level so inputs don't reload
                value: (d) => d.properties.admin0_name
              },
              country: (d) => d.properties.admin0_name,
              data: {
                label: "VoP",
                value: (d) => {
                const dataColumn = "value"
                const data = d.properties.data ? d.properties.data[dataColumn] : undefined
                return data
              },
              }
            },
            format: {
              name: true,
              country: false,
              data: (d) => formatIntDollar(d)
            }
          })
        )
      )
    ]
  });

  return htl.html`<div style="
    border: 1px dotted #ddd;
    padding: 20px;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-top: 16px;
  ">
    ${plot}
  </div>`
}
```





