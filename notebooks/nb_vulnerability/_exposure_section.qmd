---
pagetitle: "Exposure Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
  - Pete Stewart
date-created: '2025-02-19'
date-edited: today
css: styles.css
---


```{ojs}
exposureQuestion = _lang(vulnerability_translations.exposure_question)
```
# `{ojs} exposureQuestion ` {#exposure}


`{ojs} _lang(vulnerability_translations.exposure_description)`




```{ojs}



viewof selectAdmin0 = Inputs.select(dataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof selectAdmin1 = Inputs.select(dataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof selectAdmin2 = Inputs.select(dataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})


```


```{ojs}

viewof selectedHazard = Inputs.select(
  ["drought", "heat-stress", "any"],
  {label: "Hazard type", value: "any"}
)

```


```{ojs}

db = {
  const parquetUrl = await FileAttachment("/data/vulnerability_notebook/notebook_exposure.parquet").url();


  let db = await DuckDBClient.of();
    await db.query(`
    CREATE VIEW Exposure AS
    SELECT *
    FROM read_parquet('${parquetUrl}')
  `);

 return db


}



data = {
 let query = `
    SELECT *
    FROM Exposure
    WHERE hazard = '${selectedHazard}' 
    LIMIT 50
`;
  let result = await db.query(query);
  
  // Convert proxy objects to human-readable plain objects
  return result.map((row, index) => {
    const readableRow = {};
    
    // Method 1: Try to get column names from the database schema
    try {
      // Extract all properties from the proxy object
      const keys = Object.getOwnPropertyNames(row);
      keys.forEach(key => {
        if (typeof key === 'string' && !key.startsWith('Symbol')) {
          readableRow[key] = row[key];
        }
      });
      
      // If that didn't work, try iterating through the proxy
      if (Object.keys(readableRow).length === 0) {
        for (let key in row) {
          readableRow[key] = row[key];
        }
      }
      
      // If still empty, try alternative approach
      if (Object.keys(readableRow).length === 0) {
        // Get the underlying data using DuckDB's approach
        const columns = Object.keys(result.schema?.fields || {});
        columns.forEach((col, i) => {
          readableRow[col] = row[i] !== undefined ? row[i] : row[col];
        });
      }
      
    } catch (e) {
      // Fallback: just assign what we can
      readableRow.raw_data = `Row ${index + 1} (proxy object)`;
      readableRow.note = "Unable to extract readable data";
    }
    
    // Add row identifier
    readableRow._row_id = index + 1;
    
    return readableRow;
  });
}

console.log(data, selectedHazard)




```