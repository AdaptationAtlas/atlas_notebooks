---
pagetitle: "Adaptive Capacity Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: '2025-02-19'
date-edited: today
---



```{ojs}
adaptiveCapacityQuestion = _lang(vulnerability_translations.adaptive_capacity_question)
```

# `{ojs} adaptiveCapacityQuestion ` {#adaptive-capacity}

`{ojs} _lang(vulnerability_translations.adaptive_capacity_description)`

```{ojs}
// Controls section - Admin selectors using static data to prevent flickering
viewof adaptiveCapacityAdmin0 = Inputs.select(adaptiveCapacityDataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof adaptiveCapacityAdmin1 = Inputs.select(adaptiveCapacityDataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof adaptiveCapacityAdmin2 = Inputs.select(adaptiveCapacityDataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})
```

```{ojs}
adaptiveCapacityControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: nowrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin0}</div>
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin1}</div>
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin2}</div>
  </div>
</div>
`
```



```{ojs}
// Load CSV data with caching
adaptiveCapacityRawData = await loadDataWithCache('adaptiveCapacityData', async () => {
  return await FileAttachment("/data/vulnerability_notebook/enabling_vars.csv").csv({typed: true});
});
```

```{ojs}
// Load metadata with caching
adaptiveCapacityMetadata = await loadDataWithCache('adaptiveCapacityMetadata', async () => {
  return await FileAttachment("/data/vulnerability_notebook/enabling_vars_metadata.json").json();
});
```

```{ojs}
// Process the new normalized data structure
adaptiveCapacityData = {
  return adaptiveCapacityRawData.map(d => ({
    ...d,
    // Use the new normalized columns directly (0-1 scale, high = good)
    pct_electric_norm: d.pct_electric_norm,
    pct_piped_water_norm: d.pct_piped_water_norm,
    min_to_cities_norm: d.min_to_cities_norm,
    conflict_density_norm: d.conflict_density_norm,
    pct_cellphone_norm: d.pct_cellphone_norm,
    // Keep original values for tooltips
    pct_electric: d.pct_electric,
    pct_piped_water: d.pct_piped_water,
    min_to_cities: d.min_to_cities,
    conflict_density: d.conflict_density,
    pct_cellphone: d.pct_cellphone
  }))
}
```

```{ojs}
// Get current admin selections (same variable names as sensitivity section)
adaptiveCapacityAdminSelections = {
  return {
    selectAdmin0: adaptiveCapacityAdmin0?.value || null,
    selectAdmin1: adaptiveCapacityAdmin1?.value || null,
    selectAdmin2: adaptiveCapacityAdmin2?.value || null
  }
}
```

```{ojs}

// Filter data based on admin selections (same pattern as sensitivity)
filteredAdaptiveCapacityData = {
  const selections = adaptiveCapacityAdminSelections;
  let data = adaptiveCapacityData;

   if (!selections.selectAdmin1) {
    data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0))
  } else if (selections.selectAdmin1  && !selections.selectAdmin2) {
    data =  data.filter((d)=> (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1))
  } else if (selections.selectAdmin1 && selections.selectAdmin2) {
      data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1 && d.admin2_name === selections.selectAdmin2))
  }
 return data
}
```

```{ojs}
// Helper function to get current region name
getAdaptiveCapacityRegion = () => {
  const selections = adaptiveCapacityAdminSelections;
  if (selections.selectAdmin2) {
    return selections.selectAdmin2;
  } else if (selections.selectAdmin1) {
    return selections.selectAdmin1;
  } else if (selections.selectAdmin0) {
    return selections.selectAdmin0;
  } else {
    return "Africa";
  }
}
```

```{ojs}
// Visualization Implementation - Bar/Bullet Chart with proper loading/no-data states
adaptiveCapacityChart = {
  // Show loading spinner only if data is still loading (null/undefined)
  if (adaptiveCapacityRawData === null || adaptiveCapacityRawData === undefined || 
      adaptiveCapacityMetadata === null || adaptiveCapacityMetadata === undefined) {
    return createLoadingState(_lang({en: "Loading adaptive capacity data...", fr: "Chargement des données de capacité d'adaptation..."}));
  }
  
  // If data is loaded but empty, show no data state
  if (!adaptiveCapacityRawData || adaptiveCapacityRawData.length === 0 || !adaptiveCapacityMetadata || 
      !filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return createNoDataState(_lang(vulnerability_translations.no_data_available));
  }

  // Define the indicators to display using new normalized data structure
  const indicators = [
    { key: "pct_electric_norm", originalKey: "pct_electric", label: _lang({en: "Electricity Access", fr: "Accès à l'électricité"}), unit: "%" },
    { key: "pct_piped_water_norm", originalKey: "pct_piped_water", label: _lang({en: "Piped Water Access", fr: "Accès à l'eau courante"}), unit: "%" },
    { key: "min_to_cities_norm", originalKey: "min_to_cities", label: _lang({en: "Travel Time to Cities", fr: "Temps de trajet vers les villes"}), unit: "min" },
    { key: "pct_cellphone_norm", originalKey: "pct_cellphone", label: _lang({en: "Cellphone Access", fr: "Accès au téléphone portable"}), unit: "%" },
    { key: "conflict_density_norm", originalKey: "conflict_density", label: _lang({en: "Conflict Density", fr: "Densité de conflit"}), unit: "count/km²" }
  ];

  // Prepare data for the chart using normalized values
  const chartData = indicators.map(indicator => {
    // Get normalized value (0-1 scale, high = good)
    const normalizedValue = filteredAdaptiveCapacityData[0]?.[indicator.key] || 0;
    
    // Get original value for tooltips
    const originalValue = filteredAdaptiveCapacityData[0]?.[indicator.originalKey] || 0;
    
    // Calculate regional average for normalized values
    const regionalAverage = d3.mean(adaptiveCapacityData, d => d[indicator.key]) || 0;
    
    // For normalized data, all indicators follow the same logic: high = good
    // Determine color based on normalized value (0-1 scale)
    let color;
    if (normalizedValue >= 0.8) {
      color = "#216729"; // Green - high performance
    } else if (normalizedValue >= 0.5) {
      color = "#F7D732"; // Yellow - moderate performance  
    } else {
      color = "#EC5A47"; // Red - low performance
    }

    // Determine performance level
    let performanceLevel;
    if (normalizedValue >= 0.8) {
      performanceLevel = _lang({en: "high", fr: "élevé"});
    } else if (normalizedValue >= 0.5) {
      performanceLevel = _lang({en: "moderate", fr: "modéré"});
    } else {
      performanceLevel = _lang({en: "low", fr: "faible"});
    }

    return {
      indicator: indicator.label,
      value: normalizedValue, // Use normalized value for chart
      originalValue: originalValue, // Keep original for tooltips
      regionalAverage: regionalAverage,
      unit: indicator.unit,
      color: color,
      performanceLevel: performanceLevel
    };
  });


  // Sort data by value (descending)
  const sortedData = chartData.sort((a, b) => b.value - a.value);
  
  // For normalized data, max value is 1.0
  const maxValue = 1.0;


  const plot =  Plot.plot({
    width: mapWidth,
    height: 360, // Increased height to accommodate axis label
    marginLeft: 180, // Reduced from 200
    marginRight: 60, // Reduced from 100
    marginTop: 15, // Reduced from 20
    marginBottom: 50, // Increased to make room for axis label
    x: {
      label: _lang({en: "Performance Level", fr: "Niveau de performance"}),
      labelAnchor: "center",
      labelOffset: 35,
      domain: [0, 1.0], // Normalized scale 0-1
      tickFormat: (d) => (d === 0 ? _lang({en: "Low", fr: "Faible"}) : d === 1 ? _lang({en: "High", fr: "Élevé"}) : ""),
      ticks: [0, 0.5, 1.0],
      tickSize: 4
    },
    y: {
      label: null, // Remove y-axis label to save space
      tickSize: 0,
      grid: true
    },

    marks: [
      // Target lines (dashed vertical lines)
      Plot.ruleX(sortedData, {
        x: "target",
        y: "indicator", 
        stroke: "#333",
        strokeDasharray: "3,3",
        strokeWidth: 2
      }),
      
      // Regional average bars (light gray background) - full width
      Plot.barX(sortedData, {
        x: "regionalAverage",
        y: "indicator",
        fill: "#e5e5e5",
        opacity: 0.7
      }),
      
      // Actual value bars (blue bars) - narrower using inset
      Plot.barX(sortedData, {
        x: "value", 
        y: "indicator",
        fill: "#4a90e2",
        insetTop: 12,
        insetBottom: 12, 
        channels: {
          [_lang({en: "Current Value", fr: "Valeur actuelle"})]: d => (Number(d.originalValue) || 0).toFixed(1) + (d.unit || ""),
          [_lang({en: "Regional Average", fr: "Moyenne régionale"})]: d => (Number(d.regionalAverage) * 100).toFixed(1) + "%",
          [_lang({en: "Performance Level", fr: "Niveau de performance"})]: "performanceLevel"
        },
        tip: {
          anchor: "top", // Position above the blue bar
          dy: -10 // Offset upward
        }
      })
    ]
  });


  return htl.html`
    <div style="
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 15px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 12px auto;
    ">
    <!-- Legend/Key for bar colors -->
    <div style="
      display: flex;
      justify-content: center;
      gap: 25px;
      margin-bottom: 12px;
      padding: 8px 12px;
      background-color: #f8f9fa;
      border-radius: 4px;
      font-size: 13px;
      font-weight: 500;
    ">
      <div style="display: flex; align-items: center; gap: 6px;">
        <div style="
          width: 16px;
          height: 10px;
          background-color: #e5e5e5;
          border-radius: 2px;
        "></div>
        <span>${_lang({en: "Regional Average", fr: "Moyenne régionale"})}</span>
      </div>
      <div style="display: flex; align-items: center; gap: 6px;">
        <div style="
          width: 16px;
          height: 10px;
          background-color: #4a90e2;
          border-radius: 2px;
        "></div>
        <span>${_lang({en: "Current Value", fr: "Valeur actuelle"})}</span>
      </div>
    </div>
    <div style="display: flex;
      justify-content: center;">
    ${plot}
    </div>
    </div>
  `;
}
```


```{ojs}
// Download functionality
adaptiveCapacityDownloadButton = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return htl.html``;
  }
  
  const region = getAdaptiveCapacityRegion();
  return downloadButton(
    filteredAdaptiveCapacityData, 
    `adaptive_capacity_data_${region.replace(/\s+/g, '_')}`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic Insights following wireframe template
adaptiveCapacityInsights = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return createNoDataState(); // Use same function as exposure
  }
  
  const data = filteredAdaptiveCapacityData[0];
  const region = getAdaptiveCapacityRegion();
    
  // Helper function to determine threshold level
  const getThresholdLevel = (value, thresholds, isInverse = false) => {
    if (isInverse) {
      // For inverse indicators (lower is better)
      if (value <= thresholds.low[0]) return _lang({en: "high", fr: "élevé"});
      if (value <= thresholds.mid[0]) return _lang({en: "moderate", fr: "modéré"});
      return _lang({en: "low", fr: "faible"});
    } else {
      // For normal indicators (higher is better)
      if (value >= thresholds.high[0]) return _lang({en: "high", fr: "élevé"});
      if (value >= thresholds.mid[0]) return _lang({en: "moderate", fr: "modéré"});
      return _lang({en: "low", fr: "faible"});
    }
  };

  // Create indicators using new normalized data structure
  const indicators = [
    {
      key: "pct_electric_norm",
      originalKey: "pct_electric",
      label: _lang({en: "Electricity Access", fr: "Accès à l'électricité"}),
      originalValue: data.pct_electric,
      normalizedValue: data.pct_electric_norm,
      unit: "%"
    },
    {
      key: "pct_piped_water_norm",
      originalKey: "pct_piped_water", 
      label: _lang({en: "Piped Water Access", fr: "Accès à l'eau courante"}),
      originalValue: data.pct_piped_water,
      normalizedValue: data.pct_piped_water_norm,
      unit: "%"
    },
    {
      key: "min_to_cities_norm",
      originalKey: "min_to_cities",
      label: _lang({en: "Travel Time to Cities", fr: "Temps de trajet vers les villes"}),
      originalValue: data.min_to_cities,
      normalizedValue: data.min_to_cities_norm,
      unit: " min"
    },
    {
      key: "pct_cellphone_norm",
      originalKey: "pct_cellphone",
      label: _lang({en: "Cellphone Access", fr: "Accès au téléphone portable"}),
      originalValue: data.pct_cellphone,
      normalizedValue: data.pct_cellphone_norm,
      unit: "%"
    },
    {
      key: "conflict_density_norm",
      originalKey: "conflict_density",
      label: _lang({en: "Conflict Density", fr: "Densité de conflit"}),
      originalValue: data.conflict_density,
      normalizedValue: data.conflict_density_norm,
      unit: " count/km²"
    }
  ];

  // Format indicators with performance levels based on normalized values
  const thresholdIndicators = indicators.map(indicator => {
    const normalizedValue = typeof indicator.normalizedValue === 'number' ? indicator.normalizedValue : 0;
    const originalValue = typeof indicator.originalValue === 'number' ? indicator.originalValue : 0;
    
    // Determine performance level based on normalized value (0-1 scale)
    let level;
    if (normalizedValue >= 0.8) {
      level = _lang({en: "high", fr: "élevé"});
    } else if (normalizedValue >= 0.5) {
      level = _lang({en: "moderate", fr: "modéré"});
    } else {
      level = _lang({en: "low", fr: "faible"});
    }
    
    const numValue = Number(originalValue) || 0;
    const formattedValue = numValue < 1 ? numValue.toFixed(3) : numValue.toFixed(1);
    return `${indicator.label}: ${formattedValue}${indicator.unit} (${level})`;
  });
    
  // Identify limiting factors based on the exact format specified
  const limitingFactors = [];
    
  // Check each indicator for limiting factors using normalized values
  indicators.forEach(indicator => {
    const normalizedValue = typeof indicator.normalizedValue === 'number' ? indicator.normalizedValue : 0;
    const originalValue = typeof indicator.originalValue === 'number' ? indicator.originalValue : 0;
    
    // Determine if this is a limiting factor (low performance)
    if (normalizedValue < 0.5) {
      const numValue = Number(originalValue) || 0;
      let formattedValue;
      if (indicator.originalKey === "pct_electric") {
        formattedValue = `${numValue.toFixed(1)}%`;
      } else if (indicator.originalKey === "min_to_cities") {
        formattedValue = `${numValue.toFixed(0)} min`;
      } else if (indicator.originalKey === "inet_d_kbps") {
        formattedValue = `${(numValue/1000).toFixed(1)} Mbps`;
      } else if (indicator.originalKey === "pct_piped_water") {
        formattedValue = `${numValue.toFixed(0)}%`;
      } else if (indicator.originalKey === "pct_cellphone") {
        formattedValue = `${numValue.toFixed(0)}%`;
      } else if (indicator.originalKey === "conflict_density") {
        formattedValue = `${(numValue * 1000).toFixed(1)} per 1000 km²`;
      } else {
        formattedValue = `${numValue.toFixed(1)}${indicator.unit}`;
      }
      
      limitingFactors.push(`${indicator.label} (${formattedValue})`);
    }
  });

  
  // Generate insight text in the exact format specified
  const limitationLevel = limitingFactors.length > 2 ? 
    _lang({en: "significantly limited", fr: "significativement limitée"}) :
    limitingFactors.length > 0 ? 
    _lang({en: "limited", fr: "limitée"}) :
    _lang({en: "strong", fr: "forte"});
    
  // Format factors as HTML list
  const factorsList = limitingFactors.length > 0 ? 
    limitingFactors.map(factor => htl.html`<li>${factor}</li>`) :
    [htl.html`<li>${_lang({en: "Strong infrastructure and services", fr: "Infrastructure et services solides"})}</li>`];
    
  const recommendation = limitingFactors.length > 0 ?
    _lang({en: "Addressing these can improve resilience.", fr: "Traiter ces problèmes peut améliorer la résilience."}) :
    _lang({en: "Continue strengthening these systems.", fr: "Continuer à renforcer ces systèmes."});
    
  const insight = htl.html`<div>
    <p>${_lang({
      en: `In ${region}, adaptive capacity is ${limitationLevel} by:`,
      fr: `En ${region}, la capacité d'adaptation est ${limitationLevel} par :`
    })}</p>
    <ul>${factorsList}</ul>
    <p>${recommendation}</p>
  </div>`;
    
  return createInsightDisplay(insight);

}
```

