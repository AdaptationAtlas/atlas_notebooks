---
module: "Adaptive Capacity Section"
nb-authors:
  - Johnson Mwakazi
    - Brayden Youngberg
  - Pete Stewart
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
adaptiveCapacityQuestion = _lang(
  vulnerability_translations.adaptive_capacity_question,
);
```

# `{ojs} adaptiveCapacityQuestion` {#adaptive-capacity}

`{ojs} _lang(vulnerability_translations.adaptive_capacity_description)`

```{ojs}
adaptiveCapacityControlsForm = createGeographicControlsForm();
viewof adaptiveCapView = Inputs.radio(["plot", "table"], {
  label: "View Type",
  value: "plot",
});
```

```{ojs}
{
  if (adaptiveCapView == "plot") {
    return renderAdaptiveCapacityPlot();
  } else {
    return filterableDataTable(adaptiveCapacityRawData);
  }
}
```

```{ojs}
// Download functionality
downloadButton(
  adaptiveCapacityRawData,
  `adaptive_capacity_data_${getAdminNameString().replace(", ", "_")}`,
  _lang(vulnerability_translations.download_data),
);

adaptiveCapacityInsights();
```

<!-- Backend Data -->

```{ojs}
adaptiveCapacityRawData = {
  const a0 = admin0Select?.admin0_name;
  const admin = a0 ? `admin0_name in ('${a0}', 'SSA')` : `admin1_name IS NULL`;

  const resp = await localDb.query(`
    SELECT *
    FROM enabling
    WHERE ${admin}
  `);
  return resp;
}
```

```{ojs}
// Shared indicator definitions for plots and insights
adaptiveCapacityIndicators = [
  {
    key: "pct_electric_norm",
    rawKey: "pct_electric",
    label: _lang({ en: "Electricity Access", fr: "Accès à l'électricité" }),
    unit: "%",
  },
  {
    key: "pct_piped_water_norm",
    rawKey: "pct_piped_water",
    label: _lang({ en: "Piped Water Access", fr: "Accès à l'eau courante" }),
    unit: "%",
  },
  {
    key: "min_to_cities_norm",
    rawKey: "min_to_cities",
    label: _lang({
      en: "Distance to Market",
      fr: "Temps de trajet vers les villes",
    }),
    unit: " min.",
  },
  {
    key: "pct_cellphone_norm",
    rawKey: "pct_cellphone",
    label: _lang({
      en: "Cellphone Access",
      fr: "Accès au téléphone portable",
    }),
    unit: "%",
  },
  {
    key: "conflict_density_norm",
    rawKey: "conflict_density",
    label: _lang({ en: "Conflict Density", fr: "Densité de conflit" }),
    unit: " count/km²",
  },
];
```

```{ojs}
// Get current admin selections (same variable names as sensitivity section)
adaptiveCapacityAdminSelections = {
  return {
    selectAdmin0: admin0Select?.admin0_name || null,
    selectAdmin1: admin1Select?.admin1_name || null,
    selectAdmin2: admin2Select?.admin2_name || null,
  };
};
```

```{ojs}
adaptiveCapacityPlotSelectionData = {
  const data = adaptiveCapacityRawData;
  const selections = adaptiveCapacityAdminSelections;
  const isSSA = selections.selectAdmin0 === "SSA" || !selections.selectAdmin0;

  const regionData = data.filter(
    (d) =>
      d.admin0_name === (selections.selectAdmin0 || "SSA") &&
      d.admin1_name === selections.selectAdmin1 &&
      d.admin2_name === selections.selectAdmin2,
  );

  const regionName = getAdminNameString();

  let parentData = [];
  let parentName = "";

  if (!selections.selectAdmin0) {
    parentData = [];
  } else if (!selections.selectAdmin1) {
    parentData = data.filter((d) => d.admin0_name === "SSA");
    parentName = "SSA";
  } else if (!selections.selectAdmin2) {
    parentData = data.filter(
      (d) => d.admin0_name === selections.selectAdmin0 && !d.admin1_name,
    );
    parentName = selections.selectAdmin0;
  } else {
    parentData = data.filter(
      (d) =>
        d.admin0_name === selections.selectAdmin0 &&
        d.admin1_name === selections.selectAdmin1 &&
        !d.admin2_name,
    );
    parentName = selections.selectAdmin1;
  }

  return {
    isSSA,
    regionData,
    regionName,
    parentData,
    parentName,
  };
}
```

```{ojs}
adaptiveCapacityPlotData = {
  const { regionData, parentData } = adaptiveCapacityPlotSelectionData;
  const indicators = adaptiveCapacityIndicators;

  const chartData = indicators.map((indicator) => {
    const region_normalizedValue = regionData.length > 0 
      ? (regionData[0]?.[indicator.key] || null)
      : null;
    const parent_normalizedValue = parentData.length > 0
      ? (parentData[0]?.[indicator.key] || null)
      : null;
    // Get original value for tooltips
    const region_rawValue = regionData.length > 0
      ? (regionData[0]?.[indicator.rawKey] || null)
      : null;
    const parent_rawValue = parentData.length > 0
      ? (parentData[0]?.[indicator.rawKey] || null)
      : null;

    return {
      indicator: indicator.label,
      region_normalizedValue,
      region_rawValue,
      parent_normalizedValue,
      parent_rawValue,
      unit: indicator.unit,
    };
  });

  return chartData.sort((a, b) => a.indicator.localeCompare(b.indicator));
}
```

```{ojs}
renderAdaptiveCapacityPlot = () => {
  const { isSSA, regionName, parentName } = adaptiveCapacityPlotSelectionData;
  const sortedData = adaptiveCapacityPlotData;
  const maxValue = 1.0;

  const plot_channels = {
    [_lang({
      en: `${regionName} Value`,
      fr: "Valeur de la région sélectionnée",
    })]: (d) =>
      d.region_rawValue == null
        ? null
        : Number(d.region_rawValue).toFixed(1) + (d.unit || ""),
  };

  if (!isSSA) {
    plot_channels[
      _lang({ en: `${parentName} Value`, fr: "Moyenne régionale" })
    ] = (d) =>
      d.parent_rawValue == null
        ? null
        : Number(d.parent_rawValue).toFixed(1) + (d.unit || "");
  }

  const plot = Plot.plot({
    width,
    height: 400,
    marginLeft: 160,
    marginRight: 40,
    marginTop: 10,
    marginBottom: 40,
    color: {
      legend: !isSSA,
      domain: [
        _lang({ en: `${regionName} Value`, fr: `${regionName} Value` }),
        _lang({ en: `${parentName} Value`, fr: "Moyenne régionale" }),
      ],
      range: ["#4a90e2", "#e5e5e5"],
    },
    x: {
      label: _lang({ en: "Ability to Adapt", fr: "Niveau de performance" }),
      labelAnchor: "center",
      labelOffset: 30,
      domain: [0, maxValue],
      tickFormat: (d) =>
        d === 0
          ? _lang({ en: "Low", fr: "Faible" })
          : d === 1
            ? _lang({ en: "High", fr: "Élevé" })
            : "",
      ticks: [0, 0.5, 1.0],
      tickSize: 4,
      labelFontSize: 12,
      labelFontWeight: "600",
    },
    y: {
      label: null,
      tickSize: 0,
      grid: true,
    },

    marks: [
      Plot.barX(sortedData, {
        x: "parent_normalizedValue",
        y: "indicator",
        fill: "#e5e5e5",
        opacity: 0.7,
      }),

      Plot.barX(sortedData, {
        x: "region_normalizedValue",
        y: "indicator",
        fill: "#4a90e2",
        insetTop: 15,
        insetBottom: 15,
        channels: plot_channels,
        tip: {
          format: {
            x: false,
          },
        },
      }),
    ],
  });

  return plot;
};
```

```{ojs}
// Dynamic Insights following wireframe template
adaptiveCapacityInsights = () => {
  const selections = adaptiveCapacityAdminSelections;
  let data = adaptiveCapacityRawData;

  if (!selections.selectAdmin0) {
    data = data.filter((d) => d.admin0_name === "SSA" || !d.admin0_name);
  } else if (!selections.selectAdmin1) {
    data = data.filter((d) => d.admin0_name === selections.selectAdmin0);
  } else if (!selections.selectAdmin2) {
    data = data.filter(
      (d) =>
        d.admin0_name === selections.selectAdmin0 &&
        d.admin1_name === selections.selectAdmin1,
    );
  } else {
    data = data.filter(
      (d) =>
        d.admin0_name === selections.selectAdmin0 &&
        d.admin1_name === selections.selectAdmin1 &&
        d.admin2_name === selections.selectAdmin2,
    );
  }
  const region = getAdminNameString();
  const selectedRow = data[0] || {};

  const indicators = adaptiveCapacityIndicators.map((indicator) => ({
    ...indicator,
    originalValue: selectedRow[indicator.rawKey],
    normalizedValue: selectedRow[indicator.key],
  }));

  // Identify limiting factors based on the exact format specified
  const limitingFactors = [];

  // Check each indicator for limiting factors using normalized values
  const limitFormatters = {
    pct_electric: (v) => `${v.toFixed(1)}%`,
    min_to_cities: (v) => `${v.toFixed(0)} min`,
    inet_d_kbps: (v) => `${(v / 1000).toFixed(1)} Mbps`,
    pct_piped_water: (v) => `${v.toFixed(0)}%`,
    pct_cellphone: (v) => `${v.toFixed(0)}%`,
    conflict_density: (v) => `${(v * 1000).toFixed(1)} per 1000 km²`,
  };

  indicators.forEach((indicator) => {
    const normalizedValue =
      typeof indicator.normalizedValue === "number"
        ? indicator.normalizedValue
        : 0;
    const originalValue =
      typeof indicator.originalValue === "number" ? indicator.originalValue : 0;

    if (normalizedValue >= 0.5) return;

    const numValue = Number(originalValue) || 0;
    const formatter = limitFormatters[indicator.rawKey];
    const formattedValue = formatter
      ? formatter(numValue)
      : `${numValue.toFixed(1)}${indicator.unit}`;

    limitingFactors.push(`${indicator.label} (${formattedValue})`);
  });

  // Generate insight text in the exact format specified
  const limitationLevel =
    limitingFactors.length > 2
      ? _lang({ en: "significantly limited", fr: "significativement limitée" })
      : limitingFactors.length > 0
        ? _lang({ en: "limited", fr: "limitée" })
        : _lang({ en: "strong", fr: "forte" });

  // Format factors as HTML list
  const factorsList =
    limitingFactors.length > 0
      ? limitingFactors.map((factor) => htl.html`<li>${factor}</li>`)
      : [
          htl.html`<li>${_lang({ en: "Strong infrastructure and services", fr: "Infrastructure et services solides" })}</li>`,
        ];

  const recommendation =
    limitingFactors.length > 0
      ? _lang({
          en: "Addressing these can improve resilience.",
          fr: "Traiter ces problèmes peut améliorer la résilience.",
        })
      : _lang({
          en: "Continue strengthening these systems.",
          fr: "Continuer à renforcer ces systèmes.",
        });

  const insight = htl.html`<div>
    <p>${_lang({
      en: `In ${region}, adaptive capacity is ${limitationLevel} by:`,
      fr: `En ${region}, la capacité d'adaptation est ${limitationLevel} par :`,
    })}</p>
    <ul>${factorsList}</ul>
    <p>${recommendation}</p>
  </div>`;

  return createInsightDisplay(insight);
};
```
