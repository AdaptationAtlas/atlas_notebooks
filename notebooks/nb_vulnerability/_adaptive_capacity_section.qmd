---
pagetitle: "Adaptive Capacity Section"
nb-authors:
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
adaptiveCapacityQuestion = _lang(
  vulnerability_translations.adaptive_capacity_question,
);
```

# `{ojs} adaptiveCapacityQuestion` {#adaptive-capacity}

`{ojs} _lang(vulnerability_translations.adaptive_capacity_description)`

```{ojs}
// Adaptive capacity section selectors - follow shared state
viewof adaptiveCapacityAdmin0 = Inputs.select(dataAdmin0, {
  label: adminRegions.labels.admin0, 
  format: x => x.label,
  value: dataAdmin0.find(d => d.value === sharedAdmin0) || (dataAdmin0.length > 0 ? dataAdmin0[0] : null)
})
viewof adaptiveCapacityAdmin1 = Inputs.select(dataAdmin1, {
  label: adminRegions.labels.admin1, 
  format: x => x.label,
  value: dataAdmin1.find(d => d.value === sharedAdmin1) || (dataAdmin1.length > 0 ? dataAdmin1[0] : null)
})
viewof adaptiveCapacityAdmin2 = Inputs.select(dataAdmin2, {
  label: adminRegions.labels.admin2, 
  format: x => x.label,
  value: dataAdmin2.find(d => d.value === sharedAdmin2) || (dataAdmin2.length > 0 ? dataAdmin2[0] : null)
})
```

```{ojs}
adaptiveCapacityControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof adaptiveCapacityAdmin0}</div>
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof adaptiveCapacityAdmin1}</div>
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof adaptiveCapacityAdmin2}</div>
  </div>
</div>
`
```

```{ojs}
// Load data with caching - using parquet via DuckDB
adaptiveCapacityRawData = await loadDataWithCache(
  "adaptiveCapacityData",
  async () => {
    const db = await DuckDBClient.of({
      enabling_vars: FileAttachment(
        "/data/vulnerability_notebook/enabling_vars.parquet",
      ),
    });
    const data = await db.query("SELECT * FROM enabling_vars");

    return data;
  },
);
```

```{ojs}
// Load metadata with caching
adaptiveCapacityMetadata = await loadDataWithCache(
  "adaptiveCapacityMetadata",
  async () => {
    return await FileAttachment(
      "/data/vulnerability_notebook/enabling_vars_metadata.json",
    ).json();
  },
);
```

```{ojs}
// Process the new normalized data structure
adaptiveCapacityData = {
  if (!adaptiveCapacityRawData || !Array.isArray(adaptiveCapacityRawData)) {
    console.error("adaptiveCapacityRawData is not valid:", adaptiveCapacityRawData);
    return [];
  }
  
  return adaptiveCapacityRawData.map(d => ({
    ...d,
    // Use the new normalized columns directly (0-1 scale, high = good)
    pct_electric_norm: d.pct_electric_norm,
    pct_piped_water_norm: d.pct_piped_water_norm,
    min_to_cities_norm: d.min_to_cities_norm,
    conflict_density_norm: d.conflict_density_norm,
    pct_cellphone_norm: d.pct_cellphone_norm,
    // Keep original values for tooltips
    pct_electric: d.pct_electric,
    pct_piped_water: d.pct_piped_water,
    min_to_cities: d.min_to_cities,
    conflict_density: d.conflict_density,
    pct_cellphone: d.pct_cellphone
  }))
}
```

```{ojs}
// Get current admin selections (same variable names as sensitivity section)
adaptiveCapacityAdminSelections = {
  return {
    selectAdmin0: adaptiveCapacityAdmin0?.value || null,
    selectAdmin1: adaptiveCapacityAdmin1?.value || null,
    selectAdmin2: adaptiveCapacityAdmin2?.value || null
  }
}
```

```{ojs}
// Filter data based on admin selections (same pattern as sensitivity)
filteredAdaptiveCapacityData = {
  const selections = adaptiveCapacityAdminSelections;
  
  if (!adaptiveCapacityData || adaptiveCapacityData.length === 0) {
    console.error("adaptiveCapacityData is empty or undefined");
    return [];
  }
  
  let data = adaptiveCapacityData;

  if (!selections.selectAdmin0) {
      data =  data.filter((d) => (d.admin0_name === "SSA" || !d.admin0_name)) // Select just SSA data & do not show regional avg
  } else if (!selections.selectAdmin1) {
      data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0))
  } else if (selections.selectAdmin1  && !selections.selectAdmin2) {
      data =  data.filter((d)=> (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1))
  } else if (selections.selectAdmin1 && selections.selectAdmin2) {
      data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1 && d.admin2_name === selections.selectAdmin2))
  }

 return data
}
```

```{ojs}
// Helper function to get current region name (uses shared utility)
getAdaptiveCapacityRegion = () => {
  return getAdminSelection(
    adaptiveCapacityAdmin0,
    adaptiveCapacityAdmin1,
    adaptiveCapacityAdmin2
  );
};
```

```{ojs}
{
  // Check if adaptiveCapacityRawData exists and is an array before processing
  if (!adaptiveCapacityRawData || !Array.isArray(adaptiveCapacityRawData)) {
    return createNoDataState();
  }
  
  let data = adaptiveCapacityRawData;
  const selections = adaptiveCapacityAdminSelections;
  const isSSA = selections.selectAdmin0 === "SSA" || !selections.selectAdmin0;
  // Data for the blue bar - the lowest selected region
  let region_data = data.filter(
    (d) =>
      d.admin0_name === (selections.selectAdmin0 || "SSA") &&
      d.admin1_name === selections.selectAdmin1 &&
      d.admin2_name === selections.selectAdmin2,
  );
  
  let region_name = getAdaptiveCapacityRegion();

  // Data for the grey bar which is the parent
  // eg. region = AGO so parent = SSA or region = nairobi so parent = kenya
  let parent_data = [];
  let parent_name = "";

  if (!selections.selectAdmin0) {
    // Top-level (SSA selected so no parent data is returned)
    parent_data = [];
  } else if (!selections.selectAdmin1) {
    // admin0 selected but no admin1 so parent = SSA
    parent_data = data.filter((d) => d.admin0_name === "SSA");
    parent_name = "SSA";
  } else if (!selections.selectAdmin2) {
    // admin1 selected but no admin2 so parent = admin0 selection
    parent_data = data.filter(
      (d) => d.admin0_name === selections.selectAdmin0 && !d.admin1_name,
    );
    parent_name = selections.selectAdmin0;
  } else {
    // admin2 selected so parent = admin1 selected
    parent_data = data.filter(
      (d) =>
        d.admin0_name === selections.selectAdmin0 &&
        d.admin1_name === selections.selectAdmin1 &&
        !d.admin2_name,
    );
    parent_name = selections.selectAdmin1;
  }

  // Define the indicators to display using new normalized data structure
  const indicators = [
    {
      key: "pct_electric_norm",
      rawKey: "pct_electric",
      label: _lang({ en: "Electricity Access", fr: "Accès à l'électricité" }),
      unit: "%",
    },
    {
      key: "pct_piped_water_norm",
      rawKey: "pct_piped_water",
      label: _lang({ en: "Piped Water Access", fr: "Accès à l'eau courante" }),
      unit: "%",
    },
    {
      key: "min_to_cities_norm",
      rawKey: "min_to_cities",
      label: _lang({
        en: "Distance to Market",
        fr: "Temps de trajet vers les villes",
      }),
      unit: " min.",
    },
    {
      key: "pct_cellphone_norm",
      rawKey: "pct_cellphone",
      label: _lang({
        en: "Cellphone Access",
        fr: "Accès au téléphone portable",
      }),
      unit: "%",
    },
    {
      key: "conflict_density_norm",
      rawKey: "conflict_density",
      label: _lang({ en: "Lack of Conflict", fr: "Densité de conflit" }),
      unit: " count/km²",
    },
  ];

  const chartData = indicators.map((indicator) => {
    // Get normalized value (0-1 scale, high = good)
    // Check if region_data has elements before accessing [0]
    const region_normalizedValue = region_data.length > 0 
      ? (region_data[0]?.[indicator.key] || null)
      : null;
    const parent_normalizedValue = parent_data.length > 0
      ? (parent_data[0]?.[indicator.key] || null)
      : null;
    // Get original value for tooltips
    const region_rawValue = region_data.length > 0
      ? (region_data[0]?.[indicator.rawKey] || null)
      : null;
    const parent_rawValue = parent_data.length > 0
      ? (parent_data[0]?.[indicator.rawKey] || null)
      : null;

    return {
      indicator: indicator.label,
      region_normalizedValue, // Use normalized value for chart
      region_rawValue, // Keep original for tooltips
      parent_normalizedValue,
      parent_rawValue,
      unit: indicator.unit,
    };
  });

  // const sortedData = chartData.sort((a, b) => b.value - a.value);
  // sort alphabetically so consistent between selections to allow easy comparisons
  const sortedData = chartData.sort((a, b) => a.indicator.localeCompare(b.indicator));

  const maxValue = 1.0; // Technically some values pass this, but in general this should be max
  
  const plot_channels = {
    [_lang({en: `${region_name} Value`, fr: "Valeur de la région sélectionnée"})]:
      d => d.region_rawValue == null
        ? null // 0 is meaningful so this stays null
        : Number(d.region_rawValue).toFixed(1) + (d.unit || "")
  };

  if (!isSSA) {
    plot_channels[_lang({en: `${parent_name} Value`, fr: "Moyenne régionale"})] =
      d => d.parent_rawValue == null
        ? null // 0 is meaningful so this stays null
        : Number(d.parent_rawValue).toFixed(1) + (d.unit || "")
  };

  const plot =  Plot.plot({
    width: 1000, // Full width
    height: 400,
    marginLeft: 160, // Reduced for better space utilization
    marginRight: 40, // Reduced for better space utilization
    marginTop: 10, // Reduced white space
    marginBottom: 40, // Reduced white space
    color: {
      legend: !isSSA, // Only show legend if not SSA
      domain: [
        _lang({en: `${region_name} Value`, fr: `${region_name} Value`}),
        _lang({en: `${parent_name} Value`, fr: "Moyenne régionale"})
      ],
      range: ["#4a90e2", "#e5e5e5"]
    },
    x: {
      label: _lang({en: "Ability to Adapt", fr: "Niveau de performance"}),
      labelAnchor: "center",
      labelOffset: 30,
      domain: [0, maxValue], // Normalized scale 0-1
      tickFormat: (d) => (d === 0 ? _lang({en: "Low", fr: "Faible"}) : d === 1 ? _lang({en: "High", fr: "Élevé"}) : ""),
      ticks: [0, 0.5, 1.0],
      tickSize: 4,
      labelFontSize: 12,
      labelFontWeight: "600"
    },
    y: {
      label: null, // Remove y-axis label to save space
      tickSize: 0,
      grid: true,
      // domain: sortedData.map(d => d.indicator) // Only show indicators with data
    },

    marks: [
      // Regional average bars (light gray background) - full width
      Plot.barX(sortedData, {
        x: "parent_normalizedValue",
        y: "indicator",
        fill: "#e5e5e5",
        opacity: 0.7
      }),
      
      // Actual value bars (blue bars) - narrower using inset
      
      Plot.barX(sortedData, {
        x: "region_normalizedValue", 
        y: "indicator",
        fill: "#4a90e2",
        insetTop: 15, // Make bars narrower
        insetBottom: 15, 
        channels: plot_channels,
        tip: {
          anchor: "top", // Position above the blue bar
          dy: -10, // Offset upward
          format: {
            x: false
          }
        }
      })
    ]
  });

  return plot;
}
```

```{ojs}
// Download functionality
adaptiveCapacityDownloadButton = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return htl.html``;
  }
  
  const region = getAdaptiveCapacityRegion();
  return downloadButton(
    filteredAdaptiveCapacityData, 
    `adaptive_capacity_data_${region.replace(/\s+/g, '_')}`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic Insights following wireframe template
adaptiveCapacityInsights = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return createNoDataState(); // Use same function as exposure
  }
  
  const data = filteredAdaptiveCapacityData[0];
  const region = getAdaptiveCapacityRegion();
    
  // Helper function to determine threshold level
  const getThresholdLevel = (value, thresholds, isInverse = false) => {
    if (isInverse) {
      // For inverse indicators (lower is better)
      if (value <= thresholds.low[0]) return _lang({en: "high", fr: "élevé"});
      if (value <= thresholds.mid[0]) return _lang({en: "moderate", fr: "modéré"});
      return _lang({en: "low", fr: "faible"});
    } else {
      // For normal indicators (higher is better)
      if (value >= thresholds.high[0]) return _lang({en: "high", fr: "élevé"});
      if (value >= thresholds.mid[0]) return _lang({en: "moderate", fr: "modéré"});
      return _lang({en: "low", fr: "faible"});
    }
  };

  // Create indicators using new normalized data structure
  const indicators = [
    {
      key: "pct_electric_norm",
      originalKey: "pct_electric",
      label: _lang({en: "Electricity Access", fr: "Accès à l'électricité"}),
      originalValue: data.pct_electric,
      normalizedValue: data.pct_electric_norm,
      unit: "%"
    },
    {
      key: "pct_piped_water_norm",
      originalKey: "pct_piped_water", 
      label: _lang({en: "Piped Water Access", fr: "Accès à l'eau courante"}),
      originalValue: data.pct_piped_water,
      normalizedValue: data.pct_piped_water_norm,
      unit: "%"
    },
    {
      key: "min_to_cities_norm",
      originalKey: "min_to_cities",
      label: _lang({en: "Travel Time to Cities", fr: "Temps de trajet vers les villes"}),
      originalValue: data.min_to_cities,
      normalizedValue: data.min_to_cities_norm,
      unit: " min"
    },
    {
      key: "pct_cellphone_norm",
      originalKey: "pct_cellphone",
      label: _lang({en: "Cellphone Access", fr: "Accès au téléphone portable"}),
      originalValue: data.pct_cellphone,
      normalizedValue: data.pct_cellphone_norm,
      unit: "%"
    },
    {
      key: "conflict_density_norm",
      originalKey: "conflict_density",
      label: _lang({en: "Conflict Density", fr: "Densité de conflit"}),
      originalValue: data.conflict_density,
      normalizedValue: data.conflict_density_norm,
      unit: " count/km²"
    }
  ];

  // Format indicators with performance levels based on normalized values
  const thresholdIndicators = indicators.map(indicator => {
    const normalizedValue = typeof indicator.normalizedValue === 'number' ? indicator.normalizedValue : 0;
    const originalValue = typeof indicator.originalValue === 'number' ? indicator.originalValue : 0;
    
    // Determine performance level based on normalized value (0-1 scale)
    let level;
    if (normalizedValue >= 0.8) {
      level = _lang({en: "high", fr: "élevé"});
    } else if (normalizedValue >= 0.5) {
      level = _lang({en: "moderate", fr: "modéré"});
    } else {
      level = _lang({en: "low", fr: "faible"});
    }
    
    const numValue = Number(originalValue) || 0;
    const formattedValue = numValue < 1 ? numValue.toFixed(3) : numValue.toFixed(1);
    return `${indicator.label}: ${formattedValue}${indicator.unit} (${level})`;
  });
    
  // Identify limiting factors based on the exact format specified
  const limitingFactors = [];
    
  // Check each indicator for limiting factors using normalized values
  indicators.forEach(indicator => {
    const normalizedValue = typeof indicator.normalizedValue === 'number' ? indicator.normalizedValue : 0;
    const originalValue = typeof indicator.originalValue === 'number' ? indicator.originalValue : 0;
    
    // Determine if this is a limiting factor (low performance)
    if (normalizedValue < 0.5) {
      const numValue = Number(originalValue) || 0;
      let formattedValue;
      if (indicator.originalKey === "pct_electric") {
        formattedValue = `${numValue.toFixed(1)}%`;
      } else if (indicator.originalKey === "min_to_cities") {
        formattedValue = `${numValue.toFixed(0)} min`;
      } else if (indicator.originalKey === "inet_d_kbps") {
        formattedValue = `${(numValue/1000).toFixed(1)} Mbps`;
      } else if (indicator.originalKey === "pct_piped_water") {
        formattedValue = `${numValue.toFixed(0)}%`;
      } else if (indicator.originalKey === "pct_cellphone") {
        formattedValue = `${numValue.toFixed(0)}%`;
      } else if (indicator.originalKey === "conflict_density") {
        formattedValue = `${(numValue * 1000).toFixed(1)} per 1000 km²`;
      } else {
        formattedValue = `${numValue.toFixed(1)}${indicator.unit}`;
      }
      
      limitingFactors.push(`${indicator.label} (${formattedValue})`);
    }
  });

  
  // Generate insight text in the exact format specified
  const limitationLevel = limitingFactors.length > 2 ? 
    _lang({en: "significantly limited", fr: "significativement limitée"}) :
    limitingFactors.length > 0 ? 
    _lang({en: "limited", fr: "limitée"}) :
    _lang({en: "strong", fr: "forte"});
    
  // Format factors as HTML list
  const factorsList = limitingFactors.length > 0 ? 
    limitingFactors.map(factor => htl.html`<li>${factor}</li>`) :
    [htl.html`<li>${_lang({en: "Strong infrastructure and services", fr: "Infrastructure et services solides"})}</li>`];
    
  const recommendation = limitingFactors.length > 0 ?
    _lang({en: "Addressing these can improve resilience.", fr: "Traiter ces problèmes peut améliorer la résilience."}) :
    _lang({en: "Continue strengthening these systems.", fr: "Continuer à renforcer ces systèmes."});
    
  const insight = htl.html`<div>
    <p>${_lang({
      en: `In ${region}, adaptive capacity is ${limitationLevel} by:`,
      fr: `En ${region}, la capacité d'adaptation est ${limitationLevel} par :`
    })}</p>
    <ul>${factorsList}</ul>
    <p>${recommendation}</p>
  </div>`;
    
  return createInsightDisplay(insight);

}
```
