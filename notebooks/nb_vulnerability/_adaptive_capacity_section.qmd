---
pagetitle: "Adaptive Capacity Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: '2025-02-19'
date-edited: today
---



```{ojs}
adaptiveCapacityQuestion = _lang(vulnerability_translations.adaptive_capacity_question)
```

# `{ojs} adaptiveCapacityQuestion ` {#adaptive-capacity}

`{ojs} _lang(vulnerability_translations.adaptive_capacity_description)`

```{ojs}
// Controls section - Admin selectors using static data to prevent flickering
viewof adaptiveCapacityAdmin0 = Inputs.select(adaptiveCapacityDataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof adaptiveCapacityAdmin1 = Inputs.select(adaptiveCapacityDataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof adaptiveCapacityAdmin2 = Inputs.select(adaptiveCapacityDataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})
```

```{ojs}
adaptiveCapacityControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: nowrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin0}</div>
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin1}</div>
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin2}</div>
  </div>
</div>
`
```

```{ojs}
// Additional controls
// viewof genderToggle = Inputs.radio(["both", "female", "male"], {
//   label: _lang({en: "Gender", fr: "Genre"}), 
//   value: "both"
// })

viewof sortBy = Inputs.radio(["value", "alphabetical"], {
  label: _lang({en: "Sort by", fr: "Trier par"}), 
  value: "value"
})
```

```{ojs}
// Load CSV data with caching
adaptiveCapacityRawData = await loadDataWithCache('adaptiveCapacityData', async () => {
  return await FileAttachment("/data/vulnerability_notebook/enabling_vars.csv").csv({typed: true});
});
```

```{ojs}
// Load metadata with caching
adaptiveCapacityMetadata = await loadDataWithCache('adaptiveCapacityMetadata', async () => {
  return await FileAttachment("/data/vulnerability_notebook/enabling_vars_metadata.json").json();
});
```

```{ojs}
// Calculate derived indicators
adaptiveCapacityData = {
  return adaptiveCapacityRawData.map(d => ({
    ...d,
    // Calculate electricity access percentage (100 - percentage without electricity)
    pct_electric: d.total_pop > 0 ? Math.max(0, 100 - (d.no_electric_pop / d.total_pop * 100)) : null,
    // Keep other indicators as-is
    inet_d_kbps: d.inet_d_kbps,
    pct_piped_water: d.pct_piped_water,
    min_to_cities: d.min_to_cities,
    conflict_density: d.conflict_density
  }))
}
```

```{ojs}
// Get current admin selections (same variable names as sensitivity section)
adaptiveCapacityAdminSelections = {
  return {
    selectAdmin0: adaptiveCapacityAdmin0?.value || null,
    selectAdmin1: adaptiveCapacityAdmin1?.value || null,
    selectAdmin2: adaptiveCapacityAdmin2?.value || null
  }
}
```

```{ojs}

// Filter data based on admin selections (same pattern as sensitivity)
filteredAdaptiveCapacityData = {
  const selections = adaptiveCapacityAdminSelections;
  let data = adaptiveCapacityData;

   if (!selections.selectAdmin1) {
    data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0))
  } else if (selections.selectAdmin1  && !selections.selectAdmin2) {
    data =  data.filter((d)=> (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1))
  } else if (selections.selectAdmin1 && selections.selectAdmin2) {
      data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1 && d.admin2_name === selections.selectAdmin2))
  }
 return data
}
```

```{ojs}
// Helper function to get current region name
getAdaptiveCapacityRegion = () => {
  const selections = adaptiveCapacityAdminSelections;
  if (selections.selectAdmin2) {
    return selections.selectAdmin2;
  } else if (selections.selectAdmin1) {
    return selections.selectAdmin1;
  } else if (selections.selectAdmin0) {
    return selections.selectAdmin0;
  } else {
    return "Africa";
  }
}
```

```{ojs}
// Visualization Implementation - Bar/Bullet Chart with proper loading/no-data states
adaptiveCapacityChart = {
  // Show loading spinner only if data is still loading (null/undefined)
  if (adaptiveCapacityRawData === null || adaptiveCapacityRawData === undefined || 
      adaptiveCapacityMetadata === null || adaptiveCapacityMetadata === undefined) {
    return createLoadingState(_lang({en: "Loading adaptive capacity data...", fr: "Chargement des données de capacité d'adaptation..."}));
  }
  
  // If data is loaded but empty, show no data state
  if (!adaptiveCapacityRawData || adaptiveCapacityRawData.length === 0 || !adaptiveCapacityMetadata || 
      !filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return createNoDataState(_lang(vulnerability_translations.no_data_available));
  }

  // Define the indicators to display
  const indicators = [
    { key: "pct_electric", label: _lang({en: "Electricity Access", fr: "Accès à l'électricité"}), target: 100 },
    { key: "inet_d_kbps", label: _lang({en: "Internet Speed", fr: "Vitesse Internet"}), target: 10000 },  
    { key: "pct_piped_water", label: _lang({en: "Clean Water Access", fr: "Accès à l'eau potable"}), target: 100 },
    { key: "min_to_cities", label: _lang({en: "Travel Time to Cities", fr: "Temps de trajet vers les villes"}), target: 30 }, // Lower is better
    { key: "conflict_density", label: _lang({en: "Conflict Density", fr: "Densité des conflits"}), target: 0 } // Lower is better
  ];

  // Prepare data for the chart
  const chartData = indicators.map(indicator => {
    const metadata = adaptiveCapacityMetadata[indicator.key] || adaptiveCapacityMetadata["pct_no_electric"]; // fallback
    const value = filteredAdaptiveCapacityData[0]?.[indicator.key] || 0;
    
    // Calculate regional average (simplified - you may want to weight by population)
    const regionalAverage = d3.mean(adaptiveCapacityData, d => d[indicator.key]) || 0;
    const distanceToTarget = Math.abs(value - indicator.target);
    
    // Determine color based on thresholds
    const thresholds = metadata.thresholds;
    const isInverse = metadata.inverse?.[0] || false; // lower values are better for inverse indicators
    
    let color;
    if (indicator.key === "pct_electric") {
      // For electricity access, higher is better
      color = value >= 95 ? "#216729" : 
              value >= 70 ? "#F7D732" : "#EC5A47";
    } else if (isInverse) {
      color = value <= thresholds.low[0] ? "#216729" : 
              value <= thresholds.mid[0] ? "#F7D732" : "#EC5A47";
    } else {
      color = value >= thresholds.high[0] ? "#216729" : 
              value >= thresholds.mid[0] ? "#F7D732" : "#EC5A47";
    }

    return {
      indicator: indicator.label,
      value: value,
      regionalAverage: regionalAverage,
      target: indicator.target,
      distanceToTarget: distanceToTarget,
      unit: metadata.unit?.[0] || "",
      color: color,
      metadata: metadata,
      isInverse: isInverse
    };
  });


  // Sort data if needed
  const sortedData = sortBy.value === "value" 
    ? chartData.sort((a, b) => a.indicator.localeCompare(b.indicator))
    : chartData.sort((a, b) => b.value - a.value);
  const maxValue = d3.max(sortedData, d => Math.max(d.value, d.regionalAverage, d.target));


  const plot =  Plot.plot({
    width: mapWidth,
    height: 400,
    marginLeft: 200,
    marginRight: 100,
    x: {
      label: _lang({en: "Value", fr: "Valeur"}),
      grid: true,
      domain: [0, maxValue * 1.1]
    },
    y: {
      label: null
    },
    color: {
      legend: true,
      range: ["#216729", "#F7D732", "#EC5A47"],
      domain: [_lang({en: "Good", fr: "Bon"}), _lang({en: "Moderate", fr: "Modéré"}), _lang({en: "Poor", fr: "Mauvais"})]
    },
    marks: [
      // Target lines
      Plot.ruleX(sortedData, {
        x: "target",
        y: "indicator", 
        stroke: "#333",
        strokeDasharray: "3,3",
        strokeWidth: 2
      }),
      
      // Regional average bars (background)
      Plot.barX(sortedData, {
        x: "regionalAverage",
        y: "indicator",
        fill: "#e5e5e5",
        opacity: 0.5
      }),
      
      // Actual value bars
      Plot.barX(sortedData, {
        x: "value", 
        y: "indicator",
        fill: "color",
        channels: {
          [_lang({en: "Actual Value", fr: "Valeur actuelle"})]: "value",
          [_lang({en: "Regional Average", fr: "Moyenne régionale"})]: "regionalAverage", 
          [_lang({en: "Distance to Target", fr: "Distance à l'objectif"})]: "distanceToTarget",
          [_lang({en: "Unit", fr: "Unité"})]: "unit"
        },
        tip: true
      }),
      
      // Value labels
      Plot.text(sortedData, {
        x: d => d.value + (maxValue * 0.02),
        y: "indicator",
        text: d => {
          const formattedValue = d.value < 1 ? d.value.toFixed(3) : d.value.toFixed(1);
          const unitSuffix = d.unit === 'percent' ? '%' : 
                            d.unit === 'kbps' ? ' kbps' :
                            d.unit === 'minutes' ? ' min' : '';
          return `${formattedValue}${unitSuffix}`;
        },
        textAnchor: "start",
        fontSize: 12,
        fill: "#374151"
      }),
      
      // Target labels
      Plot.text(sortedData, {
        x: d => d.target,
        y: "indicator",
        text: _lang({en: "Target", fr: "Cible"}),
        textAnchor: "middle",
        fontSize: 10,
        fill: "#666",
        dy: -10
      })
    ]
  });


  return htl.html`
    <div style="
      border: 1px solid #e5e7eb;
      border-radius: 8px;
    padding: 20px;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 16px 0;
  ">
    ${plot}
    </div>
  `;
}
```


```{ojs}
// Download functionality
adaptiveCapacityDownloadButton = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return htl.html``;
  }
  
  const region = getAdaptiveCapacityRegion();
  return downloadButton(
    filteredAdaptiveCapacityData, 
    `adaptive_capacity_data_${region.replace(/\s+/g, '_')}`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic Insights following wireframe template
adaptiveCapacityInsights = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return createNoDataState(); // Use same function as exposure
  }
  
  const data = filteredAdaptiveCapacityData[0];
  const region = getAdaptiveCapacityRegion();
    
  // Identify limiting factors based on wireframe indicators
  const limitingFactors = [];
    
  // Internet access (convert kbps to descriptive)
  const internetSpeed = data.inet_d_kbps;
  if (internetSpeed < 2048) { // Below mid threshold
    limitingFactors.push(_lang({
      en: `Low internet access (${(internetSpeed/1000).toFixed(1)} Mbps)`,
      fr: `Faible accès Internet (${(internetSpeed/1000).toFixed(1)} Mbps)`
    }));
  }
    
  // Travel time to cities (healthcare proxy)
  const travelTime = data.min_to_cities;
  if (travelTime > 60) { // Above mid threshold
    limitingFactors.push(_lang({
      en: `Long travel time to healthcare (avg. ${travelTime.toFixed(0)} minutes)`,
      fr: `Temps de trajet long vers les soins de santé (moy. ${travelTime.toFixed(0)} minutes)`
    }));
  }
    
  // Electricity access (infrastructure)
  const electricityAccess = data.pct_electric;
  if (electricityAccess < 70) { // Below good threshold
    limitingFactors.push(_lang({
      en: `Limited electricity access (${electricityAccess.toFixed(1)}%)`,
      fr: `Accès limité à l'électricité (${electricityAccess.toFixed(1)}%)`
    }));
  }
    
  // Water access
  const waterAccess = data.pct_piped_water;
  if (waterAccess < 75) { // Below good threshold
    limitingFactors.push(_lang({
      en: `Limited piped water access (${waterAccess.toFixed(1)}%)`,
      fr: `Accès limité à l'eau courante (${waterAccess.toFixed(1)}%)`
    }));
  }
    
  // Conflict density
  const conflict = data.conflict_density;
  if (conflict > 0.01) { // Above low threshold
    limitingFactors.push(_lang({
      en: `High conflict incidence (${(conflict * 1000).toFixed(1)} per 1000 km²), which may disrupt access to critical services and reduce institutional support`,
      fr: `Incidence élevée de conflits (${(conflict * 1000).toFixed(1)} pour 1000 km²), ce qui peut perturber l'accès aux services essentiels et réduire le soutien institutionnel`
    }));
  }
    
  // Generate insight text
  const limitationLevel = limitingFactors.length > 2 ? 
    _lang({en: "significantly limited", fr: "significativement limitée"}) :
    limitingFactors.length > 0 ? 
    _lang({en: "limited", fr: "limitée"}) :
    _lang({en: "supported", fr: "soutenue"});
    
  // Format factors as HTML list using htl.html for proper rendering
  const factorsList = limitingFactors.length > 0 ? 
    limitingFactors.map(factor => htl.html`<li>${factor}</li>`) :
    [htl.html`<li>${_lang({en: "Strong infrastructure and services", fr: "Infrastructure et services solides"})}</li>`];
    
  const recommendation = limitingFactors.length > 0 ?
    _lang({en: "Addressing these can improve resilience.", fr: "Traiter ces problèmes peut améliorer la résilience."}) :
    _lang({en: "Continue strengthening these systems.", fr: "Continuer à renforcer ces systèmes."});
    
  const insight = htl.html`<div>
    <p>${_lang({
      en: `In ${region}, adaptive capacity is ${limitationLevel} by:`,
      fr: `En ${region}, la capacité d'adaptation est ${limitationLevel} par :`
    })}</p>
    <ul>${factorsList}</ul>
    <p>${recommendation}</p>
  </div>`;
    
  return createInsightDisplay(insight); // Use same function as exposure

}
```

