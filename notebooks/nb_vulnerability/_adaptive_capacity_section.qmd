---
pagetitle: "Adaptive Capacity Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: '2025-02-19'
date-edited: today
---



```{ojs}
adaptiveCapacityQuestion = _lang(vulnerability_translations.adaptive_capacity_question)
```

# `{ojs} adaptiveCapacityQuestion ` {#adaptive-capacity}

`{ojs} _lang(vulnerability_translations.adaptive_capacity_description)`

```{ojs}
// Controls section - Admin selectors using static data to prevent flickering
viewof adaptiveCapacityAdmin0 = Inputs.select(adaptiveCapacityDataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof adaptiveCapacityAdmin1 = Inputs.select(adaptiveCapacityDataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof adaptiveCapacityAdmin2 = Inputs.select(adaptiveCapacityDataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})
```

```{ojs}
adaptiveCapacityControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: nowrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin0}</div>
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin1}</div>
    <div style="flex: 1; min-width: 180px;">${viewof adaptiveCapacityAdmin2}</div>
  </div>
</div>
`
```

```{ojs}
// Additional controls
// viewof genderToggle = Inputs.radio(["both", "female", "male"], {
//   label: _lang({en: "Gender", fr: "Genre"}), 
//   value: "both"
// })

viewof sortBy = Inputs.radio(["value", "alphabetical"], {
  label: _lang({en: "Sort by", fr: "Trier par"}), 
  value: "value"
})
```



```{ojs}
// Load CSV data with caching
adaptiveCapacityRawData = await loadDataWithCache('adaptiveCapacityData', async () => {
  return await FileAttachment("/data/vulnerability_notebook/enabling_vars.csv").csv({typed: true});
});
```

```{ojs}
// Load metadata with caching
adaptiveCapacityMetadata = await loadDataWithCache('adaptiveCapacityMetadata', async () => {
  return await FileAttachment("/data/vulnerability_notebook/enabling_vars_metadata.json").json();
});
```

```{ojs}
// Calculate derived indicators
adaptiveCapacityData = {
  return adaptiveCapacityRawData.map(d => ({
    ...d,
    // Calculate electricity access percentage (100 - percentage without electricity)
    pct_electric: d.total_pop > 0 ? Math.max(0, 100 - (d.no_electric_pop / d.total_pop * 100)) : null,
    // Keep other indicators as-is
    inet_d_kbps: d.inet_d_kbps,
    pct_piped_water: d.pct_piped_water,
    min_to_cities: d.min_to_cities,
    conflict_density: d.conflict_density
  }))
}
```

```{ojs}
// Get current admin selections (same variable names as sensitivity section)
adaptiveCapacityAdminSelections = {
  return {
    selectAdmin0: adaptiveCapacityAdmin0?.value || null,
    selectAdmin1: adaptiveCapacityAdmin1?.value || null,
    selectAdmin2: adaptiveCapacityAdmin2?.value || null
  }
}
```

```{ojs}

// Filter data based on admin selections (same pattern as sensitivity)
filteredAdaptiveCapacityData = {
  const selections = adaptiveCapacityAdminSelections;
  let data = adaptiveCapacityData;

   if (!selections.selectAdmin1) {
    data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0))
  } else if (selections.selectAdmin1  && !selections.selectAdmin2) {
    data =  data.filter((d)=> (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1))
  } else if (selections.selectAdmin1 && selections.selectAdmin2) {
      data =  data.filter((d) => (d.admin0_name === selections.selectAdmin0 && d.admin1_name === selections.selectAdmin1 && d.admin2_name === selections.selectAdmin2))
  }
 return data
}
```

```{ojs}
// Helper function to get current region name
getAdaptiveCapacityRegion = () => {
  const selections = adaptiveCapacityAdminSelections;
  if (selections.selectAdmin2) {
    return selections.selectAdmin2;
  } else if (selections.selectAdmin1) {
    return selections.selectAdmin1;
  } else if (selections.selectAdmin0) {
    return selections.selectAdmin0;
  } else {
    return "Africa";
  }
}
```

```{ojs}
// Visualization Implementation - Bar/Bullet Chart with proper loading/no-data states
adaptiveCapacityChart = {
  // Show loading spinner only if data is still loading (null/undefined)
  if (adaptiveCapacityRawData === null || adaptiveCapacityRawData === undefined || 
      adaptiveCapacityMetadata === null || adaptiveCapacityMetadata === undefined) {
    return createLoadingState(_lang({en: "Loading adaptive capacity data...", fr: "Chargement des données de capacité d'adaptation..."}));
  }
  
  // If data is loaded but empty, show no data state
  if (!adaptiveCapacityRawData || adaptiveCapacityRawData.length === 0 || !adaptiveCapacityMetadata || 
      !filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return createNoDataState(_lang(vulnerability_translations.no_data_available));
  }

  // Define the indicators to display matching the photo
  const indicators = [
    { key: "pct_no_electric", label: _lang({en: "Electricity", fr: "Électricité"}), target: 0, isInverse: true }, // Lower is better
    { key: "min_to_cities", label: _lang({en: "Healthcare Access", fr: "Accès aux soins de santé"}), target: 30, isInverse: true }, // Lower is better
    { key: "inet_d_kbps", label: _lang({en: "Internet Speed", fr: "Vitesse Internet"}), target: 10000, isInverse: false },  
    { key: "pct_piped_water", label: _lang({en: "Credit", fr: "Crédit"}), target: 100, isInverse: false },
    { key: "conflict_density", label: _lang({en: "Market Access", fr: "Accès au marché"}), target: 0, isInverse: true } // Lower is better
  ];

  // Prepare data for the chart
  const chartData = indicators.map(indicator => {
    const metadata = adaptiveCapacityMetadata[indicator.key];
    if (!metadata) return null; // Skip if no metadata
    
    const value = filteredAdaptiveCapacityData[0]?.[indicator.key] || 0;
    
    // Calculate regional average (simplified - you may want to weight by population)
    const regionalAverage = d3.mean(adaptiveCapacityData, d => d[indicator.key]) || 0;
    const distanceToTarget = Math.abs(value - indicator.target);
    
    // Use metadata thresholds and inverse flag
    const thresholds = metadata.thresholds;
    const isInverse = metadata.inverse?.[0] || false;
    
    // Determine color based on thresholds
    let color;
    if (isInverse) {
      // For inverse indicators (lower is better)
      color = value <= thresholds.low[0] ? "#216729" : 
              value <= thresholds.mid[0] ? "#F7D732" : "#EC5A47";
    } else {
      // For normal indicators (higher is better)
      color = value >= thresholds.high[0] ? "#216729" : 
              value >= thresholds.mid[0] ? "#F7D732" : "#EC5A47";
    }

    // Determine performance level based on thresholds
    let performanceLevel;
    if (isInverse) {
      // For inverse indicators (lower is better)
      performanceLevel = value <= thresholds.low[0] ? _lang({en: "high", fr: "élevé"}) : 
                        value <= thresholds.mid[0] ? _lang({en: "moderate", fr: "modéré"}) : 
                        _lang({en: "low", fr: "faible"});
    } else {
      // For normal indicators (higher is better)
      performanceLevel = value >= thresholds.high[0] ? _lang({en: "high", fr: "élevé"}) : 
                        value >= thresholds.mid[0] ? _lang({en: "moderate", fr: "modéré"}) : 
                        _lang({en: "low", fr: "faible"});
    }

    return {
      indicator: indicator.label,
      value: value,
      regionalAverage: regionalAverage,
      target: indicator.target,
      distanceToTarget: distanceToTarget,
      unit: metadata.unit?.[0] || "",
      color: color,
      metadata: metadata,
      isInverse: isInverse,
      performanceLevel: performanceLevel
    };
  }).filter(d => d !== null); // Remove null entries


  // Sort data if needed
  const sortedData = sortBy.value === "alphabetical" 
    ? chartData.sort((a, b) => a.indicator.localeCompare(b.indicator))
    : chartData.sort((a, b) => b.value - a.value);
  const maxValue = d3.max(sortedData, d => Math.max(d.value, d.regionalAverage, d.target));


  const plot =  Plot.plot({
    width: mapWidth,
    height: 400,
    marginLeft: 200,
    marginRight: 100,
    marginTop: 20,
    marginBottom: 40,
    x: {
      label: null,
      grid: true,
      domain: [0, maxValue * 1.1]
    },
    y: {
      label: null,
      fontSize: 14
    },
    marks: [
      // Target lines (dashed vertical lines)
      Plot.ruleX(sortedData, {
        x: "target",
        y: "indicator", 
        stroke: "#333",
        strokeDasharray: "3,3",
        strokeWidth: 2
      }),
      
      // Regional average bars (light gray background)
      Plot.barX(sortedData, {
        x: "regionalAverage",
        y: "indicator",
        fill: "#e5e5e5",
        opacity: 0.7
      }),
      
      // Actual value bars (blue bars)
      Plot.barX(sortedData, {
        x: "value", 
        y: "indicator",
        fill: "#4a90e2",
        channels: {
          [_lang({en: "Admin Region", fr: "Région Admin"})]: "value",
          [_lang({en: "Regional Avg", fr: "Moyenne Régionale"})]: "regionalAverage", 
          [_lang({en: "Target", fr: "Cible"})]: "target",
          [_lang({en: "Distance to Target", fr: "Distance à l'objectif"})]: "distanceToTarget",
          [_lang({en: "Performance Level", fr: "Niveau de performance"})]: "performanceLevel"
        },
        tip: {
          format: {
            x: (d) => {
              const value = typeof d === 'number' ? d : 0;
              return value < 1 ? value.toFixed(3) : value.toFixed(1);
            }
          }
        }
      })
    ]
  });


  return htl.html`
    <div style="
      border: 1px solid #e5e7eb;
      border-radius: 8px;
    padding: 20px;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 16px 0;
  ">
    ${plot}
    </div>
  `;
}
```


```{ojs}
// Download functionality
adaptiveCapacityDownloadButton = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return htl.html``;
  }
  
  const region = getAdaptiveCapacityRegion();
  return downloadButton(
    filteredAdaptiveCapacityData, 
    `adaptive_capacity_data_${region.replace(/\s+/g, '_')}`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic Insights following wireframe template
adaptiveCapacityInsights = {
  if (!filteredAdaptiveCapacityData || filteredAdaptiveCapacityData.length === 0) {
    return createNoDataState(); // Use same function as exposure
  }
  
  const data = filteredAdaptiveCapacityData[0];
  const region = getAdaptiveCapacityRegion();
    
  // Helper function to determine threshold level
  const getThresholdLevel = (value, thresholds, isInverse = false) => {
    if (isInverse) {
      // For inverse indicators (lower is better)
      if (value <= thresholds.low[0]) return _lang({en: "high", fr: "élevé"});
      if (value <= thresholds.mid[0]) return _lang({en: "moderate", fr: "modéré"});
      return _lang({en: "low", fr: "faible"});
    } else {
      // For normal indicators (higher is better)
      if (value >= thresholds.high[0]) return _lang({en: "high", fr: "élevé"});
      if (value >= thresholds.mid[0]) return _lang({en: "moderate", fr: "modéré"});
      return _lang({en: "low", fr: "faible"});
    }
  };

  // Create threshold-based indicators list matching the requirements
  const indicators = [
    {
      key: "pct_electric",
      label: _lang({en: "Electricity", fr: "Électricité"}),
      value: data.pct_electric,
      unit: "%",
      thresholds: adaptiveCapacityMetadata.pct_electric?.thresholds || {low: [0], mid: [50], high: [80]},
      isInverse: false
    },
    {
      key: "min_to_cities",
      label: _lang({en: "Healthcare Access", fr: "Accès aux soins de santé"}),
      value: data.min_to_cities,
      unit: " min",
      thresholds: adaptiveCapacityMetadata.min_to_cities?.thresholds || {low: [0], mid: [30], high: [60]},
      isInverse: true
    },
    {
      key: "inet_d_kbps", 
      label: _lang({en: "Internet Speed", fr: "Vitesse Internet"}),
      value: data.inet_d_kbps,
      unit: " kbps",
      thresholds: adaptiveCapacityMetadata.inet_d_kbps?.thresholds || {low: [0], mid: [1024], high: [4096]},
      isInverse: false
    },
    {
      key: "pct_piped_water",
      label: _lang({en: "Credit", fr: "Crédit"}),
      value: data.pct_piped_water,
      unit: "%",
      thresholds: adaptiveCapacityMetadata.pct_piped_water?.thresholds || {low: [0], mid: [50], high: [80]},
      isInverse: false
    },
    {
      key: "conflict_density",
      label: _lang({en: "Market Access", fr: "Accès au marché"}),
      value: data.conflict_density,
      unit: "",
      thresholds: adaptiveCapacityMetadata.conflict_density?.thresholds || {low: [0], mid: [0.005], high: [0.01]},
      isInverse: true
    }
  ];

  // Format indicators with thresholds
  const thresholdIndicators = indicators.map(indicator => {
    const level = getThresholdLevel(indicator.value, indicator.thresholds, indicator.isInverse);
    const value = typeof indicator.value === 'number' ? indicator.value : 0;
    const formattedValue = value < 1 ? value.toFixed(3) : value.toFixed(1);
    return `${indicator.label}: ${formattedValue}${indicator.unit} (${level})`;
  });
    
  // Identify limiting factors based on the exact format specified
  const limitingFactors = [];
    
  // Use the actual metadata for each indicator
  const indicatorChecks = [
    {
      key: "pct_no_electric",
      label: _lang({en: "Electricity access", fr: "Accès à l'électricité"}),
      value: typeof data.pct_no_electric === 'number' ? data.pct_no_electric : 0,
      metadata: adaptiveCapacityMetadata.pct_no_electric,
      format: (v) => `${(100-v).toFixed(1)}%`, // Convert to access percentage
      isLimiting: (level) => level === _lang({en: "low", fr: "faible"})
    },
    {
      key: "min_to_cities", 
      label: _lang({en: "Healthcare access", fr: "Accès aux soins de santé"}),
      value: typeof data.min_to_cities === 'number' ? data.min_to_cities : 0,
      metadata: adaptiveCapacityMetadata.min_to_cities,
      format: (v) => `${v.toFixed(0)} min`,
      isLimiting: (level) => level === _lang({en: "low", fr: "faible"})
    },
    {
      key: "inet_d_kbps",
      label: _lang({en: "Internet speed", fr: "Vitesse Internet"}),
      value: typeof data.inet_d_kbps === 'number' ? data.inet_d_kbps : 0,
      metadata: adaptiveCapacityMetadata.inet_d_kbps,
      format: (v) => `${(v/1000).toFixed(1)} Mbps`,
      isLimiting: (level) => level === _lang({en: "low", fr: "faible"})
    },
    {
      key: "pct_piped_water",
      label: _lang({en: "Credit access", fr: "Accès au crédit"}),
      value: typeof data.pct_piped_water === 'number' ? data.pct_piped_water : 0,
      metadata: adaptiveCapacityMetadata.pct_piped_water,
      format: (v) => `${v.toFixed(0)}%`,
      isLimiting: (level) => level === _lang({en: "low", fr: "faible"})
    },
    {
      key: "conflict_density",
      label: _lang({en: "Market access", fr: "Accès au marché"}),
      value: typeof data.conflict_density === 'number' ? data.conflict_density : 0,
      metadata: adaptiveCapacityMetadata.conflict_density,
      format: (v) => `${(v * 1000).toFixed(1)} per 1000 km²`,
      isLimiting: (level) => level === _lang({en: "high", fr: "élevé"})
    }
  ];

  // Check each indicator and add to limiting factors if applicable
  indicatorChecks.forEach(indicator => {
    if (indicator.metadata) {
      const level = getThresholdLevel(indicator.value, indicator.metadata.thresholds, indicator.metadata.inverse[0]);
      if (indicator.isLimiting(level)) {
        const formattedValue = indicator.format(indicator.value);
    limitingFactors.push(_lang({
          en: `${indicator.label}: ${formattedValue} (${level})`,
          fr: `${indicator.label}: ${formattedValue} (${level})`
    }));
  }
    }
  });
  
  // Generate insight text in the exact format specified
  const limitationLevel = limitingFactors.length > 2 ? 
    _lang({en: "significantly limited", fr: "significativement limitée"}) :
    limitingFactors.length > 0 ? 
    _lang({en: "limited", fr: "limitée"}) :
    _lang({en: "strong", fr: "forte"});
    
  // Format factors as HTML list
  const factorsList = limitingFactors.length > 0 ? 
    limitingFactors.map(factor => htl.html`<li>${factor}</li>`) :
    [htl.html`<li>${_lang({en: "Strong infrastructure and services", fr: "Infrastructure et services solides"})}</li>`];
    
  const recommendation = limitingFactors.length > 0 ?
    _lang({en: "Addressing these can improve resilience.", fr: "Traiter ces problèmes peut améliorer la résilience."}) :
    _lang({en: "Continue strengthening these systems.", fr: "Continuer à renforcer ces systèmes."});
    
  const insight = htl.html`<div>
    <p>${_lang({
      en: `In ${region}, adaptive capacity is ${limitationLevel} by:`,
      fr: `En ${region}, la capacité d'adaptation est ${limitationLevel} par :`
    })}</p>
    <ul>${factorsList}</ul>
    <p>${recommendation}</p>
  </div>`;
    
  return createInsightDisplay(insight);

}
```

