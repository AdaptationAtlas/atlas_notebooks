---
module: "Adaptive Capacity Section"
nb-authors:
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
adaptiveCapacityQuestion = _lang(
  vulnerability_translations.adaptive_capacity_question,
);
```

# `{ojs} adaptiveCapacityQuestion` {#adaptive-capacity}

`{ojs} _lang(vulnerability_translations.adaptive_capacity_description)`

```{ojs}
adaptiveCapacityControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${admin012Form(masterLanguage.key)}</div>
  </div>
</div>
`;
```

```{ojs}
adaptiveCapacityRawData = {

  const a0 = admin0Select?.admin0_name;
  // pretty basic query but i need to return the country + admins
  // SSA needs to be inclided as 'parent' when admin0 is selected
  const admin = a0 ? `admin0_name in ('${a0}', 'SSA')` : `admin1_name IS NULL`;

  const resp = await localDb.query(`
    SELECT *
    FROM enabling
    WHERE ${admin}
  `);
  return resp;
}
```

```{ojs}
// Load metadata with caching
adaptiveCapacityMetadata = await loadDataWithCache(
  "adaptiveCapacityMetadata",
  async () => {
    return await FileAttachment(
      "/data/vulnerability_notebook/enabling_vars_metadata.json",
    ).json();
  },
);
```

```{ojs}
// Shared indicator definitions for plots and insights
adaptiveCapacityIndicators = [
  {
    key: "pct_electric_norm",
    rawKey: "pct_electric",
    label: _lang({ en: "Electricity Access", fr: "Accès à l'électricité" }),
    unit: "%",
  },
  {
    key: "pct_piped_water_norm",
    rawKey: "pct_piped_water",
    label: _lang({ en: "Piped Water Access", fr: "Accès à l'eau courante" }),
    unit: "%",
  },
  {
    key: "min_to_cities_norm",
    rawKey: "min_to_cities",
    label: _lang({
      en: "Distance to Market",
      fr: "Temps de trajet vers les villes",
    }),
    unit: " min.",
  },
  {
    key: "pct_cellphone_norm",
    rawKey: "pct_cellphone",
    label: _lang({
      en: "Cellphone Access",
      fr: "Accès au téléphone portable",
    }),
    unit: "%",
  },
  {
    key: "conflict_density_norm",
    rawKey: "conflict_density",
    label: _lang({ en: "Conflict Density", fr: "Densité de conflit" }),
    unit: " count/km²",
  },
];
```

```{ojs}
// Get current admin selections (same variable names as sensitivity section)
adaptiveCapacityAdminSelections = {
  return {
    selectAdmin0: admin0Select?.admin0_name || null,
    selectAdmin1: admin1Select?.admin1_name || null,
    selectAdmin2: admin2Select?.admin2_name || null
  }
}
```

```{ojs}
// Helper function to get current region name (uses shared utility)
getAdaptiveCapacityRegion = () => {
  return getAdminSelection(
    { value: admin0Select?.admin0_name },
    { value: admin1Select?.admin1_name },
    { value: admin2Select?.admin2_name },
  );
};
```

```{ojs}
{
  let data = adaptiveCapacityRawData;
  const selections = adaptiveCapacityAdminSelections;
  const isSSA = selections.selectAdmin0 === "SSA" || !selections.selectAdmin0;
  // Data for the blue bar - the lowest selected region
  let region_data = data.filter(
    (d) =>
      d.admin0_name === (selections.selectAdmin0 || "SSA") &&
      d.admin1_name === selections.selectAdmin1 &&
      d.admin2_name === selections.selectAdmin2,
  );
  
  let region_name = getAdminNameString();

  // Data for the grey bar which is the parent
  // eg. region = AGO so parent = SSA or region = nairobi so parent = kenya
  let parent_data = [];
  let parent_name = "";

  if (!selections.selectAdmin0) {
    console.log("No admin0 selected");
    // Top-level (SSA selected so no parent data is returned)
    parent_data = [];
  } else if (!selections.selectAdmin1) {
    console.log("No admin1 selected");
    // admin0 selected but no admin1 so parent = SSA
    parent_data = data.filter((d) => d.admin0_name === "SSA");
    parent_name = "SSA";
  } else if (!selections.selectAdmin2) {
    // admin1 selected but no admin2 so parent = admin0 selection
    parent_data = data.filter(
      (d) => d.admin0_name === selections.selectAdmin0 && !d.admin1_name,
    );
    parent_name = selections.selectAdmin0;
  } else {
    // admin2 selected so parent = admin1 selected
    parent_data = data.filter(
      (d) =>
        d.admin0_name === selections.selectAdmin0 &&
        d.admin1_name === selections.selectAdmin1 &&
        !d.admin2_name,
    );
    parent_name = selections.selectAdmin1;
  }

  const indicators = adaptiveCapacityIndicators;

  const chartData = indicators.map((indicator) => {
    // Get normalized value (0-1 scale, high = good)
    // Check if region_data has elements before accessing [0]
    const region_normalizedValue = region_data.length > 0 
      ? (region_data[0]?.[indicator.key] || null)
      : null;
    const parent_normalizedValue = parent_data.length > 0
      ? (parent_data[0]?.[indicator.key] || null)
      : null;
    // Get original value for tooltips
    const region_rawValue = region_data.length > 0
      ? (region_data[0]?.[indicator.rawKey] || null)
      : null;
    const parent_rawValue = parent_data.length > 0
      ? (parent_data[0]?.[indicator.rawKey] || null)
      : null;

    return {
      indicator: indicator.label,
      region_normalizedValue, // Use normalized value for chart
      region_rawValue, // Keep original for tooltips
      parent_normalizedValue,
      parent_rawValue,
      unit: indicator.unit,
    };
  });

  // const sortedData = chartData.sort((a, b) => b.value - a.value);
  // sort alphabetically so consistent between selections to allow easy comparisons
  const sortedData = chartData.sort((a, b) => a.indicator.localeCompare(b.indicator));

  const maxValue = 1.0; // Technically some values pass this, but in general this should be max
  
  const plot_channels = {
    [_lang({en: `${region_name} Value`, fr: "Valeur de la région sélectionnée"})]:
      d => d.region_rawValue == null
        ? null // 0 is meaningful so this stays null
        : Number(d.region_rawValue).toFixed(1) + (d.unit || "")
  };

  if (!isSSA) {
    plot_channels[_lang({en: `${parent_name} Value`, fr: "Moyenne régionale"})] =
      d => d.parent_rawValue == null
        ? null // 0 is meaningful so this stays null
        : Number(d.parent_rawValue).toFixed(1) + (d.unit || "")
  };

  const plot =  Plot.plot({
    width, // Full width
    height: 400,
    marginLeft: 160, // Reduced for better space utilization
    marginRight: 40, // Reduced for better space utilization
    marginTop: 10, // Reduced white space
    marginBottom: 40, // Reduced white space
    color: {
      legend: !isSSA, // Only show legend if not SSA
      domain: [
        _lang({en: `${region_name} Value`, fr: `${region_name} Value`}),
        _lang({en: `${parent_name} Value`, fr: "Moyenne régionale"})
      ],
      range: ["#4a90e2", "#e5e5e5"]
    },
    x: {
      label: _lang({en: "Ability to Adapt", fr: "Niveau de performance"}),
      labelAnchor: "center",
      labelOffset: 30,
      domain: [0, maxValue], // Normalized scale 0-1
      tickFormat: (d) => (d === 0 ? _lang({en: "Low", fr: "Faible"}) : d === 1 ? _lang({en: "High", fr: "Élevé"}) : ""),
      ticks: [0, 0.5, 1.0],
      tickSize: 4,
      labelFontSize: 12,
      labelFontWeight: "600"
    },
    y: {
      label: null, // Remove y-axis label to save space
      tickSize: 0,
      grid: true,
      // domain: sortedData.map(d => d.indicator) // Only show indicators with data
    },

    marks: [
      // Regional average bars (light gray background) - full width
      Plot.barX(sortedData, {
        x: "parent_normalizedValue",
        y: "indicator",
        fill: "#e5e5e5",
        opacity: 0.7
      }),
      
      // Actual value bars (blue bars) - narrower using inset
      
      Plot.barX(sortedData, {
        x: "region_normalizedValue", 
        y: "indicator",
        fill: "#4a90e2",
        insetTop: 15, // Make bars narrower
        insetBottom: 15, 
        channels: plot_channels,
        tip: {
          format: {
            x: false
          }
        }
      })
    ]
  });

  return plot;
}
```

```{ojs}
// Download functionality
downloadButton(
  adaptiveCapacityRawData,
  `adaptive_capacity_data_${getAdminNameString().replace(", ", "_")}`,
  _lang(vulnerability_translations.download_data),
);
```

```{ojs}
// Dynamic Insights following wireframe template
adaptiveCapacityInsights = {

  const selections = adaptiveCapacityAdminSelections;
  let data = adaptiveCapacityRawData;

  if (!selections.selectAdmin0) {
    data = data.filter(d => d.admin0_name === "SSA" || !d.admin0_name);
  } else if (!selections.selectAdmin1) {
    data = data.filter(d => d.admin0_name === selections.selectAdmin0);
  } else if (!selections.selectAdmin2) {
    data = data.filter(d => 
      d.admin0_name === selections.selectAdmin0 && 
      d.admin1_name === selections.selectAdmin1
    );
  } else {
    data = data.filter(d => 
      d.admin0_name === selections.selectAdmin0 && 
      d.admin1_name === selections.selectAdmin1 && 
      d.admin2_name === selections.selectAdmin2
    );
  }
  const region = getAdminNameString();
    
  const indicators = adaptiveCapacityIndicators.map((indicator) => ({
    ...indicator,
    originalValue: data[indicator.rawKey],
    normalizedValue: data[indicator.key],
  }));

  // Format indicators with performance levels based on normalized values
  const thresholdIndicators = indicators.map(indicator => {
    const normalizedValue = typeof indicator.normalizedValue === 'number' ? indicator.normalizedValue : 0;
    const originalValue = typeof indicator.originalValue === 'number' ? indicator.originalValue : 0;
    
    // Determine performance level based on normalized value (0-1 scale)
    let level;
    if (normalizedValue >= 0.8) {
      level = _lang({en: "high", fr: "élevé"});
    } else if (normalizedValue >= 0.5) {
      level = _lang({en: "moderate", fr: "modéré"});
    } else {
      level = _lang({en: "low", fr: "faible"});
    }
    
    const numValue = Number(originalValue) || 0;
    const formattedValue = numValue < 1 ? numValue.toFixed(3) : numValue.toFixed(1);
    return `${indicator.label}: ${formattedValue}${indicator.unit} (${level})`;
  });
    
  // Identify limiting factors based on the exact format specified
  const limitingFactors = [];
    
  // Check each indicator for limiting factors using normalized values
  const limitFormatters = {
    pct_electric: (v) => `${v.toFixed(1)}%`,
    min_to_cities: (v) => `${v.toFixed(0)} min`,
    inet_d_kbps: (v) => `${(v / 1000).toFixed(1)} Mbps`,
    pct_piped_water: (v) => `${v.toFixed(0)}%`,
    pct_cellphone: (v) => `${v.toFixed(0)}%`,
    conflict_density: (v) => `${(v * 1000).toFixed(1)} per 1000 km²`,
  };

  indicators.forEach((indicator) => {
    const normalizedValue =
      typeof indicator.normalizedValue === "number"
        ? indicator.normalizedValue
        : 0;
    const originalValue =
      typeof indicator.originalValue === "number"
        ? indicator.originalValue
        : 0;

    if (normalizedValue >= 0.5) return;

    const numValue = Number(originalValue) || 0;
    const formatter = limitFormatters[indicator.rawKey];
    const formattedValue = formatter
      ? formatter(numValue)
      : `${numValue.toFixed(1)}${indicator.unit}`;

    limitingFactors.push(`${indicator.label} (${formattedValue})`);
  });

  
  // Generate insight text in the exact format specified
  const limitationLevel = limitingFactors.length > 2 ? 
    _lang({en: "significantly limited", fr: "significativement limitée"}) :
    limitingFactors.length > 0 ? 
    _lang({en: "limited", fr: "limitée"}) :
    _lang({en: "strong", fr: "forte"});
    
  // Format factors as HTML list
  const factorsList = limitingFactors.length > 0 ? 
    limitingFactors.map(factor => htl.html`<li>${factor}</li>`) :
    [htl.html`<li>${_lang({en: "Strong infrastructure and services", fr: "Infrastructure et services solides"})}</li>`];
    
  const recommendation = limitingFactors.length > 0 ?
    _lang({en: "Addressing these can improve resilience.", fr: "Traiter ces problèmes peut améliorer la résilience."}) :
    _lang({en: "Continue strengthening these systems.", fr: "Continuer à renforcer ces systèmes."});
    
  const insight = htl.html`<div>
    <p>${_lang({
      en: `In ${region}, adaptive capacity is ${limitationLevel} by:`,
      fr: `En ${region}, la capacité d'adaptation est ${limitationLevel} par :`
    })}</p>
    <ul>${factorsList}</ul>
    <p>${recommendation}</p>
  </div>`;
    
  return createInsightDisplay(insight);
}
```
