---
pagetitle: "Adaptive Capacity Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: '2025-02-19'
date-edited: today
css: styles.css
---

```{ojs}
adaptiveCapacityQuestion = _lang(vulnerability_translations.adaptive_capacity_question)
```

# `{ojs} adaptiveCapacityQuestion ` {#adaptive-capacity}

`{ojs} _lang(vulnerability_translations.adaptive_capacity_description)`

```{ojs}
// Controls section
adaptiveCapacityControlsForm = {
  const adminInputs = [
    Inputs.select(dataAdmin0, { 
      label: adminRegions.labels.admin0, 
      format: x => x.label,
      value: dataAdmin0[0]
    }),
    Inputs.select(dataAdmin1, { 
      label: adminRegions.labels.admin1, 
      format: x => x.label,
      value: dataAdmin1[0]
    }),
    Inputs.select(dataAdmin2, { 
      label: adminRegions.labels.admin2, 
      format: x => x.label,
      value: dataAdmin2[0]
    })
  ];

  const optionInputs = [
    Inputs.select(genderOptions, {
      label: _lang(vulnerability_translations.gender_filter),
      format: d => d.label,
      value: genderOptions[0]
    }),
    Inputs.toggle({
      label: _lang(vulnerability_translations.sort_by_gap),
      value: false
    })
  ];

  return htl.html`${adminFormTemplate(adminInputs)}${controlsFormTemplate(optionInputs)}`;
}
```

```{ojs}
// Load adaptive capacity metadata and data
adaptiveCapacityMetadata = await FileAttachment("/data/vulnerability_notebook/enabling_vars_metadata.json").json()

// Process data for selected region
adaptiveCapacityData = {
  const metadata = adaptiveCapacityMetadata;
  const sampleData = metadata.sample_data;
  
  // Get data for current selection
  const region = getAdminSelection();
  let regionData;
  
  // For prototype, use sample data mapping
  if (selectedAdmin0 === "Kenya") {
    regionData = sampleData.Kenya;
  } else if (selectedAdmin0 === "Ethiopia") {
    regionData = sampleData.Ethiopia;
  } else if (selectedAdmin0 === "Nigeria") {
    regionData = sampleData.Nigeria;
  } else {
    // Use Kenya as default for SSA-level view
    regionData = sampleData.Kenya;
  }
  
  if (!regionData) return [];
  
  // Transform data into chart format
  const variables = Object.keys(metadata.variables);
  
  return variables.map(varKey => {
    const varMeta = metadata.variables[varKey];
    const varData = regionData[varKey];
    
    if (!varData) return null;
    
    // Calculate gap to target
    const gapToTarget = Math.max(0, varMeta.sdg_target - varData.value);
    const gapPercent = (gapToTarget / varMeta.sdg_target) * 100;
    
    // Determine threshold category
    let category = 'low';
    if (varData.value >= varMeta.threshold_high) category = 'high';
    else if (varData.value >= varMeta.threshold_mid) category = 'mid';
    
    return {
      variable: varKey,
      label: varMeta.label[_lang.key] || varMeta.label.en,
      value: varData.value,
      regional_avg: varData.regional_avg,
      sdg_target: varMeta.sdg_target,
      gap_to_target: gapToTarget,
      gap_percent: gapPercent,
      category,
      unit: varMeta.unit,
      description: varMeta.description[_lang.key] || varMeta.description.en,
      source: varMeta.source,
      higher_is_better: varMeta.higher_is_better
    };
  }).filter(d => d !== null);
}
```

```{ojs}
// Sort and filter data
processedAdaptiveCapacityData = {
  let data = [...adaptiveCapacityData];
  
  // Sort data
  if (sortByGap) {
    data.sort((a, b) => b.gap_percent - a.gap_percent);
  } else {
    data.sort((a, b) => b.value - a.value);
  }
  
  return data;
}
```

```{ojs}
// Adaptive capacity visualization
adaptiveCapacityChart = {
  if (!processedAdaptiveCapacityData || processedAdaptiveCapacityData.length === 0) {
    return createNoDataState(_lang(vulnerability_translations.no_data_available));
  }

  const data = processedAdaptiveCapacityData;
  const width = mapWidth;
  const height = data.length * 80 + 100;
  const marginTop = 40;
  const marginRight = 120;
  const marginBottom = 40;
  const marginLeft = 200;

  // Create scales
  const maxValue = d3.max(data, d => Math.max(d.value, d.regional_avg, d.sdg_target));
  const xScale = d3.scaleLinear()
    .domain([0, maxValue * 1.1])
    .range([marginLeft, width - marginRight]);

  const yScale = d3.scaleBand()
    .domain(data.map(d => d.variable))
    .range([marginTop, height - marginBottom])
    .padding(0.2);

  // Color scale for categories
  const colorScale = d3.scaleOrdinal()
    .domain(['low', 'mid', 'high'])
    .range(['#ef4444', '#f59e0b', '#10b981']);

  const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .style("font", "12px sans-serif");

  // Add background bars for SDG targets
  svg.selectAll(".target-bar")
    .data(data)
    .join("rect")
    .attr("class", "target-bar")
    .attr("x", marginLeft)
    .attr("y", d => yScale(d.variable))
    .attr("width", d => xScale(d.sdg_target) - marginLeft)
    .attr("height", yScale.bandwidth())
    .attr("fill", "#f3f4f6")
    .attr("stroke", "#e5e7eb");

  // Add regional average indicators
  svg.selectAll(".regional-avg")
    .data(data)
    .join("line")
    .attr("class", "regional-avg")
    .attr("x1", d => xScale(d.regional_avg))
    .attr("x2", d => xScale(d.regional_avg))
    .attr("y1", d => yScale(d.variable))
    .attr("y2", d => yScale(d.variable) + yScale.bandwidth())
    .attr("stroke", "#6b7280")
    .attr("stroke-width", 2)
    .attr("stroke-dasharray", "3,3");

  // Add value bars
  svg.selectAll(".value-bar")
    .data(data)
    .join("rect")
    .attr("class", "value-bar")
    .attr("x", marginLeft)
    .attr("y", d => yScale(d.variable) + yScale.bandwidth() * 0.2)
    .attr("width", d => Math.max(0, xScale(d.value) - marginLeft))
    .attr("height", yScale.bandwidth() * 0.6)
    .attr("fill", d => colorScale(d.category))
    .attr("opacity", 0.8);

  // Add variable labels
  svg.selectAll(".variable-label")
    .data(data)
    .join("text")
    .attr("class", "variable-label")
    .attr("x", marginLeft - 10)
    .attr("y", d => yScale(d.variable) + yScale.bandwidth() / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", "end")
    .attr("font-size", "11px")
    .attr("font-weight", "500")
    .text(d => d.label);

  // Add value labels
  svg.selectAll(".value-label")
    .data(data)
    .join("text")
    .attr("class", "value-label")
    .attr("x", d => xScale(d.value) + 5)
    .attr("y", d => yScale(d.variable) + yScale.bandwidth() / 2)
    .attr("dy", "0.35em")
    .attr("font-size", "10px")
    .attr("font-weight", "600")
    .text(d => {
      if (d.unit === "percentage") return `${d.value.toFixed(1)}%`;
      if (d.unit === "index") return d.value.toFixed(2);
      return d.value.toFixed(1);
    });

  // Add x-axis
  const xAxis = d3.axisBottom(xScale)
    .ticks(5)
    .tickFormat(d => {
      if (d >= 1000) return d3.format(".1s")(d);
      return d.toFixed(0);
    });

  svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(xAxis);

  // Add legend
  const legend = svg.append("g")
    .attr("transform", `translate(${width - marginRight + 10}, ${marginTop})`);

  const legendData = [
    { label: _lang({en: "Low Performance", fr: "Performance faible"}), color: "#ef4444" },
    { label: _lang({en: "Medium Performance", fr: "Performance moyenne"}), color: "#f59e0b" },
    { label: _lang({en: "High Performance", fr: "Performance élevée"}), color: "#10b981" },
    { label: _lang({en: "Regional Average", fr: "Moyenne régionale"}), color: "#6b7280", dashed: true },
    { label: _lang({en: "SDG Target", fr: "Objectif ODD"}), color: "#f3f4f6", stroke: "#e5e7eb" }
  ];

  legend.selectAll(".legend-item")
    .data(legendData)
    .join("g")
    .attr("class", "legend-item")
    .attr("transform", (d, i) => `translate(0, ${i * 20})`)
    .each(function(d) {
      const g = d3.select(this);
      
      if (d.dashed) {
        g.append("line")
          .attr("x1", 0)
          .attr("x2", 15)
          .attr("y1", 5)
          .attr("y2", 5)
          .attr("stroke", d.color)
          .attr("stroke-width", 2)
          .attr("stroke-dasharray", "3,3");
      } else {
        g.append("rect")
          .attr("width", 15)
          .attr("height", 10)
          .attr("fill", d.color)
          .attr("stroke", d.stroke || "none");
      }
      
      g.append("text")
        .attr("x", 20)
        .attr("y", 8)
        .attr("font-size", "10px")
        .text(d.label);
    });

  // Add tooltips
  svg.selectAll(".value-bar")
    .append("title")
    .text(d => {
      const gapText = _lang({en: "Gap to target", fr: "Écart à l'objectif"});
      const valueText = _lang({en: "Current value", fr: "Valeur actuelle"});
      const avgText = _lang({en: "Regional average", fr: "Moyenne régionale"});
      const targetText = _lang({en: "SDG target", fr: "Objectif ODD"});
      
      return `${d.label}\n${valueText}: ${d.value.toFixed(1)}\n${avgText}: ${d.regional_avg.toFixed(1)}\n${targetText}: ${d.sdg_target}\n${gapText}: ${d.gap_percent.toFixed(1)}%`;
    });

  return svg.node();
}

adaptiveCapacityVisualization = {
  const chart = adaptiveCapacityChart;
  
  return htl.html`
    <div style="
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 20px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 16px 0;
    ">
      <div style="margin-bottom: 16px;">
        <h4 style="margin: 0 0 8px 0; font-size: 16px; font-weight: 600;">
          ${_lang({en: "Adaptive Capacity Indicators", fr: "Indicateurs de capacité d'adaptation"})}
        </h4>
        <p style="margin: 0; font-size: 14px; color: #6b7280;">
          ${_lang({en: "Gray bars show SDG targets, dashed lines show regional averages, colored bars show current performance.", fr: "Les barres grises montrent les objectifs ODD, les lignes pointillées montrent les moyennes régionales, les barres colorées montrent les performances actuelles."})}
        </p>
      </div>
      ${chart}
    </div>
  `;
}
```

```{ojs}
// Download functionality
adaptiveCapacityDownloadButton = {
  if (!processedAdaptiveCapacityData || processedAdaptiveCapacityData.length === 0) {
    return htl.html``;
  }
  
  return downloadButton(
    processedAdaptiveCapacityData, 
    `adaptive_capacity_${getAdminSelection().replace(/\s+/g, '_')}`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic insights
adaptiveCapacityInsights = {
  if (!processedAdaptiveCapacityData || processedAdaptiveCapacityData.length === 0) {
    return createNoDataState();
  }

  // Find factors with largest gaps
  const sortedByGap = [...processedAdaptiveCapacityData]
    .sort((a, b) => b.gap_percent - a.gap_percent)
    .slice(0, 3);
  
  const region = getAdminSelection();
  const factors = sortedByGap.map(d => d.label).join(", ");
  const lowestFactor = sortedByGap[0].label;
  
  const template = _lang(vulnerability_translations.adaptive_capacity_insight_template);
  const replacements = [
    { name: "region", value: region },
    { name: "factors", value: factors },
    { name: "lowest_factor", value: lowestFactor }
  ];
  
  const insight = generateInsight(template, replacements);
  return createInsightDisplay(insight);
}
```

```{ojs}
// Display components
adaptiveCapacityControlsForm
adaptiveCapacityVisualization
adaptiveCapacityDownloadButton
adaptiveCapacityInsights
```
