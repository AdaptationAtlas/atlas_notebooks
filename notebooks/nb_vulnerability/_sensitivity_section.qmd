---
pagetitle: "Sensitivity Section"
nb-authors:
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: "2025-02-19"
date-edited: today
css: styles.css
---

```{ojs}
sensitivityQuestion = _lang(vulnerability_translations.sensitivity_question);
```

# `{ojs} sensitivityQuestion` {#sensitivity}

`{ojs} _lang(vulnerability_translations.sensitivity_description)`

```{ojs}
// Sensitivity section selectors - follow shared state
viewof sensitivityAdmin0 = Inputs.select(dataAdmin0, {
  label: adminRegions.labels.admin0, 
  format: x => x.label,
  value: dataAdmin0.find(d => d.value === sharedAdmin0) || (dataAdmin0.length > 0 ? dataAdmin0[0] : null)
})
viewof sensitivityAdmin1 = Inputs.select(dataAdmin1, {
  label: adminRegions.labels.admin1, 
  format: x => x.label,
  value: dataAdmin1.find(d => d.value === sharedAdmin1) || (dataAdmin1.length > 0 ? dataAdmin1[0] : null)
})
viewof sensitivityAdmin2 = Inputs.select(dataAdmin2, {
  label: adminRegions.labels.admin2, 
  format: x => x.label,
  value: dataAdmin2.find(d => d.value === sharedAdmin2) || (dataAdmin2.length > 0 ? dataAdmin2[0] : null)
})
```

```{ojs}
sensitivityControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof sensitivityAdmin0}</div>
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof sensitivityAdmin1}</div>
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${viewof sensitivityAdmin2}</div>
  </div>
</div>
`
```

```{ojs}
// Load icicle metadata and data with caching
icicleKeys = await loadDataWithCache("icicleKeys", async () => {
  return await FileAttachment(
    "/data/vulnerability_notebook/vulnerability_iciclekeys.json",
  ).json();
});
```

```{ojs}
// Load data with caching - using parquet via DuckDB
csv_raw = await loadDataWithCache("sensitivityData", async () => {
  const db = await DuckDBClient.of({
    vulnerability_icicle: FileAttachment(
      "/data/vulnerability_notebook/vulnerability_icicledata_updated.parquet",
    ),
  });
  const data = await db.query("SELECT * FROM vulnerability_icicle");

  // Convert to the expected format: array of arrays [admin0, admin1, admin2, path, value]
  // The parquet should have columns: admin0_name, admin1_name, admin2_name, path, value
  return data
    .filter((d) => d.path != null && d.path !== "")
    .map((d) => {
      // Convert null values to "NA" string to match CSV format
      const admin0 = d.admin0_name || "SSA";
      const admin1 = d.admin1_name || "NA";
      const admin2 = d.admin2_name || "NA";

      return [admin0, admin1, admin2, d.path, d.value || 0];
    });
});
```

```{ojs}
breadcrumbWidth = 200;
breadcrumbHeight = 35;
targetHeight = 425;
height = narrow ? narrowHeight : targetHeight;
narrowHeight = 600;
narrow = width <= 0;
segmentX = (d) => (narrow ? d.y0 : d.x0);
segmentY = (d) => (narrow ? d.x0 : d.y0);
segmentWidth = (d) => (narrow ? d.y1 - d.y0 : d.x1 - d.x0);
segmentHeight = (d) => (narrow ? d.x1 - d.x0 : d.y1 - d.y0);
```

```{ojs}
partition = (data, order = null) =>
  d3
    .partition()
    .padding(1)
    .size(narrow ? [height, width] : [width, height])(
    d3
      .hierarchy(data)
      .sum((d) => d.value)
      .sort((a, b) => {
        if (order) {
          // Look up indices, fallback to 999 if not defined
          return (order[a.data.name] ?? 999) - (order[b.data.name] ?? 999);
        }
        return b.value - a.value;
      }),
  );
```

```{ojs}
function buildHierarchy(csv) {
  // Helper function that transforms the given CSV into a hierarchical format.
  // Skip the population level and start directly with demographic categories
  const root = { name: "root", children: [] };
  for (let i = 0; i < csv.length; i++) {
    const sequence = csv[i][0];
    const size = +csv[i][1];
    // Skip invalid rows
    if (!sequence || isNaN(size)) {
      continue;
    }
    const parts = sequence.split("_");
    let currentNode = root;
    // Skip the first part (population) and start from the second part
    for (let j = 1; j < parts.length; j++) {
      const children = currentNode["children"];
      const nodeName = parts[j];
      let childNode = null;
      let foundChild = false;
      // Search for existing child with the same name
      for (let k = 0; k < children.length; k++) {
        if (children[k]["name"] === nodeName) {
          childNode = children[k];
          foundChild = true;
          break;
        }
      }
      // If not found, create a new child node
      if (!foundChild) {
        childNode = { name: nodeName, children: [] };
        children.push(childNode);
      }
      currentNode = childNode;
      // If it's the last part of the sequence, create a leaf node
      if (j === parts.length - 1) {
        childNode.value = size;
      }
    }
  }
  return root;
}
```

```{ojs}
csv = {
  // Check if csv_raw exists and is an array before processing
  if (!csv_raw || !Array.isArray(csv_raw) || csv_raw.length === 0) {
    return [];
  }
  
  if (!sensitivityAdmin0.value) {
    // No admin selection - use SSA data
    return csv_raw
      .filter(
        (item) => item && item[0] === "SSA" && item[1] === "NA" && item[2] === "NA" && item[3]
      )
      .map((item) => [item[3], item[4]]);
  } else if (!sensitivityAdmin1.value) {
    return csv_raw
      .filter(
        (item) => item && item[0] === sensitivityAdmin0.value && item[1] === "NA" && item[2] === "NA" && item[3]
      )
      .map((item) => [item[3], item[4]]);
  } else if (sensitivityAdmin1.value && !sensitivityAdmin2.value) {
    return csv_raw
      .filter(
        (item) => item && item[0] === sensitivityAdmin0.value && item[1] === sensitivityAdmin1.value && item[2] === "NA" && item[3]
      )
      .map((item) => [item[3], item[4]]);
  } else if (sensitivityAdmin1.value !== null && sensitivityAdmin2.value !== null) {
    return csv_raw
      .filter(
        (item) =>
          item && item[0] === sensitivityAdmin0.value && item[1] === sensitivityAdmin1.value && item[2] === sensitivityAdmin2.value && item[3]
      )
      .map((item) => [item[3], item[4]]);
  }
  return [];
}
```

```{ojs}
data = buildHierarchy(csv)

// Create percentage table for insights
icicle_pct_table = {
  if (!csv || csv.length === 0) return [];
  
  // A little function to basically calculate the same thing as the breadcrumb but for all the admin region.
  // This is what users should see if going to a tabular view and also what they should download. It is much easier to understand and work with.
  const summarize_icicle = (csv, icicle_keys = null) => {
    const rows = csv.map(([key, val]) => ({
      parts: key.split("_").slice(1),
      value: +val
    }));
    const total = d3.sum(rows, (d) => d.value);

    const maxDepth = Math.max(...rows.map((r) => r.parts.length));
    const levelNames = icicle_keys
      ? Object.keys(icicle_keys)
      : [...Array(maxDepth).keys()].map((i) => `level${i + 1}`);

    const lookupName = (dim, key) => {
      if (!icicle_keys) return key;
      return icicle_keys[dim]?.[key]?.[0] ?? key;
    };

    const genderTotals = {};
    rows.forEach((r) => {
      const gender = r.parts[0];
      genderTotals[gender] = (genderTotals[gender] || 0) + r.value;
    });

    // Recursive helper
    const recurse = (rows, depth = 0, prefix = []) => {
      if (!rows.length) return [];
      if (depth >= maxDepth) return [];

      return d3
        .rollups(
          rows,
          (v) => d3.sum(v, (d) => d.value),
          (d) => d.parts[depth]
        )
        .flatMap(([k, sum]) => {
          const current = [...prefix, k];
          const rowObj = {};
          levelNames.forEach((col, i) => {
            rowObj[col] = current[i] ? lookupName(col, current[i]) : null;
          });
          rowObj.pct_total = (100 * sum) / total;
          // pct relative to gender
          const genderKey = prefix[0];
          if (genderKey && genderTotals[genderKey]) {
            rowObj.pct_of_gender = (100 * sum) / genderTotals[genderKey];
          }
          return [
            rowObj,
            ...recurse(
              rows.filter((r) => r.parts[depth] === k),
              depth + 1,
              current
            )
          ];
        });
    };

    return recurse(rows);
  };

  return summarize_icicle(csv, icicleKeys);
}

// Create insight data structure
icicle_insight = {
  if (!icicle_pct_table || icicle_pct_table.length === 0) return {};
  
  const round = 1;
  
  // Only sum leaf-level rows (most specific combinations) to avoid double-counting
  const leafRows = icicle_pct_table.filter(d => d.gender && d.poverty && d.education);
  
  const sum = (filter) =>
    +d3
      .sum(leafRows.filter(filter), (d) => d.pct_of_gender) // Total as % of gender not total pop
      .toFixed(round);

  // Helper function to find single value
  const find = (filter) =>
    +(icicle_pct_table.find(filter)?.pct_total || 0).toFixed(round);
  
  return {
    // Total population by gender
    male: +d3.sum(leafRows.filter(d => d.gender === "male"), d => d.pct_total).toFixed(round),
    female: +d3.sum(leafRows.filter(d => d.gender === "female"), d => d.pct_total).toFixed(round),
    
    // Education levels by gender (using pct_of_gender)
    sec_edu_m: sum((d) => d.gender === "male" && d.education === "primary"),
    sec_edu_f: sum((d) => d.gender === "female" && d.education === "primary"),
    no_edu_m: sum((d) => d.gender === "male" && d.education === "noprimary"),
    no_edu_f: sum((d) => d.gender === "female" && d.education === "noprimary"),
    
    // Poverty levels by gender (using pct_of_gender)
    high_poverty_m: sum((d) => d.gender === "male" && d.poverty === "high"),
    high_poverty_f: sum((d) => d.gender === "female" && d.poverty === "high"),
    low_poverty_m: sum((d) => d.gender === "male" && d.poverty === "low"),
    low_poverty_f: sum((d) => d.gender === "female" && d.poverty === "low"),
    
    // Most vulnerable group (high poverty + no education)
    most_vuln_m: find(
      (d) =>
        d.gender === "male" &&
        d.poverty === "high" &&
        d.education === "noprimary"
    ),
    most_vuln_f: find(
      (d) =>
        d.gender === "female" &&
        d.poverty === "high" &&
        d.education === "noprimary"
    )
  };
}
```

```{ojs}
// Generate a string that describes the points of a breadcrumb SVG polygon.
function breadcrumbPoints(d, i) {
  const tipWidth = 10;
  const points = [];
  points.push("0,0");
  points.push(`${breadcrumbWidth},0`);
  points.push(`${breadcrumbWidth + tipWidth},${breadcrumbHeight / 2}`);
  points.push(`${breadcrumbWidth},${breadcrumbHeight}`);
  points.push(`0,${breadcrumbHeight}`);
  if (i > 0) {
    // Leftmost breadcrumb; don't include 6th vertex.
    points.push(`${tipWidth},${breadcrumbHeight / 2}`);
  }
  return points.join(" ");
}
```

```{ojs}
alias = {
  const flat_alias = Object.fromEntries(
    Object.values(icicleKeys).flatMap((obj) =>
      Object.entries(obj).map(([k, v]) => [k, v[0]])
    )
  );
  flat_alias.population = "Total Population";
  return flat_alias;
}
```

```{ojs}
icicle_dict = new Object({
  gender0: { en: "Male", fr: "" },
  gender1: { en: "Female", fr: "" },
  poverty1: { en: "Low Poverty", fr: "" },
  poverty2: { en: "Moderate Poverty", fr: "" },
  poverty3: { en: "High Poverty", fr: "" },
  education3: { en: "Secondary Education", fr: "" },
  education2: { en: "Primary Education", fr: "" },
  education1: { en: "No Primary Education", fr: "" },
});

icicle_color = d3
  .scaleOrdinal()
  .domain([
    "population",
    "gender1", // female
    "gender0", // male

    "poverty1", // low poverty = good // TODO: Check the directionality of this in preprocess code
    "poverty2", // mid. poverty = mid
    "poverty3", // high poverty = bad

    "education3", // high edu. = good
    "education2", // mid. edu. = mid
    "education1", // low edu = bad
  ])
  .range([
    "#a4a4a4", // population - removed
    "#59CD90", // female - #59CD90
    "#A491D3", // male

    "#f4bb21", // low poverty = good
    "#fc8a34", // mid. poverty = mid
    "#ec5a47", // high poverty = bad

    "#f4bb21", // high edu = good
    "#fc8a34", // mid. edu = mid
    "#ec5a47", // low edu = bad
  ]);
```

```{ojs}
breadcrumb = {
  // Only show breadcrumb if there's a sequence to display
  // if (!icicle.sequence || icicle.sequence.length === 0) {
  //   return htl.html`<div style="height: ${breadcrumbHeight}px;"></div>`;
  // }

  const renderBreadcrumb = () => {
    const svg = d3
      .create("svg")
      .attr("viewBox", `0 0 ${breadcrumbWidth * 4.75} ${breadcrumbHeight}`)
      .style("font", "13px sans-serif")
      .style("margin", "2px")
      .style("display", "block");

    const g = svg
      .selectAll("g")
      .data(icicle.sequence)
      .join("g")
      .attr("transform", (d, i) => `translate(${i * breadcrumbWidth}, 0)`);

    g.append("polygon")
      .attr("points", breadcrumbPoints)
      .attr("fill", (d) => {
        return icicle_color(d.data.name)
        })
      .attr("stroke", "white");

    g.append("text")
      .attr("x", (breadcrumbWidth + 10) / 2)
      .attr("y", 15)
      .attr("dy", "0.35em")
      .attr("text-anchor", "middle")
      .attr("fill", "white")
      .attr("font-size", "12px")
      .text((d) => {
        const name = d.data.name;
        return _lang(icicle_dict[name]);
        // Default fallback - capitalize and replace underscores
        // return name.charAt(0).toUpperCase() + name.slice(1).replace(/_/g, ' ');
      });

    // Always show percentage at the end of breadcrumb when there's a sequence
    if (icicle.sequence && icicle.sequence.length > 0) {
      const percentage = Number(icicle.percentage) || 0;
      svg
        .append("text")
        .text(percentage > 0 ? percentage.toFixed(1) + "%" : "")
        .attr("x", (icicle.sequence.length + 0.25) * breadcrumbWidth)
        .attr("y", breadcrumbHeight / 2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("fill", "black")
        .attr("font-weight", "bold");
    }
    return svg.node();
  };

  return htl.html`
<div style="height: ${breadcrumbHeight + 3}px; overflow: hidden;">
    ${icicle.sequence && icicle.sequence.length > 0 
      ? renderBreadcrumb(icicle.sequence)
      : ""}
  </div>
`;
}
```

```{ojs}
viewof icicle = {
  // Show loading spinner only if data is still loading (null/undefined)
  if (csv_raw === null || csv_raw === undefined || icicleKeys === null || icicleKeys === undefined) {
    const loading = createLoadingState(_lang({en: "Loading sensitivity data...", fr: "Chargement des données de sensibilité..."}));
    const element = document.createElement('div');
    element.innerHTML = loading.outerHTML;
    element.value = { sequence: [], percentage: 0.0 };
    return element;
  }
  
  // If data is loaded but empty, show no data state
  if (!csv_raw || csv_raw.length === 0 || !icicleKeys) {
    const noData = createNoDataState(_lang(vulnerability_translations.no_data_available));
    const element = document.createElement('div');
    element.innerHTML = noData.outerHTML;
    element.value = { sequence: [], percentage: 0.0 };
    return element;
  }

  const layerLabels = ["Gender", "Poverty", "Education"]; // adjust as needed

  const gutter = 80;

  const order = {
    // Set the order of the rectanges for icicle chart worse -> better
    poverty1: 2,
    poverty2: 1,
    poverty3: 0,
    education1: 0,
    education2: 1,
    education3: 2
  };

  const root = partition(data, order);

  let frozen = false;
  let frozenSequence = [];
  // const padding = 10;
  const svg = d3.create("svg");
  // Make this into a view, so that the currently hovered sequence is available to the breadcrumb
  const element = svg.node();
  element.value = { sequence: [], percentage: 0.0 };

  svg
    .attr("viewBox", `0 0 ${width + gutter} ${height}`)
    .style("font", "12px sans-serif");

  const plot = svg.append("g").attr("transform", `translate(${gutter},0)`);

  plot
    .append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none");

  const segment = plot
    .append("g")
    .attr("transform", (d) =>
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, ${-root.y1 + 40})`
    )
    .selectAll("rect")
    .data(
      root.descendants().filter((d) => {
        return d.depth;
      })
    )
    .join("rect")
    .attr("fill", (d) => icicle_color(d.data.name))
    .attr("x", segmentX)
    .attr("y", segmentY)
    .attr("width", segmentWidth)
    .attr("height", segmentHeight)
    .on("mouseenter", (event, d) => {
      if (frozen) return;
      // Get the ancestors of the current segment, minus the root
      const sequence = d.ancestors().reverse().slice(1);
      // Highlight the ancestors
      segment.attr("fill-opacity", (node) =>
        sequence.indexOf(node) >= 0 ? 1.0 : 0.3
      );
      const percentage = (100 * (d.value / root.value)).toPrecision(3);
      element.value = { sequence, percentage };
      element.dispatchEvent(new CustomEvent("input"));
    })
    .on("click", (event, d) => {
      if (frozen) {
        frozen = false;
        return;
      } else {
        frozen = true;
        frozenSequence = d.ancestors().reverse().slice(1);
        segment.attr("fill-opacity", (node) =>
          frozenSequence.indexOf(node) >= 0 ? 1.0 : 0.3
        );
        const percentage = (100 * (d.value / root.value)).toPrecision(3);
        element.value = { sequence: frozenSequence, percentage };
        element.dispatchEvent(new CustomEvent("input"));
        event.stopPropagation(); // prevent svg click from firing
      }
    });

  // Add sidebar text
  const depthNodes = d3
    .rollups(
      root.descendants().filter((d) => d.depth),
      (v) => v[0], // representative node per depth
      (d) => d.depth
    )
    .sort((a, b) => d3.ascending(a[0], b[0])); // sort by depth asc

  plot
    .append("g")
    .attr("transform", (d) =>
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, ${-root.y1 + 40})`
    )
    .selectAll("text.layer-label")
    .data(
      depthNodes.map(([depth, rep]) => ({
        depth,
        y: segmentY(rep) + segmentHeight(rep) / 2
      }))
    )
    .join("text")
    .attr("class", "layer-label")
    .attr("x", -12) // left of the icicle area (inside gutter)
    .attr("y", (d) => d.y)
    .attr("dy", "0.35em")
    .attr("text-anchor", "end")
    .attr("font-size", "12px")
    .attr("font-weight", "600")
    .text((d) => layerLabels[d.depth - 1] ?? `Layer ${d.depth}`);

  // Add percentage labels to each segment
  const labels = plot
    .append("g")
    .attr("transform", (d) =>
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, ${-root.y1 + 40})`
    )
    .selectAll("text")
    .data(
      root.descendants().filter((d) => {
        return d.depth && d.data.name !== "population";
      })
    )
    .join("text")
    .attr("x", (d) => segmentX(d) + segmentWidth(d) / 2)
    .attr("y", (d) => segmentY(d) + segmentHeight(d) / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("fill", (d) => {
      // Use contrasting colors for text based on background
      const bgColor = icicle_color(d.data.name);
      // For dark colors, use white text; for light colors, use black text
      // Updated to match new gender colors: #A491D3 (purple), #D0F0DE (light green)
      if (
        bgColor === "#A491D3" ||
        bgColor === "#ec5a47" ||
        bgColor === "#fc8a34"
      ) {
        return "white";
      } else {
        return "black";
      }
    })
    .attr("pointer-events", "none") // Prevent text from interfering with mouse events
    .text((d) => {
      let dataObj = d?.data;
      const genderName = dataObj.name.startsWith("gender") ? _lang(icicle_dict[dataObj.name]) : null;
      const gender_str = genderName ? genderName + " - " : ""
      const percentage = (100 * (d.value / root.value)).toFixed(1);
      // Only show percentage if the segment is large enough to display text
      return segmentWidth(d) > 30 && segmentHeight(d) > 15
        ? `${gender_str + percentage}%`
        : "";
    });

  const mouseLeaveHandler = () => {
    if (frozen) return;
    segment.attr("fill-opacity", 1);
    // Update the value of this view
    element.value = { sequence: [], percentage: 0.0 };
    element.dispatchEvent(new CustomEvent("input"));
  };

  const clickHandler = () => {
    if (frozen) {
      frozen = false;
      frozenSequence = [];
      segment.attr("fill-opacity", 1);
      element.value = { sequence: [], percentage: 0.0 };
      element.dispatchEvent(new CustomEvent("input"));
    }
  };

  plot.on("mouseleave", mouseLeaveHandler);
  plot.on("click", clickHandler);

  // Add disposal mechanism to clean up event listeners
  // This prevents memory leaks when the cell is re-evaluated
  if (element.dispose) {
    element.dispose();
  }
  element.dispose = () => {
    plot.on("mouseleave", null);
    plot.on("click", null);
    segment.on("mouseenter", null);
    segment.on("click", null);
  };

  // add legend
  const colorScale = d3
    .scaleOrdinal()
    .domain(["Better", "Moderate", "Worse"])
    .range(["#F4BB21", "#FC8A34", "#EC5A47"]);

  svg
    .append("rect")
    .attr("x", 1)
    .attr("y", 5)
    .attr("rx", 10) // Add rounded corners
    .attr("ry", 10) // Add rounded corners
    .attr("width", 300) // Adjust the width to fit the legend
    .attr("height", 30) // Adjust the height to fit the legend
    .attr("fill", "#fff");
  // .attr("stroke", "black");

  const legend = svg
    .selectAll(".legend")
    .data(colorScale.domain())
    .enter()
    .append("g")
    .attr("class", "legend")
    .attr("transform", function (d, i) {
      return "translate(" + (i * 100 + 25) + ",11)";
    });

  legend
    .append("rect")
    .attr("x", 0)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", colorScale);

  legend
    .append("text")
    .attr("x", 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .text(function (d) {
      return d;
    });

  return element;
}
```

```{ojs}
// Download functionality
sensitivityDownloadButton = {
  if (!icicle_pct_table || icicle_pct_table.length === 0) {
    return htl.html``;
  }
  
  return downloadButton(
    icicle_pct_table, 
    `sensitivity_data_${getSensitivityAdminSelection().replace(/\s+/g, '_')}`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic insights - reactive to icicle selection
sensitivityInsights = {
  if (!data || data.length === 0 || !csv || csv.length === 0 || !icicle_insight) {
    return createNoDataState();
  }

  const region = getSensitivityAdminSelection();
  const insight = icicle_insight;
  
  // Generate default insights (always shown)
  const totalMale = insight.male;
  const totalFemale = insight.female;
  const mostVulnTotal = (insight.most_vuln_m + insight.most_vuln_f).toFixed(1);
  const femalePct = insight.most_vuln_f.toFixed(1);
  const malePct = insight.most_vuln_m.toFixed(1);
  
  // Education comparison
  const noEduMale = insight.no_edu_m.toFixed(1);
  const noEduFemale = insight.no_edu_f.toFixed(1);
  
  // Poverty comparison  
  const highPovMale = insight.high_poverty_m.toFixed(1);
  const highPovFemale = insight.high_poverty_f.toFixed(1);
  
  // Structure the default insights as separate parts for better HTML rendering
  const defaultInsightParts = [
    `In ${region}, men represent ${totalMale}% and women represent ${totalFemale}% of the population.`,
    `Among the most vulnerable group (high poverty + no primary education), ${femalePct}% are female and ${malePct}% are male.`,
    `Education gap: ${noEduFemale}% of women vs ${noEduMale}% of men have no primary education.`,
    `Poverty gap: ${highPovFemale}% of women vs ${highPovMale}% of men live in high poverty areas.`
  ];
  const defaultInsightText = defaultInsightParts.join('\n\n');
  return createInsightDisplay(defaultInsightText);
}
```
