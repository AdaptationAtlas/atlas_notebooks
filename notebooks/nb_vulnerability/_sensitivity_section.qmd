---
module: "Sensitivity Section"
nb-authors:
  - Johnson Mwakazi
  - Brayden Youngberg
  - Pete Stewart
date-created: "2025-02-19"
date-edited: today
# css: styles.css
---

```{ojs}
sensitivityQuestion = _lang(vulnerability_translations.sensitivity_question);
```

# `{ojs} sensitivityQuestion` {#sensitivity}

`{ojs} _lang(vulnerability_translations.sensitivity_description)`

```{ojs}
sensitivityControlsForm = createGeographicControlsForm();
viewof sensitivityView = Inputs.radio(["plot", "table"], {
  label: "View Type",
  value: "plot",
});
```

```{ojs}
{
  if (sensitivityView === "plot") {
    return renderIcicle();
  } else {
    return filterableDataTable(icicle_pct_table);
  }
}
```

```{ojs}
// Download functionality
downloadButton(
  icicle_pct_table,
  `sensitivity_data_${getAdminNameString().replace(", ", "_")}`,
  _lang(vulnerability_translations.download_data),
);
```

<!-- Backend Logic -->

```{ojs}
// Load icicle metadata and data with caching
icicleKeys = await FileAttachment(
  "/data/vulnerability_notebook/vulnerability_iciclekeys.json",
).json();
```

```{ojs}
csv = {
  const data = await localDb.query(`
    SELECT *
    FROM vulnerability_icicle
    WHERE 1=1
      AND ${sqlAdminQuerySpecific()}
  `);

  return data
};
```

```{ojs}
function buildHierarchy(csv) {
  // Helper function that transforms the given CSV into a hierarchical format.
  // Skip the population level and start directly with demographic categories
  const root = { name: "root", children: [] };
  for (let i = 0; i < csv.length; i++) {
    const sequence = csv[i].path;
    const size = +csv[i].value;
    // Skip invalid rows
    if (!sequence || isNaN(size)) {
      continue;
    }
    const parts = sequence.split("_");
    let currentNode = root;
    // Skip the first part (population) and start from the second part
    for (let j = 1; j < parts.length; j++) {
      const children = currentNode["children"];
      const nodeName = parts[j];
      let childNode = null;
      let foundChild = false;
      // Search for existing child with the same name
      for (let k = 0; k < children.length; k++) {
        if (children[k]["name"] === nodeName) {
          childNode = children[k];
          foundChild = true;
          break;
        }
      }
      // If not found, create a new child node
      if (!foundChild) {
        childNode = { name: nodeName, children: [] };
        children.push(childNode);
      }
      currentNode = childNode;
      // If it's the last part of the sequence, create a leaf node
      if (j === parts.length - 1) {
        childNode.value = size;
      }
    }
  }
  return root;
}
```

```{ojs}
// Create percentage table for insights

icicle_pct_table = {
  if (!csv || csv.length === 0) return [];
  // A little function to basically calculate the same thing as the breadcrumb but for all the admin region.
  // This is what users should see if going to a tabular view and also what they should download. It is much easier to understand and work with.
  const summarize_icicle = (csv, icicle_keys = null) => {
    const rows = csv.map(({ path, value }) => ({
      parts: path.split("_").slice(1),
      value: value
    }));
    const total = d3.sum(rows, (d) => d.value);

    const maxDepth = Math.max(...rows.map((r) => r.parts.length));
    const levelNames = icicle_keys
      ? Object.keys(icicle_keys)
      : [...Array(maxDepth).keys()].map((i) => `level${i + 1}`);

    const lookupName = (dim, key) => {
      if (!icicle_keys) return key;
      return _lang(icicle_keys[dim]?.[key]) ?? key;
    };

    const genderTotals = {};
    rows.forEach((r) => {
      const gender = r.parts[0];
      genderTotals[gender] = (genderTotals[gender] || 0) + r.value;
    });

    // Recursive helper
    const recurse = (rows, depth = 0, prefix = []) => {
      if (!rows.length) return [];
      if (depth >= maxDepth) return [];

      return d3
        .rollups(
          rows,
          (v) => d3.sum(v, (d) => d.value),
          (d) => d.parts[depth]
        )
        .flatMap(([k, sum]) => {
          const current = [...prefix, k];
          const rowObj = {};
          levelNames.forEach((col, i) => {
            rowObj[col] = current[i] ? lookupName(col, current[i]) : null;
          });
          rowObj.pct_total = (100 * sum) / total;
          // pct relative to gender
          const genderKey = prefix[0];
          if (genderKey && genderTotals[genderKey]) {
            rowObj.pct_of_gender = (100 * sum) / genderTotals[genderKey];
          }
          return [
            rowObj,
            ...recurse(
              rows.filter((r) => r.parts[depth] === k),
              depth + 1,
              current
            )
          ];
        });
    };

    return recurse(rows);
  };

  return summarize_icicle(csv, icicleKeys);
}
```

```{ojs}
icicle_dict = Object.fromEntries(
  Object.values(icicleKeys).flatMap((group) => Object.entries(group)),
);
```

```{ojs}
icicle_color = d3
  .scaleOrdinal()
  .domain([
    "population",
    "gender1", // female
    "gender0", // male

    "poverty1", // low poverty = good // TODO: Check the directionality of this in preprocess code
    "poverty2", // mid. poverty = mid
    "poverty3", // high poverty = bad
    "povertyNA", // no data

    "education3", // high edu. = good
    "education2", // mid. edu. = mid
    "education1", // low edu = bad
    "educationNA", // no data
  ])
  .range([
    "#a4a4a4", // population - removed
    "#59CD90", // female - #59CD90
    "#A491D3", // male

    "#f4bb21", // low poverty = good
    "#fc8a34", // mid. poverty = mid
    "#ec5a47", // high poverty = bad
    "#a4a4a4", // no data

    "#f4bb21", // high edu = good
    "#fc8a34", // mid. edu = mid
    "#ec5a47", // low edu = bad
    "#a4a4a4", // no data
  ]);
```

```{ojs}
// config for chart
targetHeight = 425;
narrowHeight = 600;
icicleHeight = narrow ? narrowHeight : targetHeight;
narrow = width <= 0;

partitionIcicle = (data, height, order = null) =>
  d3
    .partition()
    .padding(1)
    .size(narrow ? [height, width] : [width, height])(
    d3
      .hierarchy(data)
      .sum((d) => d.value)
      .sort((a, b) => {
        if (order) {
          // Look up indices, fallback to 999 if not defined
          return (order[a.data.name] ?? 999) - (order[b.data.name] ?? 999);
        }
        return b.value - a.value;
      }),
  );

renderIcicle = () => {
  const height = icicleHeight;
  const breadcrumbHeight = 40;
  const breadcrumbWidth = 275;
  const verticalSpacing = 20;

  const _data = buildHierarchy(csv);

  const segmentX = (d) => (narrow ? d.y0 : d.x0);
  const segmentY = (d) => (narrow ? d.x0 : d.y0);
  const segmentWidth = (d) => (narrow ? d.y1 - d.y0 : d.x1 - d.x0);
  const segmentHeight = (d) => (narrow ? d.x1 - d.x0 : d.y1 - d.y0);

  if (!_data || !csv || csv.length === 0) {
    const element = document.createElement("div");
    element.value = { sequence: [], percentage: 0 };
    return element;
  }

  const config = {
    gutter: 80,
    layerLabels: ["Gender", "Poverty", "Education"],
    order: {
      povertyNA: 3,
      poverty1: 2,
      poverty2: 1,
      poverty3: 0,
      education1: 0,
      education2: 1,
      education3: 2,
      educationNA: 3,
    },
    legend: {
      height: 30,
      itemSpacing: 100,
      itemOffset: 25,
    },
  };

  const root = partitionIcicle(_data, height, config.order);

  let frozen = false;
  let frozenSequence = [];

  const totalHeight = breadcrumbHeight + config.legend.height + height;

  const svg = d3
    .create("svg")
    .attr("viewBox", `0 0 ${width + config.gutter} ${totalHeight}`)
    .style("font", "12px sans-serif");

  const element = svg.node();
  element.value = { sequence: [], percentage: 0.0 };

  // Breadcrumb
  const breadcrumbGroup = svg.append("g").attr("transform", `translate(10, 0)`);

  function breadcrumbPoints(d, i) {
    const tipWidth = breadcrumbHeight * 0.3;
    return [
      `0,0`,
      `${breadcrumbWidth},0`,
      `${breadcrumbWidth + tipWidth},${breadcrumbHeight / 2}`,
      `${breadcrumbWidth},${breadcrumbHeight}`,
      `0,${breadcrumbHeight}`,
      ...(i > 0 ? [`${tipWidth},${breadcrumbHeight / 2}`] : []),
    ].join(" ");
  }

  function renderBreadcrumb(sequence, percentage) {
    const g = breadcrumbGroup.selectAll("g").data(sequence, (d) => d.data.name);

    g.exit().remove();

    const gEnter = g.enter().append("g");

    gEnter.append("polygon").attr("stroke", "white");

    gEnter
      .append("text")
      .attr("text-anchor", "middle")
      .attr("fill", "white")
      .attr("font-size", "19px")
      .attr("dy", "0.35em");

    const merged = gEnter
      .merge(g)
      .attr("transform", (d, i) => `translate(${i * breadcrumbWidth}, 0)`);

    merged
      .select("polygon")
      .attr("points", breadcrumbPoints)
      .attr("fill", (d) => icicle_color(d.data.name));

    merged
      .select("text")
      .attr("x", breadcrumbWidth / 2)
      .attr("y", breadcrumbHeight / 2)
      .text((d) => {
        const name = d.data.name;
        const translated = icicle_dict?.[name];
        return translated ? _lang(translated) : name;
      });

    breadcrumbGroup.selectAll(".breadcrumb-percentage").remove();

    if (sequence.length > 1) {
      breadcrumbGroup
        .append("text")
        .attr("class", "breadcrumb-percentage")
        .attr("x", (sequence.length + 0.1) * breadcrumbWidth)
        .attr("y", breadcrumbHeight / 2)
        .attr("dy", "0.35em")
        .attr("font-size", "19px")
        .text(percentage > 0 ? percentage + "%" : "");
    }
  }

  // Legend
  const legendY = breadcrumbHeight + verticalSpacing;

  const colorScale = d3
    .scaleOrdinal()
    .domain(["Better", "Moderate", "Worse", "No data"])
    .range(["#F4BB21", "#FC8A34", "#EC5A47", "#a4a4a4"]);

  const legendGroup = svg
    .append("g")
    .attr("transform", `translate(${config.gutter}, ${legendY})`);

  const legend = legendGroup
    .selectAll("g")
    .data(colorScale.domain())
    .join("g")
    .attr(
      "transform",
      (d, i) => `translate(${i * config.legend.itemSpacing}, 0)`,
    );

  legend
    .append("rect")
    .attr("width", 18)
    .attr("height", 18)
    .attr("fill", colorScale);

  legend
    .append("text")
    .attr("x", 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .text((d) => d);

  // Icicle Plot
  const plot = svg
    .append("g")
    .attr("transform", `translate(${config.gutter}, 0)`);

  plot
    .append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none");

  const segment = plot
    .append("g")
    .attr(
      "transform",
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, 0)`,
    )
    .selectAll("rect")
    .data(root.descendants().filter((d) => d.depth))
    .join("rect")
    .attr("fill", (d) => icicle_color(d.data.name))
    .attr("x", segmentX)
    .attr("y", segmentY)
    .attr("width", segmentWidth)
    .attr("height", segmentHeight)
    .on("mouseenter", (event, d) => {
      if (frozen) return;
      const sequence = d.ancestors().reverse().slice(1);
      segment.attr("fill-opacity", (node) =>
        sequence.indexOf(node) >= 0 ? 1 : 0.3,
      );
      const percentage = (100 * (d.value / root.value)).toPrecision(3);
      element.value = { sequence, percentage };
      element.dispatchEvent(new CustomEvent("input"));
      renderBreadcrumb(sequence, percentage);
    })
    .on("click", (event, d) => {
      if (frozen) {
        frozen = false;
        frozenSequence = [];
        segment.attr("fill-opacity", 1);
        renderBreadcrumb([], 0);
        return;
      }
      frozen = true;
      frozenSequence = d.ancestors().reverse().slice(1);
      segment.attr("fill-opacity", (node) =>
        frozenSequence.indexOf(node) >= 0 ? 1 : 0.3,
      );
      const percentage = (100 * (d.value / root.value)).toPrecision(3);
      element.value = {
        sequence: frozenSequence,
        percentage,
      };
      element.dispatchEvent(new CustomEvent("input"));
      renderBreadcrumb(frozenSequence, percentage);
      event.stopPropagation();
    });

  svg.on("mouseleave", () => {
    if (frozen) return;
    segment.attr("fill-opacity", 1);
    // Update the value of this view
    element.value = { sequence: [], percentage: 0.0 };
    element.dispatchEvent(new CustomEvent("input"));
    renderBreadcrumb([], 0);
  });

  svg.on("click", () => {
    if (frozen) {
      frozen = false;
      frozenSequence = [];
      segment.attr("fill-opacity", 1);
      element.value = { sequence: [], percentage: 0.0 };
      element.dispatchEvent(new CustomEvent("input"));
      renderBreadcrumb([], 0);
    }
  });

  // Layer Labels
  const depthNodes = d3
    .rollups(
      root.descendants().filter((d) => d.depth),
      (v) => v[0],
      (d) => d.depth,
    )
    .sort((a, b) => d3.ascending(a[0], b[0]));

  plot
    .append("g")
    .attr(
      "transform",
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, 0)`,
    )
    .selectAll("text.layer-label")
    .data(
      depthNodes.map(([depth, rep]) => ({
        depth,
        y: segmentY(rep) + segmentHeight(rep) / 2,
      })),
    )
    .join("text")
    .attr("x", -12)
    .attr("y", (d) => d.y)
    .attr("dy", "0.35em")
    .attr("text-anchor", "end")
    .attr("font-weight", "600")
    .text((d) => config.layerLabels[d.depth - 1] ?? `Layer ${d.depth}`);

  // Percentage Labels
  plot
    .append("g")
    .attr(
      "transform",
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, 0)`,
    )
    .selectAll("text")
    .data(
      root.descendants().filter((d) => d.depth && d.data.name !== "population"),
    )
    .join("text")
    .attr("x", (d) => segmentX(d) + segmentWidth(d) / 2)
    .attr("y", (d) => segmentY(d) + segmentHeight(d) / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .attr("font-weight", "bold")
    .attr("fill", (d) =>
      ["#A491D3", "#ec5a47", "#fc8a34"].includes(icicle_color(d.data.name))
        ? "white"
        : "black",
    )
    .attr("pointer-events", "none")
    .text((d) => {
      const dataObj = d?.data;
      const genderName = dataObj.name.startsWith("gender")
        ? _lang(icicle_dict[dataObj.name])
        : null;
      const genderStr = genderName ? `${genderName} - ` : "";
      const percentage = (100 * (d.value / root.value)).toFixed(1);
      return segmentWidth(d) > 30 && segmentHeight(d) > 15
        ? `${genderStr}${percentage}%`
        : "";
    });

  return element;
};
```

```{ojs}
icicle_pct_table;

{
  const _data = icicle_pct_table;
  const template = _lang(vulnerability_translations.sensitivity_insight);
  const regionName = getAdminNameString();
  const round = 2;

  const totalsByGender = Object.fromEntries(
    _data
      .filter(d => d.poverty === null && d.education === null)
      .map(d => [d.gender, d.pct_total])
  );

  const sensitiveGroup = Object.fromEntries(
    _data
      .filter(d =>
        d.poverty === "high poverty" &&
        d.education === "no education"
      )
      .map(d => [d.gender, d.pct_total])
  );

  const highPoverty = Object.fromEntries(
    _data
      .filter(d => d.poverty === "high poverty" && d.education === null)
      .map(d => [d.gender, d.pct_of_gender])
  );

  const secondaryTotals = _data
    .filter(d =>
      d.education === "secondary education"
    )
    .reduce((acc, d) => {
      acc[d.gender] = (acc[d.gender] || 0) + d.pct_total;
      return acc;
    }, {});

    const noEduTotals = _data
      .filter(d =>
        d.education === "no education"
      )
      .reduce((acc, d) => {
        acc[d.gender] = (acc[d.gender] || 0) + d.pct_total;
        return acc;
      }, {});

  const primaryGap = noEduTotals.female - noEduTotals.male;
  const secondaryGap = secondaryTotals.female - secondaryTotals.male;

  const items = [
    {name: "region", value: regionName},
    {name: "male_pop", value: totalsByGender.male.toFixed(round)},
    {name: "female_pop", value: totalsByGender.female.toFixed(round)},
    {name: "sensitiveMale", value: sensitiveGroup.male.toFixed(round)},
    {name: "sensitiveFemale", value: sensitiveGroup.female.toFixed(round)},
    {name: "noPrimaryFemale", value: noEduTotals.female.toFixed(round)},
    {name: "noPrimaryMale", value: noEduTotals.male.toFixed(round)},
    {name: "primaryGap", value: primaryGap.toFixed(round)},
    {name: "secondaryFemale", value: secondaryTotals.female.toFixed(round)},
    {name: "secondaryMale", value: secondaryTotals.male.toFixed(round)},
    {name: "secondaryGap", value: secondaryGap.toFixed(round)},
  ]

  const insight = Lang.reduceReplaceTemplateItems(
    template,
    items
  );
  return createInsightDisplay(insight);
}
```
