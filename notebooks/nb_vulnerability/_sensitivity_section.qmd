---
pagetitle: "Sensitivity Section"
nb-authors: 
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: '2025-02-19'
date-edited: today
css: styles.css
---

```{ojs}
sensitivityQuestion = _lang(vulnerability_translations.sensitivity_question)
```

# `{ojs} sensitivityQuestion ` {#sensitivity}

`{ojs} _lang(vulnerability_translations.sensitivity_description)`

```{ojs}
// Controls section - Admin selectors using static data to prevent flickering

viewof sensitivityAdmin0 = Inputs.select(sensitivityDataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof sensitivityAdmin1 = Inputs.select(sensitivityDataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof sensitivityAdmin2 = Inputs.select(sensitivityDataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})


```

```{ojs}

sensitivityControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: nowrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px;">${viewof sensitivityAdmin0}</div>
    <div style="flex: 1; min-width: 180px;">${viewof sensitivityAdmin1}</div>
    <div style="flex: 1; min-width: 180px;">${viewof sensitivityAdmin2}</div>
  </div>
</div>
`
```

```{ojs}
// Load icicle metadata and data with caching
icicleKeys = await loadDataWithCache('icicleKeys', async () => {
  return await FileAttachment("/data/vulnerability_notebook/vulnerability_iciclekeys.json").json();
});
```

```{ojs}
csv_raw = await loadDataWithCache('sensitivityCSV', async () => {
  return d3.csvParseRows(await FileAttachment("/data/vulnerability_notebook/vulnerability_icicledata_main.csv").text()).slice(1);
});
```


```{ojs}
breadcrumbWidth = 200
breadcrumbHeight = 35
targetHeight = 350
height = narrow ? narrowHeight : targetHeight
narrowHeight = 600
narrow = width <= 0
segmentX = d => (narrow ? d.y0 : d.x0)
segmentY = d => (narrow ? d.x0 : d.y0)
segmentWidth = d => (narrow ? d.y1 - d.y0 : d.x1 - d.x0)
segmentHeight = d => (narrow ? d.x1 - d.x0 : d.y1 - d.y0)



```

```{ojs}

partition = (data) =>
  d3
    .partition()
    .padding(1)
    .size(narrow ? [height, width] : [width, height])(
    d3
      .hierarchy(data)
      .sum((d) => d.value)
      .sort((a, b) => b.value - a.value)
  )



```

```{ojs}

function buildHierarchy(csv) {
  // Helper function that transforms the given CSV into a hierarchical format.
  // Skip the population level and start directly with demographic categories
  const root = { name: "root", children: [] };
  for (let i = 0; i < csv.length; i++) {
    const sequence = csv[i][0];
    const size = +csv[i][1];
    if (isNaN(size)) {
      // e.g. if this is a header row
      continue;
    }
    const parts = sequence.split("_");
    let currentNode = root;
    // Skip the first part (population) and start from the second part
    for (let j = 1; j < parts.length; j++) {
      const children = currentNode["children"];
      const nodeName = parts[j];
      let childNode = null;
      let foundChild = false;
      // Search for existing child with the same name
      for (let k = 0; k < children.length; k++) {
        if (children[k]["name"] === nodeName) {
          childNode = children[k];
          foundChild = true;
          break;
        }
      }
      // If not found, create a new child node
      if (!foundChild) {
        childNode = { name: nodeName, children: [] };
        children.push(childNode);
      }
      currentNode = childNode;
      // If it's the last part of the sequence, create a leaf node
      if (j === parts.length - 1) {
        childNode.value = size;
      }
    }
  }
  return root;
}


```





```{ojs}
csv = {
  if (!sensitivityAdmin0.value) {
    // No admin selection - use SSA data
    return csv_raw
      .filter(
        (item) => item[0] === "SSA" && item[1] === "NA" && item[2] === "NA"
      )
      .map((item) => [item[3], item[4]]);
  } else if (!sensitivityAdmin1.value) {
    return csv_raw
      .filter(
        (item) => item[0] === sensitivityAdmin0.value && item[1] === "NA" && item[2] === "NA"
      )
      .map((item) => [item[3], item[4]]);
  } else if (sensitivityAdmin1.value && !sensitivityAdmin2.value) {
    return csv_raw
      .filter(
        (item) => item[0] === sensitivityAdmin0.value && item[1] === sensitivityAdmin1.value && item[2] === "NA"
      )
      .map((item) => [item[3], item[4]]);
  } else if (sensitivityAdmin1.value !== null && sensitivityAdmin2.value !== null) {
    return csv_raw
      .filter(
        (item) =>
          item[0] === sensitivityAdmin0.value && item[1] === sensitivityAdmin1.value && item[2] === sensitivityAdmin2.value
      )
      .map((item) => [item[3], item[4]]);
  }
}


```

```{ojs}

data = buildHierarchy(csv)

```

```{ojs}

// Generate a string that describes the points of a breadcrumb SVG polygon.
function breadcrumbPoints(d, i) {
  const tipWidth = 10;
  const points = [];
  points.push("0,0");
  points.push(`${breadcrumbWidth},0`);
  points.push(`${breadcrumbWidth + tipWidth},${breadcrumbHeight / 2}`);
  points.push(`${breadcrumbWidth},${breadcrumbHeight}`);
  points.push(`0,${breadcrumbHeight}`);
  if (i > 0) {
    // Leftmost breadcrumb; don't include 6th vertex.
    points.push(`${tipWidth},${breadcrumbHeight / 2}`);
  }
  return points.join(" ");
}

```

```{ojs}

alias = {
  const flat_alias = Object.fromEntries(
    Object.values(icicleKeys).flatMap((obj) =>
      Object.entries(obj).map(([k, v]) => [k, v[0]])
    )
  );
  flat_alias.population = "Total Population";
  return flat_alias;
}

```


```{ojs}

color = d3
  .scaleOrdinal()
  .domain([
    "population",
    "poverty2",
    "poverty1",
    "poverty0",
    "education2",
    "education1",
    "education0",
    "gender2",
    "gender1",
    "gender0"
  ])
  .range([
    "#a4a4a4",
    "#ec5a47",
    "#fc8a34",
    "#f4bb21",
    "#f4bb21",
    "#fc8a34",
    "#ec5a47",
    "#f4bb21",
    "#fc8a34",
    "#ec5a47"
  ])


```




```{ojs}

breadcrumb = {
  // Only show breadcrumb if there's a sequence to display
  if (!icicle.sequence || icicle.sequence.length === 0) {
    return htl.html`<div style="height: ${breadcrumbHeight}px;"></div>`;
  }

  const svg = d3
    .create("svg")
    .attr("viewBox", `0 0 ${breadcrumbWidth * 4.75} ${breadcrumbHeight}`)
    .style("font", "13px sans-serif")
    .style("margin", "2px")
    .style("display", "block");

  const g = svg
    .selectAll("g")
    .data(icicle.sequence)
    .join("g")
    .attr("transform", (d, i) => `translate(${i * breadcrumbWidth}, 0)`);

  g.append("polygon")
    .attr("points", breadcrumbPoints)
    .attr("fill", (d) => {
      return color(d.data.name)
      })
    .attr("stroke", "white");

  g.append("text")
    .attr("x", (breadcrumbWidth + 10) / 2)
    .attr("y", 15)
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .attr("fill", "white")
    .attr("font-size", "12px")
    .text((d) => {
      const name = d.data.name;
      
      // Create meaningful labels based on the actual data structure
      if (name === "population") return "Total Population";
      
      // Handle education levels (based on icicle keys structure)
      if (name === "secondary") return "Secondary Education";
      if (name === "primary") return "Primary Education";
      if (name === "noprimary") return "No Primary Education";
      
      // Handle gender categories
      if (name === "male") return "Male";
      if (name === "female") return "Female";
      
      // Handle poverty levels
      if (name === "low") return "Low Poverty";
      if (name === "moderate") return "Moderate Poverty";
      if (name === "high") return "High Poverty";
      
      // Handle education category codes
      if (name === "education1") return "No Primary Education";
      if (name === "education2") return "Primary Education";
      if (name === "education3") return "Secondary Education";
      
      // Handle poverty category codes
      if (name === "poverty1") return "Low Poverty";
      if (name === "poverty2") return "Moderate Poverty";
      if (name === "poverty3") return "High Poverty";
      
      // Handle gender category codes
      if (name === "gender0") return "Male";
      if (name === "gender1") return "Female";
      
      // Try to get from alias if available
      if (typeof alias !== 'undefined' && alias[name]) {
        // If alias is an array, take the first meaningful value
        if (Array.isArray(alias[name]) && alias[name].length > 0) {
          const aliasValue = alias[name][0];
          // Convert alias values to readable labels
          if (aliasValue === "secondary") return "Secondary Education";
          if (aliasValue === "primary") return "Primary Education";
          if (aliasValue === "noprimary") return "No Primary Education";
          if (aliasValue === "male") return "Male";
          if (aliasValue === "female") return "Female";
          if (aliasValue === "low") return "Low Poverty";
          if (aliasValue === "moderate") return "Moderate Poverty";
          if (aliasValue === "high") return "High Poverty";
          return aliasValue.charAt(0).toUpperCase() + aliasValue.slice(1);
        }
        return alias[name];
      }
      
      // Default fallback - capitalize and replace underscores
      return name.charAt(0).toUpperCase() + name.slice(1).replace(/_/g, ' ');
    });

  if (icicle.sequence.length > 1) {
    svg
      .append("text")
      .text(icicle.percentage > 0 ? icicle.percentage + "%" : "")
      .attr("x", (icicle.sequence.length + 0.25) * breadcrumbWidth)
      .attr("y", breadcrumbHeight / 2)
      .attr("dy", "0.35em")
      .attr("text-anchor", "middle")
      .attr("font-size", "12px");
  }

  return svg.node();
}


```


```{ojs}

viewof icicle = {
  // Show loading spinner only if data is still loading (null/undefined)
  if (csv_raw === null || csv_raw === undefined || icicleKeys === null || icicleKeys === undefined) {
    const loading = createLoadingState(_lang({en: "Loading sensitivity data...", fr: "Chargement des données de sensibilité..."}));
    const element = document.createElement('div');
    element.innerHTML = loading.outerHTML;
    element.value = { sequence: [], percentage: 0.0 };
    return element;
  }
  
  // If data is loaded but empty, show no data state
  if (!csv_raw || csv_raw.length === 0 || !icicleKeys) {
    const noData = createNoDataState(_lang(vulnerability_translations.no_data_available));
    const element = document.createElement('div');
    element.innerHTML = noData.outerHTML;
    element.value = { sequence: [], percentage: 0.0 };
    return element;
  }

  const icicle_color = d3
    .scaleOrdinal()
    .domain([
      "population",
      "poverty2",
      "poverty1",
      "poverty0",
      "education2",
      "education1",
      "education0",
      "gender2",
      "gender1",
      "gender0"
    ])
    .range([
      "transparent",  // Hide population bar
      "#ec5a47",      // poverty2 - moderate (red)
      "#fc8a34",      // poverty1 - low (orange)
      "#f4bb21",      // poverty0 - high (yellow)
      "#f4bb21",      // education2 (yellow)
      "#fc8a34",      // education1 (orange)
      "#ec5a47",      // education0 (red)
      "#f4bb21",      // gender2 (not used)
      "#4a90e2",      // gender1 - female (blue)
      "#e74c3c"       // gender0 - male (red)
    ]);
  const root = partition(data);
  let frozen = false;
  let frozenSequence = [];
  // const padding = 10;
  const svg = d3.create("svg");
  // Make this into a view, so that the currently hovered sequence is available to the breadcrumb
  const element = svg.node();
  element.value = { sequence: [], percentage: 0.0 };

  svg
    .attr("viewBox", `0 0 ${width} ${height}`)
    .style("font", "12px sans-serif");

  svg
    .append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none");

  const segment = svg
    .append("g")
    .attr("transform", (d) =>
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, ${-root.y1 + 40})`
    )
    .selectAll("rect")
    .data(
      root.descendants().filter((d) => {
        return d.depth;
      })
    )
    .join("rect")
    .attr("fill", (d) => icicle_color(d.data.name))
    .attr("x", segmentX)
    .attr("y", segmentY)
    .attr("width", segmentWidth)
    .attr("height", segmentHeight)
    .on("mouseenter", (event, d) => {
      if (frozen) return;
      // Get the ancestors of the current segment, minus the root
      const sequence = d.ancestors().reverse().slice(1);
      // Highlight the ancestors
      segment.attr("fill-opacity", (node) =>
        sequence.indexOf(node) >= 0 ? 1.0 : 0.3
      );
      const percentage = (100 * (d.value / root.value)).toPrecision(3);
      element.value = { sequence, percentage };
      element.dispatchEvent(new CustomEvent("input"));
    })
    .on("click", (event, d) => {
      if (frozen) {
        frozen = false;
        return;
      } else {
        frozen = true;
        frozenSequence = d.ancestors().reverse().slice(1);
        segment.attr("fill-opacity", (node) =>
          frozenSequence.indexOf(node) >= 0 ? 1.0 : 0.3
        );
        const percentage = (100 * (d.value / root.value)).toPrecision(3);
        element.value = { sequence: frozenSequence, percentage };
        element.dispatchEvent(new CustomEvent("input"));
        event.stopPropagation(); // prevent svg click from firing
      }
    });

  // Add percentage labels to each segment
  const labels = svg
    .append("g")
    .attr("transform", (d) =>
      narrow ? `translate(${-root.y1}, 40)` : `translate(0, ${-root.y1 + 40})`
    )
    .selectAll("text")
    .data(
      root.descendants().filter((d) => {
        return d.depth && d.data.name !== "population";
      })
    )
    .join("text")
    .attr("x", d => segmentX(d) + segmentWidth(d) / 2)
    .attr("y", d => segmentY(d) + segmentHeight(d) / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .attr("font-size", "10px")
    .attr("font-weight", "bold")
    .attr("fill", d => {
      // Use contrasting colors for text based on background
      const bgColor = icicle_color(d.data.name);
      // For light colors, use dark text; for dark colors, use light text
      if (bgColor === "#4a90e2" || bgColor === "#e74c3c") {
        return "white";
      } else {
        return "black";
      }
    })
    .attr("pointer-events", "none") // Prevent text from interfering with mouse events
    .text(d => {
      const percentage = (100 * (d.value / root.value)).toFixed(1);
      // Only show percentage if the segment is large enough to display text
      return segmentWidth(d) > 30 && segmentHeight(d) > 15 ? `${percentage}%` : "";
    });

  svg.on("mouseleave", () => {
    if (frozen) return;
    segment.attr("fill-opacity", 1);
    // Update the value of this view
    element.value = { sequence: [], percentage: 0.0 };
    element.dispatchEvent(new CustomEvent("input"));
  });

  svg.on("click", () => {
    if (frozen) {
      frozen = false;
      frozenSequence = [];
      segment.attr("fill-opacity", 1);
      element.value = { sequence: [], percentage: 0.0 };
      element.dispatchEvent(new CustomEvent("input"));
    }
  });

  // add legend
  const colorScale = d3
    .scaleOrdinal()
    .domain(["Better", "Moderate", "Worse"])
    .range(["#F4BB21", "#FC8A34", "#EC5A47"]);

  svg
    .append("rect")
    .attr("x", 1)
    .attr("y", 5)
    .attr("rx", 10) // Add rounded corners
    .attr("ry", 10) // Add rounded corners
    .attr("width", 300) // Adjust the width to fit the legend
    .attr("height", 30) // Adjust the height to fit the legend
    .attr("fill", "#fff");
  // .attr("stroke", "black");

  const legend = svg
    .selectAll(".legend")
    .data(colorScale.domain())
    .enter()
    .append("g")
    .attr("class", "legend")
    .attr("transform", function (d, i) {
      return "translate(" + (i * 100 + 25) + ",11)";
    });

  legend
    .append("rect")
    .attr("x", 0)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", colorScale);

  legend
    .append("text")
    .attr("x", 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .text(function (d) {
      return d;
    });




  return element

}



```







```{ojs}
// Download functionality
sensitivityDownloadButton = {
  if (!data || data.length === 0) {
    return htl.html``;
  }
  
  return downloadButton(
    csv, 
    `sensitivity_data_${getSensitivityAdminSelection().replace(/\s+/g, '_')}`,
    _lang(vulnerability_translations.download_data)
  );
}
```

```{ojs}
// Dynamic insights - reactive to icicle selection
sensitivityInsights = {
  if (!data || data.length === 0 || !csv || csv.length === 0) {
    return createNoDataState();
  }

  // Parse the CSV data properly - first element is the category path, second is the value
  const parsedData = csv.map(d => {
    const [categoryPath, value] = d;
    const categories = categoryPath ? categoryPath.split('_') : [];
    return {
      path: categoryPath,
      value: parseFloat(value) || 0,
      categories: categories
    };
  }).filter(d => d.value > 0);

  if (parsedData.length === 0) {
    return createNoDataState("No vulnerability data available for analysis.");
  }

  const region = getAdminSelection();

  // Check if there's an active icicle selection
  let selectedGroup = null;
  let groupLabel = "vulnerable populations";
  let groupData = [];

  if (icicle.sequence && icicle.sequence.length > 0) {
    // Use the icicle selection to determine the group
    const selectedCategories = icicle.sequence.map(d => d.data.name);
    
    // Create meaningful label from the selected sequence
    const readableCategories = selectedCategories
      .map(cat => {
        // Handle specific category mappings
        if (cat === "gender0") return "men";
        if (cat === "gender1") return "women";
        if (cat === "poverty1") return "low poverty";
        if (cat === "poverty2") return "moderate poverty";
        if (cat === "poverty3") return "high poverty";
        if (cat === "education1") return "no primary education";
        if (cat === "education2") return "primary education";
        if (cat === "education3") return "secondary education";
        return alias[cat] || cat;
      })
      .filter(cat => cat && cat !== "Total Population")
      .join(" ");
    
    groupLabel = readableCategories || "selected population";
    
    // Filter data to match the selected categories exactly
    groupData = parsedData.filter(d => {
      // Check if all selected categories are present in this data point
      return selectedCategories.every(selectedCat => d.categories.includes(selectedCat));
    });
    
    // If no exact match, try to find data that contains the most specific category
    if (groupData.length === 0 && selectedCategories.length > 0) {
      const mostSpecificCategory = selectedCategories[selectedCategories.length - 1];
      groupData = parsedData.filter(d => d.categories.includes(mostSpecificCategory));
    }
  } else {
    // No selection - show data for the most vulnerable group overall
    // Define vulnerability hierarchy: high poverty (poverty3) + no primary education (education1) = most vulnerable
    const mostVulnerableData = parsedData.filter(d => 
      d.categories.includes("poverty3") && d.categories.includes("education1")
    );

    if (mostVulnerableData.length > 0) {
      // Sort by value to get the largest most vulnerable group
      selectedGroup = mostVulnerableData.sort((a, b) => b.value - a.value)[0];
      
      // Get all data for this most vulnerable combination (across both genders)
      groupData = parsedData.filter(d => 
        d.categories.includes("poverty3") && d.categories.includes("education1")
      );
      
      groupLabel = "high poverty no primary education";
    } else {
      // Fallback: if no high poverty + no education combination, find the largest vulnerable group
      const vulnerableGroups = parsedData
        .filter(d => d.categories.includes("poverty3") || d.categories.includes("education1"))
        .sort((a, b) => b.value - a.value);
      
      if (vulnerableGroups.length > 0) {
        selectedGroup = vulnerableGroups[0];
        groupData = parsedData.filter(d => 
          selectedGroup.categories.some(cat => d.categories.includes(cat))
        );
        
        // Create label based on the most vulnerable group characteristics
        const hasHighPoverty = selectedGroup.categories.includes("poverty3");
        const hasNoEducation = selectedGroup.categories.includes("education1");
        
        if (hasHighPoverty && hasNoEducation) {
          groupLabel = "high poverty no primary education";
        } else if (hasHighPoverty) {
          groupLabel = "high poverty populations";
        } else if (hasNoEducation) {
          groupLabel = "no primary education populations";
        } else {
          groupLabel = "vulnerable populations";
        }
      }
    }
  }

  if (groupData.length === 0) {
    return createNoDataState("No data available for the selected group.");
  }

  // Calculate statistics for the selected group
  const totalGroupValue = d3.sum(groupData, d => d.value);

  // Calculate total population for percentage calculations
  const totalPopulation = d3.sum(parsedData, d => d.value);
  const groupPercentage = totalPopulation > 0 ? ((totalGroupValue / totalPopulation) * 100).toFixed(1) : "0.0";

  // Calculate gender distribution in the selected group
  const maleData = groupData.filter(d => d.categories.includes("gender0"));
  const femaleData = groupData.filter(d => d.categories.includes("gender1"));
  
  const maleValue = d3.sum(maleData, d => d.value);
  const femaleValue = d3.sum(femaleData, d => d.value);
  const totalGenderValue = maleValue + femaleValue;
  
  // Only show gender distribution if the selected group contains both genders
  let genderDistribution = "";
  if (maleValue > 0 && femaleValue > 0) {
    const malePercentage = ((maleValue / totalGenderValue) * 100).toFixed(1);
    const femalePercentage = ((femaleValue / totalGenderValue) * 100).toFixed(1);
    genderDistribution = ` Within this group: ${malePercentage}% male, ${femalePercentage}% female.`;
  } else if (maleValue > 0) {
    genderDistribution = ` This group is entirely male.`;
  } else if (femaleValue > 0) {
    genderDistribution = ` This group is entirely female.`;
  }

  // Calculate education and poverty differences between genders across ALL data (not just selected group)
  let educationComparison = "";
  let povertyComparison = "";
  
  // Get all male and female data for comparison
  const allMaleData = parsedData.filter(d => d.categories.includes("gender0"));
  const allFemaleData = parsedData.filter(d => d.categories.includes("gender1"));
  
  const allMaleValue = d3.sum(allMaleData, d => d.value);
  const allFemaleValue = d3.sum(allFemaleData, d => d.value);
  
  if (allMaleValue > 0 && allFemaleValue > 0) {
    // Education comparison - calculate rates within each gender across all education levels
    const maleEducation1 = allMaleData.filter(d => d.categories.includes("education1"));
    const maleEducation2 = allMaleData.filter(d => d.categories.includes("education2"));
    const maleEducation3 = allMaleData.filter(d => d.categories.includes("education3"));
    
    const femaleEducation1 = allFemaleData.filter(d => d.categories.includes("education1"));
    const femaleEducation2 = allFemaleData.filter(d => d.categories.includes("education2"));
    const femaleEducation3 = allFemaleData.filter(d => d.categories.includes("education3"));
    
    const maleEducation1Value = d3.sum(maleEducation1, d => d.value);
    const maleEducation2Value = d3.sum(maleEducation2, d => d.value);
    const maleEducation3Value = d3.sum(maleEducation3, d => d.value);
    
    const femaleEducation1Value = d3.sum(femaleEducation1, d => d.value);
    const femaleEducation2Value = d3.sum(femaleEducation2, d => d.value);
    const femaleEducation3Value = d3.sum(femaleEducation3, d => d.value);
    
    // Calculate no primary education rates (education1 = no primary)
    const maleNoPrimaryRate = (maleEducation1Value / allMaleValue * 100).toFixed(1);
    const femaleNoPrimaryRate = (femaleEducation1Value / allFemaleValue * 100).toFixed(1);
    
    educationComparison = ` No primary education rates: ${maleNoPrimaryRate}% for men, ${femaleNoPrimaryRate}% for women.`;
    
    // Poverty comparison - calculate rates within each gender across all poverty levels
    const malePoverty1 = allMaleData.filter(d => d.categories.includes("poverty1"));
    const malePoverty2 = allMaleData.filter(d => d.categories.includes("poverty2"));
    const malePoverty3 = allMaleData.filter(d => d.categories.includes("poverty3"));
    
    const femalePoverty1 = allFemaleData.filter(d => d.categories.includes("poverty1"));
    const femalePoverty2 = allFemaleData.filter(d => d.categories.includes("poverty2"));
    const femalePoverty3 = allFemaleData.filter(d => d.categories.includes("poverty3"));
    
    const malePoverty1Value = d3.sum(malePoverty1, d => d.value);
    const malePoverty2Value = d3.sum(malePoverty2, d => d.value);
    const malePoverty3Value = d3.sum(malePoverty3, d => d.value);
    
    const femalePoverty1Value = d3.sum(femalePoverty1, d => d.value);
    const femalePoverty2Value = d3.sum(femalePoverty2, d => d.value);
    const femalePoverty3Value = d3.sum(femalePoverty3, d => d.value);
    
    // Calculate moderate poverty rates (poverty2 = moderate)
    const maleModeratePovertyRate = (malePoverty2Value / allMaleValue * 100).toFixed(1);
    const femaleModeratePovertyRate = (femalePoverty2Value / allFemaleValue * 100).toFixed(1);
    
    povertyComparison = ` Moderate poverty rates: ${maleModeratePovertyRate}% for men, ${femaleModeratePovertyRate}% for women.`;
  }

  // Create the insight text with gender breakdown
  let insightText;
  if (icicle.sequence && icicle.sequence.length > 0) {
    // Active selection - show data for the selected group
    insightText = `In ${region}, ${groupLabel} represent ${groupPercentage}% of the population.${genderDistribution}${educationComparison}${povertyComparison}`;
  } else {
    // No selection - show data for the most vulnerable group
    insightText = `In ${region}, the most vulnerable group (${groupLabel}) represents ${groupPercentage}% of the population.${genderDistribution}${educationComparison}${povertyComparison}`;
  }

  return createInsightDisplay(insightText);
}
```



