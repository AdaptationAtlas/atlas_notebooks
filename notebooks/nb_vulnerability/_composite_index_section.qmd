---
module: "Where are investments needed?"
nb-authors:
  - Johnson Mwakazi
  - Brayden Youngberg
  - Pete Stewart
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
compositeQuestion = _lang(vulnerability_translations.composite_question);
```

# `{ojs} compositeQuestion` {#composite-index}

`{ojs} _lang(vulnerability_translations.composite_description)`

```{ojs}
createGeographicControlsForm();

viewof compositeView = Inputs.radio(["map", "table"], {
  label: "View Type",
  value: "map",
});
```

```{ojs}
{
  if (compositeView === "map") {
    return generateCompositeMap();
  } else {
    return filterableDataTable(longIndexData());
  }
}
```

```{ojs}
// Download button for composite index data
viewof compositeDownloadButton = {
  const region = getAdminNameString().replace(", ", "_");
  
  return downloadButton(
     longIndexData(), 
    `composite_vulnerability_data_${region}`,
    _lang({en: "Download Composite Index Data", fr: "Télécharger les Données de l'Indice Composite"})
  );
}
```

## `{ojs} _lang(vulnerability_translations.composite_insights_title)`

`{ojs} compositeVulnerabilityInsights`

<!-- Backend Code -->

```{ojs}
sensitivityMetadata = await FileAttachment(
  "/data/vulnerability_notebook/urgency_metadata.json",
).json();
```

```{ojs}
/**
 * Compute index from normalized values by averaging all _norm columns
 * Used for vulnerability index calculations (ND-Gain methodology)
 *
 * @param {Object} row - Data row with normalized columns ending in "_norm"
 * @returns {number|null} Average of all normalized values, or null if none found
 */
function computeIndex(row) {
  const normValues = Object.entries(row)
    .filter(
      ([key, value]) =>
        key.endsWith("_norm") && typeof value === "number" && !isNaN(value),
    )
    .map(([, value]) => value);

  if (normValues.length === 0) return null;

  const sum = normValues.reduce((a, b) => a + b, 0);
  return sum / normValues.length;
}

/**
 * Generate SQL WHERE clause for admin level filtering
 * Returns clause to filter by admin0 (country level) or admin1 (region level) based on selection
 *
 * @param {string|null} country_sel - Selected country code (or "SSA" for all countries)
 * @param {string|null} admin1_sel - Selected admin1 region (currently unused but kept for consistency)
 * @returns {string} SQL WHERE clause fragment
 */
whereAdminNull = (country_sel, admin1_sel, admin2_sel) => {
  // If all countries selected (SSA) or no selection, return country-level data (admin1_name IS NULL)
  // Otherwise, return region-level data (admin1_name IS NOT NULL)
  if (country_sel == "SSA" || !country_sel) {
    return `admin1_name IS NULL`;
  } else if (country_sel && !admin1_sel) {
    return `admin1_name IS NOT NULL AND admin2_name IS NULL`;
  } else {
    return `admin2_name IS NOT NULL`;
  }
};
```

```{ojs}
// Calculate exposure index
exposure_index = {
  try {
    return await localDb.query(`
      WITH raw_exposure AS (
          SELECT 
            admin0_name,
            admin1_name,
            admin2_name,
            SUM(value) AS total_exposure
          FROM exposure
          WHERE isfinite(value)
            AND ${whereAdminNull(
              cleanAdminInput_SQL(admin0Select?.admin0_name),
              cleanAdminInput_SQL(admin1Select?.admin1_name),
              cleanAdminInput_SQL(admin2Select?.admin2_name)
            )}
            AND admin0_name NOT IN ('${removals.join("', '")}')
          GROUP BY admin0_name, admin1_name, admin2_name
        ),
        stats AS (
          SELECT
            MIN(total_exposure) AS exposure_min,
            MAX(total_exposure) AS exposure_max
          FROM raw_exposure
          WHERE ISFINITE(total_exposure)
        )
        SELECT 
          r.admin0_name,
          r.admin1_name,
          r.admin2_name,
          r.total_exposure,
          -- Min-max normalize exposure
          (r.total_exposure - s.exposure_min) / NULLIF(s.exposure_max - s.exposure_min, 0) AS exposure_norm
        FROM raw_exposure r
        CROSS JOIN stats s
        WHERE ISFINITE(r.total_exposure)
        ORDER BY r.total_exposure DESC;
    `);
  } catch (error) {
    console.error("Failed to calculate exposure index:", error);
    return [];
  }
}
```

```{ojs}
// Calculate enabling index (adaptive capacity)
enabling_index = {
  try {
    let resp = await localDb.query(`
SELECT *
FROM enabling
WHERE admin0_name != 'SSA'
  AND ${sqlAdminQuery()}
`);

    return resp.map((row) => ({
      ...row,
      enabling_index: computeIndex(row)
    }));
  } catch (error) {
    console.error("Failed to calculate enabling index:", error);
    return [];
  }
}
```

```{ojs}
// Calculate urgency index
// Index is based on exposure and sensitivity
urgency_index = {
  try {
    let gender = "total"; //NOTE: Keeping this as an option in case future updates want gender specific index
    // sensitivity data
    let sensitivityData = await localDb.query(`
      SELECT *
      FROM urgency
      WHERE admin0_name != 'SSA'
        AND gender = '${gender}'
        AND ${sqlAdminQuery()}
    `);

    // Check if exposure_index exists and is an array before using
    const exposureMap = (exposure_index && Array.isArray(exposure_index))
      ? Object.fromEntries(
          exposure_index.map((d) => {
            const key = `${d.admin0_name}|${d.admin1_name}|${d.admin2_name}`;
            return [key, d.exposure_norm];
          })
        )
      : {};

    // merge into urgencyData
    const merged = sensitivityData.map((d) => {
      const key = `${d.admin0_name}|${d.admin1_name}|${d.admin2_name}`

      return {
        ...d,
        exposure_norm: exposureMap[key] ?? null
      };
    });

    return merged.map(row => {
      const urgency_index = computeIndex(row);

      const drivers = [
        ["exposure", row.exposure_norm],
        ["population_density", row.population_dens_norm],
        ["education", row.education_norm],
        ["poverty", row.poverty_norm]
      ];

      const urgency_driver = drivers.reduce((max, current) =>
        current[1] > max[1] ? current : max
      )[0];

      return {
        ...row,
        urgency_index,
        urgency_driver
      };
    });
  } catch (error) {
    console.error("Failed to calculate urgency index:", error);
    return [];
  }
}
```

```{ojs}
// Calculate vulnerability index (AKA composite index with ND-gain Methodology)
vulnerabilityIndex = {
  const key = (r) => `${r.admin0_name}|${r.admin1_name}|${r.admin2_name}`;
  const parse = (v) => v === "null" ? null : v;
  const toMap = (arr, k, v) => Object.fromEntries(arr.map((r) => [k(r), v(r)]));

  const uMap = toMap(urgency_index, key, (r) => r.urgency_index);
  const enMap = toMap(enabling_index, key, (r) => r.enabling_index);

  const allKeys = new Set([...Object.keys(enMap), ...Object.keys(uMap)]);

  const merged = [...allKeys].map((k) => {
    const [admin0_name, admin1_name, admin2_name] = k.split("|");
    const en = enMap[k],
      u = uMap[k];
    return {
      admin0_name,
      admin1_name: parse(admin1_name),
      admin2_name: parse(admin2_name),
      enabling_index: en ?? null,
      urgency_index: u ?? null,
      gap: en - u,
      vulnerability:
        typeof en === "number" && typeof u === "number"
          ? 100 - (en - u + 1) * 50
          : null
    };
  });

  const metrics = [
    ["vulnerability", "vuln_rank"],
    ["urgency_index", "urgency_rank"],
    ["enabling_index", "enabling_rank"]
  ];

  metrics.forEach(([key, rankField]) => {
    [...merged]
      .sort((a, b) => b[key] - a[key])
      .forEach((d, i) => d[rankField] = i + 1);
  });

  return merged.sort((a, b) => b.vulnerability - a.vulnerability);
}
```

```{ojs}
indexByAdmin = (data) => Object.fromEntries(data.map((d) => [adminKey(d), d]));

adminFilter = (row) => {
  const admin0 = admin0Select?.admin0_name;
  const admin1 = admin1Select?.admin1_name;

  return (
    // admin0 condition
    (admin0 ? row.admin0_name === admin0 : row.admin1_name == null) &&
    // admin1 condition
    (admin1 ? row.admin1_name === admin1 : row.admin2_name == null) &&
    // admin2 existence condition
    (!admin1 || row.admin2_name != null)
  );
};
```

```{ojs}
compositeGeoData = {
  const vulnerabilityByAdmin = indexByAdmin(vulnerabilityIndex);
  const filteredExposure = exposure_index.filter(adminFilter);

  const compiled = filteredExposure.map((row) => {
    const key = adminKey(row);
    const vuln = vulnerabilityByAdmin[key]?.vulnerability ?? null;

    return {
      admin0_name: row.admin0_name,
      admin1_name: row.admin1_name,
      admin2_name: row.admin2_name,

      exposure_index: row.exposure_norm ?? null,
      enabling_index: vulnerabilityByAdmin[key]?.enabling_index ?? null,
      urgency_index: vulnerabilityByAdmin[key]?.urgency_index ?? null,
      vulnerability_index: vuln,
      composite_index: vuln != null ? vuln / 100 : null
    };
  });

  return mergeDataToBoundaries({
    boundaries: filteredBoundaries(),
    data: compiled,
    boundaryKey: (feature) => adminKey(feature.properties),
    dataKey: adminKey,
    dataProp: "data",
    defaultValue: null,
  });
}
```

```{ojs}
generateCompositeMap = () => {
  // Layout
  const totalWidth = typeof width === "number" ? Math.min(1200, width) : 1000;
  const totalHeight = 600;
  const gap = 12;
  const compositeRatio = 2.2;
  const componentRatio = 1;

  const compositeWidth = Math.floor(
    totalWidth * (compositeRatio / (compositeRatio + componentRatio)),
  );
  const componentWidth = Math.floor(
    totalWidth * (componentRatio / (compositeRatio + componentRatio)),
  );
  const componentHeight = Math.floor((totalHeight - gap * 2) / 3);
  const compositeHeight = componentHeight * 3 + gap * 2 + 80;

  const components = [
    {
      key: "composite_index",
      label: _lang({ en: "Vulnerability", fr: "Vulnérabilité" }),
      invert: false,
      featured: true,
    },
    {
      key: "exposure_index",
      label: _lang({ en: "Exposure", fr: "Exposition" }),
    },
    { key: "urgency_index", label: _lang({ en: "Urgency", fr: "Urgence" }) },
    {
      key: "enabling_index",
      label: _lang({ en: "Adaptive Capacity", fr: "Capacité d’Adaptation" }),
      invert: true,
    },
  ];

  const renderComponentMap = (component, width, height) =>
    renderGeoMap({
      features: compositeGeoData.features,
      width,
      height,
      valueAccessor: (d) => d.properties.data?.[component.key],
      color: {
        type: "linear",
        range: component.invert
          ? ["#216729", "#F7D732"]
          : ["#F4BB21", "#EC5A47"],
        legend: true,
        label: component.label,
      },
      tooltip: {
        channels: {
          country: {
            label: _lang({ en: "Country", fr: "Pays" }),
            value: (d) => d.properties.admin0_name,
          },
          region: {
            label: _lang({ en: "Region", fr: "Région" }),
            value: (d) =>
              d.properties.admin2_name
                ? `${d.properties.admin2_name}, ${d.properties.admin1_name}`
                : d.properties.admin1_name,
          },
          score: {
            label: _lang({ en: "Score", fr: "Score" }),
            value: (d) => {
              const v = d.properties.data?.[component.key];
              return v != null
                ? v.toFixed(3)
                : _lang({ en: "No data", fr: "Pas de données" });
            },
          },
        },
      },
      extraMarks: [
        Plot.geo(
          admin2Select?.admin2_name
            ? compositeGeoData.features.filter(
                (d) => d.properties.admin2_name === admin2Select?.admin2_name,
              )
            : [],
          {
            fill: null,
            stroke: "#333",
            strokeWidth: 1.5,
          },
        ),
      ],
    });

  const featured = components.find((c) => c.featured);
  const secondary = components.filter((c) => !c.featured);

  const featuredMap = renderComponentMap(
    featured,
    compositeWidth,
    compositeHeight,
  );
  const secondaryMaps = secondary.map((c) =>
    renderComponentMap(c, componentWidth, componentHeight),
  );

  return htl.html`
    <div style="display:flex; flex-direction:column; gap:20px; width:100%;">
      <div style="
        display:grid;
        grid-template-columns:${compositeRatio}fr ${componentRatio}fr;
        gap:${gap}px;
      ">
        <div>${featuredMap}</div>
        <div style="display:flex; flex-direction:column; gap:${gap}px;">
          ${secondaryMaps}
        </div>
      </div>
    </div>
  `;
};
```

```{ojs}
// Dynamic Insights following wireframe template
compositeVulnerabilityInsights = {
  const numHotspots = 6;
  const templateGroup = vulnerability_translations.composite_insight.most_vulnerable
  const parent = getAdminNameString()
  const intro = Lang.reduceReplaceTemplateItems(_lang(templateGroup.intro), [{ name: "parent", value: parent }])

  const topHotspots = [...vulnerabilityIndex].slice(0, numHotspots);
  const numRegions = vulnerabilityIndex.length

  const hotspotInsights = topHotspots.map(d => {
    const gapDirection = d.gap < 0 ? "below" : "above";

    const adminName = d.admin2_name ?? d.admin1_name ?? d.admin0_name

    let structural_balance;
    if (d.gap < 0) structural_balance = "structural deficit";
    else if (d.gap < 0.15) structural_balance = "thin resilience buffer";
    else if (d.gap < 0.35) structural_balance = "moderate resilience buffer";
    else structural_balance = "strong resilience buffer";

    const insight = Lang.reduceReplaceTemplateItems(
      _lang(templateGroup.vulnerable_region),
      [
        { name: "admin", value: adminName },
        { name: "vuln_rank", value: d.vuln_rank },
        { name: "urgency_rank", value: d.urgency_rank },
        { name: "enabling_rank", value: d.enabling_rank },
        { name: "num_regions", value: numRegions },
        { name: "gapDirection", value: gapDirection },
        { name: "structural_balance", value: structural_balance }
      ]
    );
    return `- ${insight}`
  });

  return createInsightDisplay(md`${intro} \n ${hotspotInsights.join("\n\n")}`);
};
```

```{ojs}
longIndexData = () => {
  const GROUPS = {
    exposure: {
      source: exposure_index,
      variables: ["total_exposure"],
    },

    urgency: {
      source: urgency_index,
      variables: ["population_dens", "education", "poverty"],
    },

    adaptive_capacity: {
      source: enabling_index,
      variables: [
        "pct_electric",
        "pct_piped_water",
        "min_to_cities",
        "conflict_density",
        "pct_cellphone",
      ],
    },

    vulnerability: {
      source: vulnerabilityIndex,
      variables: ["vulnerability", "enabling_index", "urgency_index"],
      derived: (row) => ({
        vulnerability_norm:
          row.vulnerability != null ? row.vulnerability / 100 : null,
      }),
    },
  };

  const filteredExposure = exposure_index.filter(adminFilter);

  // use exposure as the spine for which admins to include
  const admins = filteredExposure.map((d) => ({
    admin0_name: d.admin0_name,
    admin1_name: d.admin1_name,
    admin2_name: d.admin2_name,
  }));

  // index all sources by admin
  const indexedSources = Object.fromEntries(
    Object.entries(GROUPS).map(([group, cfg]) => [
      group,
      indexByAdmin(cfg.source),
    ]),
  );

  const longData = admins.flatMap((admin) => {
    const key = adminKey(admin);

    return Object.entries(GROUPS).flatMap(([group, cfg]) => {
      const row = indexedSources[group][key] ?? {};

      // base variables
      const baseRows = cfg.variables.map((variable) => ({
        ...admin,
        group,
        variable,
        value: row[variable] ?? null,
      }));

      // derived variables (only vulnerability_norm for now)
      const derivedRows = cfg.derived
        ? Object.entries(cfg.derived(row)).map(([variable, value]) => ({
            ...admin,
            group,
            variable,
            value,
          }))
        : [];

      return [...baseRows, ...derivedRows];
    });
  });

  return longData;
};
```
