---
pagetitle: "Where are investments needed?"
nb-authors:
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: '2025-02-19'
date-edited: today
---

# `{ojs} _lang(vulnerability_translations.composite_question)`

`{ojs} _lang(vulnerability_translations.composite_description)`

```{ojs}
// Admin selectors using static data to prevent flickering
viewof compositeAdmin0 = Inputs.select(compositeDataAdmin0, {label: adminRegions.labels.admin0, format: x => x.label})
viewof compositeAdmin1 = Inputs.select(compositeDataAdmin1, {label: adminRegions.labels.admin1, format: x => x.label})
viewof compositeAdmin2 = Inputs.select(compositeDataAdmin2, {label: adminRegions.labels.admin2, format: x => x.label})

// Component selection
viewof compositeSelectedComponent = Inputs.select(
  [
    { value: "composite", label: _lang({en: "Composite Vulnerability", fr: "Vulnérabilité Composite"}) },
    { value: "exposure", label: _lang({en: "Exposure", fr: "Exposition"}) },
    { value: "sensitivity", label: _lang({en: "Sensitivity", fr: "Sensibilité"}) },
    { value: "adaptive_capacity", label: _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}) }
  ],
  {
    label: _lang({en: "Component Selection", fr: "Sélection de Composant"}),
    format: x => x.label,
    value: { value: "composite", label: _lang({en: "Composite Vulnerability", fr: "Vulnérabilité Composite"}) }
  }
)
```

```{ojs}
// Controls form with exact same HTML structure
compositeControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: nowrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px;">${viewof compositeAdmin0}</div>
    <div style="flex: 1; min-width: 180px;">${viewof compositeAdmin1}</div>
    <div style="flex: 1; min-width: 180px;">${viewof compositeAdmin2}</div>
  </div>
  <div style="margin-top: 16px;">
    <div style="flex: 1; min-width: 200px;">${viewof compositeSelectedComponent}</div>
  </div>
</div>
`
```

```{ojs}
// Note about on-the-fly calculation
htl.html`<div style="background: #f0f7ff; padding: 12px; border-radius: 8px; margin: 16px 0; border-left: 4px solid #2563eb;">
  <p style="margin: 0; font-size: 14px; color: #1e40af;">
    <strong>${_lang({ en: "Note", fr: "Note" })}:</strong> ${_lang({
			en: "This index is calculated on-the-fly within the notebook to allow greater flexibility.",
			fr: "Cet indice est calculé à la volée dans le notebook pour permettre une plus grande flexibilité.",
		})}
  </p>
</div>`;
```

```{ojs}
// Load exposure data (reuse from exposure section)
// Note: The file is NDJSON format (newline-delimited JSON)
exposureComponentData = {
  const text = await FileAttachment("/data/vulnerability_notebook/notebook_exposure.json").text();
  return text.trim().split('\n').map(line => JSON.parse(line));
}
```

```{ojs}
// Load adaptive capacity data (reuse from adaptive capacity section)
adaptiveCapacityComponentData = await FileAttachment(
	"/data/vulnerability_notebook/enabling_vars.csv",
).csv({ typed: true });
```

```{ojs}
// Load sensitivity/urgency data
sensitivityComponentData = await FileAttachment(
	"/data/vulnerability_notebook/urgency.csv",
).csv({ typed: true });
sensitivityMetadata = await FileAttachment(
	"/data/vulnerability_notebook/urgency_metadata.json",
).json();
```

```{ojs}
// Load geographic boundaries for composite maps
compositeMapBoundaries = {
  const input0 = await FileAttachment("/data/shared/atlas_gaul_a0_africa_simple-vlowres.topojson").json()
  const input1 = await FileAttachment("/data/shared/atlas_gaul_a1_africa_simple-vlowres.topojson").json()
  const input2 = await FileAttachment("/data/shared/atlas_gaul_a2_africa_simple-lowres.topojson").json()

  const geo = {
    admin0: {
      ...topojson.feature(input0, input0.objects["atlas_gaul24_a0_africa"]),
      features: topojson.feature(input0, input0.objects["atlas_gaul24_a0_africa"]).features//.filter(feature => feature.properties.admin0_name !== "Sudan")
    },
    admin1: {
      ...topojson.feature(input1, input1.objects["atlas_gaul_a1_africa"]),
      features: topojson.feature(input1, input1.objects["atlas_gaul_a1_africa"]).features//.filter(feature => feature.properties.admin0_name !== "Sudan")
    },
    admin2: {
      ...topojson.feature(input2, input2.objects["atlas_gaul_a2_africa_simple-lowres"]),
      features: topojson.feature(input2, input2.objects["atlas_gaul_a2_africa_simple-lowres"]).features//.filter(feature => feature.properties.admin0_name !== "Sudan")
    }
  }
  
  return geo
}
```

```{ojs}
// Get current admin selections
compositeAdminSelections = {
  return {
    selectAdmin0: compositeAdmin0?.value || null,
    selectAdmin1: compositeAdmin1?.value || null,
    selectAdmin2: compositeAdmin2?.value || null
  }
}
```

```{ojs}
// Calculate vulnerability scores for each geographic region
componentIndicesPerRegion = {
  const selections = compositeAdminSelections;
  const isNull = (val) => val === null || val === undefined || val === "" || val === "\\N";
  
  // Determine admin level and get unique regions
  let adminLevel, regions;
  if (!selections.selectAdmin0 || selections.selectAdmin0 === "SSA") {
    // Show all countries (admin0 level)
    adminLevel = "admin0_name";
    regions = [...new Set(adaptiveCapacityComponentData.map(d => d.admin0_name).filter(d => d))];
  } else if (!selections.selectAdmin1) {
    // Show admin1 within selected country
    adminLevel = "admin1_name";
    regions = [...new Set(adaptiveCapacityComponentData
      .filter(d => d.admin0_name === selections.selectAdmin0 && !isNull(d.admin1_name))
      .map(d => d.admin1_name))];
  } else if (!selections.selectAdmin2) {
    // Show admin2 within selected admin1
    adminLevel = "admin2_name";
    regions = [...new Set(adaptiveCapacityComponentData
      .filter(d => d.admin0_name === selections.selectAdmin0 && 
                   d.admin1_name === selections.selectAdmin1 && 
                   !isNull(d.admin2_name))
      .map(d => d.admin2_name))];
  } else {
    // Single admin2 selected
    adminLevel = "admin2_name";
    regions = [selections.selectAdmin2];
  }

  // Calculate scores for each region
  const regionScores = {};
  const maxExposure = d3.max(exposureComponentData, d => d.value || 0) || 1;

  regions.forEach(region => {
    // Filter data for this specific region
    const exposureData = exposureComponentData.filter(d => d[adminLevel] === region);
    const sensitivityData = sensitivityComponentData.filter(d => 
      d[adminLevel] === region && d.gender === "total"
    );
    const adaptiveData = adaptiveCapacityComponentData.filter(d => d[adminLevel] === region);

    // Calculate exposure score
    let exposureScore = 0;
    if (exposureData.length > 0) {
      const totalExposure = d3.sum(exposureData, d => d.value || 0);
      exposureScore = Math.min(totalExposure / maxExposure, 1);
    }

    // Calculate sensitivity score
    let sensitivityScore = 0;
    if (sensitivityData.length > 0) {
      const avgPoverty = d3.mean(sensitivityData, d => d.poverty || 0);
      const avgEducation = d3.mean(sensitivityData, d => d.education || 0);
      
      const povNorm = Math.min(avgPoverty / sensitivityMetadata.poverty.thresholds.high, 1);
      const eduNorm = Math.min((9 - avgEducation) / 7, 1);
      
      sensitivityScore = (povNorm + eduNorm) / 2;
    }

    // Calculate adaptive capacity score
    let adaptiveScore = 0;
    if (adaptiveData.length > 0) {
      const totalPop = d3.sum(adaptiveData, d => d.total_pop || 0);
      const totalElectricPop = d3.sum(adaptiveData, d => (d.total_pop || 0) - (d.no_electric_pop || 0));
      
      const electricAccess = totalPop > 0 ? (totalElectricPop / totalPop) : 0;
      const internetSpeed = d3.mean(adaptiveData, d => d.inet_d_kbps || 0);
      const waterAccess = d3.mean(adaptiveData, d => d.pct_piped_water || 0) / 100;
      const travelTime = d3.mean(adaptiveData, d => d.min_to_cities || 0);
      const conflictDensity = d3.mean(adaptiveData, d => d.conflict_density || 0);
      
      const electricNorm = 1 - Math.min(electricAccess, 1);
      const internetNorm = 1 - Math.min(internetSpeed / 10000, 1);
      const waterNorm = 1 - Math.min(waterAccess, 1);
      const accessNorm = Math.min(travelTime / 180, 1);
      const conflictNorm = Math.min(conflictDensity * 1000, 1);
      
      adaptiveScore = (electricNorm + internetNorm + waterNorm + accessNorm + conflictNorm) / 5;
    }

    // Calculate composite score
    const compositeScore = (exposureScore + sensitivityScore + adaptiveScore) / 3;

    regionScores[region] = {
      exposure: exposureScore,
      sensitivity: sensitivityScore,
      adaptive_capacity: adaptiveScore,
      composite: compositeScore
    };
  });

  return { 
    scores: regionScores, 
    adminLevel: adminLevel,
    regions: regions
  };
}
```

```{ojs}
// Small Multiples/Faceted Maps Visualization 
compositeVulnerabilityMaps = {
  if (!componentIndicesPerRegion || !componentIndicesPerRegion.scores) {
    return htl.html`<div style="padding: 40px; text-align: center; color: #6b7280;">
      ${_lang(vulnerability_translations.no_data_available)}
    </div>`;
  }

  const { scores, adminLevel } = componentIndicesPerRegion;
  const selections = compositeAdminSelections;
  
  // Get the appropriate boundary level
  let boundaries;
  if (adminLevel === "admin0_name") {
    boundaries = compositeMapBoundaries.admin0;
  } else if (adminLevel === "admin1_name") {
    boundaries = {
      ...compositeMapBoundaries.admin1,
      features: compositeMapBoundaries.admin1.features.filter(
        d => d.properties.admin0_name === selections.selectAdmin0
      )
    };
  } else {
    boundaries = {
      ...compositeMapBoundaries.admin2,
      features: compositeMapBoundaries.admin2.features.filter(
        d => d.properties.admin0_name === selections.selectAdmin0 && 
            d.properties.admin1_name === selections.selectAdmin1
      )
    };
  }

  // Define the components to show based on selection
  const showAllComponents = compositeSelectedComponent.value === "composite";
  const components = showAllComponents ? [
    { key: "composite", label: _lang({en: "Composite", fr: "Composite"}), scheme: "Reds", isComposite: true },
    { key: "exposure", label: _lang({en: "Exposure", fr: "Exposition"}), scheme: "Oranges", isComposite: false },
    { key: "sensitivity", label: _lang({en: "Sensitivity", fr: "Sensibilité"}), scheme: "Purples", isComposite: false },
    { key: "adaptive_capacity", label: _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}), scheme: "Greens", isComposite: false }
  ] : [{
    key: compositeSelectedComponent.value,
    label: compositeSelectedComponent.label,
    scheme: "Reds",
    isComposite: false
  }];

  // Calculate subplot dimensions
  const totalWidth = 900;
  const totalHeight = showAllComponents ? 600 : 300;
  
  // Create individual maps for each component
  const maps = components.map((component, index) => {
    // Create features for this component
    const componentFeatures = boundaries.features.map(feature => {
      const regionName = feature.properties[adminLevel];
      const regionScores = scores[regionName] || { 
        exposure: 0, sensitivity: 0, adaptive_capacity: 0, composite: 0 
      };
      
      return {
        ...feature,
        properties: {
          ...feature.properties,
          vulnerability: regionScores[component.key] || 0,
          regionName: regionName
        }
      };
    });

    // Calculate map dimensions based on component type
    const mapWidth = component.isComposite ? totalWidth : Math.floor(totalWidth / 3);
    const mapHeight = component.isComposite ? 300 : 250;

    return Plot.plot({
      width: mapWidth,
      height: mapHeight,
      projection: {
        type: "azimuthal-equal-area",
        domain: { type: "FeatureCollection", features: componentFeatures }
      },
      color: {
        type: "linear",
        range: ["#F7D732", "#EC5A47"], // Yellow to red for vulnerability
        domain: [0, 1],
        legend: false // Remove legend from individual maps
      },
      marks: [
        // Geographic boundaries with vulnerability coloring
        Plot.geo(componentFeatures, {
          fill: d => d.properties.vulnerability,
          stroke: "#fff",
          strokeWidth: 0.5,
          channels: {
            [_lang({en: "Region", fr: "Région"})]: d => d.properties.regionName,
            [_lang({en: "Component", fr: "Composant"})]: component.label,
            [_lang({en: "Score", fr: "Score"})]: d => d.properties.vulnerability ? d.properties.vulnerability.toFixed(3) : "No data"
          },
          tip: true
        })
      ]
    });
  });

  // Create a custom HTML legend for better centering control
  const customLegend = htl.html`
    <div style="
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 400px;
    ">
      <div style="
        font-size: 14px;
        font-weight: 600;
        color: #374151;
        margin-bottom: 12px;
        text-align: center;
      ">${_lang({en: "Vulnerability Score", fr: "Score de Vulnérabilité"})}</div>
      <div style="
        display: flex;
        align-items: center;
        gap: 8px;
        width: 100%;
        max-width: 300px;
      ">
        <span style="font-size: 12px; color: #6b7280;">0</span>
        <div style="
          flex: 1;
          height: 20px;
          background: linear-gradient(to right, #F7D732, #EC5A47);
          border-radius: 10px;
          position: relative;
        "></div>
        <span style="font-size: 12px; color: #6b7280;">1</span>
      </div>
    </div>
  `;

  // Separate composite and component maps
  const compositeMap = showAllComponents ? maps[0] : null;
  const componentMaps = showAllComponents ? maps.slice(1) : maps;

  // Return maps in a custom layout with labels and external legend
  return htl.html`
    <div style="
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      width: ${totalWidth}px;
      padding: 16px;
      background: #f8fafc;
      border-radius: 8px;
    ">
      <!-- Legend at the top -->
      <div style="
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
        padding: 10px;
      ">
        ${customLegend}
      </div>
      
      ${showAllComponents ? htl.html`
        <!-- Composite map - full width -->
        <div style="
          display: flex;
          flex-direction: column;
          align-items: center;
          width: 100%;
          margin-bottom: 20px;
        ">
          <h4 style="
            margin: 0 0 8px 0; 
            font-size: 18px; 
            font-weight: bold; 
            color: #1f2937; 
            text-align: center;
          ">${components[0].label}</h4>
          <div>${compositeMap}</div>
        </div>
        
        <!-- Component maps - 3 in a row -->
        <div style="
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          gap: 16px;
          width: 100%;
        ">
          ${componentMaps.map((map, index) => htl.html`
            <div style="display: flex; flex-direction: column; align-items: center;">
              <h4 style="
                margin: 0 0 8px 0; 
                font-size: 16px; 
                font-weight: bold; 
                color: #1f2937; 
                text-align: center;
              ">${components[index + 1].label}</h4>
              <div>${map}</div>
            </div>
          `)}
        </div>
      ` : htl.html`
        <!-- Single component map -->
        <div style="
          display: flex;
          flex-direction: column;
          align-items: center;
          width: 100%;
        ">
          <h4 style="
            margin: 0 0 8px 0; 
            font-size: 18px; 
            font-weight: bold; 
            color: #1f2937; 
            text-align: center;
          ">${components[0].label}</h4>
          <div>${componentMaps[0]}</div>
        </div>
      `}
    </div>
  `;
}
```

```{ojs}
// Dynamic Insights following wireframe template
compositeVulnerabilityInsights = {
  if (!componentIndicesPerRegion || !componentIndicesPerRegion.scores) {
    return createNoDataState();
  }

  const selections = compositeAdminSelections;
  const { scores, adminLevel } = componentIndicesPerRegion;
  
  // Get region name for insight
  let regionName;
  if (!selections.selectAdmin0 || selections.selectAdmin0 === "SSA") {
    regionName = "Sub-Saharan Africa";
  } else if (!selections.selectAdmin1) {
    regionName = selections.selectAdmin0;
  } else if (!selections.selectAdmin2) {
    regionName = selections.selectAdmin1;
  } else {
    regionName = selections.selectAdmin2;
  }
  
  // Calculate average scores across all regions for this level
  const regions = Object.keys(scores);
  const avgScores = {
    composite: d3.mean(regions, r => scores[r].composite),
    exposure: d3.mean(regions, r => scores[r].exposure),
    sensitivity: d3.mean(regions, r => scores[r].sensitivity),
    adaptive_capacity: d3.mean(regions, r => scores[r].adaptive_capacity)
  };
  
  // Determine vulnerability level
  const vulnLevel = avgScores.composite > 0.7 ? 
    _lang({en: "high", fr: "élevé"}) : 
    avgScores.composite > 0.4 ? 
    _lang({en: "moderate", fr: "modéré"}) : 
    _lang({en: "low", fr: "faible"});
  
  // Identify main drivers
  const drivers = [];
  if (avgScores.exposure > 0.6) drivers.push(_lang({en: "high exposure", fr: "exposition élevée"}));
  if (avgScores.sensitivity > 0.6) drivers.push(_lang({en: "high sensitivity", fr: "sensibilité élevée"}));  
  if (avgScores.adaptive_capacity > 0.6) drivers.push(_lang({en: "limited adaptive capacity", fr: "capacité d'adaptation limitée"}));
  
  // Recommendations based on highest scoring components
  const recommendations = [];
  if (avgScores.exposure === Math.max(avgScores.exposure, avgScores.sensitivity, avgScores.adaptive_capacity)) {
    recommendations.push(
      _lang({en: "climate hazard preparedness", fr: "préparation aux dangers climatiques"}),
      _lang({en: "resilient infrastructure", fr: "infrastructure résiliente"})
    );
  }
  if (avgScores.sensitivity > 0.5) {
    recommendations.push(
      _lang({en: "education access", fr: "accès à l'éducation"}),
      _lang({en: "poverty reduction programs", fr: "programmes de réduction de la pauvreté"})
    );
  }
  if (avgScores.adaptive_capacity > 0.5) {
    recommendations.push(
      _lang({en: "connectivity improvements", fr: "améliorations de la connectivité"}),
      _lang({en: "institutional strengthening", fr: "renforcement institutionnel"})
    );
  }

  const driversText = drivers.length > 0 ? 
    drivers.join(_lang({en: " combined with ", fr: " combiné avec "})) : 
    _lang({en: "multiple factors", fr: "facteurs multiples"});
    
  const recommendationsText = recommendations.slice(0, 2).join(_lang({en: " and ", fr: " et "})) || 
    _lang({en: "comprehensive interventions", fr: "interventions complètes"});

  // Create component scores as list items
  const componentScores = [
    htl.html`<li><strong>${_lang({en: "Exposure", fr: "Exposition"})}</strong>: ${avgScores.exposure.toFixed(2)}</li>`,
    htl.html`<li><strong>${_lang({en: "Sensitivity", fr: "Sensibilité"})}</strong>: ${avgScores.sensitivity.toFixed(2)}</li>`,
    htl.html`<li><strong>${_lang({en: "Adaptive Capacity", fr: "Capacité d'adaptation"})}</strong>: ${avgScores.adaptive_capacity.toFixed(2)}</li>`
  ];

  const insight = htl.html`<div>
    <p>${_lang({
      en: `${regionName} has a ${vulnLevel} vulnerability score of ${avgScores.composite.toFixed(2)}.`,
      fr: `${regionName} a un score de vulnérabilité ${vulnLevel} de ${avgScores.composite.toFixed(2)}.`
    })}</p>
    
    <ul>${componentScores}</ul>
    
    <p>${_lang({
      en: `${driversText} driving vulnerability. Strengthening ${recommendationsText} could reduce future risks.`,
      fr: `${driversText} génèrent la vulnérabilité. Renforcer ${recommendationsText} pourrait réduire les risques futurs.`
    })}</p>
  </div>`;
  
  return createInsightDisplay(insight);
}
```
