---
module: "Where are investments needed?"
nb-authors:
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: "2025-02-19"
date-edited: today
---

```{ojs}
compositeQuestion = _lang(vulnerability_translations.composite_question);
```

# `{ojs} compositeQuestion` {#composite-index}

`{ojs} _lang(vulnerability_translations.composite_description)`

```{ojs}
// Controls form with exact same HTML structure
compositeControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px; max-width: 100%;">${admin012Form(masterLanguage.key)}</div>
  </div>
</div>
`;
```

```{ojs}
// Keep metadata as JSON (small file, 4KB)
sensitivityMetadata = await loadDataWithCache(
  "compositeUrgencyMetadata",
  async () => {
    return await FileAttachment(
      "/data/vulnerability_notebook/urgency_metadata.json",
    ).json();
  },
);
```

```{ojs}
// Reuse cached boundary data (already loaded in shared)
compositeMapBoundaries = boundaries;
```

```{ojs}
// Get current admin selections using shared state
compositeAdminSelections = {
  return {
    selectAdmin0: admin0Select?.admin0_name || null,
    selectAdmin1: admin1Select?.admin1_name || null,
    selectAdmin2: admin2Select?.admin2_name || null
  }
}
```

```{ojs}
/**
 * Compute index from normalized values by averaging all _norm columns
 * Used for vulnerability index calculations (ND-Gain methodology)
 *
 * @param {Object} row - Data row with normalized columns ending in "_norm"
 * @returns {number|null} Average of all normalized values, or null if none found
 */
function computeIndex(row) {
  const normValues = Object.entries(row)
    .filter(
      ([key, value]) =>
        key.endsWith("_norm") && typeof value === "number" && !isNaN(value),
    )
    .map(([, value]) => value);

  if (normValues.length === 0) return null;

  const sum = normValues.reduce((a, b) => a + b, 0);
  return sum / normValues.length;
}

/**
 * Generate SQL WHERE clause for admin level filtering
 * Returns clause to filter by admin0 (country level) or admin1 (region level) based on selection
 *
 * @param {string|null} country_sel - Selected country code (or "SSA" for all countries)
 * @param {string|null} admin1_sel - Selected admin1 region (currently unused but kept for consistency)
 * @returns {string} SQL WHERE clause fragment
 */
whereAdminNull = (country_sel, admin1_sel) => {
  // If all countries selected (SSA) or no selection, return country-level data (admin1_name IS NULL)
  // Otherwise, return region-level data (admin1_name IS NOT NULL)
  if (country_sel == "SSA" || !country_sel) {
    return `AND admin1_name IS NULL`;
  } else {
    return `AND admin1_name IS NOT NULL`;
  }
};
```

```{ojs}
// Calculate exposure index
exposure_index = {
  try {
    return await localDb.query(`
      WITH raw_exposure AS (
          SELECT 
            admin0_name, 
            admin1_name, 
            SUM(value) AS total_exposure
          FROM exposure
          WHERE admin2_name IS NULL
            ${whereAdminNull(admin0Select?.admin0_name, admin1Select?.admin1_name)}
          GROUP BY admin0_name, admin1_name
        ),
        stats AS (
          SELECT
            MIN(total_exposure) AS exposure_min,
            MAX(total_exposure) AS exposure_max
          FROM raw_exposure
          WHERE ISFINITE(total_exposure)
        )
        SELECT 
          r.admin0_name,
          r.admin1_name,
          r.total_exposure,
          -- Min-max normalize exposure
          (r.total_exposure - s.exposure_min) / NULLIF(s.exposure_max - s.exposure_min, 0) AS exposure_norm
        FROM raw_exposure r
        CROSS JOIN stats s
        WHERE ISFINITE(r.total_exposure)
        ORDER BY r.total_exposure DESC;
    `);
  } catch (error) {
    console.error("Failed to calculate exposure index:", error);
    return [];
  }
}
```

```{ojs}
// Calculate enabling index (adaptive capacity)
enabling_index = {
  try {
    let resp = await localDb.query(`
SELECT *
FROM enabling
WHERE admin0_name != 'SSA'
${whereAdminNull(admin0Select?.admin0_name, admin1Select?.admin1_name)}
`);

    return resp.map((row) => ({
      ...row,
      enabling_index: computeIndex(row)
    }));
  } catch (error) {
    console.error("Failed to calculate enabling index:", error);
    return [];
  }
}
```

```{ojs}
// Calculate urgency index
// Index is based on exposure and sensitivity
urgency_index = {
  try {
    let gender = "total"; //NOTE: Keeping this as an option in case future updates want gender specific index
    // sensitivity data
    let sensitivityData = await localDb.query(`
SELECT *
FROM urgency
WHERE admin0_name != 'SSA'
AND gender = '${gender}'
${whereAdminNull(admin0Select?.admin0_name, admin1Select?.admin1_name)}
`);

    // Check if exposure_index exists and is an array before using
    const exposureMap = (exposure_index && Array.isArray(exposure_index))
      ? Object.fromEntries(
          exposure_index.map((d) => {
            const a0 = d.admin0_name;
            const a1 = d.admin1_name;
            const key = a1 ? `${a0}||${a1}` : a0; // use both if admin1 exists, else just admin0
            return [key, d.exposure_norm];
          })
        )
      : {};

    // merge into urgencyData
    const merged = sensitivityData.map((d) => {
      const a0 = d.admin0_name;
      const a1 = d.admin1_name;
      const key = a1 ? `${a0}||${a1}` : a0;

      return {
        ...d,
        exposure_norm: exposureMap[key] ?? null
      };
    });

    return merged.map((row) => ({
      ...row,
      urgency_index: computeIndex(row)
    }));
  } catch (error) {
    console.error("Failed to calculate urgency index:", error);
    return [];
  }
}
```

```{ojs}
// Calculate vulnerability index (AKA composite index with ND-gain Methodology)
vulnerabilityIndex = {
  const key = (r) => `${r.admin0_name}|${r.admin1_name}`;
  const toMap = (arr, k, v) => Object.fromEntries(arr.map((r) => [k(r), v(r)]));

  const uMap = toMap(urgency_index, key, (r) => r.urgency_index);
  const enMap = toMap(enabling_index, key, (r) => r.enabling_index);

  const allKeys = new Set([...Object.keys(enMap), ...Object.keys(uMap)]);

  const merged = [...allKeys].map((k) => {
    const [admin0_name, admin1_name] = k.split("|");
    const en = enMap[k],
      u = uMap[k];
    return {
      admin0_name,
      admin1_name,
      enabling_index: en ?? null,
      urgency_index: u ?? null,
      vulnerability:
        typeof en === "number" && typeof u === "number"
          ? 100 - (en - u + 1) * 50
          : null
    };
  });

  return merged.filter(d => d.vulnerability !== null);
}
```

```{ojs}
// Updated vulnerability index calculation using the Observable approach
componentIndicesPerRegion = {
  // Check if vulnerabilityIndex exists and is valid before processing
  if (!vulnerabilityIndex || !Array.isArray(vulnerabilityIndex) || vulnerabilityIndex.length === 0) {
    return { scores: {}, adminLevel: null, regions: [] };
  }
  
  const selections = compositeAdminSelections;
  const isNull = (val) => val === null || val === undefined || val === "" || val === "\\N";
  
  // Determine admin level and get unique regions
  let adminLevel, regions;
  if (!selections.selectAdmin0 || selections.selectAdmin0 === "SSA") {
    // Show all countries (admin0 level)
    adminLevel = "admin0_name";
    regions = [...new Set(vulnerabilityIndex.map(d => d.admin0_name).filter(d => d))];
  } else if (!selections.selectAdmin1) {
    // Show admin1 within selected country
    adminLevel = "admin1_name";
    regions = [...new Set(vulnerabilityIndex
      .filter(d => d.admin0_name === selections.selectAdmin0 && !isNull(d.admin1_name))
      .map(d => d.admin1_name))];
  } else if (!selections.selectAdmin2) {
    // Show admin2 within selected admin1
    adminLevel = "admin2_name";
    regions = [...new Set(vulnerabilityIndex
      .filter(d => d.admin0_name === selections.selectAdmin0 && 
                   d.admin1_name === selections.selectAdmin1 && 
                   !isNull(d.admin2_name))
      .map(d => d.admin2_name))];
  } else {
    // Single admin2 selected
    adminLevel = "admin2_name";
    regions = [selections.selectAdmin2];
  }

  // Calculate scores for each region using the new vulnerability index
  const regionScores = {};

  regions.forEach(region => {
    // Find vulnerability data for this region
    const vulnData = vulnerabilityIndex.find(d => d[adminLevel] === region);
    
    if (vulnData) {
      // Convert vulnerability score (0-100) to 0-1 scale for consistency
      const compositeScore = vulnData.vulnerability ? vulnData.vulnerability / 100 : 0;
      const enablingScore = vulnData.enabling_index || 0;
      const urgencyScore = vulnData.urgency_index || 0;
      
      // Urgency index represents sensitivity (population density, education, poverty)
      // Exposure is separate and comes from exposure data
      const sensitivityScore = urgencyScore; // Urgency index IS sensitivity
      
      // Get exposure score from exposure data (with null check)
      const exposureData = (exposure_index && Array.isArray(exposure_index))
        ? exposure_index.find(d => d[adminLevel] === region)
        : null;
      const exposureScore = exposureData ? exposureData.exposure_norm : 0;
      
      // FIXED: Adaptive capacity should be HIGH when enabling is HIGH (not inverted)
      // Countries with high enabling factors have HIGH adaptive capacity (good thing)
      const adaptiveScore = enablingScore; // High enabling = high adaptive capacity
      
      regionScores[region] = {
        exposure: exposureScore,
        sensitivity: sensitivityScore,
        adaptive_capacity: adaptiveScore,
        composite: compositeScore,
        // Include raw values for reference
        enabling_index: enablingScore,
        urgency_index: urgencyScore,
        vulnerability_score: vulnData.vulnerability
      };
    } else {
      // No data available for this region
      regionScores[region] = { // All null as a default of 0 could be interpreted as a score rather than missing
        exposure: null,
        sensitivity: null,
        adaptive_capacity: null,
        composite: null,
        enabling_index: null,
        urgency_index: null,
        vulnerability_score: null
      };
    }
  });

  return { 
    scores: regionScores, 
    adminLevel: adminLevel,
    regions: regions
  };
}
```

```{ojs}
// Small Multiples/Faceted Maps Visualization with proper loading/no-data states
compositeVulnerabilityMaps = {
  // Show loading spinner only if data is still loading (null/undefined)
  if ([exposure_index, enabling_index, urgency_index, sensitivityMetadata].some((d) => d === null || d === undefined)) {
    return createLoadingState(
      _lang({en: "Loading composite vulnerability data...", fr: "Chargement des données de vulnérabilité composite..."})
    );
  }

  // // If data is loaded but empty or processing failed, show no data state
  if (
    [exposure_index, enabling_index, urgency_index, sensitivityMetadata, componentIndicesPerRegion]
      .some((d) => !d) || !componentIndicesPerRegion?.scores
  ) {
    return createNoDataState(_lang(vulnerability_translations.no_data_available));
  }

  const { scores, adminLevel } = componentIndicesPerRegion;
  const selections = compositeAdminSelections;
  
  // Get the appropriate boundary level
  let boundaries;
  if (adminLevel === "admin0_name") {
    boundaries = compositeMapBoundaries.admin0;
  } else if (adminLevel === "admin1_name") {
    boundaries = {
      ...compositeMapBoundaries.admin1,
      features: compositeMapBoundaries.admin1.features.filter(
        d => d.properties.admin0_name === selections.selectAdmin0
      )
    };
  } else {
    boundaries = {
      ...compositeMapBoundaries.admin2,
      features: compositeMapBoundaries.admin2.features.filter(
        d => d.properties.admin0_name === selections.selectAdmin0 && 
            d.properties.admin1_name === selections.selectAdmin1
      )
    };
  }

  // Define the components to show (always all components)
  const components = [
    { key: "composite", label: _lang({en: "Composite", fr: "Composite"}), scheme: "Reds", isComposite: true },
    { key: "exposure", label: _lang({en: "Exposure", fr: "Exposition"}), scheme: "Oranges", isComposite: false },
    { key: "sensitivity", label: _lang({en: "Sensitivity", fr: "Sensibilité"}), scheme: "Purples", isComposite: false },
    { key: "adaptive_capacity", label: _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}), scheme: "Greens", isComposite: false }
  ];

  // Calculate subplot dimensions - use full width when available
  const totalWidth = typeof width === "number" ? Math.min(1200, width) : 1000;
  const totalHeight = 600;
  const layoutPadding = 8;
  const componentMapGap = 12;
  const legendAllowance = 40;
  const compositeColumnRatio = 2.2;
  const componentColumnRatio = 1;
  const columnTotal = compositeColumnRatio + componentColumnRatio;
  const compositeMapWidth = Math.floor(totalWidth * (compositeColumnRatio / columnTotal));
  const componentMapWidth = Math.floor(totalWidth * (componentColumnRatio / columnTotal));
  const componentMapHeight = Math.floor((totalHeight - (componentMapGap * 2)) / 3);
  const compositeMapHeight = (componentMapHeight * 3) + (componentMapGap * 2) + (legendAllowance * 2);
  
  const componentDataByKey = new Map();

  const buildComponentFeatures = (component) => {
    return boundaries.features.map(feature => {
      // Get the correct region name based on admin level
      let regionName;
      if (adminLevel === "admin0_name") {
        regionName = feature.properties.admin0_name;
      } else if (adminLevel === "admin1_name") {
        regionName = feature.properties.admin1_name;
      } else if (adminLevel === "admin2_name") {
        regionName = feature.properties.admin2_name;
      } else {
        regionName = feature.properties[adminLevel];
      }

      const regionScores = scores[regionName] || { 
        exposure: 0, sensitivity: 0, adaptive_capacity: 0, composite: 0 
      };

      return {
        ...feature,
        properties: {
          ...feature.properties,
          vulnerability: regionScores[component.key] || 0,
          regionName: regionName,
          // Add individual scores as properties for easier tooltip access
          exposureScore: regionScores.exposure || 0,
          sensitivityScore: regionScores.sensitivity || 0,
          adaptiveCapacityScore: regionScores.adaptive_capacity || 0,
          compositeScore: regionScores.composite || 0
        }
      };
    });
  };

  components.forEach(component => {
    componentDataByKey.set(component.key, {
      component,
      features: buildComponentFeatures(component)
    });
  });

  const createMapFor = (componentKey, mapWidth, mapHeight) => {
    const entry = componentDataByKey.get(componentKey);
    if (!entry) {
      return createNoDataState(_lang(vulnerability_translations.no_data_available));
    }

    const { component, features: componentFeatures } = entry;

    // Color scheme based on component
    let colorRange;
    if (component.key === "adaptive_capacity") {
      colorRange = ["#F7D732", "#216729"]; // Red (low/bad) to Green (high/good) - high adaptive capacity is good
    } else {
      colorRange = ["#F4BB21", "#EC5A47"]; // Yellow (low) to Red (high) for other components
    }

    return renderGeoMap({
      features: componentFeatures,
      width: mapWidth,
      height: mapHeight,
      valueAccessor: d => d.properties.vulnerability,
      color: {
        type: "linear",
        range: colorRange,
        legend: true,
        label: component.key === "adaptive_capacity" ? 
          _lang({en: "Adaptive Capacity (Higher = Better)", fr: "Capacité d'Adaptation"}) : 
          component.key === "exposure" ? 
            _lang({en: "Climate Exposure (Higher = Worse)", fr: "Exposition Climatique"}) :
          component.key === "sensitivity" ? 
            _lang({en: "Population Sensitivity (Higher = Worse)", fr: "Sensibilité de la Population"}) :
            _lang({en: "Composite Vulnerability (Higher = Worse)", fr: "Vulnérabilité Composite"})
      },
      tooltip: {
        channels: {
          country: {
            label: _lang({en: "Country", fr: "Pays"}),
            value: (d) => d.properties.admin0_name || "Unknown"
          },
          region: {
            label: _lang({en: "Region", fr: "Région"}),
            value: (d) => {
              if (d.properties.admin2_name) {
                return `${d.properties.admin2_name}, ${d.properties.admin1_name}`;
              } else if (d.properties.admin1_name) {
                return d.properties.admin1_name;
              } else {
                return d.properties.admin0_name;
              }
            }
          },
          component: {
            label: _lang({en: "Component", fr: "Composant"}),
            value: component.label
          },
          score: {
            label: _lang({en: "Score", fr: "Score"}),
            value: (d) => d.properties.vulnerability !== null && d.properties.vulnerability !== undefined ? d.properties.vulnerability.toFixed(3) : "No data"
          },
          ...(component.key === "composite" ? {
            exposure: {
              label: _lang({en: "Exposure", fr: "Exposition"}),
              value: (d) => d.properties.exposureScore !== null && d.properties.exposureScore !== undefined ? d.properties.exposureScore.toFixed(3) : "No data"
            },
            sensitivity: {
              label: _lang({en: "Sensitivity", fr: "Sensibilité"}),
              value: (d) => d.properties.sensitivityScore !== null && d.properties.sensitivityScore !== undefined ? d.properties.sensitivityScore.toFixed(3) : "No data"
            },
            adaptiveCapacity: {
              label: _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}),
              value: (d) => d.properties.adaptiveCapacityScore !== null && d.properties.adaptiveCapacityScore !== undefined ? d.properties.adaptiveCapacityScore.toFixed(3) : "No data"
            }
          } : {})
        }
      }
    });
  };

  const createMapContainer = (componentKey, mapWidth, mapHeight, isFeatured) => {
    const map = createMapFor(componentKey, mapWidth, mapHeight);
    const mapContainer = document.createElement("div");
    mapContainer.className = isFeatured ? "map featured" : "map";
    mapContainer.dataset.componentKey = componentKey;
    mapContainer.style.display = "flex";
    mapContainer.style.flexDirection = "column";
    mapContainer.style.alignItems = "stretch";
    mapContainer.style.width = "100%";

    const mapWrapper = document.createElement("div");
    mapWrapper.style.overflow = "visible";
    mapWrapper.append(map);

    const mapSvg = map.querySelector ? map.querySelector('svg:nth-of-type(2)') : null; // Map is the second svg of the figure. Might change
    if (mapSvg) mapSvg.setAttribute("overflow", "visible");

    mapContainer.append(mapWrapper);
    return mapContainer;
  };

  // Individual legends are now integrated with each map

  const compositeMapContainer = createMapContainer(
    "composite",
    compositeMapWidth,
    compositeMapHeight,
    true
  );
  const componentMapContainers = components
    .filter(component => !component.isComposite)
    .map(component => createMapContainer(component.key, componentMapWidth, componentMapHeight, false));

  // Return maps in a custom layout with labels and external legend
  const container = htl.html`
    <div style="
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 20px;
      width: 100%;
      max-width: 100%;
      padding: ${layoutPadding}px;
      background: white;
      border-radius: 8px;
    ">
      <!-- Individual legends are now integrated with each map -->
      
      <!-- Two-column layout: composite map left, components stacked right -->
      <div style="
        display: grid;
        grid-template-columns: minmax(0, ${compositeColumnRatio}fr) minmax(0, ${componentColumnRatio}fr);
        gap: ${componentMapGap}px;
        width: 100%;
        overflow: visible;
      ">
        <div style="
          display: flex;
          flex-direction: column;
          align-items: stretch;
          width: 100%;
        " data-role="featured">
          ${compositeMapContainer}
        </div>

        <div style="
          display: flex;
          flex-direction: column;
          align-items: stretch;
          gap: ${componentMapGap}px;
          width: 100%;
        " data-role="secondary">
          ${componentMapContainers.map((mapContainer) => mapContainer)}
        </div>
      </div>
    </div>
  `;

  // Enable double-click swapping between featured and secondary columns
  setTimeout(() => {
    const featuredColumn = container.querySelector('[data-role="featured"]');
    const secondaryColumn = container.querySelector('[data-role="secondary"]');
    if (!featuredColumn || !secondaryColumn) return;

    const bindMapEvents = () => {
      const maps = container.querySelectorAll('.map');
      maps.forEach((map) => {
        if (map.dataset.bound === "true") return;
        map.dataset.bound = "true";

        map.addEventListener('dblclick', () => {
          if (map.classList.contains('featured')) return;

          const currentFeatured = container.querySelector('.map.featured');
          if (!currentFeatured) return;

          const featuredKey = currentFeatured.dataset.componentKey;
          const clickedKey = map.dataset.componentKey;
          if (!featuredKey || !clickedKey) return;

          const newFeatured = createMapContainer(
            clickedKey,
            compositeMapWidth,
            compositeMapHeight,
            true
          );
          const newSecondary = createMapContainer(
            featuredKey,
            componentMapWidth,
            componentMapHeight,
            false
          );

          featuredColumn.innerHTML = "";
          featuredColumn.append(newFeatured);
          secondaryColumn.replaceChild(newSecondary, map);

          bindMapEvents();
        });
      });
    };

    bindMapEvents();
  }, 0);

  return container;
}
```

```{ojs}
// Dynamic Insights following wireframe template
compositeVulnerabilityInsights = {
  if (!componentIndicesPerRegion || !componentIndicesPerRegion.scores) {
    return createNoDataState();
  }

  const selections = compositeAdminSelections;
  const { scores, adminLevel } = componentIndicesPerRegion;
  
  // Get region name for insight
  let regionName;
  if (!selections.selectAdmin0 || selections.selectAdmin0 === "SSA") {
    regionName = "Sub-Saharan Africa";
  } else if (!selections.selectAdmin1) {
    regionName = selections.selectAdmin0;
  } else if (!selections.selectAdmin2) {
    regionName = selections.selectAdmin1;
  } else {
    regionName = selections.selectAdmin2;
  }
  
  // Calculate average scores across all regions for this level
  const regions = Object.keys(scores);
  const avgScores = {
    composite: d3.mean(regions, r => scores[r].composite) || 0,
    exposure: d3.mean(regions, r => scores[r].exposure) || 0,
    sensitivity: d3.mean(regions, r => scores[r].sensitivity) || 0,
    adaptive_capacity: d3.mean(regions, r => scores[r].adaptive_capacity) || 0
  };
  
  // Determine vulnerability level
  const vulnLevel = avgScores.composite > 0.7 ? 
    _lang({en: "high", fr: "élevé"}) : 
    avgScores.composite > 0.4 ? 
    _lang({en: "moderate", fr: "modéré"}) : 
    _lang({en: "low", fr: "faible"});
  
  // Identify main drivers
  const drivers = [];
  if (avgScores.exposure > 0.6) drivers.push(_lang({en: "high exposure", fr: "exposition élevée"}));
  if (avgScores.sensitivity > 0.6) drivers.push(_lang({en: "high sensitivity", fr: "sensibilité élevée"}));  
  if (avgScores.adaptive_capacity < 0.4) drivers.push(_lang({en: "limited adaptive capacity", fr: "capacité d'adaptation limitée"})); // LOW adaptive capacity is bad
  
  // Recommendations based on highest scoring components
  const recommendations = [];
  if (avgScores.exposure === Math.max(avgScores.exposure, avgScores.sensitivity, avgScores.adaptive_capacity)) {
    recommendations.push(
      _lang({en: "climate hazard preparedness", fr: "préparation aux dangers climatiques"}),
      _lang({en: "resilient infrastructure", fr: "infrastructure résiliente"})
    );
  }
  if (avgScores.sensitivity > 0.5) {
    recommendations.push(
      _lang({en: "education access", fr: "accès à l'éducation"}),
      _lang({en: "poverty reduction programs", fr: "programmes de réduction de la pauvreté"})
    );
  }
  if (avgScores.adaptive_capacity < 0.5) { // LOW adaptive capacity needs improvement
    recommendations.push(
      _lang({en: "connectivity improvements", fr: "améliorations de la connectivité"}),
      _lang({en: "institutional strengthening", fr: "renforcement institutionnel"})
    );
  }

  const driversText = drivers.length > 0 ? 
    drivers.join(_lang({en: " combined with ", fr: " combiné avec "})) : 
    _lang({en: "multiple factors", fr: "facteurs multiples"});
    
  const recommendationsText = recommendations.slice(0, 2).join(_lang({en: " and ", fr: " et "})) || 
    _lang({en: "comprehensive interventions", fr: "interventions complètes"});

  // Create component scores as list items
  const componentScores = [
    htl.html`<li><strong>${_lang({en: "Exposure", fr: "Exposition"})}</strong>: ${(avgScores.exposure || 0).toFixed(2)}</li>`,
    htl.html`<li><strong>${_lang({en: "Sensitivity", fr: "Sensibilité"})}</strong>: ${(avgScores.sensitivity || 0).toFixed(2)}</li>`,
    htl.html`<li><strong>${_lang({en: "Adaptive Capacity", fr: "Capacité d'adaptation"})}</strong>: ${(avgScores.adaptive_capacity || 0).toFixed(2)}</li>`
  ];

  const insight = htl.html`<div>
    <p>${_lang({
      en: `${regionName} has a ${vulnLevel} vulnerability score of ${(avgScores.composite || 0).toFixed(2)}.`,
      fr: `${regionName} a un score de vulnérabilité ${vulnLevel} de ${(avgScores.composite || 0).toFixed(2)}.`
    })}</p>
    
    <ul>${componentScores}</ul>
    
    <p>${_lang({
      en: `${driversText} driving vulnerability. Strengthening ${recommendationsText} could reduce future risks.`,
      fr: `${driversText} génèrent la vulnérabilité. Renforcer ${recommendationsText} pourrait réduire les risques futurs.`
    })}</p>
  </div>`;
  
  return createInsightDisplay(insight);
}
```

```{ojs}
// Create download dataset with all composite index and sub-indices
compositeDownloadData = {
  if (!componentIndicesPerRegion || !componentIndicesPerRegion.scores) return [];
  
  const { scores, adminLevel } = componentIndicesPerRegion;
  const regions = Object.keys(scores);
  
  return regions.map(region => {
    const regionScores = scores[region];
    return {
      [_lang({en: "Region", fr: "Région"})]: region,
      [_lang({en: "Composite Vulnerability Score", fr: "Score de Vulnérabilité Composite"})]: regionScores.composite ? regionScores.composite.toFixed(3) : "N/A",
      [_lang({en: "Exposure Score", fr: "Score d'Exposition"})]: regionScores.exposure ? regionScores.exposure.toFixed(3) : "N/A",
      [_lang({en: "Sensitivity Score", fr: "Score de Sensibilité"})]: regionScores.sensitivity ? regionScores.sensitivity.toFixed(3) : "N/A",
      [_lang({en: "Adaptive Capacity Score", fr: "Score de Capacité d'Adaptation"})]: regionScores.adaptive_capacity ? regionScores.adaptive_capacity.toFixed(3) : "N/A",
      [_lang({en: "Enabling Index", fr: "Indice d'Enabling"})]: regionScores.enabling_index ? regionScores.enabling_index.toFixed(3) : "N/A",
      [_lang({en: "Urgency Index", fr: "Indice d'Urgence"})]: regionScores.urgency_index ? regionScores.urgency_index.toFixed(3) : "N/A",
      [_lang({en: "Raw Vulnerability Score", fr: "Score de Vulnérabilité Brut"})]: regionScores.vulnerability_score || "N/A"
    };
  });
}
```

```{ojs}
// Download button for composite index data
viewof compositeDownloadButton = {
  if (!compositeDownloadData || compositeDownloadData.length === 0) {
    return htl.html`<p>${_lang({en: "No data available for download", fr: "Aucune donnée disponible pour le téléchargement"})}</p>`;
  }
  
  const region = getAdminNameString().replace(", ", "_");
  
  return downloadButton(
    compositeDownloadData, 
    `composite_vulnerability_data_${region}`,
    _lang({en: "Download Composite Index Data", fr: "Télécharger les Données de l'Indice Composite"})
  );
}
```

<div style="margin-top: 32px;"></div>

## `{ojs} _lang(vulnerability_translations.composite_insights_title)`

`{ojs} compositeVulnerabilityInsights`
