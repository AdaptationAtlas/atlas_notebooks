---
pagetitle: "Where are investments needed?"
nb-authors:
  - Johnson Mwakazi
  - Pete Stewart
  - Brayden Youngberg
date-created: '2025-02-19'
date-edited: today
---

```{ojs}
compositeQuestion = _lang(vulnerability_translations.composite_question)
```

# `{ojs} compositeQuestion ` {#composite-index}

`{ojs} _lang(vulnerability_translations.composite_description)`

```{ojs}
// Composite section selectors - follow shared state
viewof compositeAdmin0 = Inputs.select(dataAdmin0, {
  label: adminRegions.labels.admin0, 
  format: x => x.label,
  value: dataAdmin0.find(d => d.value === sharedAdmin0) || dataAdmin0[0]
})
viewof compositeAdmin1 = Inputs.select(dataAdmin1, {
  label: adminRegions.labels.admin1, 
  format: x => x.label,
  value: dataAdmin1.find(d => d.value === sharedAdmin1) || dataAdmin1[0]
})  
viewof compositeAdmin2 = Inputs.select(dataAdmin2, {
  label: adminRegions.labels.admin2, 
  format: x => x.label,
  value: dataAdmin2.find(d => d.value === sharedAdmin2) || dataAdmin2[0]
})

// Component selection
viewof compositeSelectedComponent = Inputs.select(
  [
    { value: "composite", label: _lang({en: "Composite Vulnerability", fr: "Vulnérabilité Composite"}) },
    { value: "exposure", label: _lang({en: "Exposure", fr: "Exposition"}) },
    { value: "sensitivity", label: _lang({en: "Sensitivity", fr: "Sensibilité"}) },
    { value: "adaptive_capacity", label: _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}) }
  ],
  {
    label: _lang({en: "Component Selection", fr: "Sélection de Composant"}),
    format: x => x.label,
    value: { value: "composite", label: _lang({en: "Composite Vulnerability", fr: "Vulnérabilité Composite"}) }
  }
)
```

```{ojs}
// Controls form with exact same HTML structure
compositeControlsForm = htl.html`
<div style="
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  margin: 16px 0;
">
  <h3 style="margin: 0 0 20px 0; color: #2d3748; font-size: 1.1rem; font-weight: 600;">
    ${_lang(vulnerability_translations.geographic_selection)}
  </h3>
  <div style="
    display: flex;
    align-items: flex-start;
    gap: 20px;
    flex-wrap: nowrap;
    justify-content: space-between;
  " class="form-inputs-container">
    <div style="flex: 1; min-width: 180px;">${viewof compositeAdmin0}</div>
    <div style="flex: 1; min-width: 180px;">${viewof compositeAdmin1}</div>
    <div style="flex: 1; min-width: 180px;">${viewof compositeAdmin2}</div>
  </div>
  <div style="margin-top: 16px;">
    <div style="flex: 1; min-width: 200px;">${viewof compositeSelectedComponent}</div>
  </div>
</div>
`
```

```{ojs}
// Note about on-the-fly calculation
htl.html`<div style="background: #f0f7ff; padding: 12px; border-radius: 8px; margin: 16px 0; border-left: 4px solid #2563eb;">
  <p style="margin: 0; font-size: 14px; color: #1e40af;">
    <strong>${_lang({ en: "Note", fr: "Note" })}:</strong> ${_lang({
			en: "This index is calculated on-the-fly within the notebook to allow greater flexibility.",
			fr: "Cet indice est calculé à la volée dans le notebook pour permettre une plus grande flexibilité.",
		})}
  </p>
</div>`;
```

```{ojs}
// Load exposure data with caching (reuse from exposure section)
exposureComponentData = await loadDataWithCache('compositeExposureData', async () => {
  const text = await FileAttachment("/data/vulnerability_notebook/notebook_exposure.json").text();
  return text.trim().split('\n').map(line => JSON.parse(line));
});
```

```{ojs}
// Reuse cached adaptive capacity data
adaptiveCapacityComponentData = await loadDataWithCache('adaptiveCapacityData', async () => {
  return await FileAttachment("/data/vulnerability_notebook/enabling_vars.csv").csv({ typed: true });
});
```

```{ojs}
// Load sensitivity/urgency data with caching
sensitivityComponentData = await loadDataWithCache('compositeUrgencyData', async () => {
  return await FileAttachment("/data/vulnerability_notebook/urgency_index.csv").csv({ typed: true });
});

sensitivityMetadata = await loadDataWithCache('compositeUrgencyMetadata', async () => {
  return await FileAttachment("/data/vulnerability_notebook/urgency_metadata.json").json();
});
```

```{ojs}
// Reuse cached boundary data (already loaded in shared)
compositeMapBoundaries = boundaries;
```

```{ojs}
// Get current admin selections using shared state
compositeAdminSelections = {
  return {
    selectAdmin0: compositeAdmin0?.value || sharedAdmin0 || null,
    selectAdmin1: compositeAdmin1?.value || sharedAdmin1 || null,
    selectAdmin2: compositeAdmin2?.value || sharedAdmin2 || null
  }
}
```

```{ojs}
// Helper function to compute index from normalized values (from Observable notebook)
function computeIndex(row) {
  const normValues = Object.entries(row)
    .filter(
      ([key, value]) =>
        key.endsWith("_norm") && typeof value === "number" && !isNaN(value)
    )
    .map(([, value]) => value);

  if (normValues.length === 0) return null;

  const sum = normValues.reduce((a, b) => a + b, 0);
  return sum / normValues.length;
}
```

```{ojs}
// Calculate enabling index (adaptive capacity) using computeIndex function
enablingIndex = {
  if (!adaptiveCapacityComponentData || adaptiveCapacityComponentData.length === 0) return [];
  
  return adaptiveCapacityComponentData.map((row) => ({
    ...row,
    enabling_index: computeIndex(row)
  }));
}
```

```{ojs}
// Calculate exposure index with min-max normalization
exposureIndex = {
  if (!exposureComponentData || exposureComponentData.length === 0) return [];
  
  // Group by admin0_name, admin1_name and sum exposure values
  const groupedExposure = d3.group(exposureComponentData, d => `${d.admin0_name}|${d.admin1_name}`);
  
  const rawExposure = Array.from(groupedExposure.entries()).map(([key, values]) => {
    const [admin0_name, admin1_name] = key.split("|");
    // Filter out null, undefined, and zero values before summing
    const validValues = values.filter(d => d.value !== null && d.value !== undefined && d.value > 0);
    const totalExposure = validValues.length > 0 ? d3.sum(validValues, d => d.value) : 0;
    return { admin0_name, admin1_name, totalExposure, validCount: validValues.length };
  });
  
  // Include all regions, but handle normalization carefully
  const validExposure = rawExposure.filter(d => d.totalExposure > 0);
  
  if (validExposure.length === 0) {
    // If no valid exposure data anywhere, return all regions with 0 exposure
    return rawExposure.map(d => ({
      ...d,
      exposure_norm: 0
    }));
  }
  
  // Min-max normalize exposure using only regions with valid data
  const exposureMin = d3.min(validExposure, d => d.totalExposure) || 0;
  const exposureMax = d3.max(validExposure, d => d.totalExposure) || 1;
  
  // Return all regions, with normalized values for those with data, 0 for those without
  return rawExposure.map(d => ({
    ...d,
    exposure_norm: d.totalExposure > 0 ? 
      (d.totalExposure - exposureMin) / (exposureMax - exposureMin) : 0
  }));
}
```

```{ojs}
// Calculate urgency index (sensitivity + exposure) using computeIndex function
urgencyIndex = {
  if (!sensitivityComponentData || sensitivityComponentData.length === 0) return [];
  
  // Filter for total gender only
  const totalGenderData = sensitivityComponentData.filter(d => d.gender === "total");
  
  // Create exposure map for merging
  const exposureMap = Object.fromEntries(
    exposureIndex.map((d) => [`${d.admin0_name}|${d.admin1_name}`, d.exposure_norm])
  );
  
  // Merge urgency data with exposure data
  const merged = totalGenderData.map((d) => ({
    ...d,
    exposure_norm: exposureMap[`${d.admin0_name}|${d.admin1_name}`] ?? null
  }));
  
  return merged.map((row) => ({
    ...row,
    urgency_index: computeIndex(row)
  }));
}
```

```{ojs}
// Database connection for index calculations
index_db = DuckDBClient.of({
  exposure: FileAttachment("/data/vulnerability_notebook/notebook_exposure.parquet"),
  urgency: FileAttachment("/data/vulnerability_notebook/urgency.parquet"),
  enabling: FileAttachment("/data/vulnerability_notebook/enabling_vars.parquet") // AKA adaptive capacity
})
```

```{ojs}
// Helper function for admin level filtering
whereAdminNull = (country_sel, admin1_sel) => {
  if (country_sel == "SSA" || !country_sel || !admin1_sel) {
    return `AND admin1_name IS NULL`;
  } else {
    return `AND admin1_name IS NOT NULL`;
  }
}
```

```{ojs}
// Calculate exposure index
exposure_index = index_db.query(`      
    WITH raw_exposure AS (
        SELECT 
          admin0_name, 
          admin1_name, 
          SUM(value) AS total_exposure
        FROM exposure
        WHERE admin2_name IS NULL
          ${whereAdminNull(compositeAdmin0, compositeAdmin1)}
        GROUP BY admin0_name, admin1_name
      ),
      stats AS (
        SELECT
          MIN(total_exposure) AS exposure_min,
          MAX(total_exposure) AS exposure_max
        FROM raw_exposure
        WHERE ISFINITE(total_exposure)
      )
      SELECT 
        r.admin0_name,
        r.admin1_name,
        r.total_exposure,
        -- Min-max normalize exposure
        (r.total_exposure - s.exposure_min) / NULLIF(s.exposure_max - s.exposure_min, 0) AS exposure_norm
      FROM raw_exposure r
      CROSS JOIN stats s
      WHERE ISFINITE(r.total_exposure)
      ORDER BY r.total_exposure DESC;
`)
```


```{ojs}
// Calculate enabling index (adaptive capacity)
enabling_index = {
  let resp = await index_db.query(`
SELECT *
FROM enabling
WHERE admin0_name != 'SSA'
${whereAdminNull(compositeAdmin0, compositeAdmin1)}
`);

  return resp.map((row) => ({
    ...row,
    enabling_index: computeIndex(row)
  }));
}
```

```{ojs}
// Calculate urgency index
urgency_index = {
  let gender = "total";
  let resp = await index_db.query(`
SELECT *
FROM urgency
WHERE admin0_name != 'SSA'
AND gender = '${gender}'
${whereAdminNull(compositeAdmin0, compositeAdmin1)}
`);

  const exposureMap = Object.fromEntries(
    exposure_index.map((d) => [d.admin0_name, d.exposure_norm])
  );

  // merge into urgencyData
  const merged = resp.map((d) => ({
    ...d,
    exposure_norm: exposureMap[d.admin0_name] ?? null // null if no match
  }));

  return merged.map((row) => ({
    ...row,
    urgency_index: computeIndex(row)
  }));
}
```

```{ojs}
// Calculate vulnerability index
vulnerabilityIndex = {
  const key = (r) => `${r.admin0_name}|${r.admin1_name}`;
  const toMap = (arr, k, v) => Object.fromEntries(arr.map((r) => [k(r), v(r)]));

  const uMap = toMap(urgency_index, key, (r) => r.urgency_index);
  const enMap = toMap(enabling_index, key, (r) => r.enabling_index);

  const allKeys = new Set([...Object.keys(enMap), ...Object.keys(uMap)]);

  const merged = [...allKeys].map((k) => {
    const [admin0_name, admin1_name] = k.split("|");
    const en = enMap[k],
      u = uMap[k];
    return {
      admin0_name,
      admin1_name,
      enabling_index: en ?? null,
      urgency_index: u ?? null,
      vulnerability:
        typeof en === "number" && typeof u === "number"
          ? 100 - (en - u + 1) * 50
          : null
    };
  });

  return merged.filter(d => d.vulnerability !== null);
}
```

```{ojs}
// Updated vulnerability index calculation using the Observable approach
componentIndicesPerRegion = {
  const selections = compositeAdminSelections;
  const isNull = (val) => val === null || val === undefined || val === "" || val === "\\N";
  
  // Determine admin level and get unique regions
  let adminLevel, regions;
  if (!selections.selectAdmin0 || selections.selectAdmin0 === "SSA") {
    // Show all countries (admin0 level)
    adminLevel = "admin0_name";
    regions = [...new Set(vulnerabilityIndex.map(d => d.admin0_name).filter(d => d))];
  } else if (!selections.selectAdmin1) {
    // Show admin1 within selected country
    adminLevel = "admin1_name";
    regions = [...new Set(vulnerabilityIndex
      .filter(d => d.admin0_name === selections.selectAdmin0 && !isNull(d.admin1_name))
      .map(d => d.admin1_name))];
  } else if (!selections.selectAdmin2) {
    // Show admin2 within selected admin1
    adminLevel = "admin2_name";
    regions = [...new Set(vulnerabilityIndex
      .filter(d => d.admin0_name === selections.selectAdmin0 && 
                   d.admin1_name === selections.selectAdmin1 && 
                   !isNull(d.admin2_name))
      .map(d => d.admin2_name))];
  } else {
    // Single admin2 selected
    adminLevel = "admin2_name";
    regions = [selections.selectAdmin2];
  }

  // Calculate scores for each region using the new vulnerability index
  const regionScores = {};

  regions.forEach(region => {
    // Find vulnerability data for this region
    const vulnData = vulnerabilityIndex.find(d => d[adminLevel] === region);
    
    if (vulnData) {
      // Convert vulnerability score (0-100) to 0-1 scale for consistency
      const compositeScore = vulnData.vulnerability ? vulnData.vulnerability / 100 : 0;
      const enablingScore = vulnData.enabling_index || 0;
      const urgencyScore = vulnData.urgency_index || 0;
      
      // Urgency index represents sensitivity (population density, education, poverty)
      // Exposure is separate and comes from exposure data
      const sensitivityScore = urgencyScore; // Urgency index IS sensitivity
      
      // Get exposure score from exposure data
      const exposureData = exposure_index.find(d => d[adminLevel] === region);
      const exposureScore = exposureData ? exposureData.exposure_norm : 0;
      
      // FIXED: Adaptive capacity should be HIGH when enabling is HIGH (not inverted)
      // Countries with high enabling factors have HIGH adaptive capacity (good thing)
      const adaptiveScore = enablingScore; // High enabling = high adaptive capacity
      
      regionScores[region] = {
        exposure: exposureScore,
        sensitivity: sensitivityScore,
        adaptive_capacity: adaptiveScore,
        composite: compositeScore,
        // Include raw values for reference
        enabling_index: enablingScore,
        urgency_index: urgencyScore,
        vulnerability_score: vulnData.vulnerability
      };
    } else {
      // No data available for this region
      regionScores[region] = {
        exposure: 0,
        sensitivity: 0,
        adaptive_capacity: 0,
        composite: 0,
        enabling_index: null,
        urgency_index: null,
        vulnerability_score: null
      };
    }
  });

  return { 
    scores: regionScores, 
    adminLevel: adminLevel,
    regions: regions
  };
}
```

```{ojs}
// Small Multiples/Faceted Maps Visualization with proper loading/no-data states
compositeVulnerabilityMaps = {
  // Show loading spinner only if data is still loading (null/undefined)
  if (exposureComponentData === null || exposureComponentData === undefined ||
      adaptiveCapacityComponentData === null || adaptiveCapacityComponentData === undefined ||
      sensitivityComponentData === null || sensitivityComponentData === undefined ||
      sensitivityMetadata === null || sensitivityMetadata === undefined) {
    return createLoadingState(_lang({en: "Loading composite vulnerability data...", fr: "Chargement des données de vulnérabilité composite..."}));
  }
  
  // If data is loaded but empty or processing failed, show no data state
  if (!exposureComponentData || !adaptiveCapacityComponentData || !sensitivityComponentData || !sensitivityMetadata ||
      !componentIndicesPerRegion || !componentIndicesPerRegion.scores) {
    return createNoDataState(_lang(vulnerability_translations.no_data_available));
  }

  const { scores, adminLevel } = componentIndicesPerRegion;
  const selections = compositeAdminSelections;
  
  // Get the appropriate boundary level
  let boundaries;
  if (adminLevel === "admin0_name") {
    boundaries = compositeMapBoundaries.admin0;
  } else if (adminLevel === "admin1_name") {
    boundaries = {
      ...compositeMapBoundaries.admin1,
      features: compositeMapBoundaries.admin1.features.filter(
        d => d.properties.admin0_name === selections.selectAdmin0
      )
    };
  } else {
    boundaries = {
      ...compositeMapBoundaries.admin2,
      features: compositeMapBoundaries.admin2.features.filter(
        d => d.properties.admin0_name === selections.selectAdmin0 && 
            d.properties.admin1_name === selections.selectAdmin1
      )
    };
  }

  // Define the components to show based on selection
  const showAllComponents = compositeSelectedComponent.value === "composite";
  const components = showAllComponents ? [
    { key: "composite", label: _lang({en: "Composite", fr: "Composite"}), scheme: "Reds", isComposite: true },
    { key: "exposure", label: _lang({en: "Exposure", fr: "Exposition"}), scheme: "Oranges", isComposite: false },
    { key: "sensitivity", label: _lang({en: "Sensitivity", fr: "Sensibilité"}), scheme: "Purples", isComposite: false },
    { key: "adaptive_capacity", label: _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}), scheme: "Greens", isComposite: false }
  ] : [{
    key: compositeSelectedComponent.value,
    label: compositeSelectedComponent.label,
    scheme: "Reds",
    isComposite: false
  }];

  // Calculate subplot dimensions - use full width
  const totalWidth = 1000; // Increased width for better coverage
  const totalHeight = showAllComponents ? 600 : 300;
  
  // Create individual maps for each component
  const maps = components.map((component, index) => {
    // Create features for this component
    const componentFeatures = boundaries.features.map(feature => {
      const regionName = feature.properties[adminLevel];
      const regionScores = scores[regionName] || { 
        exposure: 0, sensitivity: 0, adaptive_capacity: 0, composite: 0 
      };
      
      return {
        ...feature,
        properties: {
          ...feature.properties,
          vulnerability: regionScores[component.key] || 0,
          regionName: regionName
        }
      };
    });

    // Calculate map dimensions based on component type
    const mapWidth = component.isComposite ? 1000 : Math.floor(1000 / 3);
    const mapHeight = component.isComposite ? 300 : 250;

    return Plot.plot({
      width: mapWidth,
      height: mapHeight,
      projection: {
        type: "azimuthal-equal-area",
        domain: { type: "FeatureCollection", features: componentFeatures }
      },
      color: {
        type: "linear",
        range: ["#F7D732", "#EC5A47"], // Same color pattern for all maps: yellow (low) to red (high)
        domain: [0, 1],
        legend: false // Remove legends from minimaps
      },
      marks: [
        // Geographic boundaries with vulnerability coloring
        Plot.geo(componentFeatures, {
          fill: d => d.properties.vulnerability,
          stroke: "#fff",
          strokeWidth: 0.5,
          channels: {
            [_lang({en: "Region", fr: "Région"})]: d => d.properties.regionName,
            [_lang({en: "Component", fr: "Composant"})]: component.label,
            [_lang({en: "Score", fr: "Score"})]: d => d.properties.vulnerability ? d.properties.vulnerability.toFixed(3) : "No data",
            ...(component.key === "composite" ? {
              [_lang({en: "Exposure", fr: "Exposition"})]: d => {
                const regionName = d.properties.regionName;
                const regionScores = scores[regionName];
                return regionScores && regionScores.exposure !== null ? regionScores.exposure.toFixed(3) : "No data";
              },
              [_lang({en: "Sensitivity", fr: "Sensibilité"})]: d => {
                const regionName = d.properties.regionName;
                const regionScores = scores[regionName];
                return regionScores && regionScores.sensitivity !== null ? regionScores.sensitivity.toFixed(3) : "No data";
              },
              [_lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"})]: d => {
                const regionName = d.properties.regionName;
                const regionScores = scores[regionName];
                return regionScores && regionScores.adaptive_capacity !== null ? regionScores.adaptive_capacity.toFixed(3) : "No data";
              }
            } : {})
          },
          tip: true
        }),
        
      ]
    });
  });

  // Individual legends are now integrated with each map

  // Separate composite and component maps
  const compositeMap = showAllComponents ? maps[0] : null;
  const componentMaps = showAllComponents ? maps.slice(1) : maps;

  // Return maps in a custom layout with labels and external legend
  return htl.html`
    <div style="
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      width: 100%;
      max-width: 100%;
      padding: 16px;
      background: white;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    ">
      <!-- Individual legends are now integrated with each map -->
      
      ${showAllComponents ? htl.html`
        <!-- Composite map - full width -->
        <div style="
          display: flex;
          flex-direction: column;
          align-items: center;
          width: 100%;
          margin-bottom: 20px;
        ">
          <h4 style="
            margin: 0 0 8px 0; 
            font-size: 18px; 
            font-weight: bold; 
            color: #1f2937; 
            text-align: center;
          ">${_lang({en: "Composite", fr: "Composite"})}</h4>
          <div>${compositeMap}</div>
        </div>
        
        <!-- Component maps - 3 in a row -->
        <div style="
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          gap: 16px;
          width: 100%;
        ">
          ${componentMaps.map((map, index) => {
            const component = components[index + 1];
            const title = component.key === "adaptive_capacity" ? 
              _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}) : 
              component.key === "exposure" ? 
                _lang({en: "Climate Exposure", fr: "Exposition Climatique"}) :
              component.key === "sensitivity" ? 
                _lang({en: "Population Sensitivity", fr: "Sensibilité de la Population"}) :
                component.label;
            
            return htl.html`
              <div style="display: flex; flex-direction: column; align-items: center;">
                <h4 style="
                  margin: 0 0 8px 0; 
                  font-size: 16px; 
                  font-weight: bold; 
                  color: #1f2937; 
                  text-align: center;
                ">${title}</h4>
                <div>${map}</div>
              </div>
            `;
          })}
        </div>
      ` : htl.html`
        <!-- Single component map -->
        <div style="
          display: flex;
          flex-direction: column;
          align-items: center;
          width: 100%;
        ">
          <h4 style="
            margin: 0 0 8px 0; 
            font-size: 18px; 
            font-weight: bold; 
            color: #1f2937; 
            text-align: center;
          ">${components[0].key === "adaptive_capacity" ? 
            _lang({en: "Adaptive Capacity", fr: "Capacité d'Adaptation"}) : 
            components[0].key === "exposure" ? 
              _lang({en: "Climate Exposure", fr: "Exposition Climatique"}) :
            components[0].key === "sensitivity" ? 
              _lang({en: "Population Sensitivity", fr: "Sensibilité de la Population"}) :
              _lang({en: "Composite", fr: "Composite"})}</h4>
          <div>${componentMaps[0]}</div>
        </div>
      `}
    </div>
  `;
}
```

```{ojs}
// Dynamic Insights following wireframe template
compositeVulnerabilityInsights = {
  if (!componentIndicesPerRegion || !componentIndicesPerRegion.scores) {
    return createNoDataState();
  }

  const selections = compositeAdminSelections;
  const { scores, adminLevel } = componentIndicesPerRegion;
  
  // Get region name for insight
  let regionName;
  if (!selections.selectAdmin0 || selections.selectAdmin0 === "SSA") {
    regionName = "Sub-Saharan Africa";
  } else if (!selections.selectAdmin1) {
    regionName = selections.selectAdmin0;
  } else if (!selections.selectAdmin2) {
    regionName = selections.selectAdmin1;
  } else {
    regionName = selections.selectAdmin2;
  }
  
  // Calculate average scores across all regions for this level
  const regions = Object.keys(scores);
  const avgScores = {
    composite: d3.mean(regions, r => scores[r].composite) || 0,
    exposure: d3.mean(regions, r => scores[r].exposure) || 0,
    sensitivity: d3.mean(regions, r => scores[r].sensitivity) || 0,
    adaptive_capacity: d3.mean(regions, r => scores[r].adaptive_capacity) || 0
  };
  
  // Determine vulnerability level
  const vulnLevel = avgScores.composite > 0.7 ? 
    _lang({en: "high", fr: "élevé"}) : 
    avgScores.composite > 0.4 ? 
    _lang({en: "moderate", fr: "modéré"}) : 
    _lang({en: "low", fr: "faible"});
  
  // Identify main drivers
  const drivers = [];
  if (avgScores.exposure > 0.6) drivers.push(_lang({en: "high exposure", fr: "exposition élevée"}));
  if (avgScores.sensitivity > 0.6) drivers.push(_lang({en: "high sensitivity", fr: "sensibilité élevée"}));  
  if (avgScores.adaptive_capacity < 0.4) drivers.push(_lang({en: "limited adaptive capacity", fr: "capacité d'adaptation limitée"})); // LOW adaptive capacity is bad
  
  // Recommendations based on highest scoring components
  const recommendations = [];
  if (avgScores.exposure === Math.max(avgScores.exposure, avgScores.sensitivity, avgScores.adaptive_capacity)) {
    recommendations.push(
      _lang({en: "climate hazard preparedness", fr: "préparation aux dangers climatiques"}),
      _lang({en: "resilient infrastructure", fr: "infrastructure résiliente"})
    );
  }
  if (avgScores.sensitivity > 0.5) {
    recommendations.push(
      _lang({en: "education access", fr: "accès à l'éducation"}),
      _lang({en: "poverty reduction programs", fr: "programmes de réduction de la pauvreté"})
    );
  }
  if (avgScores.adaptive_capacity < 0.5) { // LOW adaptive capacity needs improvement
    recommendations.push(
      _lang({en: "connectivity improvements", fr: "améliorations de la connectivité"}),
      _lang({en: "institutional strengthening", fr: "renforcement institutionnel"})
    );
  }

  const driversText = drivers.length > 0 ? 
    drivers.join(_lang({en: " combined with ", fr: " combiné avec "})) : 
    _lang({en: "multiple factors", fr: "facteurs multiples"});
    
  const recommendationsText = recommendations.slice(0, 2).join(_lang({en: " and ", fr: " et "})) || 
    _lang({en: "comprehensive interventions", fr: "interventions complètes"});

  // Create component scores as list items
  const componentScores = [
    htl.html`<li><strong>${_lang({en: "Exposure", fr: "Exposition"})}</strong>: ${(avgScores.exposure || 0).toFixed(2)}</li>`,
    htl.html`<li><strong>${_lang({en: "Sensitivity", fr: "Sensibilité"})}</strong>: ${(avgScores.sensitivity || 0).toFixed(2)}</li>`,
    htl.html`<li><strong>${_lang({en: "Adaptive Capacity", fr: "Capacité d'adaptation"})}</strong>: ${(avgScores.adaptive_capacity || 0).toFixed(2)}</li>`
  ];

  const insight = htl.html`<div>
    <p>${_lang({
      en: `${regionName} has a ${vulnLevel} vulnerability score of ${(avgScores.composite || 0).toFixed(2)}.`,
      fr: `${regionName} a un score de vulnérabilité ${vulnLevel} de ${(avgScores.composite || 0).toFixed(2)}.`
    })}</p>
    
    <ul>${componentScores}</ul>
    
    <p>${_lang({
      en: `${driversText} driving vulnerability. Strengthening ${recommendationsText} could reduce future risks.`,
      fr: `${driversText} génèrent la vulnérabilité. Renforcer ${recommendationsText} pourrait réduire les risques futurs.`
    })}</p>
  </div>`;
  
  return createInsightDisplay(insight);
}
```



```{ojs}
// Create download dataset with all composite index and sub-indices
compositeDownloadData = {
  if (!componentIndicesPerRegion || !componentIndicesPerRegion.scores) return [];
  
  const { scores, adminLevel } = componentIndicesPerRegion;
  const regions = Object.keys(scores);
  
  return regions.map(region => {
    const regionScores = scores[region];
    return {
      [_lang({en: "Region", fr: "Région"})]: region,
      [_lang({en: "Composite Vulnerability Score", fr: "Score de Vulnérabilité Composite"})]: regionScores.composite ? regionScores.composite.toFixed(3) : "N/A",
      [_lang({en: "Exposure Score", fr: "Score d'Exposition"})]: regionScores.exposure ? regionScores.exposure.toFixed(3) : "N/A",
      [_lang({en: "Sensitivity Score", fr: "Score de Sensibilité"})]: regionScores.sensitivity ? regionScores.sensitivity.toFixed(3) : "N/A",
      [_lang({en: "Adaptive Capacity Score", fr: "Score de Capacité d'Adaptation"})]: regionScores.adaptive_capacity ? regionScores.adaptive_capacity.toFixed(3) : "N/A",
      [_lang({en: "Enabling Index", fr: "Indice d'Enabling"})]: regionScores.enabling_index ? regionScores.enabling_index.toFixed(3) : "N/A",
      [_lang({en: "Urgency Index", fr: "Indice d'Urgence"})]: regionScores.urgency_index ? regionScores.urgency_index.toFixed(3) : "N/A",
      [_lang({en: "Raw Vulnerability Score", fr: "Score de Vulnérabilité Brut"})]: regionScores.vulnerability_score || "N/A"
    };
  });
}
```

```{ojs}
// Download button for composite index data
viewof compositeDownloadButton = {
  if (!compositeDownloadData || compositeDownloadData.length === 0) {
    return htl.html`<p>${_lang({en: "No data available for download", fr: "Aucune donnée disponible pour le téléchargement"})}</p>`;
  }
  
  const region = compositeSelectedComponent.value === "composite" ? 
    _lang({en: "All_Regions", fr: "Toutes_Les_Régions"}) : 
    compositeSelectedComponent.label.replace(/\s+/g, '_');
  
  return downloadButton(
    compositeDownloadData, 
    `composite_vulnerability_data_${region}`,
    _lang({en: "Download Composite Index Data", fr: "Télécharger les Données de l'Indice Composite"})
  );
}
```

<div style="margin-top: 32px;"></div>

## `{ojs} _lang(vulnerability_translations.composite_insights_title)`


`{ojs} compositeVulnerabilityInsights`
