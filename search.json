[
  {
    "objectID": "notebooks/roi/notebook.html",
    "href": "notebooks/roi/notebook.html",
    "title": "",
    "section": "",
    "text": "import {\n  dropdown_section,\n  downloadButton,\n  makeTooltipLabel,\n} from \"/helpers/uiComponents.ojs\";\n\nimport { atlasTOC } from \"/helpers/toc.ojs\";\nimport { formatUSD, inputTemplate } from \"/helpers/std.ojs\";\n\nimport { heroImage as atlasHero } from \"/helpers/hero.js\";\n\nimport {\n  filterableDataTable as atlasTable,\n  sparkbar,\n} from \"/helpers/atlasTable.ojs\";\n\nimport { renderMarkdownWithSlots } from \"/helpers/mdTranslate.ojs\";\nhtml`${atlasHero(nbTitle, \"./../../images/notebooks/roi.webp\")}`;\n\n\n\n\n\n\n\natlasTOC({\n  skip: [\"notebook-title\", \"appendix\", \"source-code\"], // These should be the section headings in the {# headings}\n  heading: `&lt;b&gt;${Lang.toSentenceCase(_lang(general_translations.toc))}&lt;/b&gt;`,\n});"
  },
  {
    "objectID": "notebooks/roi/notebook.html#langnbtext.projectsetup.blocks.costs.h2",
    "href": "notebooks/roi/notebook.html#langnbtext.projectsetup.blocks.costs.h2",
    "title": "",
    "section": "",
    "text": "viewof inputProjectOptions = {\n  const inputProjectCost = Inputs.text({\n    label: makeTooltipLabel({\n      labelText: inputOptions_projectCost.label,\n      tooltipText: inputOptions_projectCost.tooltip\n    }),\n    pattern: inputOptions_projectCost.pattern,\n    placeholder: inputOptions_projectCost.placeholder,\n    value: inputOptions_projectCost.valueString\n  });\n  const inputProjectYears = Inputs.select(inputOptions_projectYears.data, {\n    format: (x) =&gt; x.label,\n    label: makeTooltipLabel({\n      labelText: inputOptions_projectYears.label,\n      tooltipText: inputOptions_projectYears.tooltip\n    }),\n    value: inputOptions_projectYears.data.find((d) =&gt; d.value == 8)\n    });\n\n  return Inputs.form(\n    {\n      cost: inputProjectCost,\n      years:inputProjectYears\n    },\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    }\n  );\n}\n\n\n\n\n\n\n\n{\n  const template = _lang(nbText.projectSetup.blocks.costs.calloutTemplate)\n  const templateItems = [\n    {name: \"money\", value: formatUSD({locale: language.locale})(rangeProjectCost)},\n    {name: \"time\", value: inputProjectOptions.years.label},\n  ]\n  const formatted = Lang.reduceReplaceTemplateItems(template, templateItems)\n  return md`${formatted}`\n}"
  },
  {
    "objectID": "notebooks/roi/notebook.html#langnbtext.projectsetup.blocks.impacts.h2",
    "href": "notebooks/roi/notebook.html#langnbtext.projectsetup.blocks.impacts.h2",
    "title": "",
    "section": "",
    "text": "viewof selections_econPerfWalkthrough = {\n  const _label_prodImpact = makeTooltipLabel({\n      labelText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.prodImpactDropdown.label,\n      ),\n      tooltipText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.prodImpactDropdown.tooltip,\n      ),\n    })\n\n  const _label_Adoption = makeTooltipLabel({\n      labelText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.adoptionRateDropdown.label,\n      ),\n      tooltipText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.adoptionRateDropdown.tooltip,\n      ),\n    })\n\n  const _label_CisImpact = makeTooltipLabel({\n      labelText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.cisImpactDropdown.label,\n      ),\n      tooltipText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.cisImpactDropdown.tooltip,\n      ),\n    })\n\n  const inputProdImpact = Inputs.range(\n    [0, 55],\n    {\n      step: 5,\n      label : _label_prodImpact,\n      value: 30\n    },\n  )\n\n  const inputAdoption = Inputs.range(\n    [0.25, 2],\n    {\n      step: 0.25,\n      label : _label_Adoption,\n      value: 1\n    },\n  )\n\n  const inputCisImpact = Inputs.range(\n    [0, 55],\n    {\n      step: 5,\n      label : _label_CisImpact,\n      value: 25\n    },\n\n  )\n\n  return Inputs.form(\n    {\n      inputProdImpact,\n      inputAdoption,\n      inputCisImpact\n},\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    }\n  )\n}\n\noptions_econPerfWalkthrough = {\n  const formatted = {};\n  for (const [key, value] of Object.entries(selections_econPerfWalkthrough)) {\n    formatted[key] = {\n      label: `${value}%`,\n      value: value / 100\n    };\n  }\n  return formatted;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  const advancedControlsText = nbText.projectSetup.blocks.costs.advancedControls;\n\n  const _benefitLowLabel = makeTooltipLabel({\n    labelText: _lang(advancedControlsText.inputs.benefitScaleLow.label),\n    tooltipText: _lang(advancedControlsText.inputs.benefitScaleLow.tooltip),\n  });\n  const _benefitHighLabel = makeTooltipLabel({\n    labelText: _lang(advancedControlsText.inputs.benefitScaleHigh.label),\n    tooltipText: _lang(advancedControlsText.inputs.benefitScaleHigh.tooltip),\n  });\n  const _costLowLabel = makeTooltipLabel({\n    labelText: _lang(advancedControlsText.inputs.costScaleLow.label),\n    tooltipText: _lang(advancedControlsText.inputs.costScaleLow.tooltip),\n  });\n  const _costHighLabel = makeTooltipLabel({\n    labelText: _lang(advancedControlsText.inputs.costScaleHigh.label),\n    tooltipText: _lang(advancedControlsText.inputs.costScaleHigh.tooltip),\n  });\n\n  const formBenefitScale = Inputs.form(\n    {\n      low: Inputs.range([0.5, 1], {\n        step: 0.01,\n        label: _benefitLowLabel,\n        value: 0.85,\n      }),\n      high: Inputs.range([1, 1.6], {\n        step: 0.01,\n        label: _benefitHighLabel,\n        value: 1.15,\n      }),\n    },\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    },\n  );\n\n  const formCostScale = Inputs.form(\n    {\n      low: Inputs.range([0.5, 1], {\n        step: 0.01,\n        label: _costLowLabel,\n        value: 0.9,\n      }),\n      high: Inputs.range([1, 1.8], {\n        step: 0.01,\n        label: _costHighLabel,\n        value: 1.2,\n      }),\n    },\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    },\n  );\n\n  const _discountLabel = makeTooltipLabel({\n    labelText: _lang(advancedControlsText.inputs.discountRate.label),\n    tooltipText: _lang(advancedControlsText.inputs.discountRate.tooltip),\n  })\n\n  const _roiLabel = makeTooltipLabel({\n    labelText: _lang(advancedControlsText.inputs.roi.label),\n    tooltipText: _lang(advancedControlsText.inputs.roi.tooltip),\n  })\n\n  const formFinancialControls = Inputs.form(\n    {\n      discountRate: Inputs.bind(\n        Inputs.range(\n          [0, 1],\n          {step: 0.01, format: x =&gt; (x * 100), label : _discountLabel, value: 0.12}\n        ),\n        viewof discountRate\n      ),\n      bcr: Inputs.bind(\n        Inputs.range(\n          [0.5, 2],\n          {step: 0.01, label: _roiLabel, value: 1.62}\n        ),\n        viewof bcr\n      )\n    },\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    }\n  );\n\n  return dropdown_section(\n    _lang(general_translations.advancedControls),\n    false,\n    formFinancialControls,\n    `&lt;b&gt;${_lang(advancedControlsText.modelUncertainty)}&lt;/b&gt;`,\n    Inputs.bind(formBenefitScale, viewof uncertaintyBenefitScale),\n    Inputs.bind(formCostScale, viewof uncertaintyCostScale)\n  )\n}\n\n\n\n\n\n\n\nuncertainty = runSimulationFromCashflowRows(recipe_dataCashflow, {\n  simulations: 250,\n  discountRate: discountRate,\n  benefitScale: {\n    low: uncertaintyBenefitScale.low,\n    mode: 1.0,\n    high: uncertaintyBenefitScale.high,\n  },\n  costScale: {\n    low: uncertaintyCostScale.low,\n    mode: 1.0,\n    high: uncertaintyCostScale.high,\n  },\n});"
  },
  {
    "objectID": "notebooks/roi/notebook.html#source-code",
    "href": "notebooks/roi/notebook.html#source-code",
    "title": "",
    "section": "Source code",
    "text": "Source code"
  },
  {
    "objectID": "notebooks/roi/notebook.html#data-import-and-cleaning",
    "href": "notebooks/roi/notebook.html#data-import-and-cleaning",
    "title": "",
    "section": "Data import and cleaning",
    "text": "Data import and cleaning\n\ndb = {\n  let db = await DuckDBClient.of({\n    cv_raw: FileAttachment(\"/data/economicReturns/faostat_prod_cv.parquet\")\n  })\n  await db.query(`\n    CREATE TABLE exposure AS  -- data is ~ 1 mb so table possibly more performant\n      SELECT\n        iso3,\n        admin0_name,\n        admin1_name,\n        REGEXP_REPLACE(crop, '-tropical|-highland', '') AS crop,\n        CONCAT(exposure, '_', unit) AS exposure,\n        SUM(value) AS value\n      FROM read_parquet(\"s3://digital-atlas/domain=exposure/type=combined/source=glw4-2020_spam2020AA/region=ssa/processing=atlas-harmonized/variable=vop_nominal-usd-2021.parquet\")\n      WHERE\n        admin2_name IS NULL AND admin1_name IS NOT NULL\n        AND (tech = 'all' OR tech IS NULL)\n        AND isfinite(value)\n        AND crop !~ '(^other-|rest-of|temperate-fruit|tropical-fruit|vegetables)'\n      GROUP BY\n        iso3,\n        admin0_name,\n        admin1_name,\n        crop,\n        CONCAT(exposure, '_', unit)\n  `)\n  await db.query(`\n    CREATE VIEW cv AS\n      SELECT\n        admin0_name,\n        -- clean and standardize crop names\n        REGEXP_REPLACE(\n          REGEXP_REPLACE(\n            REPLACE(REPLACE(crop, '_meat', ''), ' ', '-'),\n            'goat$', 'goats'\n          ),\n          'pig$', 'pigs'\n        ) AS crop,\n        value_filled AS cv\n      FROM cv_raw\n      WHERE NOT (crop ILIKE '%milk%' OR crop ILIKE '%eggs%' OR LOWER(crop) = 'total')\n\n      UNION ALL\n      -- add robusta-coffee and small-millet substitutes\n      SELECT admin0_name, 'robusta-coffee', value_filled AS cv\n      FROM cv_raw\n      WHERE crop = 'arabica-coffee'\n\n      UNION ALL\n      SELECT admin0_name, 'small-millet', value_filled AS cv\n      FROM cv_raw\n      WHERE crop = 'pearl-millet';\n`)\n  return db;\n};\n\ncountries = {\n  const country_list = await FileAttachment(\"/data/shared/atlas_countries.json\").json();\n  const filteredCountries = country_list\n    .filter((c) =&gt; c.include && c.iso3c !== \"SDN\")\n    .map(({ include, ...rest }) =&gt; rest);\n  return filteredCountries;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndataAdminRegions = {\n  const regions = await db.query(`\n    SELECT DISTINCT admin0_name, admin1_name, iso3\n    FROM exposure\n    WHERE admin1_name IS NOT null\n    AND iso3 in ('${select_country.join(\"', '\")}')\n  `)\n\n  return regions.map(row =&gt; ({\n    ...row,\n    id: `${row.iso3}_${row.admin1_name}`\n  }));\n}\n\n//TODO: Need to add translations and label cleaning to items\ndataCrops = await db.query(`\n  SELECT DISTINCT crop AS item\n  FROM exposure\n  ORDER BY item\n`)"
  },
  {
    "objectID": "notebooks/roi/notebook.html#inputs",
    "href": "notebooks/roi/notebook.html#inputs",
    "title": "",
    "section": "Inputs",
    "text": "Inputs\n\ninputOptions_projectCost = {\n  return {\n    range: [1e6, 5e8],\n    label: _lang(nbText.projectSetup.blocks.costs.inputs.costInput.label),\n    tooltip: _lang(nbText.projectSetup.blocks.costs.inputs.costInput.tooltip),\n    step: 1e5,\n    value: 50_000_000,\n    format: d3.format('$.3s'),\n    outputWidth: 90,\n    placeholder: \"Ex. $5,000,000\",\n    pattern: \"^[$]?[1-9]+[0-9,$]*$\",\n    valueString: \"$50,000,000\"\n  }\n}\n\ninputOptions_projectYears = {\n  const years = _lang(\n      nbText.projectSetup.blocks.costs.inputs.projectYearDropdown.terms.year.plural,\n  );\n  return {\n    range: [2, 16],\n    data: d3\n      .range(2, 16 + 1, 1)\n      .map((d) =&gt; ({ label: `${d} ${years}`, value: d })),\n    label: _lang(nbText.projectSetup.blocks.costs.inputs.projectYearDropdown.label),\n    tooltip: _lang(nbText.projectSetup.blocks.costs.inputs.projectYearDropdown.tooltip),\n    step: 1,\n    value: 8,\n    outputWidth: 90\n  };\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScope Selectors - country, region, crop\n\nviewof select_country = {\n  const data = countries\n    .map((d) =&gt; ({\n      value: d.iso3c, //Migrating to iso codes for future flexability\n      label: _lang(d.translation)\n    }))\n  let input = dropdownInput({\n    inputLabel: makeTooltipLabel({\n      labelText: _lang(nbText.supportNbText.words.country.plural),\n      tooltipText: _lang(\n        nbText.projectSetup.blocks.locations.inputs.countryDropdown.tooltip\n      )\n    }),\n    inputId: \"positionsTest\",\n    placeholderText: \"Select Countries...\",\n    options: data,\n    selected: [\"KEN\", \"TZA\"],\n  });\n\n  return debounce(input, 1000); // Noisy input, so delay it a bit.\n}\n\n\n\n\n\n\n\n// admin multi-select: regions\nviewof select_region = {\n  // filter regions based on country id's\n  const filteredRegions = dataAdminRegions\n  // const translateCountry = (d) =&gt; _lang(td.admin0_name.values?.[d]);\n  const translateCountry = (iso) =&gt; _lang(countries.find((c) =&gt; c.iso3c === iso).translation);\n  const data = filteredRegions.map((d) =&gt; ({\n    value: d.id,\n    label: `${translateCountry(d.iso3)}: ${d.admin1_name}`\n  }));\n  const selectedIds = filteredRegions.map((d) =&gt; d.id);\n  const text = {\n    label: _lang(nbText.supportNbText.words.region.plural),\n    tooltip: _lang(nbText.projectSetup.blocks.locations.inputs.regionDropdown.tooltip),\n  }\n  const input = dropdownInput({\n    inputLabel: makeTooltipLabel({labelText: text.label, tooltipText: text.tooltip}),\n    inputId: \"positionsTest\",\n    placeholderText: \"Select regions...\",\n    options: data,\n    selected: selectedIds\n  });\n\n  return debounce(input, 1000);\n}\n\n\n\n\n\n\n\n// admin multi-select: countries\nviewof select_crop = {\n  const data = dataCrops\n    .map((d) =&gt; ({\n      value: d.item,\n      label: Lang.toSentenceCase(d.item) //TODO: Add translations\n    }))\n    .sort((a,b) =&gt; a.label &gt; b.label);\n  const selectedId = dataCrops\n    .filter((d) =&gt; [\"bean\", \"goats\", \"maize\"].includes(d.item))\n    .map((d) =&gt; d.item);\n  const text = {\n    label: _lang(nbText.supportNbText.words.commodity.plural),\n    tooltip: _lang(\n      nbText.projectSetup.blocks.locations.inputs.commodityDropdown.tooltip\n    )\n  };\n  const input = dropdownInput({\n    inputLabel: makeTooltipLabel({\n      labelText: text.label,\n      tooltipText: text.tooltip\n    }),\n    inputId: \"positionsTest\",\n    placeholderText: \"Select crops...\",\n    options: data,\n    selected: selectedId\n  });\n\n  return debounce(input, 1000);\n}"
  },
  {
    "objectID": "notebooks/roi/notebook.html#economic-input-variables",
    "href": "notebooks/roi/notebook.html#economic-input-variables",
    "title": "",
    "section": "Economic Input Variables",
    "text": "Economic Input Variables\n\nMain Control Variables\n\nrangeProjectCost = {\n  const unpack = Number(inputProjectOptions.cost.replace(/[,|$]/g, \"\"))\n  const number = Number(unpack)\n  return number\n}\n\nprojectYears = inputProjectOptions.years.value\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrender_econPerfWalkthrough = () =&gt; {\n  const terms = {\n    none: _lang(nbText.projectSetup.blocks.impacts.terms.none, {\n      key: language.key,\n    }),\n    low: _lang(nbText.projectSetup.blocks.impacts.terms.low, {\n      key: language.key,\n    }),\n    moderate: _lang(nbText.projectSetup.blocks.impacts.terms.moderate, {\n      key: language.key,\n    }),\n    high: _lang(nbText.projectSetup.blocks.impacts.terms.high, {\n      key: language.key,\n    }),\n    incremental: _lang(nbText.projectSetup.blocks.impacts.terms.incremental),\n    transformative: _lang(\n      nbText.projectSetup.blocks.impacts.terms.transformative,\n    ),\n  };\n  const dataProdImpact = [\n    { label: `10% (${terms.incremental})`, value: 0.1 },\n    { label: `20%`, value: 0.2 },\n    { label: `30% (${terms.moderate})`, value: 0.3 },\n    { label: `40%`, value: 0.4 },\n    { label: `50% (${terms.transformative})`, value: 0.5 },\n  ];\n  const inputProdImpact = Inputs.select(dataProdImpact, {\n    label: makeTooltipLabel({\n      labelText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.prodImpactDropdown.label,\n      ),\n      tooltipText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.prodImpactDropdown.tooltip,\n      ),\n    }),\n    format: (x) =&gt; x.label,\n    value: dataProdImpact.find((d) =&gt; d.value == 0.3),\n  });\n  const dataAdoption = [\n    { label: `0.5% (${terms.low})`, value: 0.005 },\n    { label: `1% (${terms.moderate})`, value: 0.01 },\n    { label: `2% (${terms.high})`, value: 0.02 },\n  ];\n  const inputAdoption = Inputs.select(dataAdoption, {\n    label: makeTooltipLabel({\n      labelText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.adoptionRateDropdown.label,\n      ),\n      tooltipText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.adoptionRateDropdown.tooltip,\n      ),\n    }),\n    format: (x) =&gt; x.label,\n    value: dataAdoption.find((d) =&gt; d.value == 0.01),\n  });\n  const dataCisImpact = [\n    { label: `0% (${terms.none})`, value: 0 },\n    { label: `10% (${terms.low})`, value: 0.1 },\n    { label: `25% (${terms.moderate})`, value: 0.25 },\n    { label: `50% (${terms.high})`, value: 0.5 },\n  ];\n  const inputCisImpact = Inputs.select(dataCisImpact, {\n    label: makeTooltipLabel({\n      labelText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.cisImpactDropdown.label,\n      ),\n      tooltipText: _lang(\n        nbText.projectSetup.blocks.impacts.inputs.cisImpactDropdown.tooltip,\n      ),\n    }),\n    format: (x) =&gt; x.label,\n    value: dataCisImpact.find((d) =&gt; d.value == 0.25),\n  });\n  return Inputs.form(\n    {\n      inputProdImpact,\n      inputAdoption,\n      inputCisImpact,\n    },\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    },\n  );\n};\n\n\n\n\n\n\n\n\nAdvanced Control Variables\n\nviewof discountRate = Inputs.range([0, 1],{step: 0.01, format: x =&gt; (x * 100), value: 0.12, label: \"Discount Rate\"} ) // 0-1 as a pct\nviewof bcr = Inputs.range([0.5, 2], {step: 0.01, label: \"BCR\", value: 1.62} )\n\n\nviewof uncertaintyBenefitScale = Inputs.form(\n    {\n      low: Inputs.range([0.5, 1], {\n        step: 0.01,\n        value: 0.9,\n      }),\n      high: Inputs.range([1, 1.8], {\n        step: 0.01,\n        value: 1.2,\n      }),\n    },\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    },\n  );\n\nviewof uncertaintyCostScale = Inputs.form(\n    {\n      low: Inputs.range([0.5, 1], {\n        step: 0.01,\n        value: 0.9,\n      }),\n      high: Inputs.range([1, 1.8], {\n        step: 0.01,\n        value: 1.2,\n      }),\n    },\n    {\n      template: inputTemplate({ gap: \"3em\" }),\n    },\n  );\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOther Selections\n\n// Plot Variable\n// base selector for metric type\nviewof pickMetricWalkthrough = {\n  return Inputs.select(dataPickMetric, {\n    label: _lang(nbText.indicators.general.terms.indicator),\n    format: (x) =&gt; x.labelFull,\n    value: dataPickMetric.find((d) =&gt; d.key == \"irr\")\n  });\n}"
  },
  {
    "objectID": "notebooks/roi/notebook.html#elements",
    "href": "notebooks/roi/notebook.html#elements",
    "title": "",
    "section": "Elements",
    "text": "Elements\n\nimport { dropdownInput, dropdownCSS } from \"/helpers/multiSelect.ojs\";\n\ndropdownCSS;"
  },
  {
    "objectID": "notebooks/roi/notebook.html#helper-functions",
    "href": "notebooks/roi/notebook.html#helper-functions",
    "title": "",
    "section": "Helper Functions",
    "text": "Helper Functions\n\ndebounce = (input, delay = 500) =&gt; {\n  class DelayedEvent extends Event {}\n  let id;\n  input.addEventListener(\"input\", (e) =&gt; {\n    if (e instanceof DelayedEvent) return;\n    e.stopImmediatePropagation();\n    clearTimeout(id);\n    id = setTimeout(\n      () =&gt; input.dispatchEvent(new DelayedEvent(\"input\", { bubbles: true })),\n      delay,\n    );\n  });\n  return input;\n};"
  },
  {
    "objectID": "notebooks/roi/notebook.html#language",
    "href": "notebooks/roi/notebook.html#language",
    "title": "",
    "section": "Language",
    "text": "Language\n\n\nnbTitle = _lang({\n  en: \"Estimate Economic Returns on Adaptation\",\n  fr: \"Estimer les retours sur économiques l'adaptation\",\n});\n// key_insights = _lang({en: \"Key Insights\", fr: \"Résumé\"})\nnbOverview = _lang({ en: \"Overview\", fr: \"Vue d’Ensemble\" });\nheading1 = _lang({ en: \"Project Set-Up\", fr: \"Configuration de Project\" });\nheading2 = _lang({ en: \"Investment Returns\", fr: \"Retours d'Investissements\" });\nnbSummary = _lang({ en: \"Summary\", fr: \"Résumé\" });\nnbMethods = _lang({ en: \"Methods & Sources\", fr: \"Méthodes & Sources\" });\nappendix = _lang(general_translations.appendix);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { lang as Lang } from \"/helpers/lang.js\"\n\ngeneral_translations = await FileAttachment(\"/data/shared/generalTranslations.json\").json()\n\nnbText = await FileAttachment(\"/data/economicReturns/translations.json\").json()\n\nlanguages = [\n  { key: \"en\", label: \"English\", locale: 'en-US' },\n  { key: \"fr\", label: \"Français\", locale: 'fr-FR' }\n]\n\ndefaultLangKey = {\n  const name = \"lang\";\n  const list = languages.map((d) =&gt; d.key);\n  const defaultKey = \"en\";\n  const queryParam = await Lang.getParamFromList({ name, list });\n  return queryParam ?? defaultKey;\n}\n\n_lang = Lang.lg(masterLanguage.key)\n\nviewof masterLanguage = Inputs.radio(languages, {\n  label: \"Main language toggle\",\n  format: (d) =&gt; d.key,\n  value: languages.find((x) =&gt; x.key === defaultLangKey),\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction NavbarLangSelector(language_obj, masterLanguage) {\n  let navEnd = document.querySelector(\".navbar-nav.ms-auto .nav-item.compact\");\n  if (navEnd) {\n    let existingLangSelector = document.getElementById(\"nav-lang-selector\");\n    if (!existingLangSelector) {\n      let lang_sel = Inputs.bind(\n        Inputs.radio(language_obj, {\n          label: \"\",\n          format: (d) =&gt; d.label\n        }),\n        viewof masterLanguage\n      );\n      lang_sel.id = \"nav-lang-selector\";\n\n      // Hack the css together for the observable inputs\n      lang_sel.style.display = \"flex\";\n      lang_sel.style.alignItems = \"center\";\n      lang_sel.style.marginLeft = \"10px\";\n      let lang_div = lang_sel.querySelector(\"div\");\n      lang_div.style.display = \"flex\";\n      lang_div.style.flexDirection = \"column\";\n\n      // Insert the new item after the GitHub icon and other elements\n      navEnd.parentNode.appendChild(lang_sel);\n    }\n  }\n}\n\nNavbarLangSelector(languages, masterLanguage)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarkdown notebook text\n\ndataPickMetric = {\n  return [\n    {\n      key: \"irr\",\n      columnName: \"irr\",\n      label: _lang(nbText.indicators.irr.label),\n      tooltip: _lang(nbText.indicators.irr.tooltip),\n      labelLong: _lang(nbText.indicators.irr.labelLong),\n      labelFull: _lang(nbText.indicators.irr.labelFull),\n      info: {\n        what: _lang(nbText.indicators.irr.info.what),\n        interpret: _lang(nbText.indicators.irr.info.interpret),\n        tell: _lang(nbText.indicators.irr.info.tell)\n      },\n      yFormat: (d) =&gt; `${d.toFixed(1)}%`\n    },\n    {\n      key: \"mirr\",\n      columnName: \"mirr\",\n      label: _lang(nbText.indicators.mirr.label),\n      tooltip: _lang(nbText.indicators.mirr.tooltip),\n      labelLong: _lang(nbText.indicators.mirr.labelLong),\n      labelFull: _lang(nbText.indicators.mirr.labelFull),\n      info: {\n        what: _lang(nbText.indicators.mirr.info.what),\n        interpret: _lang(nbText.indicators.mirr.info.interpret),\n        tell: _lang(nbText.indicators.mirr.info.tell)\n      },\n      yFormat: (d) =&gt; `${d.toFixed(1)}%`\n    },\n    {\n      key: \"npv\",\n      columnName: \"npv\",\n      label: _lang(nbText.indicators.npv.label),\n      tooltip: _lang(nbText.indicators.npv.tooltip),\n      labelLong: _lang(nbText.indicators.npv.labelLong),\n      labelFull: _lang(nbText.indicators.npv.labelFull),\n      info: {\n        what: _lang(nbText.indicators.npv.info.what),\n        interpret: _lang(nbText.indicators.npv.info.interpret),\n        tell: _lang(nbText.indicators.npv.info.tell)\n      },\n       yFormat: (d) =&gt; formatUSD()(d)\n    },\n    {\n      key: \"bcr\",\n      columnName: \"discounted_bcr\",\n      label: _lang(nbText.indicators.bcr.label),\n      tooltip: _lang(nbText.indicators.bcr.tooltip),\n      labelLong: _lang(nbText.indicators.bcr.labelLong),\n      labelFull: _lang(nbText.indicators.bcr.labelFull),\n      info: {\n        what: _lang(nbText.indicators.bcr.info.what),\n        interpret: _lang(nbText.indicators.bcr.info.interpret),\n        tell: _lang(nbText.indicators.bcr.info.tell)\n      },\n      yFormat: d3.format(\".2f\")\n    }\n  ];\n}\n\n\n\n\n\n\n\nrenderReview1 = () =&gt; {\n  const langBasePath = nbText.investmentReturns.blocks.insightReview.setupBlock;\n  const langMissingTemplate = _lang(langBasePath.missingMessage, {\n    key: language.key,\n  });\n\n  const isoSet = new Set(select_country);\n\n  const admin0List = countries\n    .filter((d) =&gt; isoSet.has(d.iso3c))\n    .map((d) =&gt; d.admin0_name);\n\n  const cropList = select_crop;\n\n  // const cropList = adminCropChoices.crops.sort((a,b) =&gt; _lang(a.translation) &gt; _lang(b.translation));\n  const truncateSize = 3;\n  const admin0ListTruncated = admin0List.slice(0, truncateSize);\n  const cropListTruncated = cropList.slice(0, truncateSize); // .map((d) =&gt; _lang(d.translation));\n\n  if (admin0List.length == 0 || cropList.length == 0) {\n    return md`${langMissingTemplate}`;\n  }\n\n  // new code\n  const insertCropCount = cropList.length;\n  const insertCropWord =\n    cropList.length == 1\n      ? _lang(nbText.supportNbText.words.crop.singular, {\n          key: language.key,\n        })\n      : _lang(nbText.supportNbText.words.crop.plural, {\n          key: language.key,\n        });\n  const insertCropList = `(**${cropListTruncated.join(\", \")}${\n    cropList.length &gt; truncateSize ? \"...\" : \"\"\n  }**)`;\n  const insertCrop = `**${insertCropCount} ${insertCropWord}** ${insertCropList}`;\n\n  const insertRegionCount = select_region.length;\n  const insertRegionWord =\n    insertRegionCount == 1\n      ? _lang(nbText.supportNbText.words.region.singular, {\n          key: language.key,\n        })\n      : _lang(nbText.supportNbText.words.region.plural, {\n          key: language.key,\n        });\n  const insertRegion = `${insertRegionCount} ${insertRegionWord}`;\n\n  const insertCountryCount = admin0List.length;\n  const insertCountryWord =\n    insertCountryCount == 1\n      ? _lang(nbText.supportNbText.words.country.singular, {\n          key: language.key,\n        })\n      : _lang(nbText.supportNbText.words.country.plural, {\n          key: language.key,\n        });\n  const insertCountryList = `(**${admin0ListTruncated.join(\", \")}${\n    insertCountryCount &gt; truncateSize ? \"...\" : \"\"\n  }**)`;\n  const insertCountry = `**${insertCountryCount} ${insertCountryWord}** ${insertCountryList}`;\n\n  // insert to template\n  const langTemplate = _lang(langBasePath.template, {\n    key: language.key,\n  });\n  const langTemplateItems = [\n    { name: \"crop_string\", value: insertCrop },\n    { name: \"region_string\", value: insertRegion },\n    { name: \"country_string\", value: insertCountry },\n    {\n      name: \"cost_string\",\n      value: formatUSD({ locale: language.locale })(rangeProjectCost),\n    },\n    { name: \"year_string\", value: projectYears + \" years\" }, //TODO: add correct \"years\" string at end of this\n  ];\n  const selectionFormattedTemplate = Lang.reduceReplaceTemplateItems(\n    langTemplate,\n    langTemplateItems,\n  );\n\n  return md`${selectionFormattedTemplate}`;\n};\n\n\n\n\n\n\n\nrenderReview2 = () =&gt; {\n  const investmentTemplate = _lang(\n    nbText.investmentReturns.blocks.insightReview.indicatorBlock,\n  );\n  const investmentTemplateItems = [\n    {\n      name: \"prod_impact_label\",\n      value: options_econPerfWalkthrough.inputProdImpact.label,\n    },\n    {\n      name: \"adoption_rate_label\",\n      value: options_econPerfWalkthrough.inputAdoption.label,\n    },\n    {\n      name: \"cis_impact_label\",\n      value: options_econPerfWalkthrough.inputCisImpact.label,\n    },\n    { name: \"year_string\", value: projectYears + \" years\" },\n  ];\n\n  return md`${Lang.reduceReplaceTemplateItems(investmentTemplate, investmentTemplateItems)}:`;\n};\n\n\n\n\n\n\n\n\nResult Elements\n\nbigNumbersResults = () =&gt; {\n  const y = projectYears;\n  const e = walkthroughEconomicIndicators?.enriched?.find((d) =&gt; d.year === y);\n\n  const data = dataPickMetric.map((d) =&gt; {\n    let value;\n\n    if (d.key === \"irr\" && e?.irr != null) {\n      value = e.irr; // IRR as percentage\n    } else if (d.key === \"mirr\" && e?.mirr != null) {\n      value = e.mirr; // MIRR as percentage\n    } else if (\n      d.key === \"npv\" &&\n      e?.discounted_benefit_cum != null &&\n      e?.discounted_cost_cum != null\n    ) {\n      value = +(e.discounted_benefit_cum - e.discounted_cost_cum).toFixed(1); // NPV, 1 dp\n    } else if (d.key === \"bcr\") {\n      value = e?.discounted_bcr;\n    }\n\n    return { ...d, value };\n  });\n\n  return htl.html`\n  &lt;style&gt;\n    .outer-div {\n      display: flex;\n      gap: 2em;\n    }\n    .inner-div {\n      width: 30%;\n      padding: 80px 30px;\n      border: 1px solid #efefef;\n    }\n    .label {\n      display: block;\n      font-weight: 400;\n      font-size: 14px;\n      text-transform: uppercase;\n      color: #666;\n    }\n    .value {\n      font-weight: bold;\n      font-size: 42px;\n    }\n    .negative {\n      color: #EC5A47;\n    }\n    .tooltip-card {\n        position: relative;\n        display: inline-block;\n        cursor: pointer;\n        width: 100%;\n    }\n    .tooltip-card .tooltiptext-card {\n        position: absolute;\n        z-index: 1;\n        visibility: hidden;\n        left: 0;\n        bottom: 90%;\n        background-color: #efefef;\n        color: #333;\n        padding: 14px 20px;\n        font-size: 14px;\n        line-height: 1.6;\n        text-align: left;\n        opacity: 0;\n        transition: opacity 0.3s;\n    }\n    .tooltip-card:hover .tooltiptext-card {\n        visibility: visible;\n        opacity: 1;\n        cursor: default;\n    }\n  &lt;/style&gt;\n\n  &lt;body&gt;\n    &lt;div class=\"outer-div\"&gt;\n      ${data.map(\n        (d) =&gt; htl.html`&lt;div class=\"inner-div\"&gt;\n          &lt;span class=\"tooltip-card\"&gt;\n            &lt;span class=\"tooltiptext-card\"&gt;${d.tooltip}&lt;/span&gt;\n            &lt;span class=\"value ${d.value != null && d.value &lt; 0 ? \"negative\" : \"\"}\"&gt;${\n              d.value != null ? d.yFormat(d.value) : \"---\"\n            }&lt;/span&gt;\n            &lt;span class=\"label\"&gt;${d.labelFull}&lt;/span&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;`,\n      )}\n    &lt;/div&gt;\n  &lt;/body&gt;`;\n};\n\n\n\n\n\n\n\nresultTable = () =&gt; {\n  const fmtUSD = formatUSD({ locale: language.locale });\n  const selectedYear = projectYears;\n  const enriched = (walkthroughEconomicIndicators?.enriched ?? []).filter(\n    (d) =&gt; d.year &lt;= selectedYear,\n  );\n\n  const tableHeaders =\n    nbText.investmentReturns.blocks.exploreIndicators.tableHeaders;\n  const headerNames = [\n    _lang(tableHeaders.year),\n    _lang(tableHeaders.benefit),\n    _lang(tableHeaders.cost),\n    _lang(tableHeaders.cashflow),\n    _lang(tableHeaders.discountedBenefitCum),\n    _lang(tableHeaders.discountedCostCum),\n    _lang(tableHeaders.discountedNpvCum),\n    _lang(tableHeaders.discountedBcr),\n    _lang(tableHeaders.irr),\n    _lang(tableHeaders.mirr),\n  ];\n\n  return html`\n    &lt;style&gt;\n      .econ-table {\n        font-family: sans-serif;\n        border-collapse: collapse;\n        font-size: 13.75px;\n        margin-top: 1em;\n        min-width: 100%;\n      }\n      .econ-table th, .econ-table td {\n        border: 1px solid #ddd;\n        padding: 6px 10px;\n        text-align: right;\n      }\n      .econ-table th {\n        background-color: #f4f4f4;\n        white-space: normal;\n        text-align: center;\n      }\n      .econ-table td.year-col {\n        text-align: center;\n        font-weight: bold;\n      }\n      .econ-table tr.final-row td {\n        font-weight: bold;\n        background-color: #f1f1f1;\n      }\n      .table-container {\n        overflow-x: auto;\n        display: block;\n        padding-bottom: 4px;\n      }\n    &lt;/style&gt;\n\n    &lt;div class=\"table-container\"&gt;\n      &lt;table class=\"econ-table\"&gt;\n        &lt;thead&gt;\n          &lt;tr&gt;\n            ${headerNames.map((h) =&gt; html`&lt;th title=\"${h}\"&gt;${h}&lt;/th&gt;`)}\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          ${enriched.map((d, i) =&gt; {\n            const isFinal = i === enriched.length - 1;\n            const npv_i =\n              d.discounted_benefit_cum != null && d.discounted_cost_cum != null\n                ? d.discounted_benefit_cum - d.discounted_cost_cum\n                : null;\n\n            return html`&lt;tr class=${isFinal ? \"final-row\" : \"\"}&gt;\n              &lt;td class=\"year-col\"&gt;${d.year}&lt;/td&gt;\n              &lt;td&gt;${d.project_benefit != null ? fmtUSD(d.project_benefit) : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${d.cost != null ? fmtUSD(d.cost) : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${d.cashflow != null ? fmtUSD(d.cashflow) : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${d.discounted_benefit_cum != null ? fmtUSD(d.discounted_benefit_cum) : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${d.discounted_cost_cum != null ? fmtUSD(d.discounted_cost_cum) : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${npv_i != null ? fmtUSD(npv_i) : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${d.discounted_bcr != null ? d.discounted_bcr.toFixed(2) : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${d.irr != null ? `${(d.irr).toFixed(2)}%` : \"—\"}&lt;/td&gt;\n              &lt;td&gt;${d.mirr != null ? `${(d.mirr).toFixed(2)}%` : \"—\"}&lt;/td&gt;\n            &lt;/tr&gt;`;\n          })}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/div&gt;\n  `;\n};\n\n\n\n\n\n\n\nresultPlot = () =&gt; {\n  const projectYearCutoff = walkthroughSelections.project_years;\n  const selector = pickMetricWalkthrough;\n  const plotData = walkthroughEconomicIndicators?.enriched ?? [];\n  const uncertaintyYearly = uncertainty?.yearly ?? [];\n\n  // Always include all years for consistent x-axis\n  const fullYears = d3.range(0, projectYears + 1); // 0 to 8 inclusive\n  const completePlotData = fullYears.map((y) =&gt; {\n    const row = plotData.find((d) =&gt; d.year === y);\n    return row ?? { year: y };\n  });\n\n  const bandData = (() =&gt; {\n    const metricKey = selector.key;\n    return fullYears\n      .map((year) =&gt; {\n        const row = uncertaintyYearly.find((d) =&gt; d.year === year);\n        const low = row?.[metricKey]?.p10;\n        const high = row?.[metricKey]?.p90;\n        if (!Number.isFinite(low) || !Number.isFinite(high)) return null;\n        return { year, low, high };\n      })\n      .filter((d) =&gt; d != null);\n  })();\n\n  const ruleYValue = selector.key === \"bcr\" ? 1 : 0;\n\n  return Plot.plot({\n    width,\n    marginRight: 80,\n    inset: 5,\n    x: {\n      label: _lang(\n        nbText.investmentReturns.blocks.exploreIndicators.projectYear,\n      ),\n      ticks: fullYears,\n      tickFormat: \"d\",\n      labelAnchor: \"center\",\n      labelArrow: \"none\",\n    },\n    y: {\n      label: selector.label,\n      tickFormat: selector.yFormat,\n    },\n    marks: [\n      Plot.axisY({\n        anchor: \"right\",\n        label: selector.label,\n        tickFormat: selector.yFormat,\n        tickSize: 0,\n        color: (d) =&gt; {\n          return d &gt;= 0 ? \"black\" : \"#EC5A47\";\n        },\n      }),\n      // horizontal reference line\n      Plot.ruleY([ruleYValue], {\n        stroke: \"#333\",\n        strokeDasharray: [3],\n      }),\n\n      Plot.areaY(bandData, {\n        x: \"year\",\n        y1: \"low\",\n        y2: \"high\",\n        fill: \"#2c7fb8\",\n        fillOpacity: 0.16,\n      }),\n\n      // line\n      Plot.line(completePlotData, {\n        x: \"year\",\n        y: selector.columnName,\n        stroke: \"#444\",\n        strokeOpacity: 0.7,\n        strokeWidth: 2,\n        tip: true,\n      }),\n\n      // dots\n      Plot.dot(completePlotData, {\n        x: \"year\",\n        y: selector.columnName,\n        r: 3,\n        fill: \"#444\",\n        stroke: \"#fff\",\n        strokeWidth: 0.5,\n        tip: {\n          format: {\n            x: true,\n            y: selector.yFormat,\n          },\n        },\n      }),\n\n      // highlight selected year\n      Plot.dot(\n        completePlotData.filter((d) =&gt; d.year === projectYearCutoff),\n        {\n          x: \"year\",\n          y: selector.columnName,\n          r: 7,\n          fill: \"#fff\",\n          stroke: (d) =&gt; (d[selector.columnName] &gt;= 0 ? \"#333\" : \"#EC5A47\"),\n          strokeWidth: 2,\n        },\n      ),\n    ],\n  });\n};"
  },
  {
    "objectID": "notebooks/roi/notebook.html#data-analysis-and-processing",
    "href": "notebooks/roi/notebook.html#data-analysis-and-processing",
    "title": "",
    "section": "Data Analysis and Processing",
    "text": "Data Analysis and Processing\n\nadmin0_names = {\n  const isoSet = new Set(select_country);\n  return countries\n  .filter((d) =&gt; isoSet.has(d.iso3c))\n  .map((d) =&gt; d.admin0_name);\n}\n\n\n\n\n\n\n\nCV Data\n\n// Module Imports for the calculation of ROI data\nimport {\n  avlossCalc,\n  avlossCalcUncertainty,\n  calcMIRR,\n  calcIRR,\n  npvDiscreteCumulative,\n  runSimulationFromCashflowRows,\n} from \"/notebooks/roi/roi_tools.js\";\n\n\n\n\n\n\n\nmutable cv_result = [];\nmutable cv_cache_key = '';\n\ncalcCV = async () =&gt; {\n  const cis_impact = options_econPerfWalkthrough.inputCisImpact.value;\n\n  const cache_key = `${[...admin0_names].sort().join(',')}|${[...select_crop].sort().join(',')}|${cis_impact}`;\n\n  if (cv_cache_key === cache_key) {\n    console.log('Skipped cv run as inputs the same');\n    return cv_result;\n  }\n\n  console.log('Running the cv analysis as inputs changed')\n  const cv_data = await db.query(`\n    SELECT *\n    FROM cv\n    WHERE crop in ('${select_crop.join(\"', '\")}')\n    AND admin0_name in ('${admin0_names.join(\"', '\")}') -- This needs the a0_name rather than iso3\n`);\n\n  const cv_monteCarlo = await Promise.all(\n    cv_data.map(async ({ crop, admin0_name, cv }) =&gt; {\n      const av = await avlossCalc(cv, cis_impact);\n      const avloss = Math.abs(Number(av.toFixed?.(4) ?? av));\n      return { admin0_name, crop, cv, cis_impact, avloss };\n    }),\n  );\n\n  const cv_index = new Map();\n  for (const { admin0_name, crop, avloss } of cv_monteCarlo) {\n    cv_index.set(`${admin0_name}|${crop}`, avloss);\n  }\n\n  mutable cv_result = cv_index\n  mutable cv_cache_key = cache_key\n  return cv_index\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOther ROI X Exposure Variables\n\n// getExposureData = async (crops, countries) =&gt; {\n// NOTE: Making this a dataset rather than a function so it only re-runs when crop or country change.\n// Defaulting to all admin 1 data as all admin regions are selected by defualt and this\n// will prevent having to have users re-query the datasets when changing regions in a county.\n\nexposure_data = {\n  let crops = select_crop;\n  let countries = select_country;\n  let data = await db.query(`\n    SELECT *\n    FROM exposure\n    WHERE crop in ('${crops.join(\"', '\")}')\n    AND iso3 in ('${countries.join(\"', '\")}')\n    -- POSSIBLY add admin1 name filter, but defaults to full country, so maybe bigger query is better.\n  `);\n  return data;\n};\n\n\n\n\n\n\n\ncrop_adoption = async () =&gt; {\n  // Globals from the notebook\n  const adoption = options_econPerfWalkthrough.inputAdoption.value;\n  const years = projectYears;\n  const prod_impact = options_econPerfWalkthrough.inputProdImpact.value;\n  // let data = await getExposureData(select_crop, select_country);\n  const data = exposure_data;\n  const result = [];\n\n  for (const row of data) {\n    const value = row.value || 0;\n    let xPrev = 0;\n\n    for (let i = 1; i &lt;= years; i++) {\n      // cumulative adoption\n      let x;\n      if (i === 1) {\n        x = Math.round(value * adoption * 10) / 10;\n      } else {\n        x = Math.round((value - xPrev) * adoption * 10) / 10 + xPrev;\n      }\n\n      xPrev = x;\n\n      // push a long-form row\n      result.push({\n        admin0_name: row.admin0_name,\n        admin1_name: row.admin1_name,\n        iso3c: row.iso3,\n        crop: row.crop,\n        exposure: row.exposure,\n        value: row.value,\n        adoption: adoption,\n        prod_impact: prod_impact,\n        year_char: `y${i}`,\n        year: i,\n        result: x,\n      });\n    }\n  }\n\n  return result.map((row) =&gt; {\n    const result_w_impact =\n      Math.round(row.result * (1 + (row.prod_impact ?? 0)) * 10) / 10;\n    const marginal_impact =\n      Math.round((result_w_impact - row.result) * 10) / 10;\n    return { ...row, result_w_impact, marginal_impact };\n  });\n};\n\n//NOTE: QAQC RESULTS:\n// 1 region & crop: PERFECT - This output matches the R script output exactly\n\n\n\n\n\n\n\nroiResults = async () =&gt; {\n  const index = await calcCV();\n  const data = await crop_adoption();\n\n  const withImpact = data.map((row) =&gt; {\n    const key = `${row.admin0_name}|${row.crop}`;\n    const avloss = index.get(key) ?? 0; // default to 0 if missing\n\n    const result_w_impact_cis =\n      Math.round(row.result_w_impact * (1 + avloss) * 10) / 10;\n    const marginal_cis =\n      Math.round((result_w_impact_cis - row.result_w_impact) * 10) / 10;\n    const marginal_impact_cis =\n      (marginal_cis || 0) + (row.marginal_impact || 0);\n\n    return {\n      ...row,\n      avloss,\n      result_w_impact_cis,\n      marginal_cis,\n      marginal_impact_cis,\n    };\n  });\n\n  return withImpact.map((d) =&gt; {\n    const project_benefit =\n      Math.round((d.marginal_impact_cis - d.marginal_impact_cis / bcr) * 10) /\n      10;\n    const cis_impact = options_econPerfWalkthrough.inputCisImpact.value;\n    return { ...d, bcr, cis_impact, project_benefit };\n  });\n};\n\n//NOTE: QAQC RESULTS:\n// 1 region & crop: Good - Output is close, the MC simulation gives different results, but the difference is few $100 each time\n\n\n\n\n\n\n\n\nROI X inputs Calculations\n\nSum across admins and crops\nWe select all the data for admin regions and crops, and sum up to get the benefit across all parameter combos.\n\nregionSet = new Set(select_region);\n\n\n\n\n\n\n\nrecipe_dataSummed = async () =&gt; {\n  document.body.style.cursor = \"wait\";\n  const roi_data = await roiResults();\n\n  // Filter down on this step to the selected regions\n  const roi_data_filtered = roi_data.filter((d) =&gt;\n    regionSet.has(`${d.iso3c}_${d.admin1_name}`),\n  );\n\n  const aggregated = d3\n    .flatGroup(\n      roi_data_filtered,\n      (d) =&gt; d.adoption,\n      (d) =&gt; d.prod_impact,\n      (d) =&gt; d.cis_impact,\n      (d) =&gt; d.bcr,\n      (d) =&gt; d.year,\n    )\n    .map(([adoption, prod_impact, cis_impact, bcr, year, group]) =&gt; ({\n      adoption,\n      prod_impact,\n      cis_impact,\n      bcr,\n      year,\n      project_benefit: d3.sum(group, (d) =&gt; d.project_benefit),\n    }));\n\n  document.body.style.cursor = \"default\";\n  return aggregated;\n};\n\n\n\n\n\n\n\n\nDefine project payment schedule\nBelow we define the project cost schedule\n\nCost is evenly distributed across years (\n\nEx. 1M over 5 years is 200K, 400K, 600K, 800K, 1M; the first year has no project benefit ($200K, 0 benefit)\n\n\n\nrecipe_paymentSchedule = Array.from({ length: projectYears }).map((_, i) =&gt; {\n  return {\n    year: i,\n    cost: (1 / projectYears) * rangeProjectCost,\n    cost_cum: ((i + 1) / projectYears) * rangeProjectCost,\n  };\n});\n\n\n\n\n\n\n\n\nAdd project scope to data\n\nAdd a zero year at the start (the return rate is hardcoded to one year)\nAlso if the project cost is zero, return an empty array\n\n\nrecipe_dataCashflow = {\n  if (!rangeProjectCost || rangeProjectCost === 0) return [];\n\n  const payByYear = new Map(recipe_paymentSchedule.map((d) =&gt; [d.year, d]));\n\n  const data = await recipe_dataSummed();\n\n  return d3\n    .flatGroup(\n      data,\n      (d) =&gt; d.adoption,\n      (d) =&gt; d.prod_impact,\n      (d) =&gt; d.cis_impact,\n      (d) =&gt; d.bcr,\n    )\n    .flatMap(([adoption, prod_impact, cis_impact, bcr, rows]) =&gt; {\n      const allRows = [\n        ...rows,\n        { adoption, prod_impact, cis_impact, bcr, year: 0, project_benefit: 0 },\n      ].sort((a, b) =&gt; a.year - b.year);\n\n      return allRows.map((r) =&gt; {\n        const pay = payByYear.get(r.year) || {};\n        const cost = pay.cost ?? 0;\n        const cost_cum = pay.cost_cum ?? rangeProjectCost;\n        return {\n          ...r,\n          cost,\n          cost_cum,\n          cashflow: (r.project_benefit ?? 0) - cost,\n          discount_rate: discountRate,\n        };\n      });\n    });\n};\n\n\n\n\n\n\n\n\nFormat that into final indicators\n\nwalkthroughEconomicIndicators = {\n  const selection = walkthroughSelections;\n\n  const data = recipe_dataCashflow\n\n  const years = data.map(d =&gt; d.year);\n  const benefit = data.map(d =&gt; d.project_benefit);\n  const cost = data.map(d =&gt; d.cost);\n  const cashflow = benefit.map((b, i) =&gt; b - cost[i]);\n  const discountRate = selection.discount_rate;\n\n  const npv = npvDiscreteCumulative(cashflow, discountRate);\n  const npv_benefit = npvDiscreteCumulative(benefit, discountRate);\n  const npv_cost = npvDiscreteCumulative(cost, discountRate);\n  const discounted_bcr = npv_benefit.map((b, i) =&gt; npv_cost[i] === 0 ? null : b / npv_cost[i]);\n\n  const proj_irr = calcIRR(cashflow);\n  const proj_mirr = calcMIRR(cashflow, discountRate, discountRate);\n  const proj_npv = npv.at(-1);\n  const proj_bcr = discounted_bcr.at(-1);\n\n  // === Enriched table\n  const enrichedData = years.map((year, i) =&gt; {\n    const cashflowToDate = cashflow.slice(0, i + 1);\n    return {\n      year,\n      project_benefit: benefit[i],\n      cost: cost[i],\n      cashflow: cashflow[i],\n      discounted_benefit_cum: npv_benefit[i],\n      discounted_cost_cum: npv_cost[i],\n      discounted_bcr: discounted_bcr[i],\n      irr: calcIRR(cashflowToDate)*100,\n      mirr: calcMIRR(cashflowToDate, discountRate, discountRate)*100,\n      npv: npv[i]\n    };\n  });\n\n  return {\n    summary: {\n      proj_npv,\n      proj_irr,\n      proj_mirr,\n      proj_bcr\n    },\n    enriched: enrichedData\n  };\n}\n\n\n\n\n\n\n\n\nCalculate final values\nAt this point, following the recipe, we have the timeseries for the selected parameters, with financial values calculated. Specifically:\n\nadoption\nprod_impact\ncis_impact\nbcr\ndiscount_rate\n\nAcross:\n\nyear\n\nData:\n\nproject_benifit\ncost and cashflow\nProject IRR\nProject NPV\nProject BCR"
  },
  {
    "objectID": "notebooks/roi/notebook.html#selections",
    "href": "notebooks/roi/notebook.html#selections",
    "title": "",
    "section": "Selections",
    "text": "Selections\n\nwalkthroughSelections = {\n  return {\n    countries: select_country,\n    regions: select_region,\n    crops: select_crop,\n    project_years: projectYears,\n    project_cost: rangeProjectCost,\n    prod_impact: options_econPerfWalkthrough.inputProdImpact.value,\n    adoption: options_econPerfWalkthrough.inputAdoption.value,\n    cis_impact: options_econPerfWalkthrough.inputCisImpact.value,\n    discount_rate: discountRate,\n    bcr: bcr,\n    // time_horizon: options_econPerfWalkthrough.inputTime.value,\n  };\n}"
  },
  {
    "objectID": "docs/translation.html",
    "href": "docs/translation.html",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Author: Zach Bogart, Brayden Youngberg Version: 2.0.1\n\n\nThe Lang module provides a set of helper functions to manage translations, template insertions, and string formatting in JavaScript notebooks and apps. It is especially useful for multi-language support and dynamic text replacement.\n\n\n\n\nDefine available languages with keys, labels, and locales:\n\nimport { lang as Lang } from \"/helpers/lang.js\"\n// or if running into errors due to cells running before the import:\n// const lang = await import(\"/helpers/lang.js\");\n// or if only needing the main lg function:\n// import { lg } from \"/helpers/lang.js\"\n\nlanguages = [\n  { key: \"en\", label: \"English\", locale: \"en-US\" },\n  { key: \"fr\", label: \"Français\", locale: \"fr-FR\" }\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStructure your translations as a nested object or external JSON, with language keys for each field:\n\nnbText = new Object({\n  \"hello\": {\n    \"en\": \"hello\",\n    \"fr\": \"Bonjour\"\n  },\n  \"error\": {\n    \"en\": \"Whoops\"\n  },\n  \"insert\": {\n    \"small\": {\n      \"en\": \"This is an insertion example: :::field:::\",\n      \"fr\": \"Ceci est un exemple d'insertion: :::field:::\"\n    },\n    \"big\": {\n      \"en\": \"This is an insertion example: :::field::: :::name:::\",\n      \"fr\": \"Ceci est un exemple d'insertion: :::field::: :::name:::\"\n    }\n  }\n})\n\n\n\n\n\n\n\n\n\nCreate a master toggle to pick the language key (Observable Inputs):\n\nviewof language = Inputs.radio(languages, {\n  label: \"Main language toggle\",\n  format: (d) =&gt; d.key,\n  value: languages.find((x) =&gt; x.key === defaultLangKey),\n})\n\n\n\n\n\n\nA “pretty” toggle with label that changes based on the language:\n\nNOTE: it is required to do this in a new Input, as there would be a circular definition otherwise\n\n\nviewof prettyLanguageView = {\n  return Inputs.bind(\n    Inputs.radio(languages, {\n      label: Lang.getText({en: \"Language\", fr: \"Langue\"}, { key: language.key }),\n      format: (d) =&gt; d.label\n    }),\n    viewof language\n  );\n}\n\n\n\n\n\n\n\n\n\nGet a translation for the current language:\n\nLang.getText(nbText.hello, { key: language.key });\n\n\n\n\n\n\n\n\nTo avoid repeating the language key, use lg:\n\n_lang = Lang.lg(language.key);\n_lang(nbText.hello);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReplace placeholders in template strings with dynamic values.\n\n\n\n{\n    const template = Lang.getText(nbText.insert.small, { key: language.key });\n    const items = [{ name: \"field\", value: \"hello world!\" }];\n    return Lang.reduceReplaceTemplateItems(template, items);\n}\n\n\n\n\n\n\n\n\n\n\n{\n    const template = Lang.getText(nbText.insert.big, { key: language.key });\n    const greeting = Lang.getText(nbText.hello, { key: language.key });\n    const items = [\n    { name: \"field\", value: greeting },\n    { name: \"name\", value: \"Alice\" }\n    ];\n    return Lang.reduceReplaceTemplateItems(template, items);\n}\n\n\n\n\n\n\n\n\n\n\n{\n    const customTemplate = \"This is a test: &gt;field&lt;\";\n    const result = Lang.reduceReplaceTemplateItems(\n        customTemplate,\n        [{ name: \"field\", value: \"hello world!\" }],\n        { start: \"&gt;\", end: \"&lt;\" }\n    );\n    return result\n}\n\n\n\n\n\n\n\n\n\n\nFind missing language keys in your text object:\n\nLang.listLeavesMissingObjectKeys(nbText, [\"en\", \"fr\"]);\n// Returns an array of paths to missing translations\n\n\n\n\n\n\n\n\n\n\nLang.toTitleCase(\"welcome to my home\");\n\n\n\n\n\n\n\nLang.toSentenceCase(\"welcome to my home\");\n\n\n\n\n\n\n\n\n\n\n\n\nSet the default language using a URL parameter (?lang=fr):\n\nqueryLanguage = await Lang.getParamFromList({\n  name: \"lang\",\n  list: languages.map((d) =&gt; d.key)\n});\n\ndefaultLangKey = queryLanguage ?? \"en\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nlg(defaultKey)\nReturns a function to fetch text for a default language key.\n\n\ngetText(textObj, { key })\nGets text for the specified language key.\n\n\ngetRegexForNamedInsertion(item, opts)\nReturns regex to match placeholders (default: :::item:::).\n\n\nreduceReplaceTemplateItems(...)\nReplaces all placeholders in a template with provided values.\n\n\nlistLeavesMissingObjectKeys(obj, keys)\nLists object leaves missing specified keys.\n\n\ngetParamFromList({ name, list, ... })\nReturns query parameter value if it exists in a provided list.\n\n\ntoTitleCase(str)\nConverts a string to title case.\n\n\ntoSentenceCase(str)\nConverts a string to sentence case.\n\n\n\n\nLinks: Observable Notebook Example\nHappy translating!"
  },
  {
    "objectID": "docs/translation.html#overview",
    "href": "docs/translation.html#overview",
    "title": "Lang Module Guide",
    "section": "",
    "text": "The Lang module provides a set of helper functions to manage translations, template insertions, and string formatting in JavaScript notebooks and apps. It is especially useful for multi-language support and dynamic text replacement."
  },
  {
    "objectID": "docs/translation.html#installation-defining-languages",
    "href": "docs/translation.html#installation-defining-languages",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Define available languages with keys, labels, and locales:\n\nimport { lang as Lang } from \"/helpers/lang.js\"\n// or if running into errors due to cells running before the import:\n// const lang = await import(\"/helpers/lang.js\");\n// or if only needing the main lg function:\n// import { lg } from \"/helpers/lang.js\"\n\nlanguages = [\n  { key: \"en\", label: \"English\", locale: \"en-US\" },\n  { key: \"fr\", label: \"Français\", locale: \"fr-FR\" }\n];"
  },
  {
    "objectID": "docs/translation.html#setting-up-translation-json",
    "href": "docs/translation.html#setting-up-translation-json",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Structure your translations as a nested object or external JSON, with language keys for each field:\n\nnbText = new Object({\n  \"hello\": {\n    \"en\": \"hello\",\n    \"fr\": \"Bonjour\"\n  },\n  \"error\": {\n    \"en\": \"Whoops\"\n  },\n  \"insert\": {\n    \"small\": {\n      \"en\": \"This is an insertion example: :::field:::\",\n      \"fr\": \"Ceci est un exemple d'insertion: :::field:::\"\n    },\n    \"big\": {\n      \"en\": \"This is an insertion example: :::field::: :::name:::\",\n      \"fr\": \"Ceci est un exemple d'insertion: :::field::: :::name:::\"\n    }\n  }\n})"
  },
  {
    "objectID": "docs/translation.html#language-toggle-ui-observable-example",
    "href": "docs/translation.html#language-toggle-ui-observable-example",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Create a master toggle to pick the language key (Observable Inputs):\n\nviewof language = Inputs.radio(languages, {\n  label: \"Main language toggle\",\n  format: (d) =&gt; d.key,\n  value: languages.find((x) =&gt; x.key === defaultLangKey),\n})\n\n\n\n\n\n\nA “pretty” toggle with label that changes based on the language:\n\nNOTE: it is required to do this in a new Input, as there would be a circular definition otherwise\n\n\nviewof prettyLanguageView = {\n  return Inputs.bind(\n    Inputs.radio(languages, {\n      label: Lang.getText({en: \"Language\", fr: \"Langue\"}, { key: language.key }),\n      format: (d) =&gt; d.label\n    }),\n    viewof language\n  );\n}"
  },
  {
    "objectID": "docs/translation.html#retrieving-translations",
    "href": "docs/translation.html#retrieving-translations",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Get a translation for the current language:\n\nLang.getText(nbText.hello, { key: language.key });\n\n\n\n\n\n\n\n\nTo avoid repeating the language key, use lg:\n\n_lang = Lang.lg(language.key);\n_lang(nbText.hello);"
  },
  {
    "objectID": "docs/translation.html#template-insertion",
    "href": "docs/translation.html#template-insertion",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Replace placeholders in template strings with dynamic values.\n\n\n\n{\n    const template = Lang.getText(nbText.insert.small, { key: language.key });\n    const items = [{ name: \"field\", value: \"hello world!\" }];\n    return Lang.reduceReplaceTemplateItems(template, items);\n}\n\n\n\n\n\n\n\n\n\n\n{\n    const template = Lang.getText(nbText.insert.big, { key: language.key });\n    const greeting = Lang.getText(nbText.hello, { key: language.key });\n    const items = [\n    { name: \"field\", value: greeting },\n    { name: \"name\", value: \"Alice\" }\n    ];\n    return Lang.reduceReplaceTemplateItems(template, items);\n}\n\n\n\n\n\n\n\n\n\n\n{\n    const customTemplate = \"This is a test: &gt;field&lt;\";\n    const result = Lang.reduceReplaceTemplateItems(\n        customTemplate,\n        [{ name: \"field\", value: \"hello world!\" }],\n        { start: \"&gt;\", end: \"&lt;\" }\n    );\n    return result\n}"
  },
  {
    "objectID": "docs/translation.html#checking-for-missing-translations",
    "href": "docs/translation.html#checking-for-missing-translations",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Find missing language keys in your text object:\n\nLang.listLeavesMissingObjectKeys(nbText, [\"en\", \"fr\"]);\n// Returns an array of paths to missing translations"
  },
  {
    "objectID": "docs/translation.html#string-formatting-helpers",
    "href": "docs/translation.html#string-formatting-helpers",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Lang.toTitleCase(\"welcome to my home\");\n\n\n\n\n\n\n\nLang.toSentenceCase(\"welcome to my home\");"
  },
  {
    "objectID": "docs/translation.html#advanced-default-language-from-url",
    "href": "docs/translation.html#advanced-default-language-from-url",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Set the default language using a URL parameter (?lang=fr):\n\nqueryLanguage = await Lang.getParamFromList({\n  name: \"lang\",\n  list: languages.map((d) =&gt; d.key)\n});\n\ndefaultLangKey = queryLanguage ?? \"en\";"
  },
  {
    "objectID": "docs/translation.html#api-reference",
    "href": "docs/translation.html#api-reference",
    "title": "Lang Module Guide",
    "section": "",
    "text": "Function\nDescription\n\n\n\n\nlg(defaultKey)\nReturns a function to fetch text for a default language key.\n\n\ngetText(textObj, { key })\nGets text for the specified language key.\n\n\ngetRegexForNamedInsertion(item, opts)\nReturns regex to match placeholders (default: :::item:::).\n\n\nreduceReplaceTemplateItems(...)\nReplaces all placeholders in a template with provided values.\n\n\nlistLeavesMissingObjectKeys(obj, keys)\nLists object leaves missing specified keys.\n\n\ngetParamFromList({ name, list, ... })\nReturns query parameter value if it exists in a provided list.\n\n\ntoTitleCase(str)\nConverts a string to title case.\n\n\ntoSentenceCase(str)\nConverts a string to sentence case.\n\n\n\n\nLinks: Observable Notebook Example\nHappy translating!"
  },
  {
    "objectID": "docs/glossary.html",
    "href": "docs/glossary.html",
    "title": "Atlas Definitions",
    "section": "",
    "text": "Atlas Definitions"
  },
  {
    "objectID": "docs/doc_index.html",
    "href": "docs/doc_index.html",
    "title": "Adaptation Atlas Documentation Index",
    "section": "",
    "text": "Tips on Notebook Development\n\nGuidelines for Observable Notebooks\nNotebook Translation Guide\nGlossary\nFrequently Asked Questions"
  },
  {
    "objectID": "docs/faq.html",
    "href": "docs/faq.html",
    "title": "FAQ",
    "section": "",
    "text": "FAQ"
  },
  {
    "objectID": "docs/nb_guidelines.html",
    "href": "docs/nb_guidelines.html",
    "title": "Overview",
    "section": "",
    "text": "Show the code\nimport { atlasHero } from \"/helpers/uiComponents.ojs\"\n\n{\n  let hero_url = \"./../../images/default_crop.webp\"\n  return atlasHero(nbTitle, hero_url)\n}"
  },
  {
    "objectID": "docs/nb_guidelines.html#headers",
    "href": "docs/nb_guidelines.html#headers",
    "title": "Overview",
    "section": "Headers",
    "text": "Headers\nWe recommend using title case for headers. Main section headings should be a question which is answered by the narrative and figures in the following section. For example, instead of “Identifying Risk Hotspots”, consider using “Where Is Most At Risk?”\nTo best format the sections within the narrative, please use header tags:\n\nAdding “#” before text creates an H1 header. Use it for headings of main sections.\nAdding “##” before text creates an H2 header. Use it for chart titles.\nAdding “###” before text creates an H3 header. Use it for subtitles within charts and for titles for data insights related to charts.\n\nBecause our content requires dynamic headers for translation, the standard Quarto header syntax needs a slight adjustment. There are several ways to create dynamic headers, but the method described here is the most straightforward and closely aligned with standard Quarto formatting:\n```{ojs}\nheading1 = _lang({en: \"Heading 1\", fr: \"Titre 1\"}) // define ojs var for heading\n```\n\n# ``{ojs} heading1` {#example-heading2} &lt;!-- Use the ojs var as a heading & add an id--&gt;\nNote that the id for the heading is assigned. This is important for the TOC generation and is required."
  },
  {
    "objectID": "docs/nb_guidelines.html#table-of-contents",
    "href": "docs/nb_guidelines.html#table-of-contents",
    "title": "Overview",
    "section": "Table of Contents",
    "text": "Table of Contents\nWe have put together a table of contents function that should be used across notebooks. This can be imported from the ‘helpers’ directory. Below is an example of its use:\n\n\nShow the code\nimport { atlasTOC } from \"/helpers/toc.ojs\"\n\natlasTOC({\n  skip: ['notebook-title', 'appendix', 'source-code'], // heading ids to skip\n  heading: `&lt;b&gt;In This Notebook&lt;/b&gt;`,\n  selector: \"h1\", // Selectors to include (e.g., \"h1,h2,h3\")\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice that by defining the id’s for each header, we can specify which ones to ignore in the TOC. The function defaults to only show h1 headers but this can be adjusted by changing the selector variable, but in general it should stay as h1. You can copy the code above to use in notebooks and it should work with no modifications."
  },
  {
    "objectID": "docs/nb_guidelines.html#dynamic-insights",
    "href": "docs/nb_guidelines.html#dynamic-insights",
    "title": "Overview",
    "section": "Dynamic Insights",
    "text": "Dynamic Insights\nAs can be seen in the “What’s at Risk” notebook, we have developed dynamic insights within the text that changes based on the selection of various controls throughout the tool. To emphasize that this text is dynamic, we bold the dynamic portion of the sentence.\nDynamic Insights are to be placed in a subsection with an H3 header ““###”” below each visualization at the end of each main section.\nThese dynamic insights can be in partial or full sentence form, and in either an bulleted list or not (could vary depending on the specific insight)."
  },
  {
    "objectID": "docs/nb_guidelines.html#color-scales",
    "href": "docs/nb_guidelines.html#color-scales",
    "title": "Overview",
    "section": "Color Scales",
    "text": "Color Scales\nBelow are some example linear color scales you can use, all defined by endpoint color values.\nPlease note that color scales may need to be designed on a chart-by-chart basis. The color scales listed below are a few developed for various charts in the “What’s at Risk?” and “On-farm Solutions for Today” notebooks.\nRegarding the direction to apply the scales, we have been mapping green (from the yellowGreen scale) to normatively “better” values and red (from the orangeRed scale) to normatively “worse” values.\n\n\nShow the code\ncolorScales = [\n  { name: \"yellowGreen\", range: [\"#F7D732\", \"#216729\"] },\n  { name: \"orangeRed\", range: [\"#F4BB21\", \"#EC5A47\"] }\n]\n\nviewof select = Inputs.select(colorScales, {label: \"Show a color scale\", format: x =&gt; x.name})\n\nPlot.plot({\n  color: {\n    type: \"linear\",\n    range: select.range,\n  },\n  marks: [\n    Plot.cell(d3.range(50), {x: d =&gt; d, fill: d =&gt; d})\n  ],\n  axis: null,\n  height: 30,\n  x: {padding: -0.1},\n  width: 600\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow the code\nviewof copyImport = Inputs.button(`Copy ${select.name} color range`, {reduce: () =&gt; navigator.clipboard.writeText(select.range)})"
  },
  {
    "objectID": "docs/nb_guidelines.html#visualizations",
    "href": "docs/nb_guidelines.html#visualizations",
    "title": "Overview",
    "section": "Visualizations",
    "text": "Visualizations\nTo ensure a good user experience, all plots, maps, and figures within the notebooks should have a consistent fixed height to prevent page shifts during interactive changes. A maximum height of 800px is recommended, although it can be adjusted based on specific design requirements. The height parameter should be set, especially for maps, where different admins will have different sizes, resulting in large content shifts if not set. A maximum width of 1000px is suggested. Text should be large enough to be read with ease.\nMost previous Data Exploration Notebooks have used the Observable Plot library for creating visualizations. Examples using this library can be found here or within the Atlas here. Some also use d3 to create more complex or interactive visualizations. Any JS plotting library should work fine so long as they allow:\n\nDynamic Plots: Plots should adapt dynamically based on user inputs such as region or crop selection, provided no data is unavailable.\nTooltips for Additional Information: Tooltips can enhance understanding but should not overwhelm the main plot. Plots should generally convey information succinctly and effectively."
  },
  {
    "objectID": "docs/nb_guidelines.html#data-download-buttons",
    "href": "docs/nb_guidelines.html#data-download-buttons",
    "title": "Overview",
    "section": "Data Download buttons",
    "text": "Data Download buttons\nEvery figure should include a data download button that can be used to download the data used in the figure. For consistency and ease, there is a function in the /helpers folder that can be used to create the download button.\n```{ojs}\nimport { downloadButton } from \"/helpers/uiComponents.ojs\"\ndata = [{a: 1, b: 2}, {a: 3, b: 4}, {a: 5, b: 6}]\ndownloadButton(data, filename, label = \"Download\")\n\n```"
  },
  {
    "objectID": "docs/nb_guidelines.html#selectors",
    "href": "docs/nb_guidelines.html#selectors",
    "title": "Overview",
    "section": "Selectors",
    "text": "Selectors\nThe Observable standard library comes with many inputs/selectors pre-included. These should be used when possible, rather than building selectors from scratch or importing them from elsewhere. Documentation on these selectors can be found here with many examples on ObservableHQ. We use a custom CSS to modify the styling of these inputs, these should be automatically applied on quarto render and preview.\nWhen multiple selectors are used together - such as to select multiple admin levels - they should be grouped together in a single horizontal block using an Inputs.form, or other methods where necessary. When multiple selectors are used across a notebook to select the same variable in different places, there should be one master selector that is updated when other selectors are used (using Inputs.bind()). The below example shows how to do this, along with how to use the Inputs.form selector to group selectors together:\n\n\nShow the code\nviewof var1_master = Inputs.radio([\"var1\", \"var2\", \"var3\"], {label: \"Variable 1\", value: \"var1\"})\n\nviewof form = Inputs.form( // returns a JS object of {var1: ..., var2: ...}\n  {\n    var1: Inputs.bind(\n      Inputs.radio([\"1\", \"2\", \"3\"], {label: \"Variable 1\", value: var1_master}),\n      viewof var1_master\n    ),\n    var2: Inputs.select([\"a\", \"b\", \"c\"], {label: \"Variable 2\", value: \"var2\"})\n  },\n  {\n    template: (inputs) =&gt; htl.html`\n      &lt;div style=\"display: flex; gap: 3em\"&gt;\n        ${Object.values(inputs)}\n      &lt;/div&gt;`\n  }\n)\n\nform\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow the code\nvar1_master"
  },
  {
    "objectID": "docs/nb_guidelines.html#images",
    "href": "docs/nb_guidelines.html#images",
    "title": "Overview",
    "section": "Images",
    "text": "Images\nEach notebook should include a single hero image in .webp format, optimized for minimal file size without noticeable quality loss. Save the image in the /images directory using the notebook’s name as the filename. Included in the /scripts/assets folder is a function to crop an image to the required size of 800x175 pixels and convert it to webP, if not already in this format. It is not required to use this function, but images do need to be in webP and cropped to this size for best performance. If a specific part of the image should be used, it should be manually cropped, rather than using the function.\nThe below example shows how to use this function:\nquarto run scripts/assets/cropToWebP.ts 'default_im.webp' 'default_crop.webp'"
  },
  {
    "objectID": "docs/nb_guidelines.html#storing-data",
    "href": "docs/nb_guidelines.html#storing-data",
    "title": "Overview",
    "section": "Storing Data",
    "text": "Storing Data\nA lot of the processing of data is/should be done before hand due to the limitations of client-side processing and page performance. This pre-processed data should be stored in the Adaptation Atlas S3 bucket in a cloud-optimized format, such as parquet for tabular data. For development this data could be sotored elsewhere, but should be migrated to the Atlas S3 bucket for production. Get in touch with us to complete this. Files that may need to be updated should be stored in the S3 bucket to allow easier updating and version control.\nTo easily manage data and allow users to access the raw datasets being queried and pulled from the S3, data paths, alongside some metadata, should be stored in a JSON file in the notebook sub-directory in the /data folder. At minimum this should include a dataset name, source, and the sections the data is used. See the example below:\n{\n    \"HeatData\" : {\n      \"source\": \"https://digital-atlas.s3.us-east-1.amazonaws.com/heat.parquet\",\n      \"name\": \"Historical and Future heat Data\",\n      \"sections\": [\n        \"Where is the heat?\",\n        \"How hot will it be in the Future?\"\n      ]\n    },\n    \"OtherData\": {\n      \"source\": \"https://digital-atlas.s3.us-east-1.amazonaws.com/example.parquet\",\n      \"name\": \"Some More Data\",\n      \"sections\": [\n        \"Section 1\"\n      ]\n    }\n}\nData can also be stored within the quarto project and loaded into quarto notebooks using File Attachments. This should be reserved for the translations and small files with a specific use - such as datasets needed for a single plot or files requiring a specific format. Any data stored within the project should be within a sub-directory in the /data folder with the notebook name."
  },
  {
    "objectID": "docs/nb_guidelines.html#importing-data",
    "href": "docs/nb_guidelines.html#importing-data",
    "title": "Overview",
    "section": "Importing data",
    "text": "Importing data\nIn general, DuckDB-wasm should be used for data import, querying, and some data processing. DuckDB can be used to directly query parquet data from the S3 bucket in an incredibly efficient manner. Some of the datasets used may be extremly large and contain may rows and columns - importing all of them at once would be terrible for page performance. We strongly suggest dynamically querying data by admin region and variable of interest to limit the about of data imported at a time. For large files, we suggest reading them as views, rather than tables, this can be seen in the below example. Some basic functions and data aggregation methods can also be performed using DuckDB, but JS methods can also be used for this, and are sometimes more efficient. Regarding data manipulation, it is recommended to consolidate data wrangling into a few OJS cells rather than splitting each processing step into seperate cells. For example, you can use a block within a js cell to define multiple lines (see Cells from Observable Documentation for examples).\nTo use DuckDB to import subsets data into the documents from the S3:\n\n\nShow the code\nviewof time = Inputs.radio([\"historic\", \"2021_2040\", \"2041_2060\"], {label: \"Timeframe\", value: \"historic\"})\n\ndb = {\n  let db = await DuckDBClient.of()\n  await db.query(`\n    CREATE VIEW Hazard AS\n    SELECT admin0_name, admin1_name, admin2_name, scenario, timeframe, hazard, value\n    FROM read_parquet(\"s3://digital-atlas/hazards/hazard_timeseries_mean/annual/haz_means_adm.parquet\")\n  `);\n  return await db;\n}\n\ndata = {\n // The query below can be made dynamic using template literals\n // and it will automatically re-run when the interpolated values change.\n  let query = `\n    SELECT *\n    FROM Hazard\n    WHERE admin1_name IS NULL\n    AND \"hazard\" IN ('HSH_max', 'HSH_mean', 'NDWL0', 'NDWS', 'NTx35', 'NTx40', 'TAI', 'THI_max', 'THI_mean', 'TAVG', 'PTOT')\n    AND \"timeframe\" = '${time}'\n    LIMIT 3`\n  return db.query(query)\n}\n\ndata\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo load File Attachements follow this pattern:\n```{ojs}\ndata = await FileAttachment(\"/data/shared/atlas-region_admin0_simplified.json\").json()\n```\nImportant Note: Windows devices using certain web browsers have a error which results in cached parquet data becoming invalid when using DuckDB. This results in errors across any figure/section using this data when the page is reloaded or refreshed. The GitHub issue can be followed here. The solution to this is to prevent the use of cached parquet data on windows devices. There is an included function in the /helpers folder which itentifies if the device is a windows device and prevents the use of cached data though “cache busting”. It is required to use this function when loading parquet data into a notebook. Its use can be seen in the above example using DuckDB."
  },
  {
    "objectID": "docs/nb_guidelines.html#country-boundaries-and-geospatial-data",
    "href": "docs/nb_guidelines.html#country-boundaries-and-geospatial-data",
    "title": "Overview",
    "section": "Country Boundaries and Geospatial data",
    "text": "Country Boundaries and Geospatial data\nFor all spatial data within the Adaptation Atlas data explorations, use the following guidelines to maintain consistency and efficiency:\n\nEnsure that all maps, geographic selectors, and other geospatial elements utilize the Adaptation Atlas boundary dataset. These boundaries are based on the GAUL 2024, but include modifications so that country boundaries appear as each country represents themselves, including disputed areas.\nIn general the Data Explorations should provide data to admin level 2 where possible, although data should be limited to the highest resolution data avaliable.\nAnalysis and any raster extraction should use the highest resoltuon boundaries from the Atlas boundary dataset.\nAny visualizations within the data explorations should use the low or very low resolution boundaries, unless there is a valid reason for using higher resolution boundaries. This is to insure fast page load speeds, as there is a signifigant difference in file sizes between dataset resolution.\nOnly one set of admin boundaries should be used in each data exploration - all datasets with a spatial “aspect” should be stored in raw tabular format and merged to the admin boundries within each notebook using the matching ‘admin0_name’, ‘admin1_name’, and ‘admin2_name’ columns. This will prevent multiple large boundary datasets from being loaded in each notebook."
  },
  {
    "objectID": "docs/nb_guidelines.html#ojs-in-quarto",
    "href": "docs/nb_guidelines.html#ojs-in-quarto",
    "title": "Overview",
    "section": "OJS in Quarto",
    "text": "OJS in Quarto\nOJS is slighty different than vanilla JavaScript and cells will automatically re-run when a variable they are dependent on is changed. The main differences can be outlined in the documentation. Quarto includes code blocks and OJS itself is based on cells, so it is important to note some differences. It is possible to have multiple OJS Cells within a quarto code block, and OJS cells can include blocks of JavaScript code. This can be seen in the below example, which return the same resutl using 3 different ways of structuring the code:\nExample 1:\n```{ojs}\nx = 10\n\ny = x + 5\n\nresult = y * 10\n```\nExample 2:\n```{ojs}\nx = 10\n```\n\n```{ojs}\ny = x + 5\n```\n\n```{ojs}\nresult = y * 10\n```\nExample 3:\n```{ojs}\nresult = {\n  let x = 10\n  let y = x + 5\n  return y * 10\n}\n```\nExample 1 and 2 are exactly the same, just split up across quarto code blocks. Both result in globals of x and y and result. Example 3 uses 1 quarto code block and 1 OJS cell with a block to return just result rather than the intermediate variables. In general, using a block to avoid assigning globals is preferred. Multiple OJS cells can be used in one Quarto code blocks, but aim for consistent and logical methods of organizing code.\nInline code blocks are useful for simple and short code such as selectors and text chunks. NOTE: These should only have 1 backtick at the start. The below example uses a extra backtick at the start as a hack to get the code to show correctly and prevent it from executing. For more about inline code, see the Quarto docs\nThis is some text in my document ``{ojs} \"example\".toUpperCase()`\n\n\n### ``{ojs} \"example_h3\".toUpperCase()`"
  },
  {
    "objectID": "docs/nb_guidelines.html#modular-code",
    "href": "docs/nb_guidelines.html#modular-code",
    "title": "Overview",
    "section": "Modular code",
    "text": "Modular code\n\nQuarto Modules\nElements of a notebook can be split into multiple different .qmd documents. This can be useful in keeping code cleaner and more organized. This can be done using the {{&lt; include _myFile.qmd &gt;}} shortcode\nA few important considerations when doing this: - Variables, Functions, and JS modules are shared between the imports because the include/merge is done on build/render. - This means having x defined in both or importing the same module in both will result in an error. - There are no performance implications of doing this, since the files are merged on build. - Any additional qmd module files used for these imports should be in the same directory as the main notebook, and imported modules should begin with an underscore so that quarto does not try to render them as standalone\n\n\nImports in OJS\nOJS cells also have the ability to call in imports. Unlike the above quarto imports, this is done post-render on the client.This can include importing other OJS cells, using the .ojs extension, importing local JS code and modules, and importing modules from NPM. Although possible, this method should not be used to import large sections of a notebook - the above Quarto imports are better suited for this. However, this is useful for sharing functions and importing external libraries.\nTo import a local JS module or code in an OJS file (documented here):\n```{ojs}\nimport { lang as Lang } from \"/helpers/lang.js\"\n\nimport { atlasTOC } from \"/helpers/toc.ojs\"\nimport { atlasHero } from \"/helpers/uiComponents.ojs\"\n```\nTo import an NPM module or something from an observableHQ notebook:\n```{ojs}\ntopojson = require(\"topojson\") // Regular import\nd3 = require(\"d3@7\") // With a version\nimport {resolveWindowsCacheIssue} from \"cbd32f92c155bf5b\" // From an observableHQ notebook\ninitgeosJs = (await import(\"https://cdn.skypack.dev/geos-wasm\")).default; // Directly from a CDN\nduckdb = import(\"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.1-dev215.0/+esm\")\n\n```\n\n\nFolder and File structure\nThe main folder structure for the project is as follows:\n.\n├── index.qmd                   # Main index file required by Quarto\n├── data\n│   ├── notebook_name           # Named folder containing individual notebook data\n│   │   ├── dataset1.json       # Notebook specific data not stored in S3\n│   │   └── S3_data.json        # Paths to data stored externally in S3\n│   │   └── translations.json   # Notebook specific translations\n│   └── shared                  # Data shared across notebooks\n├── helpers                     # Code and modules shared between notebooks\n├── images\n│   └── notebook_name.webp      # A single hero image for each notebook\n├── notebooks                   # Code for all notebooks will end here\n│   └── notebook_name           # Named folder containing individual notebook code\n│       ├── notebook_name.qmd   # Main notebook file\n│       ├── _module1.qmd        # Module imported into main notebook\n│       ├── _module2.qmd\n│       └── notebook_stye.css   # Notebook specific styling\n├── _quarto.yml                 # Main project configuration\n├── README.md                   # Main project README\n├── _site                       # Output directory build by Quarto on render\n└── styles/main.css             # Main project styling\nA concise and descriptive folder name should be used for each notebook, and this name should be used consistently across the main project folders (i.e. as the sub-directory names in the /notebooks, and /data folders and file names in the /images folder)."
  },
  {
    "objectID": "docs/nb_guidelines.html#shared-data",
    "href": "docs/nb_guidelines.html#shared-data",
    "title": "Overview",
    "section": "Shared Data",
    "text": "Shared Data\nAt the moment the only data shared across all notebooks is the admin0 boundaries and some general translations. The admin1 and admin2 boundaries are stored and queried from the S3 bucket, but will be included in this folder in the future following a data update."
  },
  {
    "objectID": "docs/nb_guidelines.html#helpers-and-functions",
    "href": "docs/nb_guidelines.html#helpers-and-functions",
    "title": "Overview",
    "section": "Helpers and functions",
    "text": "Helpers and functions\nThe /helpers folder contains code and modules that are used across the notebooks. This includes the lang module for the translations, some style builders to build elements on the page such as the TOC and hero image, and functions to handle other tasks. This folder also includes a post-render script which is automatically run to minify the CSS and JS files."
  },
  {
    "objectID": "docs/nb_guidelines.html#styling",
    "href": "docs/nb_guidelines.html#styling",
    "title": "Overview",
    "section": "Styling",
    "text": "Styling\nThe main styling for the project can be found under styles/main.css with modular imports such as styles/toc.css. Any styling that is notebook specific should be stored within the `/notebooks/notebook_name/” directory and applied using the yaml header at the top of the document/imported with OJS, or it should be including within the notebook code itself as a style block."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Adaptation Atlas Notebooks",
    "section": "",
    "text": "Adaptation Atlas V2 Notebooks\n\n\n\n\n\nOther Documentation and Notebook Guidelines\n\nGuidelines for Developing Observable Notebooks\nNotebook Translation Guide"
  }
]