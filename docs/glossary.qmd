---
pagetitle: "Atlas Glossary"
nb-authors:
  - Hannah Lang
  - Lolita Muller
  - Brayden Youngberg
  - Pete Stewart
date-created: "2025-11-10"
date-edited: today
filters:
  - ./../helpers/glossaryToJSON.lua
---

# Atlas Definitions

<div id="h1-list"></div>

```{=html}
<div id="toc" class="atlas-toc"></div>

<input
  type="text"
  id="searchBox"
  placeholder="Search glossary..."
  style="margin-bottom: 20px; padding: 8px; width: 100%; max-width: 400px;"
/>

<div id="output"></div>
```

```{=html}
<script>
const navEnd = document.querySelector(".navbar-nav.ms-auto .nav-item.compact");

if (navEnd) {
  // Only add it if it doesn't already exist
  if (!document.getElementById("nav-lang-selector")) {
    // Create wrapper
    const langSel = document.createElement("div");
    langSel.id = "nav-lang-selector";
    langSel.style.display = "flex";
    langSel.style.alignItems = "center";
    langSel.style.marginLeft = "10px";

    // Create inner container
    const langDiv = document.createElement("div");
    langDiv.style.display = "flex";
    langDiv.style.flexDirection = "column";

    // Build radios dynamically
    const langs = [
      { code: "EN", label: "English" },
      { code: "FR", label: "FranÃ§ais" },
    ];

    langs.forEach(lang => {
      const label = document.createElement("label");
      label.style.fontWeight = "500";
      label.style.cursor = "pointer";

      const input = document.createElement("input");
      input.type = "radio";
      input.name = "language";
      input.value = lang.code;
      input.style.accentColor = "var(--atlasGreen)";
      input.style.marginRight = "5px";
      input.style.cursor = "pointer";

      if (lang.code === "EN") input.checked = true;

      // When changed â†’ handle switching logic
      input.addEventListener("change", e => {
        if (e.target.checked) {
          currentLang = lang.code;
          window.currentLang = lang.code;
          renderGlossary();
          renderTOC();
          updateSearchPlaceholder();
        }
      });

      label.appendChild(input);
      label.appendChild(document.createTextNode(lang.label));
      langDiv.appendChild(label);
    });

    // Assemble and attach
    langSel.appendChild(langDiv);
    navEnd.parentNode.appendChild(langSel);
  }
}
</script>
```

<script>
let currentLang = 'EN';
let glossaryData = null;
let searchQuery = '';

fetch("./../../data/shared/glossary.json")
  .then(response => {
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    return response.json();
  })
  .then(data => {
    glossaryData = data;
    renderGlossary();
    renderTOC();

    // Language toggle
    document.querySelectorAll('input[name="language"]').forEach(radio => {
      // currentLang = localStorage.getItem('glossaryLang') || 'EN';
      radio.addEventListener('change', event => {
        currentLang = event.target.value;
        updateSearchPlaceholder();
        renderGlossary();
        renderTOC();
        attachTOCListeners();
        updateBackToTopLabel();
      });
    });

    // Search filter
    let searchTimeout;
    document.getElementById('searchBox').addEventListener('input', event => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchQuery = event.target.value.toLowerCase();
        renderGlossary();
      }, 200);
    });
    updateSearchPlaceholder();
  })
  .catch(error => {
    console.error("Error loading JSON:", error);
    document.getElementById("output").innerHTML =
      `<p style="color: red;">Error loading glossary: ${error.message}</p>`;
  });

function updateSearchPlaceholder() {
  const searchBox = document.getElementById('searchBox');
  searchBox.placeholder =
    currentLang === 'FR' ? 'Rechercher dans le glossaire...' : 'Search glossary...';
}

// Sanitize section name for use as HTML ID
function sanitizeId(str) {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

// Build TOC dynamically
function renderTOC() {
  if (!glossaryData) return;

  // Collect sections
  const sections = {};
  Object.entries(glossaryData).forEach(([key, entry]) => {
    const section = entry.Section || "Other";
    sections[section] = true;
  });

  const sectionNames = Object.keys(sections).sort();

  // Build TOC HTML (class-based, no inline styling)
  let tocHtml = `
    <div class="atlas-toc-heading">Sections</div>
    <div class="atlas-toc-list">
  `;

  sectionNames.forEach((section, i) => {
    const id = sanitizeId(section);
    tocHtml += `
      <a class="toc-link" href="#section-${id}">${section}</a>
    `;
  });

  tocHtml += `</div>`;

  document.getElementById("toc").innerHTML = tocHtml;

  attachGlossaryScrollSpy();
}

function attachTOCListeners() {
  document.querySelectorAll('#toc a').forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault();
      const targetId = link.getAttribute('href').substring(1);
      const target = document.getElementById(targetId);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    });
  });
}

function attachGlossaryScrollSpy() {
  const links = Array.from(document.querySelectorAll("#toc .toc-link"));
  if (!links.length) return;

  // Map each link to its target section element
  const sections = links.map(link => {
    const id = link.getAttribute("href").slice(1); // remove #
    return document.getElementById(id);
  });

  function setActiveLink(activeLink) {
    links.forEach(link => link.classList.remove("active"));
    if (activeLink) activeLink.classList.add("active");
  }

  function onScroll() {
    // Compute distances
    const distances = sections.map(sec =>
      Math.abs(sec.getBoundingClientRect().top)
    );

    // Identify closest section
    const minIndex = distances.indexOf(Math.min(...distances));
    const activeLink = links[minIndex];

    setActiveLink(activeLink);
  }

  window.addEventListener("scroll", onScroll);
  onScroll(); // run once
}

// Render glossary
function renderGlossary() {
  if (!glossaryData) return;

  const sections = {};
  Object.entries(glossaryData).forEach(([key, entry]) => {
    const section = entry.Section || 'Other';
    if (!sections[section]) sections[section] = [];
    sections[section].push({ key, ...entry });
  });

  let html = '<div>';

  Object.keys(sections).sort().forEach(section => {
    const filteredEntries = sections[section].filter(entry => {
      const term = entry.Term?.toLowerCase() || '';
      const acronym = entry.Acronym?.toLowerCase() || '';
      const defEN = entry['Definition EN']?.toLowerCase() || entry['Definiton EN']?.toLowerCase() || '';
      const defFR = entry['Definition FR']?.toLowerCase() || '';
      const tooltipEN = entry['Tooltip EN']?.toLowerCase() || '';
      const tooltipFR = entry['Tooltip FR']?.toLowerCase() || '';

      return (
        !searchQuery ||
        term.includes(searchQuery) ||
        acronym.includes(searchQuery) ||
        defEN.includes(searchQuery) ||
        defFR.includes(searchQuery) ||
        tooltipEN.includes(searchQuery) ||
        tooltipFR.includes(searchQuery)
      );
    });

    if (filteredEntries.length === 0) return;

    const sectionId = sanitizeId(section);
    html += `<h1 id="section-${sectionId}">${section}</h1>`;

    filteredEntries
      .sort((a, b) => a.Term.localeCompare(b.Term))
      .forEach(entry => {
        const acronym = entry.Acronym?.trim() || null;
        const definition =
          currentLang === 'EN'
            ? entry['Definiton EN'] || entry['Definition EN'] || ''
            : entry['Definition FR'] || '';
        const tooltip =
          currentLang === 'EN' ? entry['Tooltip EN'] || '' : entry['Tooltip FR'] || '';

        html += '<div style="margin-bottom: 30px;">';
        html += `<h2 style="color: #555; margin-bottom: 5px; font-size: 1.3em;">
                  ${entry.Term}${acronym ? ` (${acronym})` : ''}
                 </h2>`;
        if (tooltip)
          html += `<p style="color: #667; font-style: italic; margin: 5px 0; font-size: 0.9em;">${tooltip}</p>`;
        if (definition)
          html += `<p style="color: #444; line-height: 1.6; margin-top: 10px;">${definition}</p>`;
        html += '</div>';
      });
  });

  html += '</div>';
  document.getElementById('output').innerHTML = html;
}
</script>

<button id="backToTopBtn" class="back-to-top">â†‘ Top</button>

<style>
.back-to-top {
  position: fixed;
  bottom: 25px;
  right: 30px;
  padding: 12px 16px;
  font-size: 16px;
  cursor: pointer;
  display: none; /* Hidden by default */
  border: none;
  border-radius: 6px;
  background-color: #333;
  color: white;
}
</style>

<script>
const btn = document.getElementById('backToTopBtn');

function updateBackToTopLabel() {
 btn.textContent = currentLang === "FR" ? "â†‘ Haut" : "â†‘ Top";
}

updateBackToTopLabel();

// Show/hide button on scroll
window.addEventListener('scroll', () => {
  if (window.scrollY > 300) {
    btn.style.display = 'block';
  } else {
    btn.style.display = 'none';
  }
});

// Scroll smoothly to top when clicked
btn.addEventListener('click', () => {
  window.scrollTo({
    top: 0,
    behavior: 'smooth'
  });
});
</script>

<script>
function observeH1ChangesForTOC(idsToIgnore = []) {
    const outputElement = document.getElementById('h1-list');

    // Create a Set for fast lookup of IDs to ignore
    const ignoredIdSet = new Set(idsToIgnore);

    // Helper function to convert text into a URL-friendly slug
    const slugify = (text) => {
        return text.toString().toLowerCase()
            .trim()
            .replace(/\s+/g, '-')
            .replace(/[^\w\-]+/g, '')
            .replace(/\-\-+/g, '-');
    };

    // 1. Function to refresh the TOC from the live DOM
    const updateH1List = () => {
        const h1Elements = document.querySelectorAll('h1');
        const ul = document.createElement('ul');
        const tocItems = [];

        h1Elements.forEach((h1) => {
            const h1Text = h1.textContent.trim();
            let id = h1.id;

            // Generate/Ensure ID
            if (!id) {
                id = slugify(h1Text);
                let suffix = 1;
                let finalId = id;
                while (document.getElementById(finalId)) {
                    finalId = id + '-' + suffix++;
                }
                h1.id = finalId;
                id = finalId;
            }

            // --- ðŸ”‘ New Exclusion Check: Skip if the ID is in the ignored set ---
            if (ignoredIdSet.has(id)) {
                return; // Skip this H1 and move to the next one
            }

            // Create the link element
            const li = document.createElement('li');
            const a = document.createElement('a');

            a.href = `#${id}`;
            a.textContent = h1Text || '[Empty H1]';

            li.appendChild(a);
            ul.appendChild(li);
        });

        // Update the output element
        outputElement.innerHTML = '';
        if (ul.children.length > 0) {
            outputElement.appendChild(ul);
        } else {
            outputElement.textContent = 'No eligible <h1> elements found.';
        }

        console.log('TOC updated. Ignored IDs:', idsToIgnore);
    };

    // 2. Set up the MutationObserver (configuration remains the same for efficiency)
    const observer = new MutationObserver((mutationsList, observer) => {
        // ... (mutation checking logic is unchanged) ...
        let needsUpdate = false;
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                const relevantNodes = [...mutation.addedNodes, ...mutation.removedNodes];
                if (relevantNodes.some(node => node.nodeType === 1 && (node.matches('h1') || node.querySelector('h1')))) {
                    needsUpdate = true;
                    break;
                }
            } else if (mutation.type === 'characterData') {
                if (mutation.target.parentElement && mutation.target.parentElement.matches('h1')) {
                    needsUpdate = true;
                    break;
                }
            }
        }

        if (needsUpdate) {
            requestAnimationFrame(updateH1List);
        }
    });

    const config = { childList: true, subtree: true, characterData: true };
    observer.observe(document.body, config);
    updateH1List();

    return {
        update: updateH1List,
        disconnect: () => observer.disconnect()
    };
}

// Ensure the HTML elements exist before running the function
document.addEventListener('DOMContentLoaded', () => {
    observeH1ChangesForTOC(['atlas-definitions-1']);
});

</script>
